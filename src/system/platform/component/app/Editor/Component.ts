import { Graph } from '../../../../../Class/Graph'
import { NOOP } from '../../../../../NOOP'
import { Registry } from '../../../../../Registry'
import { LayoutNode } from '../../../../../client/LayoutNode'
import { addListener, addListeners } from '../../../../../client/addListener'
import { Component } from '../../../../../client/component'
import {
  parentClass,
  parentComponent,
} from '../../../../../client/createParent'
import { Element } from '../../../../../client/element'
import { makeCustomListener } from '../../../../../client/event/custom'
import { UnitPointerEvent } from '../../../../../client/event/pointer'
import { makeClickListener } from '../../../../../client/event/pointer/click'
import { parentElement } from '../../../../../client/platform/web/parentElement'
import {
  emptySpec,
  findInputDataExamples,
  getComponentSpec,
  getGraphSpec,
  getSpec,
  getSpecInputs,
  getSpecOutputs,
  getSpecRender,
  getSpecRenderById,
  hasSubComponent,
  hasSubComponents,
  isComponentId,
  isComponentSpec,
  isEmptySpec,
  isSystemSpec,
  isSystemSpecId,
  newMergeIdInSpec,
  newSpecId,
  newUnitId,
  newUnitIdFromName,
} from '../../../../../client/spec'
import {
  ZOOM_IDENTITY,
  Zoom,
  translate,
  zoomInvert,
  zoomTransformCenteredAt,
} from '../../../../../client/zoom'
import { Moment } from '../../../../../debug/Moment'
import { mirror } from '../../../../../mirror'
import { System } from '../../../../../system'
import { Callback } from '../../../../../types/Callback'
import { Dict } from '../../../../../types/Dict'
import { GraphSpec } from '../../../../../types/GraphSpec'
import { Unlisten } from '../../../../../types/Unlisten'
import { $Component } from '../../../../../types/interface/async/$Component'
import { $Graph } from '../../../../../types/interface/async/$Graph'
import { AsyncGraph } from '../../../../../types/interface/async/AsyncGraph'
import { weakMerge } from '../../../../../weakMerge'
import {
  ID_AUDIO,
  ID_EDITOR,
  ID_IMAGE,
  ID_IMAGE_1,
  ID_SCROLL_SNAP_Y_DIV,
  ID_VIDEO,
} from '../../../../_ids'
import { clamp } from '../../../../core/relation/Clamp/f'
import { firstGlobalComponentPromise } from '../../../../globalComponent'
import Div from '../../Div/Component'
import Frame from '../../Frame/Component'
import Transcend from '../Transcend/Component'

import {
  GraphBulkEditData,
  GraphMoveSubComponentRootData,
  GraphMoveSubGraphData,
  GraphMoveSubGraphIntoData,
  GraphMoveSubGraphOutOfData,
  GraphRemoveMergeDataData,
  GraphRemoveUnitPinDataData,
  GraphSetComponentSizeData,
  GraphSetMetadataData,
  GraphSetSubComponentSizeData,
  GraphSetUnitSizeData,
} from '../../../../../Class/Graph/interface'
import {
  GraphLike,
  moveMerge,
  movePlug,
  moveSubgraph,
} from '../../../../../Class/Graph/moveSubgraph'
import { Opt, Unit, UnitEvents } from '../../../../../Class/Unit'
import { Memory } from '../../../../../Class/Unit/Memory'
import {
  UnitRemovePinDataData,
  UnitTakeInputData,
} from '../../../../../Class/Unit/interface'
import { DataRef } from '../../../../../DataRef'
import {
  Heap,
  addHeapNode,
  removeHeapNode,
  setHeapNode,
  traverseHeap,
} from '../../../../../Heap'
import { Pin } from '../../../../../Pin'
import { PinOpt } from '../../../../../PinOpt'
import { PinOpts } from '../../../../../PinOpts'
import { Pins } from '../../../../../Pins'
import {
  bundleSpec,
  unitBundleSpec,
  unitBundleSpecById,
} from '../../../../../bundle'
import { DEFAULT_FONT_SIZE } from '../../../../../client/DEFAULT_FONT_SIZE'
import { IOElement } from '../../../../../client/IOElement'
import { MAX_Z_INDEX } from '../../../../../client/MAX_Z_INDEX'
import { ANIMATION_C } from '../../../../../client/animation/ANIMATION_C'
import { ANIMATION_T_S } from '../../../../../client/animation/ANIMATION_T_S'
import { animateSimulate } from '../../../../../client/animation/animateSimulate'
import {
  AnimatableValue,
  animateSimulateTick,
} from '../../../../../client/animation/animateSimulateTick'
import {
  ANIMATION_T_MS,
  ifLinearTransition,
  linearTransition,
} from '../../../../../client/animation/animation'
import { applyAttr } from '../../../../../client/attr'
import { classnames } from '../../../../../client/classnames'
import {
  RGBA,
  hexToRgba,
  rgbaToHex,
  setAlpha,
} from '../../../../../client/color'
import {
  UNIT_MIN_RADIUS,
  getSpecRadius,
} from '../../../../../client/complexity'
import { ANIMATION_DELTA_THRESHOLD } from '../../../../../client/component/app/graph/ANIMATION_DELTA_THRESHOLD'
import { joinPath } from '../../../../../client/component/app/graph/joinLeafPath'
import {
  MAX_HEIGHT as DATUM_MAX_HEIGHT,
  MAX_WIDTH as DATUM_MAX_WIDTH,
  getDatumSize,
} from '../../../../../client/component/getDatumSize'
import { mergeProps } from '../../../../../client/component/mergeProps'
import { mergePropStyle } from '../../../../../client/component/mergeStyle'
import { componentClassFromSpecId } from '../../../../../client/componentClassFromSpecId'
import {
  componentFromSpecId,
  componentFromUnitBundle,
} from '../../../../../client/componentFromSpecId'
import { Context } from '../../../../../client/context'
import { preventContextMenu } from '../../../../../client/contextMenu'
import { getCircle, getLine, getRectangle } from '../../../../../client/drawing'
import { IODragEvent } from '../../../../../client/event/drag'
import { makeDragEnterListener } from '../../../../../client/event/drag/dragenter'
import { makeDragLeaveListener } from '../../../../../client/event/drag/dragleave'
import { makeDragOverListener } from '../../../../../client/event/drag/dragover'
import { makeDragStartListener } from '../../../../../client/event/drag/dragstart'
import { makeDropListener } from '../../../../../client/event/drag/drop'
import { makeBlurListener } from '../../../../../client/event/focus/blur'
import { makeFocusListener } from '../../../../../client/event/focus/focus'
import { Gamepad_ } from '../../../../../client/event/gamepad'
import { makeInputListener } from '../../../../../client/event/input'
import {
  IOKeyboardEvent,
  Shortcut,
  isKeyPressed,
  makeKeydownListener,
  makeShortcutListener,
} from '../../../../../client/event/keyboard'
import { keyToKeyCode } from '../../../../../client/event/keyboard/keyCode'
import { writeToTextField } from '../../../../../client/event/keyboard/write'
import {
  CLICK_TIMEOUT,
  POINTER_CLICK_RADIUS,
  POINTER_LONG_PRESS_MAX_DELTA,
} from '../../../../../client/event/pointer/constants'
import { makePointerCancelListener } from '../../../../../client/event/pointer/pointercancel'
import { makePointerDownListener } from '../../../../../client/event/pointer/pointerdown'
import { makePointerEnterListener } from '../../../../../client/event/pointer/pointerenter'
import { makePointerLeaveListener } from '../../../../../client/event/pointer/pointerleave'
import { makePointerMoveListener } from '../../../../../client/event/pointer/pointermove'
import { makePointerUpListener } from '../../../../../client/event/pointer/pointerup'
import {
  IOFrameResizeEvent,
  makeResizeListener,
} from '../../../../../client/event/resize'
import {
  IOWheelEvent,
  makeWheelListener,
} from '../../../../../client/event/wheel'
import { extractStyle } from '../../../../../client/extractStyle'
import { extractTrait } from '../../../../../client/extractTrait'
import { findRef } from '../../../../../client/findRef'
import { getSize } from '../../../../../client/getSize'
import {
  GraphNodeMap,
  add_link_to_graph,
  add_node_to_graph,
  build_subgraph,
  change_link_source_on_graph,
  change_link_target_on_graph,
  getSubPinSpecNodeId,
  getSubPinSpecNodeId_,
  remove_link_from_graph,
  remove_node_from_graph,
} from '../../../../../client/graph'
import { _DEFAULT_STYLE } from '../../../../../client/graph/constant/DEFAULT_STYLE'
import { enableModeKeyboard } from '../../../../../client/graph/shortcut/modes'
import { graphComponentFromId } from '../../../../../client/graphComponentFromSpec'
import {
  getDatumNodeId,
  getErrNodeId,
  getExtNodeId,
  getExtNodeIdFromIntNodeId,
  getIdFromMergeNodeId,
  getIntNodeId,
  getIntNodeIdFromExtNodeId,
  getLinkId,
  getMergeNodeId,
  getOutputNodeId,
  getPinLinkId,
  getPinLinkIdFromPinNodeId,
  getPinNodeId,
  getPinNodeId__,
  getSelfPinNodeId,
  getTypeFromLinkPinNodeId,
  getTypeNodeId,
  isBaseSpec,
  isBaseSpecId,
  isDatumLinkId,
  isDatumNodeId,
  isExternalLinkId,
  isExternalNodeId,
  isInputPinId as isInputPinNodeId,
  isInternalNodeId,
  isLinkPinNodeId,
  isMergeNodeId,
  isOutputPinId,
  isPinLinkId,
  isUnitNodeId,
  segmentDatumLinkId,
  segmentDatumNodeId,
  segmentErrNodeId,
  segmentExternalLinkId,
  segmentInternalNodeId,
  segmentLinkId,
  segmentLinkPinNodeId,
  segmentMergeNodeId,
  segmentPinLinkId,
  segmentPlugNodeId,
} from '../../../../../client/id'
import { getComponentInterface } from '../../../../../client/interface'
import { isCanvasLike } from '../../../../../client/isCanvas'
import { isSVGLike } from '../../../../../client/isSVG'
import { isTableLike } from '../../../../../client/isTable'
import { isTextLike } from '../../../../../client/isText'
import { LayoutBase } from '../../../../../client/layout'
import { listenMovement } from '../../../../../client/listenMovement'
import { Mode } from '../../../../../client/mode'
import { _pinTypeMatch } from '../../../../../client/parser'
import { rawExtractStyle } from '../../../../../client/rawExtractStyle'
import {
  expandSlot,
  reflectComponentBaseTrait,
} from '../../../../../client/reflectComponentBaseTrait'
import { SimLink, SimNode, Simulation } from '../../../../../client/simulation'
import {
  stopAllPropagation,
  stopByPropagation,
} from '../../../../../client/stopPropagation'
import { applyDynamicStyle, applyStyle } from '../../../../../client/style'
import {
  COLOR_DARK_LINK_YELLOW,
  COLOR_DARK_YELLOW,
  COLOR_GREEN,
  COLOR_LINK_YELLOW,
  COLOR_NONE,
  COLOR_OPAQUE_RED,
  COLOR_YELLOW,
  applyTheme,
  getThemeLinkModeColor,
  getThemeModeColor,
  themeBackgroundColor,
} from '../../../../../client/theme'
import {
  NULL_VECTOR,
  Shape,
  Thing,
  _surfaceDistance,
  addVector,
  applyVector,
  centerOfMass,
  centerRectsBoundingLine,
  centerRectsBoundingRect,
  centerToSurfaceDistance,
  describeArc,
  distance,
  isInside,
  jigglePoint,
  lineIntersect,
  mediumPoint,
  norm,
  normalize,
  perpendicular,
  pointDistance,
  pointInCircle,
  pointInNode,
  pointInRectangle,
  pointUnitVector,
  pointVector,
  radBetween,
  randomInPaddedRect,
  randomInRadius,
  randomInRect,
  randomUnitVector,
  resizeVector,
  roundPoint,
  subtractVector,
  surfaceDistance,
  unitVector,
} from '../../../../../client/util/geometry'
import {
  Circle,
  Line,
  Point,
  Position,
  Rect,
  Size,
} from '../../../../../client/util/geometry/types'
import { getUnitPinPosition } from '../../../../../client/util/geometry/unit/getUnitPinPosition'
import {
  getRelativePosition,
  getScrollPosition,
} from '../../../../../client/util/style/getPosition'
import { userSelect } from '../../../../../client/util/style/userSelect'
import {
  LINK_DISTANCE,
  LINK_DISTANCE_DATA,
  LINK_DISTANCE_ERR,
  LINK_DISTANCE_EXPOSED,
  LINK_DISTANCE_EXPOSED_PLUGGED_FACTOR,
  LINK_DISTANCE_IGNORED,
  LINK_DISTANCE_TYPE,
} from '../../../../../constant/LINK_DISTANCE'
import { PIN_RADIUS } from '../../../../../constant/PIN_RADIUS'
import { SELF } from '../../../../../constant/SELF'
import { UNTITLED } from '../../../../../constant/STRING'
import { GraphMergePinDataMomentData } from '../../../../../debug/GraphMergePinDataMoment'
import { GraphMoment } from '../../../../../debug/GraphMoment'
import { GraphUnitErrMomentData } from '../../../../../debug/GraphUnitErrMoment'
import { GraphUnitPinDataMomentData } from '../../../../../debug/GraphUnitPinDataMoment'
import { GraphUnitPinDropMomentData } from '../../../../../debug/GraphUnitPinDropMoment'
import { PinDataMomentData } from '../../../../../debug/PinDataMoment'
import { PinDropMomentData } from '../../../../../debug/PinDropMoment'
import { GraphBulkEditMomentData } from '../../../../../debug/graph/watchGraphBulkEditEvent'
import { GraphExposePinEventData } from '../../../../../debug/graph/watchGraphExposedPinEvent'
import { GraphExposedPinSetMomentData } from '../../../../../debug/graph/watchGraphExposedPinSetEvent'
import { GraphForkMomentData } from '../../../../../debug/graph/watchGraphForkEvent'
import { GraphMergeMomentData } from '../../../../../debug/graph/watchGraphMergeEvent'
import { GraphMetadataMomentData } from '../../../../../debug/graph/watchGraphMetadataEvent'
import { GraphMoveSubComponentRootMomentData } from '../../../../../debug/graph/watchGraphMoveSubComponentRoot'
import { GraphMoveSubgraphIntoMomentData } from '../../../../../debug/graph/watchGraphMoveSubgraphIntoEvent'
import { GraphMergePinMomentData } from '../../../../../debug/graph/watchGraphPinMergeEvent'
import { GraphPlugMomentData } from '../../../../../debug/graph/watchGraphPlugEvent'
import { GraphRemoveUnitPinDataMomentData } from '../../../../../debug/graph/watchGraphRemoveUnitPinDataEvent'
import { GraphReorderSubComponentMomentData } from '../../../../../debug/graph/watchGraphReorderSubComponent'
import { GraphSetNameMomentData } from '../../../../../debug/graph/watchGraphSetNameEvent'
import { GraphSetPinSetDefaultIgnoredMomentData } from '../../../../../debug/graph/watchGraphSetPinSetDefaultIgnored'
import { GraphSetPinSetFunctionalMomentData } from '../../../../../debug/graph/watchGraphSetPinSetFunctionalEvent'
import { GraphSetPinSetIdMomentData } from '../../../../../debug/graph/watchGraphSetPinSetIdEvent'
import { GraphSetUnitIdMomentData } from '../../../../../debug/graph/watchGraphSetUnitIdEvent'
import { GraphSetUnitPinConstantMomentData } from '../../../../../debug/graph/watchGraphSetUnitPinConstantEvent'
import { GraphSetUnitPinDataMomentData } from '../../../../../debug/graph/watchGraphSetUnitPinDataEvent'
import { GraphSetUnitPinIgnoredMomentData } from '../../../../../debug/graph/watchGraphSetUnitPinIgnoredEvent'
import {
  GraphAddUnitMomentData,
  GraphCloneUnitMomentData,
} from '../../../../../debug/graph/watchGraphUnitEvent'
import { GraphSpecUnitMoveMomentData } from '../../../../../debug/graph/watchGraphUnitMoveEvent'
import { deepSet_ } from '../../../../../deepSet'
import { CodePathNotImplementedError } from '../../../../../exception/CodePathNotImplemented'
import { InvalidStateError } from '../../../../../exception/InvalidStateError'
import { MethodNotImplementedError } from '../../../../../exception/MethodNotImplementedError'
import { ShouldNeverHappenError } from '../../../../../exception/ShouldNeverHappenError'
import { injectUserBundle, injectUserSpecs } from '../../../../../injectBundle'
import { isFrameRelativeValue } from '../../../../../isFrameRelative'
import { proxyWrap } from '../../../../../proxyWrap'
import {
  MOVE_SUB_COMPONENT_ROOT,
  REORDER_SUB_COMPONENT,
  makeMoveSubComponentRootAction,
  makeReorderSubComponentAction,
} from '../../../../../spec/actions/C'
import {
  ADD_DATUM,
  ADD_DATUM_LINK,
  REMOVE_DATUM,
  REMOVE_DATUM_LINK,
  makeAddDatumAction,
  makeAddDatumLinkAction,
  makeRemoveDatumAction,
} from '../../../../../spec/actions/D'
import {
  ADD_MERGE,
  ADD_PIN_TO_MERGE,
  ADD_UNIT,
  BULK_EDIT,
  COVER_PIN_SET,
  COVER_UNIT_PIN_SET,
  EXPOSE_PIN_SET,
  EXPOSE_UNIT_PIN_SET,
  MOVE_SUBGRAPH_INTO,
  MOVE_SUBGRAPH_OUT_OF,
  PLUG_PIN,
  REMOVE_MERGE,
  REMOVE_PIN_FROM_MERGE,
  REMOVE_UNIT,
  REMOVE_UNIT_PIN_DATA,
  SET_COMPONENT_SIZE,
  SET_PIN_SET_FUNCTIONAL,
  SET_SUB_COMPONENT_SIZE,
  SET_UNIT_PIN_CONSTANT,
  SET_UNIT_PIN_DATA,
  SET_UNIT_PIN_IGNORED,
  SET_UNIT_SIZE,
  TAKE_UNIT_ERR,
  UNPLUG_PIN,
  makeAddMergeAction,
  makeAddPinToMergeAction,
  makeAddUnitAction,
  makeBulkEditAction,
  makeCloneUnitAction,
  makeCoverPinAction,
  makeCoverPinSetAction,
  makeCoverUnitPinSetAction,
  makeExposePinAction,
  makeExposePinSetAction,
  makeExposeUnitPinSetAction,
  makePlugPinAction,
  makeRemoveMergeAction,
  makeRemovePinFromMergeAction,
  makeRemoveUnitAction,
  makeRemoveUnitPinDataAction,
  makeSetComponentSizeAction,
  makeSetPinSetFunctionalAction,
  makeSetSubComponentSizeAction,
  makeSetUnitPinConstantAction,
  makeSetUnitPinDataAction,
  makeSetUnitPinIgnoredAction,
  makeSetUnitSizeAction,
  makeUnplugPinAction,
  processActions,
  reverseAction,
  wrapMoveSubgraphIntoData,
  wrapMoveSubgraphOutOfData,
  wrapRemoveMergeDataAction,
  wrapRemoveUnitPinDataAction,
} from '../../../../../spec/actions/G'
import {
  wrapRemovePinDataAction,
  wrapTakeInputAction,
} from '../../../../../spec/actions/U'
import { graphComplexity } from '../../../../../spec/complexity'
import { emptyIO } from '../../../../../spec/emptyIO'
import { emptyGraphSpec } from '../../../../../spec/emptySpec'
import { escape } from '../../../../../spec/escape'
import { _evaluate, evaluate } from '../../../../../spec/evaluate'
import { evaluateDataValue } from '../../../../../spec/evaluateDataValue'
import {
  evaluateBundleStr,
  idFromUnitValue,
} from '../../../../../spec/idFromUnitValue'
import {
  ANY_TREE,
  STRING_TREE,
  TreeNode,
  TreeNodeType,
  _filterEmptyNodes,
  _getNodeAtPath,
  _getValueType,
  _isTypeMatch,
  _isValidTree,
  _isValidValue,
  _matchAllExcTypes,
  _updateNodeAt,
  getTree,
  getValueTree,
  isTypeMatch,
} from '../../../../../spec/parser'
import {
  appendRoot,
  appendSubComponentChild,
  insertRoot,
  insertSubComponentChild,
  moveRoot,
  moveSubComponentRoot,
  removeRoot,
  removeSubComponent,
  removeSubComponentChild,
  removeSubComponentFromParent,
  reorderSubComponent,
  setSize,
  setSubComponent,
} from '../../../../../spec/reducers/component'
import {
  addMerge,
  addPinToMerge,
  addUnit,
  coverPin,
  coverPinSet,
  exposePin,
  exposePinSet,
  mergeMerges,
  plugPin,
  removeDatum,
  removeMerge,
  removePinFromMerge,
  removeUnit,
  removeUnitPinData,
  setComponentSize,
  setDatum,
  setMetadata,
  setName,
  setPinSetDataType,
  setPinSetDefaultIgnored,
  setPinSetFunctional,
  setPinSetId,
  setPinSetRef,
  setSubComponentSize,
  setUnitId,
  setUnitMetadata,
  setUnitPinConstant,
  setUnitPinData,
  setUnitPinIgnored,
  setUnitSize,
  unplugPin,
} from '../../../../../spec/reducers/spec'
import { remapBundle } from '../../../../../spec/remapBundle'
import { remapUnitBundle } from '../../../../../spec/remapUnitBundle'
import { stringify } from '../../../../../spec/stringify'
import { stringifyDataValue } from '../../../../../spec/stringifyDataValue'
import { stringifyBundleSpec } from '../../../../../spec/stringifySpec'
import {
  TypeTreeInterfaceCache,
  TypeTreeMap,
  _getGraphTypeMap,
  _getSpecTypeInterfaceById,
  _mostSpecific,
} from '../../../../../spec/type'
import {
  getSubComponentChildren,
  getSubComponentParentId,
} from '../../../../../spec/util/component'
import {
  countMergePlugs,
  findMergePlugs,
  findPinMergeId,
  findSpecAtPath,
  findUnitPinPlug,
  findUnitPlugs,
  forEachGraphSpecPin,
  forEachGraphSpecPinOfType,
  forEachPinOnMerge,
  forEachPinOnMerges,
  forEachSpecPin,
  getExposePinSpec,
  getExposedPinSpecs,
  getInputNodeId,
  getMerge,
  getMergePinCount,
  getMergePinTypeCount,
  getPinSpec,
  getPlugCount,
  getPlugSpecs,
  getSpecPinIcon,
  getSubPinSpec,
  getUnitExposedPins,
  getUnitMergesSpec,
  hasMerge,
  hasMergePin,
  hasPinNamed,
  hasPlug,
  hasUnit,
  isPinRef,
  isPinSpecRef,
  isSelfPin,
  isSubPinSpecRef,
  isUnitComponent,
  isUnitPinConstant,
  makeFullSpecCollapseMap,
  opposite,
  opposite as oppositePinType,
  shouldExposePin,
} from '../../../../../spec/util/spec'
import {
  validateBundleSpec,
  validateGraphSpec,
} from '../../../../../spec/validate'
import { start } from '../../../../../start'
import {
  flushAnimation,
  waitFinish,
} from '../../../../../test/client/util/animation'
import {
  BaseComponentSpec,
  Classes,
  ComponentSpec,
  DatumSpec,
  GraphComponentSpec,
  GraphDataSpec,
  GraphPinsSpec,
  GraphPlugOuterSpec,
  GraphPlugSpec,
  GraphSubComponentSpec,
  GraphSubPinSpec,
  GraphUnitMetadataSpec,
  GraphUnitPinOuterSpec,
  PinSpec,
  PinsSpecBase,
  Spec,
  Specs,
} from '../../../../../types'
import { Action } from '../../../../../types/Action'
import { BundleSpec } from '../../../../../types/BundleSpec'
import { GraphConnectUnitMeta } from '../../../../../types/GraphConnectUnitMeta'
import { GraphMergeSpec } from '../../../../../types/GraphMergeSpec'
import { GraphMergesSpec } from '../../../../../types/GraphMergesSpec'
import { GraphPinSpec } from '../../../../../types/GraphPinSpec'
import { GraphSpecs } from '../../../../../types/GraphSpecs'
import { GraphUnitConnect } from '../../../../../types/GraphUnitConnect'
import { GraphUnitMerges } from '../../../../../types/GraphUnitMerges'
import { GraphUnitPinSpec } from '../../../../../types/GraphUnitPinSpec'
import { GraphUnitPlugs } from '../../../../../types/GraphUnitPlugs'
import { GraphUnitSpec } from '../../../../../types/GraphUnitSpec'
import { GraphUnitsSpec } from '../../../../../types/GraphUnitsSpec'
import { IO } from '../../../../../types/IO'
import {
  IOKindOf,
  IOOf,
  forIO,
  forIOObjKV,
  io,
} from '../../../../../types/IOOf'
import { InjectSubComponentOpt } from '../../../../../types/InjectSubComponentOpt'
import { TagData } from '../../../../../types/TagData'
import { UnitBundleSpec } from '../../../../../types/UnitBundleSpec'
import { R } from '../../../../../types/interface/R'
import { U, U_EE } from '../../../../../types/interface/U'
import { UCG } from '../../../../../types/interface/UCG'
import { UCGEE } from '../../../../../types/interface/UCGEE'
import { $U } from '../../../../../types/interface/async/$U'
import {
  randomTreeOfType,
  randomValueOfType,
} from '../../../../../types/parser/randomValue'
import {
  butLast,
  forEach,
  insert,
  last,
  pull,
  push,
  remove,
} from '../../../../../util/array'
import { randomInArray } from '../../../../../util/array/randomInArray'
import { bit } from '../../../../../util/boolean'
import { callAll } from '../../../../../util/call/callAll'
import { clone } from '../../../../../util/clone'
import { parseNumberSentence } from '../../../../../util/dictation'
import { readFileAsText } from '../../../../../util/file'
import { hashCode } from '../../../../../util/hashCode'
import { randomIdNotIn } from '../../../../../util/id'
import {
  deepDec,
  deepDelete,
  deepGet,
  deepGetOrDefault,
  deepInc,
  deepSet,
  filterObj,
  forEachObjKV,
  getObjSingleKey,
  invertObj,
  isEmptyObject,
  makeTagObj,
  mapObjKV,
  mapObjKey,
  mapObjKeyKV,
  mapObjVK,
  reduceObj,
  revertObj,
} from '../../../../../util/object'
import { removeWhiteSpace } from '../../../../../util/string'
import { getDivTextSize } from '../../../../../util/text/getDivTextSize'
import { getTextWidth } from '../../../../../util/text/getPlainTextWidth'
import { getTextLines, spaces } from '../../../../../util/text/getTextLines'
import forEachValueKey from '../../../../core/object/ForEachKeyValue/f'
import { keyCount } from '../../../../core/object/KeyCount/f'
import isEqual from '../../../../f/comparison/Equals/f'
import deepMerge from '../../../../f/object/DeepMerge/f'
import _dissoc from '../../../../f/object/Delete/f'
import _keys, { keys } from '../../../../f/object/Keys/f'
import { Style, Tag } from '../../../Style'
import { default as Icon, default as IconButton } from '../../Icon/Component'
import Zoom_ from '../../Zoom/Component'
import Canvas_ from '../../canvas/Canvas/Component'
import SVGDefs from '../../svg/Defs/Component'
import SVGG from '../../svg/Group/Component'
import SVGMarker from '../../svg/Marker/Component'
import SVGPath from '../../svg/Path/Component'
import SVGRect from '../../svg/Rect/Component'
import SVGSVG from '../../svg/SVG/Component'
import SVGText from '../../svg/Text/Component'
import SVGTextPath from '../../svg/TextPath/Component'
import TextArea from '../../value/TextArea/Component'
import TextField from '../../value/TextField/Component'
import Cabinet from '../Cabinet/Component'
import ClassDatum from '../Class/Component'
import DataTree from '../DataTree/Component'
import { Datum } from '../Datum/Component'
import GUI from '../GUI/Component'
import Minimap, { MINIMAP_HEIGHT, MINIMAP_WIDTH } from '../Minimap/Component'
import Modes from '../ModeSelector/Component'
import { IOResizeEvent, default as Resize } from '../Resize/Component'
import Search from '../Search/Component'
import Selection from '../Selection/Component'

const UNIT_NAME_MAX_CHAR_LINE: number = 12
const UNIT_NAME_MAX_LINE_COUNT: number = 3
const UNIT_CORE_NAME_FONT_SIZE: number = 12

const PLUG_NAME_FONT_SIZE: number = 10
const PLUG_NAME_MAX_CHAR_LINE: number = 12

export const UNIT_NAME_MAX_SIZE: number =
  UNIT_NAME_MAX_LINE_COUNT * UNIT_NAME_MAX_CHAR_LINE

const UNIT_DESCRIPTION_FONT_SIZE: number = 10
const UNIT_DESCRIPTION_MAX_LINE_COUNT: number = 3
const UNIT_DESCRIPTION_MAX_LINE_LENGTH: number = 24

export const UNIT_DESCRIPTION_MAX_SIZE: number =
  UNIT_DESCRIPTION_MAX_LINE_COUNT * UNIT_DESCRIPTION_MAX_LINE_LENGTH

const LINK_TEXT_FONT_SIZE: number = 10

const PIN_NAME_MAX_SIZE: number = 12
const PIN_NAME_FONT_SIZE: number = 10

const MIN_WIDTH: number = 42
const MIN_HEIGHT: number = 42

const MAX_WIDTH: number = Infinity
const MAX_HEIGHT: number = Infinity

const SURFACE_UNPLUG_DISTANCE = 1.5 * LINK_DISTANCE_EXPOSED

const DATUM_FONT_SIZE = 12

const MIN_DRAG_DROP_MAX_D = POINTER_LONG_PRESS_MAX_DELTA

export const NEAR = 36

let i = 0

export const OPPOSITE_MOMENT_EVENT = {
  data: 'drop',
  drop: 'data',
}

export const getOppositeMoment = (moment: any): any => {
  const { type, event, data } = moment

  return {
    type,
    event: OPPOSITE_MOMENT_EVENT[event],
    data,
  }
}

// export const SUBGRAPH_MAX_D: number = 9  * LINK_DISTANCE
export const SUBGRAPH_MAX_D: number = 6 * LINK_DISTANCE
// export const SUBGRAPH_MAX_D: number = Infinity
// export const SUBGRAPH_MAX_D: number = 2 * LINK_DISTANCE
export const NOT_SUBGRAPH_MAX_D: number = 2 * LINK_DISTANCE

export const describeArrowSemicircle = (r: number): string => {
  r += 1
  const k = (PIN_RADIUS + 1) / r
  return describeArc(r + 0.5, 1, r, 270 - 60 * k, 270 + 60 * k)
}

export const describeArrowShape = (shape: Shape, r: number): string => {
  if (shape === 'circle') {
    return describeArrowSemicircle(r)
  } else {
    return ARROW_FLAT
  }
}

const saveToUnitFile = async (
  system: System,
  fileHandle: FileSystemFileHandle,
  bundle: BundleSpec
) => {
  const {
    api: {
      text: { TextEncoder },
    },
  } = system

  const json = JSON.stringify(bundle, null, 2)

  try {
    const writableStream = await fileHandle.createWritable()

    if (CompressionStream && fileHandle.name.endsWith('.unit.gzip')) {
      function stringToStream(str) {
        const encoder = new TextEncoder()

        const uint8Array = encoder.encode(str)

        let position = 0

        return new ReadableStream({
          pull(controller) {
            const chunkSize = 1024

            if (position >= uint8Array.length) {
              controller.close()

              return
            }

            const chunk = uint8Array.slice(position, position + chunkSize)

            controller.enqueue(chunk)

            position += chunkSize
          },
        })
      }

      const inputReadableStream = stringToStream(bundle)

      const compressedReadableStream = inputReadableStream.pipeThrough(
        new CompressionStream('gzip')
      )

      compressedReadableStream.pipeTo(writableStream)
    } else {
      await writableStream.write(json)
      await writableStream.close()
    }
  } catch (err) {
    // console.log(err)
  }
}

export const ARROW_NONE = ''
export const ARROW_MEMORY = 'M-6,4 L0,1 L-6,-2'
export const ARROW_NORMAL = 'M-0.25,2.25 L2,1 L-0.25,-0.25'
export const ARROW_FLAT = 'M0,8 L0,-5.5'
export const ARROW_SEMICIRCLE = describeArrowSemicircle(PIN_RADIUS)
export const ID_ARROW_MEMORY = 'id-arrow-memory'
export const ID_ARROW_NORMAL = 'id-arrow-normal'
export const ID_ARROW_SEMICIRCLE = 'id-arrow-semicircle'

export const LAYOUT_HORIZONTAL_PADDING = 45
export const LAYOUT_VERTICAL_PADDING = 80

export const KEYBOARD_POINTER_ID = -1

export const LAYER_OPACITY_MULTIPLIER = 0.1

export const DEFAULT_IGNORED_PIN_SET_OPACITY = 0.5

export const DEFAULT_SELECTION_PADDING = 6

const DEFAULT_STYLE = {
  position: 'relative',
  width: '100%',
  height: '100%',
  overflow: 'hidden',
  touchAction: 'none',
}

export type Config_ = {
  zoom: Zoom & {
    minZoom: number
    maxZoom: number
  }
}

export type Config = {
  geometryOverride: boolean
  plugIcons: boolean
  unlinkTake: boolean
  dataCreate: boolean
  dataEdit: boolean
  dataUnlink: boolean
  dataSelect: boolean
  dataCompatible: boolean
  drawing: boolean
  enterGraph: boolean
  highlightCompatible: boolean
  plugReverse: boolean
  plugUnit: boolean
  multiInputMerge: boolean
  edgeDrag: boolean
  animate: boolean
  zoom: boolean | Partial<Config_['zoom']>
  plugNames: boolean
  unitNames: boolean
  pinNames: boolean
}

export interface Props {
  className?: string
  style?: Dict<string>
  attr?: Dict<string>
  disabled?: boolean
  graph?: $Graph
  editor?: Editor_
  controls?: boolean
  fullwindow?: boolean
  component?: Component
  frame?: $Component
  fallback?: Component<HTMLElement>
  container?: Component<HTMLElement>
  background?: Div
  transcend?: Transcend
  root?: Frame
  zoom?: Zoom
  animate?: boolean
  typeCache?: TypeTreeMap
  config?: Config
  fork?: boolean
  system?: System
}

export default class Editor extends Element<HTMLDivElement, Props> {
  private _pod: $Graph

  private _root: Frame
  private _editor: Editor_
  private _component: Component
  private _fallback_frame_container: Component<HTMLElement>
  private _fallback_frame: Component<HTMLElement>
  private _transcend: Transcend
  private _frame: Component<HTMLElement>
  private _frame_out: boolean = false
  private _background: Div

  private _system: System

  private _unlisten_graph: Unlisten
  private _unlisten_transcend: Unlisten

  private _type_cache: TypeTreeMap = {}

  constructor($props: Props, $system: System) {
    super(deepMerge(defaultProps, $props), $system)

    const {
      graph,
      className,
      style,
      attr,
      zoom,
      config,
      controls = true,
      animate,
      fullwindow,
      fallback,
      container,
      system,
    } = this.$props

    let { component, editor, transcend, background, root } = $props

    const specs = weakMerge(this.$system.specs, {})

    this._system =
      system ??
      this.$system.boot({
        specs,
      })

    mirror(this.$system.specs_, this._system.specs_)

    this._pod = graph

    this._fallback_frame_container =
      container || this._create_fallback_frame_container()

    this._fallback_frame = fallback || this._create_fallback_frame()

    this._frame = this._fallback_frame

    transcend =
      transcend ||
      new Transcend(
        {
          down: fullwindow,
          style: {
            display: controls ? 'flex' : 'none',
          },
        },
        this.$system
      )
    this._transcend = transcend

    this._listen_transcend()

    this._component = component ?? parentComponent({}, this.$system)

    if (editor) {
      mergeProps(editor, {
        specs: this._system.specs,
        typeCache: this._type_cache,
        system: this._system,
        hasSpec: this._has_spec,
        emptySpec: this._empty_spec,
        getSpec: this._get_spec,
        setSpec: this._set_spec,
        newSpec: this._new_spec,
        deleteSpec: this._delete_spec,
        forkSpec: this._fork_spec,
        injectSpecs: this._inject_specs,
        shouldFork: this._should_fork,
        lockSpec: this._lock_spec,
        unlockSpec: this._unlock_spec,
        registerUnit: this._register_unit,
        unregisterUnit: this._unregister_unit,
        newSpecId: this._new_spec_id,
        dispatchEvent: this._dispatch_event,
        enterFullwindow: this._enter_fullwindow,
        leaveFullwindow: this._leave_fullwindow,
      })
    } else {
      editor = new Editor_(
        {
          className,
          graph: this._pod,
          frame: this._frame,
          container: this._fallback_frame_container,
          component: this._component,
          zoom,
          fullwindow,
          config,
          specs: this._system.specs,
          system: this._system,
          typeCache: this._type_cache,
          hasSpec: this._has_spec,
          emptySpec: this._empty_spec,
          getSpec: this._get_spec,
          setSpec: this._set_spec,
          newSpec: this._new_spec,
          deleteSpec: this._delete_spec,
          forkSpec: this._fork_spec,
          injectSpecs: this._inject_specs,
          shouldFork: this._should_fork,
          registerUnit: this._register_unit,
          unregisterUnit: this._unregister_unit,
          lockSpec: this._lock_spec,
          unlockSpec: this._unlock_spec,
          newSpecId: this._new_spec_id,
          dispatchEvent: this._dispatch_event,
          enterFullwindow: this._enter_fullwindow,
          leaveFullwindow: this._leave_fullwindow,
        },
        this.$system
      )

      editor.enter(false, {}, true)
    }

    this._editor = editor

    this._editor.addEventListeners([
      makeCustomListener('data_removed', ({ datumId, specId }) => {
        const { specs } = this._system

        if (specs[specId] && isSystemSpecId(specs, specId)) {
          // console.log('data_removed', { datumId, specId })

          const spec = clone(specs[specId]) as GraphSpec

          removeDatum({ datumId }, spec)

          this._system.setSpec(specId, spec)
        }
      }),
      makeCustomListener('data_added', ({ datumId, specId, value }) => {
        const { specs } = this._system

        if (specs[specId] && isSystemSpecId(specs, specId)) {
          // console.log('data_added', { datumId, specId, value })

          const spec = clone(specs[specId]) as GraphSpec

          setDatum({ datumId, value }, spec)

          this._system.setSpec(specId, spec)
        }
      }),
    ])

    this._reset_frame()
    this._listen_graph()

    background =
      background ||
      new Div(
        {
          style: {
            className: 'graph-background',
            position: 'absolute',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
          },
        },
        this.$system
      )
    this._background = background

    root =
      root ||
      new Frame(
        {
          className: 'graph-root',
          style: {
            position: 'relative',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            overflow: 'hidden',
          },
        },
        this.$system
      )
    root.registerParentRoot(this._background)
    root.registerParentRoot(this._editor)
    root.registerParentRoot(this._fallback_frame_container)
    root.registerParentRoot(this._transcend)

    this._fallback_frame_container.registerParentRoot(this._fallback_frame)

    preventContextMenu(root)

    this._root = root

    this._root.$ref['transcend'] = transcend

    this._reset_graph()

    const $element = parentElement($system)

    this.$element = $element
    this.$slot = {
      default: this._editor.$slot['default'],
      '1': this._background.$slot['default'],
    }
    this.$unbundled = false
    this.$primitive = true

    applyAttr(this._root.$element, attr ?? {}, {}, new Set())
    applyDynamicStyle(this, this._root.$element, { ...DEFAULT_STYLE, ...style })

    this.setSubComponents({
      background,
      root,
      editor,
      container: this._fallback_frame_container,
      frame: this._fallback_frame,
      transcend,
    })

    this.registerRoot(this._root)
  }

  private _dispatch_event = (type: string, detail: any, bubbles: boolean) => {
    this.dispatchEvent(type, detail, bubbles)
  }

  onDestroy() {
    super.onDestroy()

    this._editor.destroy()
  }

  moment(path, data: { type: 'unit' | 'graph'; moment: Moment }): void {
    this._editor.moment(path, data)
  }

  public focus(options: FocusOptions | undefined = { preventScroll: true }) {
    // console.log('Editor', 'focus')

    this._editor.focus()
  }

  public blur(options: FocusOptions | undefined = { preventScroll: true }) {
    // console.log('Editor', 'blur')

    this._editor.blur()
  }

  private _set_spec = (id: string, spec: GraphSpec): void => {
    // console.log('Graph', '_set_spec', id, spec)

    delete this._type_cache[id]

    this._system.setSpec(id, spec)
  }

  private _fork_spec = (
    spec: GraphSpec,
    specId: string
  ): [string, GraphSpec] => {
    // console.log('Graph', '_fork_spec', spec, specId)

    return this._system.forkSpec(spec, specId)
  }

  private _enter_fullwindow = () => {
    this._fallback_frame_container.$element.style.pointerEvents = 'inherit'
  }

  private _leave_fullwindow = () => {
    this._fallback_frame_container.$element.style.pointerEvents = 'none'
  }

  private _new_spec_id = () => {
    return this._system.newSpecId()
  }

  private _has_spec = (id: string): boolean => {
    return this._system.hasSpec(id)
  }

  private _empty_spec = () => {
    return this._system.emptySpec()
  }

  private _new_spec = (spec: GraphSpec) => {
    return this._system.newSpec(spec)
  }

  private _get_spec = (id: string): Spec => {
    return this._system.getSpec(id)
  }

  private _delete_spec = (id: string) => {
    return this._system.deleteSpec(id)
  }

  private _inject_specs = (specs: GraphSpecs) => {
    return this._system.injectSpecs(specs)
  }

  private _register_unit = (id: string) => {
    return this._system.registerUnit(id)
  }

  private _unregister_unit = (id: string) => {
    return this._system.unregisterUnit(id)
  }

  private _should_fork = (id: string): boolean => {
    return this._system.shouldFork(id)
  }

  private _lock_spec = (id: string): void => {
    return this._system.lockSpec(id)
  }

  private _unlock_spec = (id: string): void => {
    return this._system.unlockSpec(id)
  }

  private _create_fallback_frame_container = (): Component => {
    return new Div(
      {
        className: 'graph-fallback-frame-container',
        style: {
          position: 'absolute',
          top: '0',
          left: '0',
          width: '100%',
          height: '100%',
          overflow: 'auto',
          pointerEvents: 'none',
          zIndex: '0',
        },
        attr: {
          tabindex: '-1',
        },
      },
      this.$system
    )
  }

  private _create_fallback_frame = (): Component => {
    const { component: fallback_frame } = graphComponentFromId(
      this.$system,
      ID_SCROLL_SNAP_Y_DIV,
      {
        style: {
          position: 'absolute',
          top: '0',
          left: '0',
          width: '100%',
          height: '100%',
          overflow: 'auto',
          zIndex: '0',
          'white-space': 'normal',
        },
      }
    )

    return fallback_frame
  }

  private _listen_graph = (): void => {
    this._unlisten_graph = this._editor.addEventListeners([
      makeCustomListener(
        'transcend',
        () => {
          this._on_transcend()
        },
        false
      ),
      makeCustomListener('zoom', this._on_zoom),
    ])
  }

  private _listen_transcend = (): void => {
    this._unlisten_transcend = this._transcend.addEventListener(
      makeCustomListener('transcend', this._on_transcend_detach, false)
    )
  }

  private _on_transcend_detach = () => {
    this._on_transcend()
  }

  private _reset_graph = () => {
    const { graph } = this.$props

    this._pod = graph
  }

  private _reset_frame = (): void => {
    // console.log('Graph', '_reset_frame')

    const { frame, animate } = this.$props

    const set = (frame: Component<HTMLElement>, frame_out: boolean) => {
      this._frame = frame
      this._frame_out = frame_out

      this.$ref['foreground'] =
        findRef(this._frame, 'foreground') ?? this._frame

      this._editor.setProp('frame', this._frame)
      this._editor.setProp('frameOut', this._frame_out)
    }

    if (frame) {
      frame.$getGlobalId({}, async (globalId) => {
        const _frame = (await firstGlobalComponentPromise(
          this.$system,
          globalId
        )) as Component<HTMLElement>

        if (_frame) {
          set(_frame, true)
        }
      })
    } else {
      set(this._fallback_frame, false)
    }
  }

  private _on_transcend = (): void => {
    // console.log('Graph', '_on_transcend')

    const { specs } = this.$system
    const { $width, $height } = this.$context
    const { config } = this.$props

    const id = newSpecId(specs)

    const editor_unit_id = 'editor'

    const fullwindow = this._editor.isFullwindow()
    const editor_bundle = this._editor.getUnitBundle()

    const GRAPH_WIDTH = 300
    const GRAPH_HEIGHT = 300
    const PADDING = 60

    let max_width = Number.MIN_SAFE_INTEGER
    let max_height = Number.MIN_SAFE_INTEGER

    const nodes = this._editor.get_nodes()

    for (const node_id in nodes) {
      const node = nodes[node_id]

      const { width, height } = node

      max_width = Math.max(max_width, width)
      max_height = Math.max(max_height, height)
    }

    const _width = clamp(max_width, GRAPH_WIDTH, $width)
    const _height = clamp(max_height, GRAPH_HEIGHT, $height)

    const width = _width + PADDING
    const height = _height + PADDING

    const editor_unit_spec = {
      id: ID_EDITOR,
      input: {
        controls: {
          ignored: true,
        },
        zoom: {
          ignored: true,
        },
        fullwindow: {
          ignored: !fullwindow,
          data: `${fullwindow}`,
        },
        disabled: {
          ignored: true,
        },
        frame: {
          ignored: true,
        },
        graph: {
          constant: true,
          ignored: false,
        },
      },
      metadata: {
        component: {
          width,
          height,
        },
      },
    }

    const spec = this.$system.emptySpec({ id })

    spec.units = spec.units || {}
    spec.units[editor_unit_id] = editor_unit_spec
    spec.component = {
      subComponents: {
        [editor_unit_id]: {},
      },
      children: [editor_unit_id],
    }

    const bundle = {
      unit: {
        id,
      },
      specs: {
        [id]: spec,
      },
    }

    this._editor._prevent_next_reset = true

    this._unlisten_graph()
    this._unlisten_transcend()

    this.unregisterRoot(this._root)

    this._root.unregisterParentRoot(this._transcend)
    this._root.unregisterParentRoot(this._fallback_frame_container)
    this._root.unregisterParentRoot(this._editor)
    this._root.unregisterParentRoot(this._background)

    this._fallback_frame_container.unregisterParentRoot(this._fallback_frame)

    this.removeSubComponent('transcend')
    this.removeSubComponent('background')
    this.removeSubComponent('editor')
    this.removeSubComponent('root')
    this.removeSubComponent('frame')

    let graph_slot = this._editor.$slot['default']
    let graph_slot_element = graph_slot.$element

    let background_slot = this._background.$slot['default']
    let background_slot_element = background_slot.$element

    const background_slot_children = []

    while (background_slot_element.firstChild) {
      background_slot_children.unshift(background_slot_element.lastChild)
      background_slot_element.removeChild(background_slot_element.lastChild)
    }

    const unit_editor = new Editor(
      {
        graph: this._pod,
        editor: this._editor,
        fallback: this._fallback_frame,
        container: this._fallback_frame_container,
        transcend: this._transcend,
        background: this._background,
        root: this._root,
        component: this._component,
        fullwindow: true,
        system: this._system,
      },
      this.$system
    )

    unit_editor.$preventLoad = true

    const transcend = new Transcend({}, this.$system)

    this._transcend = transcend

    this._listen_transcend()

    this._fallback_frame_container = this._create_fallback_frame_container()

    const fallback_frame = this._create_fallback_frame()

    this._fallback_frame = fallback_frame

    const Parent = parentClass()

    const component = new Parent({}, this.$system)

    component.setSubComponent(editor_unit_id, unit_editor)
    component.pushRoot(unit_editor)

    this._component = component

    const style = this.getProp('style')

    const parent_graph = new Graph(spec, {}, this.$system, spec.id)

    parent_graph.play()

    const parent_pod = proxyWrap(AsyncGraph(parent_graph), UCGEE)

    this._pod = parent_pod

    const editor = new Editor_(
      {
        style,
        graph: this._pod,
        system: this._system,
        component: this._component,
        container: this._fallback_frame_container,
        frame: this._fallback_frame,
        specs: this._system.specs,
        typeCache: this._type_cache,
        config,
        disabled: false,
        hasSpec: this._has_spec,
        emptySpec: this._empty_spec,
        getSpec: this._get_spec,
        setSpec: this._set_spec,
        newSpec: this._new_spec,
        deleteSpec: this._delete_spec,
        forkSpec: this._fork_spec,
        shouldFork: this._should_fork,
        injectSpecs: this._inject_specs,
        registerUnit: this._register_unit,
        unregisterUnit: this._unregister_unit,
        lockSpec: this._lock_spec,
        unlockSpec: this._unlock_spec,
        newSpecId: this._new_spec_id,
        dispatchEvent: this._dispatch_event,
        enterFullwindow: this._enter_fullwindow,
        leaveFullwindow: this._leave_fullwindow,
      },
      this.$system
    )

    this._editor = editor

    this._listen_graph()

    const background = new Div(
      {
        style: {
          className: 'graph-background',
          position: 'absolute',
          top: '0',
          left: '0',
          width: '100%',
          height: '100%',
        },
      },
      this.$system
    )
    this._background = background

    const root = new Frame(
      {
        className: 'graph-root',
        style: {
          position: 'relative',
          top: '0',
          left: '0',
          width: '100%',
          height: '100%',
          overflow: 'hidden',
        },
      },
      this.$system
    )
    this._root = root

    graph_slot = this._editor.$slot['default']
    graph_slot_element = graph_slot.$element

    background_slot = this._background.$slot['default']
    background_slot_element = background_slot.$element

    this.$slot = {
      default: graph_slot,
      '1': background_slot,
    }

    for (const child of background_slot_children) {
      background_slot_element.appendChild(child)
    }

    this.setSubComponents({
      background,
      root,
      editor,
      frame: this._fallback_frame,
      container: this._fallback_frame_container,
      transcend,
    })

    this._root.$ref['transcend'] = transcend

    this._root.registerParentRoot(this._background)
    this._root.registerParentRoot(this._editor)
    this._root.registerParentRoot(this._fallback_frame_container)
    this._root.registerParentRoot(this._transcend)

    this._fallback_frame_container.registerParentRoot(this._fallback_frame)

    this.registerRoot(this._root)

    this._editor.select_node(editor_unit_id)
    this._editor.unlock_sub_component(editor_unit_id, true)
    this._editor.enter(false)
    this._editor.enterFullwindow(false, false)
    this._editor.leaveFullwindow(true)
    this._editor.temp_fixate_node(editor_unit_id, 100)

    this._editor._prevent_next_reset = false

    this._editor.__spec_set_pin_data('editor', 'input', 'graph', {
      ref: [[]],
      data: editor_bundle,
    })
  }

  private _on_zoom = (zoom) => {
    // console.log('Graph', '_on_zoom')
    this.set('zoom', zoom)
  }

  onPropChanged(prop: string, current: any): void {
    // console.log('Graph', name, current)

    if (prop === 'style') {
      this._root.setProp('style', {
        ...DEFAULT_STYLE,
        ...current,
      })

      mergePropStyle(this._editor, {
        color: current?.color,
      })
    } else if (prop === 'attr') {
      const attr = current ?? {}

      applyAttr(
        this._root.$element,
        attr,
        this.getProp('attr') ?? {},
        new Set()
      )
    } else if (prop === 'disabled') {
      this._editor.setProp('disabled', current)
    } else if (prop === 'graph') {
      this._reset_graph()

      this._editor.setProp('graph', this._pod)
    } else if (prop === 'frame') {
      this._reset_frame()
    } else if (prop === 'fullwindow') {
      this._editor.setProp('fullwindow', current)
    } else if (prop === 'zoom') {
      this._editor.setProp('zoom', current)
    } else if (prop === 'controls') {
      mergePropStyle(this._transcend, {
        display: current ? 'flex' : 'none',
      })
    } else if (prop === 'config') {
      this._editor.setProp('config', current)
    }
  }
}

export interface LinkProps {
  style?: Dict<string>

  className?: string
  hidden?: boolean

  stroke?: string
  opacity?: number
  strokeWidth?: number
  strokeDasharray?: number

  text?: string
  textHidden?: boolean
  textVisibility?: string
  textDy?: number
  textOpacity?: number

  showStart?: boolean
  showEnd?: boolean

  startMarker?: SVGPath | null
  startMarkerX?: number

  endMarker?: SVGPath | null
  endMarkerX?: number
}

export interface LinkArrowOpt {
  fill?: string
}

export interface LinkMarkerOpt {
  component?: Element | null
  x?: number
}

export type UnitPinPosition = IOOf<Dict<Position>>

export interface ExposedPosition {
  internal: Position
  external: Position
}

export interface MaxLinkHeapValue {
  link_id: string
  l: number
  t: number
}

export interface SelectionOpt {
  className?: string
  style?: object
  width: number
  height: number
  paddingX?: number
  paddingY?: number
  shape: Shape
  strokeWidth?: number
  strokeDasharray?: string
  stroke?: string
}

export interface AreaOpt {
  className?: string
  width: number
  height: number
  style?: Dict<string>
}

export interface Props_ extends R {
  className?: string
  style?: Dict<string>
  disabled?: boolean
  fullwindow?: boolean
  parent?: Editor_
  graph: $Graph
  component: Component
  frame?: Component<HTMLElement>
  container: Component<HTMLElement>
  frameOut?: boolean
  fork?: boolean
  bubble?: boolean
  specs?: Specs
  system?: System
  typeCache?: TypeTreeInterfaceCache
  config?: Config
  zoom?: Zoom
  dispatchEvent: (type: string, detail: any, bubbles: boolean) => void
  enterFullwindow: () => void
  leaveFullwindow: () => void
}

export interface DefaultProps {
  style: Dict<string>
  config: Omit<Config, 'zoom'> & Config_
}

const defaultProps: DefaultProps = {
  style: {},
  config: {
    zoom: {
      x: 0,
      y: 0,
      z: 1,
      minZoom: 1,
      maxZoom: 6,
    },
    animate: true,
    geometryOverride: false,
    plugIcons: false,
    unlinkTake: false,
    dataCreate: true,
    dataEdit: true,
    dataUnlink: true,
    dataSelect: true,
    dataCompatible: true,
    drawing: true,
    enterGraph: true,
    highlightCompatible: true,
    plugReverse: true,
    plugUnit: true,
    multiInputMerge: true,
    edgeDrag: true,
    plugNames: true,
    unitNames: true,
    pinNames: true,
  },
}

// zoom

export const ZOOM_INTENSITY = 0.05

// selection

export const NOT_SELECTED_AREA = { x0: 0, y0: 0, x1: 0, y1: 0 }

// area

export const NODE_PADDING: number = 12

export const hasPinId = (spec: Spec, type: IO, pinId: string): boolean => {
  return !!(spec[`${type}s`] || {})[pinId]
}

export const newSpecPinId = (
  spec: GraphSpec,
  type: IO,
  start: string,
  blacklist: Set<string> = new Set()
): string => {
  let i = 0
  let newPinId = start

  while (hasPinId(spec, type, newPinId) || blacklist.has(newPinId)) {
    newPinId = `${start}${i}`
    i++
  }

  return newPinId
}

export const newSpecPinIdStart = (spec: GraphSpec, type: IO): string => {
  let pin_id_start_i = 97
  let pin_id_start = 'a'

  while (hasPinId(spec, type, pin_id_start)) {
    pin_id_start_i++
    pin_id_start = String.fromCharCode(pin_id_start_i)
  }

  return pin_id_start
}

export const newSubPinId = (
  pinSpec: GraphPinSpec,
  blacklist: Set<string> = new Set()
): string => {
  const { plug = {} } = pinSpec

  let i = 0

  while (plug[i] || blacklist.has(`${i}`)) {
    i++
  }

  return `${i}`
}

export const LAYER_NONE = 0
export const LAYER_NORMAL = 1
export const LAYER_COLLAPSE = 2
export const LAYER_SEARCH = 3
export const LAYER_IGNORED = 4
export const LAYER_EXPOSED = 5
export const LAYER_DATA_LINKED = 6
export const LAYER_DATA = 7
export const LAYER_ERR = 8
export const LAYER_TYPE = 9

export const NODE_MASS_RELATIVE: number[][] = [
  [1, 1, 0, 1, 1, 1, 1, 1, 1, 1], // none           // 0
  [0, 1, 0, 1, 1, 1, 1, 1, 1, 1], // normal         // 1
  [0, 1, 0, 1, 1, 1, 1, 1, 1, 1], // collapse       // 2
  [0, 0, 0, 1, 1, 1, 0, 1, 1, 1], // search         // 3
  [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], // ignored        // 4
  [0, 0, 0, 0, 0, 1, 1, 1, 1, 1], // exposed        // 5
  [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], // data (linked)  // 6
  [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], // data           // 7
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1], // err            // 8
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // type           // 9
]

export const LINK_MASS_RELATIVE: number[][] = [
  [1, 1, 0, 1, 1, 1, 1, 1, 1, 1], // none           // 0
  [0, 1, 0, 1, 1, 1, 1, 1, 1, 1], // normal         // 1
  [0, 1, 0, 1, 1, 1, 1, 1, 1, 1], // collapse       // 2
  [0, 0, 0, 1, 1, 1, 1, 1, 1, 1], // search         // 3
  [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], // ignored        // 4
  [0, 0, 0, 0, 0, 1, 1, 1, 1, 1], // exposed        // 5
  [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], // data (linked)  // 6
  [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], // data           // 7
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1], // err            // 8
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // type           // 9
]

const SCMD = LINK_DISTANCE / SUBGRAPH_MAX_D / 3 // SUBGRAPH_CLOSE_MAX_D

export const SUBGRAPH_RELATIVE_MAX_L: number[][] = [
  [1, 1, 1, 1, 1, SCMD, 1, 1, 1, SCMD], // 0
  [1, 1, 1, 1, 1, SCMD, SCMD, 1, 1, SCMD], // 1
  [1, 1, 1, 1, 1, SCMD, 1, 1, 1, SCMD], // 2
  [1, 1, 1, 1, 1, SCMD, 1, 1, 1, SCMD], // 3
  [1, 1, 1, 1, 1, SCMD, 1, 1, 1, SCMD], // 4
  [1, 1, 1, 1, 1, 3 * SCMD, 1, 1, 1, SCMD], //5
  [1, 1, 1, 1, 1, 1, 1, 1, 1, SCMD], // 6
  [1, 1, 1, 1, 1, 1, 1, 1, 1, SCMD],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, SCMD],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, SCMD],
]

const NSCMD = LINK_DISTANCE / NOT_SUBGRAPH_MAX_D / 3 // NOT_SUBGRAPH_CLOSE_MAX_D

export const NOT_SUBGRAPH_RELATIVE_MAX_D: number[][] = [
  [1, 1, 1, 1, 1, 1, 1, 1, 1, SCMD],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, SCMD],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, SCMD],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, SCMD],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, SCMD],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, SCMD],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, SCMD],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, SCMD],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, SCMD],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, SCMD],
]

const SIMULATION_DEFAULT_ALPHA_DECAY = 0.01

export type GraphSimLink = SimLink<{ type: string; head: number }>
export type GraphSimLinks = Dict<GraphSimLink>
export type GraphSimNode = SimNode<{
  layer: number
  _width?: number
  _height?: number
  _r?: number
}>
export type GraphSimNodes = Dict<GraphSimNode>

const _tree_cache: Dict<TreeNode> = {}
const _type_match_cache: Dict<boolean> = {}

export const _isTypeMatch__cached = (
  specs: Specs,
  source: TreeNode,
  target: TreeNode
): boolean => {
  const cacheKey = `${source.value}@${target.value}`

  if (_type_match_cache[cacheKey]) {
    return _type_match_cache[cacheKey]
  }

  const match = _isTypeMatch(specs, source, target)

  _type_match_cache[cacheKey] = match

  return match
}

export const getTree__cached = (
  value: string,
  keyValue?: boolean,
  ignoreKeyword?: boolean
): TreeNode => {
  if (_tree_cache[value]) {
    return _tree_cache[value]
  }

  const tree = getTree(value, keyValue, ignoreKeyword)

  _tree_cache[value] = tree

  return tree
}

const _value_type_cache: Dict<TreeNode> = {}

export const getValueType__cached = (
  specs: Specs,
  data: TreeNode
): TreeNode => {
  if (_value_type_cache[data.value]) {
    return _value_type_cache[data.value]
  }

  const tree = _getValueType(specs, data)

  _value_type_cache[data.value] = tree

  return tree
}

export const _getValueTree__cached = (value: string): TreeNode => {
  if (_tree_cache[value]) {
    return _tree_cache[value]
  }
  const tree = getValueTree(value)
  _tree_cache[value] = tree
  return tree
}

const _evaluate_cache: {
  [value: string]: any
} = {}

export const _evaluate__cached = (
  value: string,
  specs: Specs,
  classes: Classes
): any => {
  if (_evaluate_cache[value]) {
    return _evaluate_cache[value]
  }

  const data = evaluate(value, specs, classes)

  _evaluate_cache[value] = data

  return data
}

const buildGraphRemap = (
  spec: GraphSpec,
  getSpec,
  newUnitId,
  newMergeId,
  newSubPinId,
  newDatumId
) => {
  const { units = {}, merges = {}, inputs = {}, outputs = {}, data = {} } = spec

  const map_unit_id: Dict<string> = {}
  const map_merge_id: Dict<string> = {}
  const map_input_id: Dict<string> = {}
  const map_output_id: Dict<string> = {}
  const map_plug_id: IOOf<Dict<Dict<string>>> = { input: {}, output: {} }
  const map_datum_id: Dict<string> = {}

  const set_unit_id: Set<string> = new Set()
  const set_merge_id: Set<string> = new Set()
  const set_plug_id: IOOf<Dict<Set<string>>> = { input: {}, output: {} }
  const set_output_id: Set<string> = new Set()
  const set_datum_id: Set<string> = new Set()

  const selected_node_ids = []

  const pin_to_merge = {}
  const pin_to_plug = {}
  const merge_to_plug = {}

  for (const unit_id in units) {
    const unit: GraphUnitSpec = units[unit_id]

    const { id } = unit

    const new_unit_id = newUnitId(id, set_unit_id)

    set_unit_id.add(new_unit_id)

    map_unit_id[unit_id] = new_unit_id

    selected_node_ids.push(new_unit_id)
  }

  for (const merge_id in merges) {
    const merge_spec = merges[merge_id]

    let ref = false
    let pin_ref = false

    forEachPinOnMerge(merge_spec, (unitId, type, pinId) => {
      if (pinId === SELF) {
        ref = true

        return
      }

      const unit = units[unitId]

      const unit_spec = getSpec(unit.id)

      if (unit_spec[`${type}s`]?.[pinId]?.ref) {
        ref = true
        pin_ref = true
      }
    })

    const new_merge_id = newMergeId(set_merge_id)

    set_merge_id.add(new_merge_id)

    map_merge_id[merge_id] = new_merge_id

    const new_merge_node_id = getMergeNodeId(new_merge_id)

    if (!ref || pin_ref) {
      selected_node_ids.push(new_merge_node_id)
    }

    forEachPinOnMerge(merge_spec, (unit_id, type, pin_id) => {
      deepSet(pin_to_merge, [unit_id, type, pin_id], new_merge_id)
    })
  }

  const process_pin = (type: IO, pin_id: string): void => {
    const pin_spec = spec[`${type}s`][pin_id]

    const { plug = {} } = pin_spec

    for (const sub_pin_id in plug) {
      set_plug_id[type][pin_id] = set_plug_id[type][pin_id] ?? new Set()

      const new_sub_pin_id = newSubPinId(
        type,
        pin_id,
        set_plug_id[type][pin_id]
      )

      deepSet(map_plug_id, [type, pin_id, sub_pin_id], new_sub_pin_id)

      set_plug_id[type][pin_id].add(new_sub_pin_id)

      const sub_pin = plug[sub_pin_id]

      if (sub_pin.unitId && sub_pin.pinId) {
        const next_unit_id = map_unit_id[sub_pin.unitId]

        deepSet(pin_to_plug, [next_unit_id, type, sub_pin.pinId], {
          pin_id,
          pin_spec,
          sub_pin_id,
          sub_pin,
        })
      } else if (sub_pin.mergeId) {
        //
      } else {
        //
      }
    }
  }

  for (const input_id in inputs) {
    process_pin('input', input_id)
  }
  for (const output_id in outputs) {
    process_pin('output', output_id)
  }

  for (const unit_id in units) {
    const unit: GraphUnitSpec = units[unit_id]

    const { id } = unit

    const new_unit_id = map_unit_id[unit_id]

    const unit_spec = getSpec(id)

    forEachGraphSpecPin(unit_spec, (type, unit_pin_id, unit_pin_spec) => {
      const { defaultIgnored, plug = {} } = unit_pin_spec

      const pin_node_id = getPinNodeId(new_unit_id, type, unit_pin_id)

      const next_merge_id = deepGetOrDefault(
        pin_to_merge,
        [unit_id, type, unit_pin_id],
        null
      )

      const next_plug_spec = deepGetOrDefault(
        pin_to_plug,
        [new_unit_id, type, unit_pin_id],
        null
      )

      if (!defaultIgnored) {
        if (next_merge_id) {
          //
        } else {
          if (next_plug_spec) {
            if (
              shouldExposePin(
                type,
                next_plug_spec.pin_id,
                next_plug_spec.pin_spec,
                next_plug_spec.sub_pin_id,
                next_plug_spec.sub_pin,
                false
              )
            ) {
              selected_node_ids.push(pin_node_id)
            }
          } else {
            selected_node_ids.push(pin_node_id)
          }
        }
      }
    })
  }

  for (const datum_id in data) {
    const new_datum_id = newDatumId(set_datum_id)

    set_datum_id.add(new_datum_id)

    map_datum_id[datum_id] = new_datum_id

    const new_datum_node_id = getDatumNodeId(new_datum_id)

    selected_node_ids.push(new_datum_node_id)
  }

  return {
    map_unit_id,
    map_merge_id,
    map_plug_id,
    map_datum_id,
    selected_node_ids,
  }
}

const remapGraph = (
  graph: GraphSpec,
  map_unit_id: Dict<string>,
  map_merge_id: Dict<string>,
  map_plug_id: IOOf<Dict<Dict<string>>>,
  map_datum_id: Dict<string>
): GraphSpec => {
  const {
    units = {},
    merges = {},
    inputs = {},
    outputs = {},
    component = {},
    data = {},
    metadata = {},
  } = graph

  const _graph: GraphSpec = {
    units: {},
    merges: {},
    inputs: {},
    outputs: {},
    component: {
      subComponents: {},
      children: [],
    },
    data: {},
    metadata,
  }

  for (const unit_id in units) {
    const unit = units[unit_id]
    const new_unit_id = map_unit_id[unit_id] ?? unit_id

    _graph.units[new_unit_id] = unit
  }

  for (const merge_id in merges) {
    const merge = merges[merge_id]
    const new_merge_id = map_merge_id[merge_id] ?? merge_id
    const new_merge: GraphMergeSpec = {}

    for (const unit_id in merge) {
      const unit = merge[unit_id]
      const new_unit_id = map_unit_id[unit_id]

      new_merge[new_unit_id] = unit
    }
    _graph.merges[new_merge_id] = new_merge
  }

  const type_pins = { input: inputs, output: outputs }

  io((type) => {
    const pins = type_pins[type]

    for (const pin_id in pins) {
      const type_pin = pins[pin_id]
      const { plug = {} } = type_pin

      const new_pin: GraphPinSpec = {
        ...type_pin,
        plug: {},
      }

      for (const sub_pin_id in plug) {
        const sub_pin = plug[sub_pin_id]

        const next_sub_pin_id = deepGetOrDefault(
          map_plug_id,
          [type, pin_id, sub_pin_id],
          sub_pin_id
        )

        const { unitId, pinId, mergeId, kind = type } = sub_pin

        if (unitId && pinId) {
          const new_unit_id = map_unit_id[unitId]

          if (new_unit_id) {
            new_pin.plug[next_sub_pin_id] = {
              unitId: new_unit_id,
              pinId,
              kind,
            }
          }
        } else if (mergeId) {
          const new_merge_id = map_merge_id[mergeId]

          if (new_merge_id) {
            new_pin.plug[next_sub_pin_id] = { mergeId: new_merge_id }
          }
        } else {
          new_pin.plug[next_sub_pin_id] = {}
        }
      }

      _graph[`${type}s`][pin_id] = new_pin
    }
  })

  const { subComponents = {}, children = [] } = component

  for (const child_id of children) {
    const new_unit_id = map_unit_id[child_id]

    _graph.component.children.push(new_unit_id)
  }

  for (const unit_id in subComponents) {
    const sub_component = subComponents[unit_id]

    const { children = [], childSlot = {} } = sub_component

    const new_unit_id = map_unit_id[unit_id]

    _graph.component.subComponents[new_unit_id] = {
      width: sub_component.width,
      height: sub_component.height,
      children: [],
      childSlot: {},
    }

    for (const child_id of children) {
      const new_child_id = map_unit_id[child_id]

      _graph.component.subComponents[new_unit_id].children.push(new_child_id)
      _graph.component.subComponents[new_unit_id].childSlot[new_child_id] =
        childSlot[child_id]
    }
  }

  for (const datum_id in data) {
    const value = data[datum_id]
    const new_datum_id = map_datum_id[datum_id] || datum_id
    _graph.data[new_datum_id] = value
  }

  return _graph
}

export const formatUnitName = (name: string, maxLineLength: number): string => {
  const emptyStartSize = name.length - name.trimStart().length
  const emptyEndSize = name.length - name.trimEnd().length

  const emptyStart = spaces(emptyStartSize)
  const emptyEnd = spaces(emptyEndSize)

  const _name = name.trim()

  const lines = getTextLines(_name, maxLineLength)

  const _lines = []

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]

    let line_to_add = line

    if (line.endsWith(' ') && i < lines.length - 1) {
      line_to_add = line_to_add.slice(0, -1) + '\n'
    }

    if (line_to_add.startsWith(' ')) {
      line_to_add = '\n' + line_to_add.slice(1)
    }

    _lines.push(line_to_add)
  }

  return emptyStart + _lines.join('') + emptyEnd
}

export const replaceNodeName = (name: string) => {
  return name.replace(/\s+/g, ' ').replace('\n', ' ')
}

const MAX_DEBUG_BUFFER_SIZE: number = 1000

const MAX_DROP_ELEMENT_WIDTH: number = 420
const MAX_DROP_ELEMENT_HEIGHT: number = 420

export type LayoutLayer = {
  layer: Div
  height: Div
  children: Div
  layers: Div
  foreground: Div
  content: Div
  child_foreground: Div
}

export class Editor_ extends Element<HTMLDivElement, Props_> {
  private _spec: GraphSpec = emptyGraphSpec()

  private _disabled: boolean = true
  private _input_disabled: boolean = true

  private _focused: boolean = false

  private _main: Div
  private _foreground: Div
  private _subgraph: Div

  private _graph: Div

  private _unlisten_minimap: Unlisten | undefined = undefined
  private _minimap_screen: SVGRect
  private _minimap_pointer_down: boolean = false

  private _subgraph_cache: Dict<Editor_> = {}
  private _subgraph_pod_cache: Dict<$Graph> = {}
  private _subgraph_graph: Editor_ | null = null
  private _subgraph_fork: boolean = true
  private _subgraph_unit_id: string | null = null
  private _subgraph_depth: number = 0
  private _subgraph_unlisten: Unlisten

  private _is_fullwindow: boolean = false
  private _is_all_fullwindow: boolean = false

  private _zoom: Zoom = clone(ZOOM_IDENTITY)
  private _touch_zoom_position_start = {
    x: 0,
    y: 0,
  }
  private _zoom_timeout: number | null = null
  private _touch_zoom_position = { x: 0, y: 0 }
  private _touch_zoom_d: number
  private _zooming = false

  private _translating: boolean = false
  private _translate_x: number = 0
  private _translate_y: number = 0

  private _unit_datum: {
    input: Dict<string>
    output: Dict<string>
  } = {
    input: {},
    output: {},
  }

  private _layout_comp: Div
  private _layout_root: LayoutLayer
  private _layout_layer: Dict<LayoutLayer> = {}
  private _layout_scroll_animation: number
  private _layout_core: Dict<Div> = {}

  private _between_container: Dict<Frame> = {}

  private _leaf_init_style: Dict<Style> = {}
  private _leaf_style: Dict<Style> = {}
  private _leaf_target_trait: Dict<LayoutNode> = {}
  private _leaf_attr: Dict<Dict<string>> = {}
  private _leaf_frame: Dict<Frame> = {}
  private _leaf_frame_active: Dict<boolean> = {}
  private _leaf_frame_layer: Dict<Component<HTMLElement>> = {}
  private _leaf_frame_node: Dict<LayoutNode> = {}

  private _layout_parent_children_animation_frame: Dict<number> = {}

  private _layout_parent_animation: Dict<number> = {}

  private _layout_transfer_parent_animating: Dict<boolean> = {}
  private _layout_transfer_parent_callback: Dict<Callback> = {}

  private _layout_transfer_parent_leaf: Dict<Dict<[string[], Component][]>> = {}
  private _layout_transfer_parent_leaf_sub_component_id: Dict<Dict<string[]>> =
    {}
  private _layout_transfer_parent_leaf_path: Dict<Dict<string[][]>> = {}
  private _layout_transfer_parent_leaf_comp: Dict<Dict<Component[]>> = {}
  private _layout_transfer_parent_leaf_count: Dict<Dict<number>> = {}
  private _layout_transfer_parent_leaf_end_count: Dict<Dict<number>> = {}
  private _layout_transfer_parent_leaf_end_set: Dict<Dict<Set<string>>> = {}
  private _layout_transfer_parent_remaining_child: Dict<Dict<Set<string>>> = {}

  private _zoom_comp: Zoom_
  private _zoom_comp_alt: Zoom_

  private _node_comp: Dict<Div> = {}
  private _node_content: Dict<Div> = {}
  private _node_selection: Dict<Selection> = {}

  private _link_comp: Dict<SVGG> = {}
  private _link_base: Dict<SVGPath> = {}
  private _link_base_area: Dict<SVGPath> = {}
  private _link_base_text: Dict<SVGPath> = {}
  private _link_text: Dict<SVGText> = {}
  private _link_text_value: Dict<string> = {}
  private _link_text_path: Dict<SVGTextPath> = {}
  private _link_marker_end: Dict<SVGPath> = {}
  private _link_marker_start: Dict<SVGPath> = {}

  private _core: Dict<Div> = {}
  private _core_content: Dict<Div> = {}
  private _core_main: Dict<Div> = {}
  private _core_area: Dict<Div> = {}
  private _core_icon: Dict<Icon> = {}
  private _core_name: Dict<TextArea> = {}
  private _core_description: Dict<TextArea> = {}

  private _edit_node_name_id: string | null = null
  private _edit_node_name_was_selected: boolean

  private _core_component_overlay: Dict<Div> = {}
  private _core_component_resize: Dict<Resize> = {}
  private _core_component_frame: Dict<Frame> = {}
  private _core_component_self: Dict<Div> = {}

  private _core_component_max_width: number[] = []
  private _core_component_max_height: number[] = []
  private _core_component_max_width_id: string[] = []
  private _core_component_max_height_id: string[] = []

  private _core_layout_core_unlisten: Dict<Unlisten> = {}

  private _core_component_frame_context: Dict<Context> = {}

  private _core_component_unlocked: Dict<boolean> = {}
  private _core_component_unlocked_count: number = 0

  private _pin: Dict<Div> = {}
  private _pin_name: Dict<TextField> = {}

  private _link_pin_ref_set: Set<string> = new Set()
  private _link_pin_input_set: Set<string> = new Set()
  private _link_pin_output_set: Set<string> = new Set()

  private _pin_link_start_marker: Dict<SVGPath> = {}
  private _pin_link_end_marker: Dict<SVGPath> = {}

  private _link_pin_constant_count: number = 0
  private _link_pin_memory_count: number = 0

  private _exposed_pin_set_count: number = 0

  private _exposed_pin_plugged_count = 0
  private _exposed_pin_unplugged_count = 0

  private _ext_pin_name: Dict<TextField> = {}
  private _exposed_link_start_marker: Dict<SVGPath> = {}
  private _exposed_link_end_marker: Dict<SVGPath> = {}
  private _int_to_node: Dict<string> = {}
  private _ext_to_node: Dict<string> = {}
  private _node_to_ext: Dict<Set<string>> = {}
  private _exposed_ext_unplugged: Dict<boolean> = {}
  private _exposed_int_unplugged: Dict<boolean> = {}

  private _merge: Dict<Div> = {}
  private _merge_name: Dict<TextField> = {}
  private _merge_input: Dict<Div> = {}
  private _merge_output: Dict<Div> = {}

  private _datum_container: Dict<Div> = {}
  private _datum_area: Dict<Div> = {}
  private _datum: Dict<Datum | ClassDatum> = {}
  private _datum_overlay: Dict<Div> = {}
  private _datum_unlisten: Dict<Unlisten> = {}

  private _err_comp: Dict<Div> = {}
  private _err_area: Dict<Div> = {}
  private _err_overlay: Dict<Div> = {}

  private _edit_datum_id: string | null = null
  private _edit_datum_node_id: string | null = null
  private _edit_datum_path: number[] | null = null
  private _edit_datum_committed: boolean = false
  private _edit_datum_last_manually_committed: boolean = false

  private _type_container: Dict<Div> = {}
  private _type: Dict<DataTree> = {}

  private _node_unlisten: Dict<Unlisten> = {}
  private _link_unlisten: Dict<Unlisten> = {}

  private _node: GraphSimNodes = {}
  private _node_fixed: Dict<boolean> = {}
  private _node_draggable: Dict<boolean> = {}
  private _node_charge: Dict<Dict<number>> = {}
  private _node_z: Dict<Dict<number>> = {}

  private _link_force_count_k: Dict<number> = {}

  private _node_link_count: Dict<number> = {}
  private _node_link_heap_root: Heap<{ count: number; id: string }> = null
  private _node_link_heap: Dict<Heap<{ count: number; id: string }>> = {}

  private _node_type: Dict<string> = {}
  private _link_type: Dict<string> = {}

  private _selection_opt: Dict<SelectionOpt> = {}

  private _link: GraphSimLinks = {}
  private _none_link: GraphSimLinks = {}
  private _pin_link: GraphSimLinks = {}
  private _exposed_link: GraphSimLinks = {}
  private _data_link: GraphSimLinks = {}
  private _type_link: GraphSimLinks = {}
  private _collapse_link: GraphSimLinks = {}
  private _search_link: GraphSimLinks = {}
  private _ignored_link: GraphSimLinks = {}
  private _visible_data_link: GraphSimLinks = {}
  private _err_link: GraphSimLinks = {}

  private _unit_node: GraphSimNodes = {}
  private _pin_node: GraphSimNodes = {}
  private _normal_node: GraphSimNodes = {}
  private _data_node: GraphSimNodes = {}
  private _err_node: GraphSimNodes = {}
  private _type_node: GraphSimNodes = {}
  private _collapse_node: GraphSimNodes = {}
  private _search_node: GraphSimNodes = {}
  private _ignored_node: GraphSimNodes = {}
  private _exposed_node: GraphSimNodes = {}
  private _exposed_ext_node: GraphSimNodes = {}
  private _exposed_int_node: GraphSimNodes = {}
  private _visible_data_node: GraphSimNodes = {}
  private _hidden_data_node: GraphSimNodes = {}
  private _linked_data_node: GraphSimNodes = {}
  private _visible_linked_data_node: GraphSimNodes = {}
  private _visible_unlinked_data_node: GraphSimNodes = {}
  private _unlinked_data_node: GraphSimNodes = {}
  private _empty_merge_node: GraphSimNodes = {}

  private _empty_merge_node_count: number = 0

  private _layer_node: GraphSimNodes[] = []
  private _layer_link: GraphSimLinks[] = []

  private _err: Dict<string> = {}

  private _unit_to_unit: Dict<number> = {}

  private _node_count: number = 0
  private _unit_count: number = 0

  private _unit_component_count: number = 0

  private _unit_active_pin_count: Dict<number> = {}

  private _component_nodes: GraphSimNodes = {}

  private _pressed_node_pointer_count: number = 0
  private _node_pressed_count: Dict<number> = {}
  private _pressed_node_count: number = 0
  private _pressed_node_id_pointer_id: Dict<Dict<boolean>> = {}
  private _pointer_id_pressed_node_id: Dict<string> = {}
  private _pointer_id_hover_link_id: Dict<string> = {}

  private _link_id_hover_pointer_id: Dict<number> = {}

  private _drag_count: number = 0
  private _drag_node_id: Dict<boolean> = {}
  private _drag_node_pointer_id: Dict<number> = {}
  private _drag_pointer_id_node: Dict<Set<string>> = {}

  private _drag_along_node: Dict<string[]> = {}
  private _drag_along_source: Dict<string> = {}
  private _drag_along_relative_position: Dict<Dict<Position>> = {}

  private _drag_ext_node_id: Set<string> = new Set()
  private _drag_ext_node_count: number = 0

  private _dropped_node_id: Set<string> = new Set()

  private _drag_and_drop: boolean = false
  private _drag_and_drop_pointer: number | null = null
  private _drag_and_drop_bundle: BundleSpec = null
  private _drag_and_drop_cancel: Unlisten

  private _transcend_pointer_id: number | null = null
  private _transcend_timeout: NodeJS.Timeout | null = null
  private _transcend_on_pointer_up: boolean = false

  private _static: boolean = false
  private _static_position: Dict<Position> = {}
  private _static_count: Dict<number> = {}
  private _static_subgraph_anchor: Dict<Dict<boolean>> = {}
  private _static_subgraph_anchor_count: Dict<number> = {}

  private _hover_node_count: number = 0
  private _hover_node_pointer_count: Dict<number> = {}
  private _hover_node_id: Dict<boolean> = {}
  private _hover_node_id_pointer_id: Dict<Dict<boolean>> = {}

  private _pointer_id_hover_node_id: Dict<string> = {}

  private _selected_node_count: number = 0
  private _selected_pin_count: number = 0
  private _selected_node_id: Dict<boolean> = {}

  private _selected_component_count: number = 0
  private _selected_component: Dict<boolean> = {}

  private _compatible_node_id: Dict<boolean> = {}
  private _compatible_node_count: number = 0

  private _resize_pointer_count: number = 0
  private _resize_node_id_pointer_id: Dict<number> = {}
  private _resize_pointer_id_node_id: Dict<string> = {}

  private _fullwindow_component_set: Set<string> = new Set()
  private _fullwindow_component_ids: string[] = []

  private _datum_tree: Dict<TreeNode> = {}

  private _datum_to_pin: Dict<string> = {}
  private _pin_to_datum: Dict<string> = {}

  private _datum_to_plug: Dict<string> = {}
  private _plug_to_datum: Dict<string> = {}

  private _pin_datum_tree: Dict<TreeNode> = {}

  private _pin_to_int: IOOf<Dict<string>> = {
    input: {},
    output: {},
  }
  private _pin_to_ext: IOOf<Dict<string>> = {
    input: {},
    output: {},
  }

  private _pin_to_merge: Dict<string> = {}

  private _pin_invalid_set: Set<string> = new Set()

  private _merge_to_pin: Dict<Dict<boolean>> = {}
  private _merge_to_input: Dict<Dict<boolean>> = {}
  private _merge_to_output: Dict<Dict<boolean>> = {}

  private _merge_pin_name_count: Dict<IOOf<Dict<number>>> = {}
  private _merge_pin_count: Dict<number> = {}
  private _merge_output_count: Dict<number> = {}
  private _merge_active_output_count: Dict<number> = {}
  private _merge_input_count: Dict<number> = {}
  private _merge_active_input_count: Dict<number> = {}
  private _merge_ref: Dict<boolean> = {}

  private _merge_to_ref_unit: Dict<string> = {}
  private _merge_to_ref_output: Dict<string> = {}

  private _ref_unit_to_merge: Dict<string> = {}

  private _ref_output_to_merge: Dict<string> = {}
  private _ref_output_pin_icon: Dict<Icon> = {}

  private _node_graph: GraphNodeMap = {}

  private _node_to_subgraph: Dict<string> = {}
  private _subgraph_to_node: Dict<Set<string>> = {}

  private _node_layer: Dict<number> = {}
  private _link_layer: Dict<number> = {}

  private _layout_node: Dict<LayoutNode> = {}
  private _layout_target_node: Dict<LayoutNode> = {}
  private _layout_core_abort_animation: Dict<() => void> = {}
  private _layout_core_animating: Set<string> = new Set()
  private _layout_core_children_counter: Dict<Div> = {}
  private _layout_path: string[] = []
  private _layout_component_count: Dict<number> = {}
  private _layout_sub_component_parent: Dict<string> = {}

  private _layout_dragging: boolean = false
  private _layout_drag_node_count: number = 0
  private _layout_drag_node: Dict<boolean> = {}
  private _layout_drag_index: Dict<number> = {}
  private _layout_drag_direction: Dict<undefined | 'up' | 'down'> = {}
  private _layout_drag_start_scroll_top: Dict<number> = {}
  private _layout_drag_start_scroll_height: Dict<number> = {}
  private _layout_drag_swap: Dict<string> = {}
  private _layout_drag_swap_index: Dict<number> = {}
  private _layout_drag_client_position: Dict<Position> = {}
  private _layout_drag_start_children: Dict<string[]> = {}
  private _layout_drag_start_position: Dict<Position> = {}
  private _layout_drag_init_position: Dict<Position> = {}

  private _pointer_down: Dict<boolean> = {}
  private _pointer_down_position: Dict<Position> = {}
  private _pointer_down_count: number = 0
  private _pointer_position: Dict<Position> = {}
  private _pointer_down_move_count: Dict<number> = {}

  private _long_press_pointer: Set<number> = new Set()
  private _long_press_count: number = 0

  private _long_press_screen_position: Position = NULL_VECTOR

  private _long_press_background_pointer: Set<number> = new Set()
  private _long_press_background_count: number = 0

  private _collapsing: boolean = false
  private _collapse_commit: boolean = false
  private _collapse_pointer_to_unit: Dict<string> = {}
  private _collapse_init_node_id_set: Set<string> = new Set()

  private _collapse_world_position: Position = NULL_VECTOR
  private _collapse_init_spec: GraphSpec = null
  private _collapse_unit_id: string | null = null
  private _collapse_unit_spec: Dict<Spec> = {}
  private _collapse_next_unit_id: string | null = null
  private _collapse_next_spec_id: string | null = null
  private _collapse_unit_next_pin_map: GraphMoveSubGraphData['nextPinIdMap'] =
    {}
  private _collapse_merge_next_pin_map: GraphMoveSubGraphData['nextMergePinId'] =
    {}
  private _collapse_next_plug_spec_map: GraphMoveSubGraphData['nextPlugSpec'] =
    emptyIO({}, {})
  private _collapse_next_unit_pin_merge_map: GraphMoveSubGraphData['nextUnitPinMergeMap'] =
    {}
  private _collapse_datum_id: string | null = null
  private _collapse_datum_node_id: string | null = null
  private _collapse_remaining: number = 0
  private _collapse_end_set: Set<string> = new Set()

  private _collapse_sub_component_parent_id: Dict<string | null> = {}
  private _collapse_next_sub_component_index_map: GraphMoveSubGraphData['nextSubComponentIndexMap'] =
    {}
  private _collapse_next_sub_component_parent_slot: GraphMoveSubGraphData['nextSubComponentParentSlot'] =
    {}
  private _collapse_next_sub_component_slot: GraphMoveSubGraphData['nextSubComponentSlot'] =
    {}
  private _collapse_sub_component_children: Dict<string[]> = {}
  private _collapse_sub_component_next_parent_id: Dict<string | null> = {}
  private _collapse_sub_component_next_children: Dict<string[]> = {}

  private _collapse_next_map: GraphMoveSubGraphData
  private _collapse_node_id: Set<string> = new Set()
  private _collapse_units: string[]
  private _collapse_link_pins: GraphUnitPinOuterSpec[]
  private _collapse_merges: string[]
  private _collapse_plugs: GraphPlugOuterSpec[] = []
  private _collapse_next_id_map: GraphMoveSubGraphData['nextIdMap']

  // multiselect area

  private _multiselect_area_svg: SVGSVG
  private _multiselect_area_svg_rect: SVGRect
  private _multiselect_area_start_position: Position = {
    x: 0,
    y: 0,
  }
  private _multiselect_area_rect: {
    x0: number
    y0: number
    x1: number
    y1: number
  } = NOT_SELECTED_AREA
  private _multiselect_area_node: Dict<boolean> = {}
  private _multiselect_area_ing: boolean = false

  // simulation

  private _simulation: Simulation<{}, { type: string }>
  private _simulation_layer: number = 0
  private _simulation_end: boolean = false

  private _debug_interval: NodeJS.Timeout | null = null
  private _debug_buffer: Moment<any>[] = []
  private _debug_cursor: number = -1

  private _control_lock: boolean = false

  private _temp_control_lock: boolean = false
  private _temp_control_unlock: boolean = false

  private _search_lock: boolean = false
  private _search_hidden: boolean = true

  private _search_start_unit_id: string | null = null
  private _search_start_spec_id: string | null = null
  private _search_start_unit_position: Position = null
  private _search_start_unit_merges: GraphUnitMerges = {}
  private _search_start_unit_plugs: GraphUnitPlugs = {}
  private _search_start_unit_data: IOOf<Dict<TreeNode>> = {}
  private _search_start_unit_parent_id: string | null = null
  private _search_start_unit_index: number | null = null
  private _search_start_graph_unit_spec: GraphUnitSpec | null = null

  private _search_start_component_index: number | null = null

  private _search_unit_id: string | null = null
  private _search_unit_spec_id: string | null = null

  private _search_unit_graph_position: Position | null = null
  private _search_unit_component_size: Size | null = null

  private _search_unit_merges: GraphUnitMerges = {}
  private _search_unit_plugs: GraphUnitPlugs = {}
  private _search_unit_ref_merge_id: string | null = null
  private _search_unit_ref_merge: GraphMergeSpec | null = null
  private _search_unit_input_count: number
  private _search_unit_output_count: number
  private _search_fallback_position: Position
  private _search_unit_merged_pin_ids: {
    input: { data: string[]; ref: string[] }
    output: { data: string[]; ref: string[] }
  } = {
    input: {
      data: [],
      ref: [],
    },
    output: {
      data: [],
      ref: [],
    },
  }
  private _search_option_valid_pin_matches: Dict<{
    input: {
      ref: [number, number][][]
      data: [number, number][][]
    }
    output: {
      ref: [number, number][][]
      data: [number, number][][]
    }
  }> = {}
  private _search_unit_exposed_pin_ids: {
    input: {
      data: Dict<[string, string, IO]>
      ref: Dict<[string, string, IO]>
    }
    output: {
      data: Dict<[string, string, IO]>
      ref: Dict<[string, string, IO]>
    }
  }
  private _search_unit_merged_pin_index: IOOf<{
    data: Dict<number>
    ref: Dict<number>
  }>
  private _search_unit_exposed_pin_index: IOOf<{
    data: Dict<number>
    ref: Dict<number>
  }>

  private _search_unit_exposed_pin_count: {
    input: { data: number; ref: number }
    output: { data: number; ref: number }
  }
  private _search_unit_datum_id: string | null = null
  private _search_unit_datum_node_id: string | null = null
  private _search_unit_datum_start_position: Position | null = null
  private _search_unit_datum_spec_id: string

  private _search_unit_spec_id_changed: boolean = false

  // modes

  private _mode: Mode = 'none'
  private _mode_pointer: Dict<boolean> = {}

  // cancel

  private _cancel_click: boolean = false
  private _cancel_long_click: boolean = false
  private _cancel_long_press: boolean = false
  private _cancel_double_click: boolean = false
  private _cancel_click_hold: boolean = false
  private _cancel_node_long_click: boolean = false

  private _cancel_node_click: Set<string> = new Set()

  private _swap_next_click_hold_long_press: boolean = false

  // drawing

  private _capturing_gesture: boolean = false
  private _restart_gesture: boolean = false

  // err

  private _removing_err: boolean = false

  // layout

  private _tree_layout: boolean = false

  // dragging

  private _clone_drag: boolean = false
  private _clone_drag_node_id: string | null = null
  private _clone_drag_clone_id: string | null = null
  private _clone_node_ids: string[] = []
  private _clone_drag_actions: Action[] = []

  private _blue_drag: boolean = false
  private _blue_drag_init_id: string | null = null
  private _blue_drag_init_start_position: Dict<Position> = {}
  private _blue_drag_init_pin_to_anchor: Dict<string> = {}
  private _blue_drag_init_anchor_to_pin: Dict<string> = {}
  private _blue_drag_init_merge_swap: Dict<string> = {}
  private _blue_drag_hover_unit_id: string | null = null
  private _blue_drag_hover_position: Dict<Position> = {}
  private _blue_drag_hover_merge_anchor: Dict<string> = {}
  private _blue_drag_hover_merge_swap: Dict<string> = {}

  private _animating_enter_fullwindow = false
  private _animating_sub_component_fullwindow: Set<string> = new Set()
  private _animating_sub_component_base_id: Set<string> = new Set()

  private _abort_sub_component_enter_base_animation: Dict<Unlisten> = {}
  private _abort_sub_component_leave_base_animation: Dict<Unlisten> = {}
  private _abort_tree_layout_sub_component_base_animation: Dict<Unlisten> = {}
  private _abort_sub_component_parent_animation: Dict<Unlisten> = {}

  private _gamepad_connection_unlisten: Unlisten | undefined
  private _gamepad_unlisten: Unlisten | undefined

  private _gamepad: Gamepad_ | undefined

  private _abort_leave_fullwindow: Dict<
    () => {
      x: number
      y: number
      w: number
      h: number
    }
  > = {}
  private _abort_enter_fullwindow: Dict<
    () => {
      x: number
      y: number
      w: number
      h: number
    }
  > = {}

  public _prevent_next_reset: boolean = false

  private _search_to_be_focused: boolean = false
  private _search_to_be_focused_by_click: boolean = false
  private _datum_to_be_focused: boolean = false
  private _datum_to_be_focused_by_click: boolean = false
  private _name_to_be_focused: boolean = false

  private _refresh_theme = (): void => {
    const { $theme, $color } = this.$context

    const { style = {} } = this.$props

    const { color = $color } = style

    const dark = $theme === 'dark'

    const data = dark ? COLOR_YELLOW : COLOR_DARK_YELLOW
    const data_link = dark ? COLOR_LINK_YELLOW : COLOR_DARK_LINK_YELLOW

    const background = themeBackgroundColor($theme)

    const theme: {
      node: string
      background: string
      text: string
      pin_text: string
      selected: string
      type: string
      sub_text: string
      link: string
      hovered: string
      data: string
      data_link: string
    } = {
      background,
      node: applyTheme($theme, color, 0),
      text: applyTheme($theme, color, 10),
      selected: applyTheme($theme, color, 20),
      pin_text: applyTheme($theme, color, 30),
      type: applyTheme($theme, color, 30),
      sub_text: applyTheme($theme, color, 30),
      link: applyTheme($theme, color, 50),
      hovered: applyTheme($theme, color, 60),
      data,
      data_link,
    }

    const defaults = mapObjVK(
      theme,
      (color, name) => `var(--color-${name}, ${color})`
    )

    const colors = mapObjKeyKV(defaults, (name) => `--default-color-${name}`)

    mergePropStyle(this._graph, colors)
  }

  private _refresh_config = (): void => {
    const {
      config: { unitNames, pinNames },
    } = this.$props

    for (const unit_id in this._unit_node) {
      const unit_core = this._core[unit_id]

      unit_core.$props.style.visibility = unitNames ? 'visible' : 'hidden'
    }

    for (const pin_node_id in this._pin_name) {
      const pin_name = this._pin_name[pin_node_id]

      pin_name.$props.style.visibility = pinNames ? 'visible' : 'hidden'
    }

    for (const ext_plug_node_id in this._exposed_ext_node) {
      const ext_name = this._ext_pin_name[ext_plug_node_id]

      ext_name.$props.style.visibility = unitNames ? 'visible' : 'hidden'
    }
  }

  private _theme: {
    node: string
    background: string
    text: string
    pin_text: string
    selected: string
    type: string
    sub_text: string
    link: string
    hovered: string
    data: string
    data_link: string
  } = {
    node: 'var(--default-color-node, currentcolor)',
    background: 'var(--default-color-background, currentcolor)',
    text: 'var(--default-color-text, currentcolor)',
    pin_text: 'var(--default-color-pin_text, currentcolor)',
    selected: 'var(--default-color-selected, currentcolor)',
    type: 'var(--default-color-type, currentcolor)',
    sub_text: 'var(--default-color-sub_text, currentcolor)',
    link: 'var(--default-color-link, currentcolor)',
    hovered: 'var(--default-color-hovered, currentcolor)',
    data: 'var(--default-color-data, currentcolor)',
    data_link: 'var(--default-color-data_link, currentcolor)',
  }

  private _component: Component
  private _frame_out: boolean = false

  private _pod: $Graph

  private _width: number = 0
  private _height: number = 0

  private _q_was_pressed_before_name_focus: any
  private _q_first_repeat_prevented: boolean = false

  private _system: System

  constructor($props: Props_, $system: System, $element?: HTMLDivElement) {
    super($props, $system)

    let {
      style = {},
      component,
      disabled = true,
      frameOut,
      fullwindow,
      graph: pod,
      frame,
      specs,
      system,
    } = this.$props as Props_ & DefaultProps

    const { animate, zoom } = this._config()

    component = component ?? parentComponent({}, this.$system)

    this._system = system ?? this.$system.boot()

    this._pod = pod
    this._component = component

    this._component.setControlled(true)

    this._frame_out = frameOut

    this._zoom = clone(zoom ?? ZOOM_IDENTITY)

    this._frame = frame

    this._disabled = disabled

    this.$props.specs = this.$props.specs ?? specs
    this.$props.getSpec = this.$props.getSpec ?? this._fallback_get_spec
    this.$props.hasSpec = this.$props.hasSpec ?? this._fallback_has_spec
    this.$props.setSpec = this.$props.setSpec ?? this._fallback_set_spec
    this.$props.deleteSpec =
      this.$props.deleteSpec ?? this._fallback_delete_spec
    this.$props.forkSpec = this.$props.forkSpec ?? this._fallback_fork_spec
    this.$props.injectSpecs =
      this.$props.injectSpecs ?? this._fallback_inject_specs
    this.$props.emptySpec = this.$props.emptySpec ?? this._fallback_empty_spec
    this.$props.newSpec = this.$props.newSpec ?? this._fallback_new_spec
    this.$props.registerUnit =
      this.$props.registerUnit ?? this._fallback_register_unit
    this.$props.unregisterUnit =
      this.$props.unregisterUnit ?? this._fallback_unregister_unit

    const zoom_comp = new Zoom_(
      {
        className: 'graph-zoom',
        style: {
          transition: ifLinearTransition(animate, 'opacity'),
        },
        width: 0,
        height: 0,
        zoom: this._zoom,
      },
      this.$system
    )
    this._zoom_comp = zoom_comp
    const zoom_comp_alt = new Zoom_(
      {
        className: 'graph-zoom-alt',
        style: {
          pointerEvents: 'none',
        },
        width: 0,
        height: 0,
        zoom: this._zoom,
      },
      this.$system
    )
    this._zoom_comp_alt = zoom_comp_alt

    const area_select_rect = new SVGRect(
      {
        className: 'graph-area-select-rect',
        width: 0,
        height: 0,
        style: {
          pointerEvents: 'none',
          fill: 'none',
          strokeDasharray: '6',
          strokeWidth: '1',
          stroke: this._theme.selected,
        },
      },
      this.$system
    )
    this._multiselect_area_svg_rect = area_select_rect

    const area_select_svg = new SVGSVG(
      {
        className: 'graph-area-select-svg',
        attr: {
          width: `0`,
          height: `0`,
        },
        style: {
          display: 'none',
          width: '0',
          height: '0',
          position: 'absolute',
          top: '0',
        },
      },
      this.$system
    )
    area_select_svg.appendChild(area_select_rect)
    this._multiselect_area_svg = area_select_svg

    this._simulation = new Simulation({
      alpha: 0.25,
      alphaDecay: SIMULATION_DEFAULT_ALPHA_DECAY,
      // alphaDecay: 0,
      alphaTarget: 0,
      n: 6,
      // velocityDecay: 0.25,
      velocityDecay: 0.1,
      force: this._force,
    })
    this._simulation.nodes(this._node)
    this._simulation.links(this._link)
    this._simulation.addListener('tick', this._on_simulation_tick)
    this._simulation.addListener('end', this._on_simulation_end)

    const subgraph = new Div(
      {
        className: 'graph-subgraph',
        style: {
          position: 'absolute',
          top: '0',
          left: '0',
          pointerEvents: 'none',
          height: '100%',
          width: '100%',
        },
      },
      this.$system
    )
    this._subgraph = subgraph

    const layout_root = this._create_layout_layer({
      className: 'graph-layout-root',
      style: {
        position: 'absolute',
        top: '0',
        left: '0',
        width: '100%',
        height: '100%',
      },
    })
    this._layout_root = layout_root

    const layout_comp = new Div(
      {
        className: 'graph-layout',
        style: {
          pointerEvents: 'none',
          userSelect: 'none',
          height: '100%',
          width: '100%',
        },
      },
      this.$system
    )
    this._layout_comp = layout_comp
    layout_comp.registerParentRoot(layout_root.layer)

    const main = new Div(
      {
        className: 'graph-main',
        style: {
          position: 'relative',
          top: '0',
          left: '0',
          width: '100%',
          height: '100%',
          '-webkit-touch-callout': 'none',
        },
      },
      this.$system
    )
    main.addEventListeners([
      makePointerDownListener(this._on_pointer_down),
      makePointerMoveListener(this._on_pointer_move),
      makePointerUpListener(this._on_pointer_up),
      makePointerEnterListener(this._on_pointer_enter),
      makePointerLeaveListener(this._on_pointer_leave),
      makePointerCancelListener(this._on_pointer_cancel),
      makeClickListener({
        onClick: this._on_click,
        onClickCancel: this._on_click_cancel,
        onDoubleClick: this._on_double_click,
        onLongClick: this._on_long_click,
        onLongPress: this._on_long_press,
        onLongClickCancel: this._on_long_click_cancel,
        onClickHold: this._on_click_hold,
      }),
      makeDragOverListener(this._on_drag_over),
      makeDropListener(this._on_drop),
    ])

    const shouldPreventSelection = (target: EventTarget) => {
      return (
        target === this._zoom_comp._svg.$element ||
        (target instanceof HTMLElement &&
          (target.classList.contains('datum_overlay') ||
            target.classList.contains('core-overlay') ||
            target.classList.contains('core-area') ||
            target.classList.contains('core-content') ||
            target.classList.contains('pin') ||
            target.classList.contains('plug')))
      )
    }

    // prevent focus if "pointerdown" is on background
    const preventFocusListener = (event: Event): boolean => {
      const { target } = event

      if (shouldPreventSelection(target)) {
        if (this._core_component_unlocked_count === 0) {
          event.preventDefault()

          return false
        }
      }
    }
    main.$element.addEventListener('mousedown', preventFocusListener)
    main.$element.addEventListener('touchdown', preventFocusListener)
    main.$element.addEventListener('touchstart', (event: Event) => {
      const { target } = event

      if (shouldPreventSelection(target)) {
        event.preventDefault()

        return false
      }
    })

    main.$element.setAttribute('dropTarget', 'true')

    main.registerParentRoot(zoom_comp)
    main.registerParentRoot(zoom_comp_alt)
    main.registerParentRoot(layout_comp)
    main.registerParentRoot(area_select_svg)

    this._main = main

    const foreground = new Div(
      {
        className: 'graph-foreground',
        style: {
          pointerEvents: 'none',
          position: 'absolute',
          top: '0',
          left: '0',
          width: '100%',
          height: '100%',
        },
      },
      this.$system
    )
    this._foreground = foreground

    const graph = new Div(
      {
        className: 'graph',
        style: {
          ..._DEFAULT_STYLE,
          ...style,
        },
        tabIndex: 0,
      },
      this.$system
    )

    graph.addEventListener(makeWheelListener(this._on_wheel))
    graph.addEventListener(makeWheelListener(this._on_scroll))
    graph.addEventListener(makeFocusListener(this._on_focus))
    graph.addEventListener(makeBlurListener(this._on_blur))

    graph.registerParentRoot(main)
    graph.registerParentRoot(subgraph)

    this._graph = graph

    this._graph.$ref['foreground'] = this._foreground

    $element = $element || parentElement($system)

    this.$element = $element
    this.$slot = graph.$slot
    this.$unbundled = false
    this.$primitive = true

    this.setSubComponents({
      graph,
      subgraph,
      foreground,
      main,
    })

    this.registerRoot(graph)
    this.registerRoot(foreground)

    if (fullwindow) {
      this._enter_all_fullwindow(false)
    }
  }

  private _last_open_filename: string

  private _on_drag_over = async (event, _event: DragEvent) => {
    _event.preventDefault()
  }

  private _on_drop = async (event, _event: DragEvent) => {
    _event.preventDefault()

    const { clientX, clientY, screenX, screenY } = event

    const { dataTransfer } = _event

    const drop_position = this._screen_to_world(clientX, clientY)

    const screen_position = { x: screenX, y: screenY }

    if (dataTransfer) {
      const { items, files } = dataTransfer

      if (items) {
        for (let i = 0; i < items.length; i++) {
          const item = items[i]

          this._drop_data_transfer_item(item, drop_position, screen_position)
        }
      } else {
        for (let i = 0; i < files.length; i++) {
          const file = items[i].getAsFile()

          this._drop_file(file, drop_position)
        }
      }
    }
  }

  private _drop_data_transfer_item_as_string = async (
    item: DataTransferItem,
    position: Position
  ) => {
    return new Promise((resolve) => {
      item.getAsString((text) => {
        this._drop_text(text, position)

        resolve(text)
      })
    })
  }

  private _drop_data_transfer_item = async (
    item: DataTransferItem,
    position: Position,
    screen_position: Position
  ) => {
    if (item.kind === 'file') {
      const file = item.getAsFile() as File

      // @ts-ignore
      if (item.getAsFileSystemHandle) {
        const handle =
          // @ts-ignore
          (await item.getAsFileSystemHandle()) as FileSystemDirectoryHandle

        if (handle) {
          if (handle.kind === 'directory') {
            this._drop_file_system_directory_handle(handle, screen_position)

            return
          }
        }
      }

      if (item.webkitGetAsEntry) {
        const entry = item.webkitGetAsEntry() as FileSystemEntry

        if (entry) {
          this._drop_file_system_entry(entry, position, screen_position)

          return
        }
      }

      this._drop_file(file, position)
    } else if (item.kind === 'string') {
      if (item.type === 'text/plain') {
        await this._drop_data_transfer_item_as_string(item, position)
      } else if (item.type === 'text/html') {
        //
      } else if (item.type === 'text/uri-list') {
        await this._drop_data_transfer_item_as_string(item, position)
      }
    } else if (item.kind === 'text/uri-list') {
      //
    } else if (item.kind === 'text/html') {
      //
    }
  }

  private _drop_file_system_entry = (
    entry: FileSystemEntry,
    position: Position,
    screen_position: Position
  ) => {
    if (entry.isDirectory) {
      this._animate_pulse(screen_position.x, screen_position.y, 'out')

      this._drop_file_system_directory_entry(entry as FileSystemDirectoryEntry)
    } else if (entry.isFile) {
      this._drop_file_system_file_entry(entry as FileSystemFileEntry, position)
    } else {
      throw new InvalidStateError()
    }
  }

  private _drop_file_system_directory_entry = (
    entry: FileSystemDirectoryEntry
  ) => {
    const reader = entry.createReader()

    reader.readEntries(
      (entries) => {
        this._paste_file_system_directory_entries(entries)
      },
      (err: any) => {
        //
      }
    )
  }

  private _drop_file_system_file_entry = (
    entry: FileSystemFileEntry,
    position: Position
  ) => {
    entry.file(
      async (file: File) => {
        this._drop_file(file, position)
      },
      (err: any) => {
        //
      }
    )
  }

  private _drop_file_system_directory_handle = async (
    dirHandle: FileSystemDirectoryHandle,
    screenPosition: Position
  ) => {
    this._animate_pulse(screenPosition.x, screenPosition.y, 'out')

    await this._paste_file_system_directory_handle(dirHandle)
  }

  private _paste_file_system_directory_handle = async (
    dirHandle: FileSystemDirectoryHandle
  ) => {
    // @ts-ignore
    if (dirHandle.entries) {
      // @ts-ignore
      const entries = (await dirHandle.entries()) as [
        string,
        FileSystemFileHandle | FileSystemDirectoryHandle,
      ][]

      for await (const entry of entries) {
        const [_, handle] = entry

        if (handle.kind === 'file') {
          const file = (await (
            handle as FileSystemFileHandle
          ).getFile()) as File

          const bundle = await this._read_bundle_file(file)

          if (bundle) {
            const { specs } = bundle

            injectUserSpecs(this.$props, specs)
          }
        } else if (handle.kind === 'directory') {
          this._paste_file_system_directory_handle(
            handle as FileSystemDirectoryHandle
          )
        } else {
          throw new InvalidStateError()
        }
      }
    }
  }

  private _paste_file_system_directory_entries = async (
    entries: FileSystemEntry[]
  ) => {
    for (const entry of entries) {
      if (entry.isFile) {
        ;(entry as FileSystemFileEntry).file(
          async (file: File) => {
            const bundle = await this._read_bundle_file(file)

            if (bundle) {
              const specIdMap = injectUserBundle(this._system, bundle)

              const bundle_ = clone(bundle)

              remapBundle(bundle_, specIdMap)
            }
          },
          (err: any) => {
            //
          }
        )
      } else if (entry.isDirectory) {
        this._drop_file_system_directory_entry(
          entry as FileSystemDirectoryEntry
        )
      } else {
        throw new InvalidStateError()
      }
    }
  }

  private _drop_file = async (
    file: File | Blob,
    position?: Position
  ): Promise<void> => {
    if (file.type.startsWith('image/')) {
      return this._drop_image_file(file, position)
    } else if (file.type.startsWith('audio/')) {
      return this._drop_audio_file(file, position)
    } else if (file.type.startsWith('video/')) {
      return this._drop_video_file(file, position)
    } else if (
      file.type.startsWith('text/plain') ||
      file.type.startsWith('application/json')
    ) {
      const text = await readFileAsText(file)

      this._drop_text(text, position)

      return
    }

    if (file instanceof File) {
      this._last_open_filename = file.name

      this._drop_bundle_file(file, position)
    }
  }

  private _drop_image_file = async (file: File | Blob, position?: Position) => {
    const reader = new FileReader()

    reader.onload = async (e) => {
      const image_data_url = e.target.result.toString()

      const image = this.$system.api.document.createElement('img')

      image.src = image_data_url

      image.onload = () => {
        const id = ID_IMAGE_1

        const new_unit_id = this._new_unit_id(id)

        const ratio = image.naturalWidth / image.naturalHeight

        let width = image.naturalWidth
        let height = image.naturalHeight

        if (width > height) {
          width = clamp(width, MIN_WIDTH, MAX_DROP_ELEMENT_WIDTH)
          height = width / ratio
        } else {
          height = clamp(height, MIN_HEIGHT, MAX_DROP_ELEMENT_HEIGHT)
          width = height * ratio
        }

        const bundle: UnitBundleSpec = {
          unit: {
            id,
            input: {
              src: {
                data: `"${image_data_url}"`,
                constant: true,
                ignored: true,
              },
              style: {
                ignored: true,
              },
            },
            metadata: {
              component: {
                width,
                height,
              },
            },
          },
          specs: {},
        }

        const center_of_screen = position ?? this._jiggle_world_screen_center()

        this._add_unit(
          new_unit_id,
          bundle,
          position,
          {},
          center_of_screen,
          null
        )

        this._sim_add_sub_component(
          new_unit_id,
          {},
          undefined,
          undefined,
          image
        )

        this._connect_sub_component(new_unit_id)

        image.onload = null
      }
    }

    reader.readAsDataURL(file)

    return
  }

  private _drop_audio_file = async (file: File | Blob, position: Position) => {
    const {
      api: {
        url: { createObjectURL },
      },
    } = this.$system

    const url = await createObjectURL(file)

    const id = ID_AUDIO

    const new_unit_id = this._new_unit_id(id)

    const bundle: UnitBundleSpec = {
      unit: {
        id,
        input: {
          src: {
            data: `"${url}"`,
            constant: true,
            ignored: true,
          },
          stream: {
            ignored: true,
          },
          style: {
            ignored: true,
          },
          controls: {
            ignored: true,
          },
        },
        metadata: {},
      },
      specs: {},
    }

    const center_of_screen = position ?? this._jiggle_world_screen_center()

    this._add_unit(new_unit_id, bundle, position, {}, center_of_screen, null)

    this._sim_add_sub_component(new_unit_id, {}, undefined, undefined)

    this._connect_sub_component(new_unit_id)
  }

  private _drop_video_file = async (file: File | Blob, position: Position) => {
    const {
      api: {
        url: { createObjectURL },
      },
    } = this.$system

    const url = await createObjectURL(file)

    const element = this.$system.api.document.createElement('video')

    element.oncanplaythrough = () => {
      const new_unit_id = this._new_unit_id(ID_IMAGE)

      let width = element.videoWidth
      let height = element.videoHeight

      const ratio = width / height

      if (width > height) {
        width = clamp(width, MIN_WIDTH, MAX_DROP_ELEMENT_WIDTH)
        height = width / ratio
      } else {
        height = clamp(height, MIN_HEIGHT, MAX_DROP_ELEMENT_HEIGHT)
        width = height * ratio
      }

      const bundle: UnitBundleSpec = {
        unit: {
          id: ID_VIDEO,
          input: {
            src: {
              data: `"${url}"`,
              constant: true,
              ignored: true,
            },
            attr: {
              data: "{loop:'true'}",
              ignored: true,
              constant: true,
            },
            stream: {
              ignored: true,
            },
            style: {
              ignored: true,
            },
            controls: {
              ignored: true,
            },
          },
          metadata: {
            component: {
              width,
              height,
            },
          },
        },
        specs: {},
      }

      const center_of_screen = position ?? this._jiggle_world_screen_center()

      this._add_unit(new_unit_id, bundle, position, {}, center_of_screen, null)

      this._sim_add_sub_component(
        new_unit_id,
        {},
        undefined,
        undefined,
        element
      )

      this._connect_sub_component(new_unit_id)

      element.oncanplaythrough = null
    }

    element.src = url
  }

  private _drop_bundle_file = async (
    file: File,
    position?: Position
  ): Promise<void> => {
    position = position ?? this._jiggle_world_screen_center()

    const bundle = await this._read_bundle_file(file)

    if (bundle) {
      this.paste_bundle(bundle, position, true, true, false)
    } else {
      throw new Error('invalid bundle file')
    }
  }

  private _read_bundle_file = async (file: File): Promise<BundleSpec> => {
    const {
      api: {
        text: { TextDecoder },
      },
    } = this.$system

    let json: string

    if (file.name.endsWith('.unit')) {
      try {
        json = await file.text()
      } catch (err) {
        return null
      }
    } else if (file.name.endsWith('.unit.gzip')) {
      const decompressionStream = new DecompressionStream('gzip')
      const decompressedStream = file
        .stream()
        // @ts-ignore
        .pipeThrough(decompressionStream) as ReadableStream

      const reader = decompressedStream.getReader()
      const chunks = []

      while (true) {
        const { value, done } = await reader.read()

        if (done) {
          break
        }

        chunks.push(value)
      }

      const concatenated = new Uint8Array(
        chunks.reduce((acc, chunk) => acc + chunk.length, 0)
      )

      let offset = 0

      for (const chunk of chunks) {
        concatenated.set(chunk, offset)

        offset += chunk.length
      }

      json = new TextDecoder().decode(concatenated)
    }

    let bundle: BundleSpec

    try {
      bundle = JSON.parse(json)
    } catch (err) {
      return null
    }

    return bundle
  }

  private _spec_refresh_node_position = (spec: GraphSpec): void => {
    this._set_units_position(spec.units)
  }

  private _config = (): Omit<Config, 'zoom'> & Config_ => {
    const { config, zoom } = this.$props

    return {
      ...config,
      ...{
        zoom:
          zoom || typeof config.zoom === 'boolean'
            ? config.zoom
              ? defaultProps.config.zoom
              : {
                  x: this._zoom.x,
                  y: this._zoom.y,
                  z: this._zoom.z,
                  maxZoom: this._zoom.z,
                  minZoom: this._zoom.z,
                }
            : deepMerge(defaultProps.config.zoom, config.zoom),
      },
    } as Omit<Config, 'zoom'> & Config_
  }

  private _disable = (hide?: boolean): void => {
    // console.log('Graph', '_disable')

    const { animate } = this._config()

    hide = hide ?? animate

    if (!this._disabled) {
      this._disabled = true

      if (this._subgraph_unit_id) {
        const sub_graph = this._subgraph_cache[this._subgraph_unit_id]

        sub_graph.setProp('disabled', true)
      } else {
        if (this._core_component_unlocked_count > 0) {
          for (const unit_id in this._core_component_unlocked) {
            this._disable_core_frame(unit_id)
          }
        } else {
          this._unlock_control(hide)
        }
      }
    }
  }

  private _enable = (): void => {
    if (this._disabled) {
      // console.log('Graph', '_enable', this._id)

      this._disabled = false

      if (this._subgraph_unit_id) {
        const sub_graph = this._subgraph_cache[this._subgraph_unit_id]

        sub_graph.setProp('disabled', false)
      } else {
        if (
          this._core_component_unlocked_count > 0 &&
          this._pointer_down_count === 0
        ) {
          for (const unit_id in this._core_component_unlocked) {
            this._enable_core_frame(unit_id)
          }
        } else {
          if (!this._is_fullwindow || this._frame_out) {
            if (this._control_lock) {
              this._enable_input()
            }
          }
        }

        if (!this._subgraph_unit_id) {
          this._enable_transcend()
        }
      }
    }
  }

  private _enable_minimap(): void {
    const { $width, $height } = this.$context

    if (this._minimap && !this._unlisten_minimap) {
      // console.log('Graph', '_enable_minimap')

      this._unlisten_minimap = this._minimap.addEventListeners([
        makeWheelListener(this._on_minimap_wheel),
        makePointerDownListener(this._on_minimap_pointer_down),
        makePointerMoveListener(this._on_minimap_pointer_move),
        makePointerUpListener(this._on_minimap_pointer_up),
        makePointerEnterListener(this._on_minimap_pointer_enter),
        makePointerLeaveListener(this._on_minimap_pointer_leave),
        makeDragStartListener(this._on_minimap_drag_start),
      ])

      if (this._tree_layout) {
        this._set_minimap_to_layout()
      } else {
        this._set_minimap_to_graph()
      }

      const minimap_screen = new SVGRect(
        {
          x: this._zoom.x,
          y: this._zoom.y,
          width: $width / this._zoom.z,
          height: $height / this._zoom.z,
          style: {
            display: this._unit_count > 0 ? 'block' : 'none',
            fill: 'none',
            stroke: this._theme.link,
          },
        },
        this.$system
      )

      this._minimap_screen = minimap_screen

      this._minimap.setChildren([minimap_screen])

      if (this._mode === 'add') {
        this._enable_minimap_drag_and_drop()
      }

      this._refresh_minimap_color()

      this._tick_minimap()
    }
  }

  private _minimap_drag_and_drop_unlisten: Unlisten

  private _enable_minimap_drag_and_drop = () => {
    // console.log('Graph', '_enable_minimap_drag_and_drop')

    if (this._minimap) {
      this._minimap.$element.setAttribute('draggable', 'true')

      const listener = (event) => {
        const { specs } = this.$props

        const bundle = bundleSpec(this._spec, specs)

        const json = JSON.stringify(bundle)

        event.dataTransfer.setData('text/plain', json)

        event.dataTransfer.dropEffect = 'copy'
      }

      this._minimap.$element.addEventListener('dragstart', listener)

      this._minimap_drag_and_drop_unlisten = () => {
        this._minimap.$element.removeEventListener('dragstart', listener)
      }
    }
  }

  private _disable_minimap_drag_and_drop = () => {
    // console.log('Graph', '_disable_minimap_drag_and_drop')

    if (this._minimap) {
      this._minimap.$element.removeAttribute('draggable')

      if (this._minimap_drag_and_drop_unlisten) {
        this._minimap_drag_and_drop_unlisten()

        this._minimap_drag_and_drop_unlisten = undefined
      }
    }
  }

  private _disable_minimap(): void {
    if (this._minimap && this._unlisten_minimap) {
      // console.log('Graph', '_disable_minimap')

      this._unlisten_minimap()
      this._unlisten_minimap = undefined

      this._minimap.setChildren([])

      this._tick_minimap()
    }
  }

  private _init: boolean = false

  private _context_unlisten: Unlisten

  private _destroy_subgraph_cache = () => {
    for (const subgraph_unit_id in this._subgraph_cache) {
      const editor = this._subgraph_cache[subgraph_unit_id]

      editor.destroy()
    }
  }

  onDestroy() {
    // console.log('Graph', 'onDestroy', this._spec.name)

    this._destroy_subgraph_cache()

    this._disable(false)
    this._pause_debugger()
    this._clear_debugger()
    this._stop_graph_simulation()
    this._plunk_pod()
  }

  private _sub_component_escape_unlisten: Unlisten

  private _listen_sub_component_escape = (sub_component_id: string) => {
    // console.log('Graph', '_listen_sub_component_escape', sub_component_id)

    const sub_component_frame = this._get_sub_component_frame(sub_component_id)

    this._sub_component_escape_unlisten = addListener(
      sub_component_frame.$$context,
      makeKeydownListener((event) => {
        const { key } = event

        if (key === 'Escape') {
          this._lock_sub_component(sub_component_id)

          this.focus()
        }
      })
    )
  }

  private _unlisten_sub_component_escape = () => {
    this._sub_component_escape_unlisten()
    this._sub_component_escape_unlisten = undefined
  }

  onMount() {
    // console.log('Graph', 'onMount', this._id)

    const { $width, $height, $disabled } = this.$context

    const { animate } = this._config()

    this._disable_control_lock()

    this._control = findRef(this, 'control') as GUI | null

    this._enable_control_lock()

    this._search = findRef(this, 'search') as Search | null
    this._cabinet = findRef(this, 'cabinet') as Cabinet | null
    this._minimap = findRef(this, 'minimap') as Minimap | null
    this._modes = findRef(this, 'modes') as Modes | null
    this._import = findRef(this, 'import') as IconButton | null
    this._export = findRef(this, 'export') as IconButton | null
    this._transcend = findRef(this, 'transcend') as Transcend | null

    if (this._transcend) {
      if (!this._disabled) {
        if (!this._subgraph_unit_id) {
          this._enable_transcend()
        }
      }
    }

    if (!this._disabled) {
      if (this._input_disabled) {
        if (!this._core_component_unlocked_count) {
          this._enable_input()
        }
      }
    }

    this._context_unlisten = addListeners(this.$context, [
      makeResizeListener(this._on_context_resize),
      makeCustomListener('themechanged', this._on_context_theme_changed),
      makeCustomListener('colorchanged', this._on_context_color_changed),
    ])

    if (!this._init) {
      if ($width !== 0 && $height !== 0) {
        this._resize($width, $height)

        this._width = $width
        this._height = $height
      }
    }

    if (!this._init) {
      this._init = true

      this._reset_spec()
    }

    this._refresh_theme()
    this._refresh_color()

    if (this._focused) {
      this._refresh_enabled()
    }

    if (this._node_count > 0) {
      this._start_graph_simulation(LAYER_NONE)
    }
  }

  public onUnmount(): void {
    // console.log('Graph', 'onUnmount', this._id)

    const {
      api: {
        animation: { cancelAnimationFrame },
      },
    } = this.$system

    this._disable_input()
    this._context_unlisten()
    this._stop_graph_simulation()
    this._pause_debugger()

    this._control = null
    this._search = null
    this._minimap = null
    this._modes = null
    this._transcend = null

    this._minimap_hidden = undefined

    if (this._center_graph_frame !== undefined) {
      cancelAnimationFrame(this._center_graph_frame)

      this._center_graph_frame = undefined
    }
  }

  public get_subraph_depth = (): number => {
    return this._subgraph_depth
  }

  private _get_subgraph_pod = (unit_id: string): $Graph => {
    let pod = this._subgraph_pod_cache[unit_id]

    if (!pod) {
      pod = this._pod.$refUnit({
        unitId: unit_id,
        _: UCGEE,
      }) as $Graph

      this._subgraph_pod_cache[unit_id] = pod
    }

    return pod
  }

  public get_units = (): GraphUnitsSpec => {
    const { units } = this._spec
    return units || {}
  }

  public get_unit_relative_positions = () => {
    return this.get_nodes_center_relative_positions(this._unit_node)
  }

  public get_node_relative_positions = (): Dict<Position> => {
    return this.get_nodes_center_relative_positions(this._node)
  }

  public get_nodes_bounding_rect = (nodes: Dict<Rect>): Rect => {
    const nodes_list = Object.values(nodes)

    const rect = centerRectsBoundingRect(nodes_list)

    return rect
  }

  public get_nodes_bounding_line = (nodes: Dict<Rect>): Line => {
    const nodes_list = Object.values(nodes)

    const rect = centerRectsBoundingLine(nodes_list)

    return rect
  }

  public get_nodes_bounding_rect_center = (nodes: Dict<any>): Point => {
    const rect = this.get_nodes_bounding_rect(nodes)

    const center = { x: rect.x, y: rect.y }

    return center
  }

  public get_nodes_center_relative_positions = (
    nodes: Dict<any>
  ): Dict<Position> => {
    const center = this.get_nodes_bounding_rect_center(nodes)

    return this.get_nodes_center_relative_positions_to(nodes, center)
  }

  public get_nodes_center_relative_positions_to = (
    nodes: Dict<any>,
    center: Point
  ): Dict<Position> => {
    const node_positions: Dict<Position> = {}

    for (const node_id in nodes) {
      const node = this.get_node(node_id)

      const node_relative_position = pointVector(center, node)

      node_positions[node_id] = node_relative_position
    }

    return node_positions
  }

  public get_node_positions = (): Dict<Position> => {
    return this._node
  }

  public get_pin_positions = (): Dict<Position> => {
    return this._pin_node
  }

  private _get_unit = (id: string): GraphUnitSpec => {
    const units = this.get_units()
    return units[id]
  }

  private _get_unit_ids = () => {
    const units = this.get_units()
    const unit_ids = keys(units)
    return unit_ids
  }

  public get_sub_component_frame_context = (
    sub_component_id: string
  ): Context => {
    const frame = this._core_component_frame[sub_component_id]
    const { $$context } = frame
    return $$context
  }

  private _get_unit_bundle = (unit_id: string): UnitBundleSpec => {
    const unit = this._get_unit(unit_id)

    const { specs } = this.$props

    const bundle = unitBundleSpec(unit, specs)

    return bundle
  }

  private _get_graph_bundle_spec = (unit_id: string): BundleSpec => {
    const { specs } = this.$props

    const spec = this._get_unit_spec(unit_id) as GraphSpec

    const bundle = bundleSpec(spec, specs)

    return bundle
  }

  private _get_graph_unit_bundle_spec = (unit_id: string): UnitBundleSpec => {
    const { specs } = this.$props

    const unit = this._get_unit(unit_id)

    const bundle = unitBundleSpec(unit, specs)

    return bundle
  }

  private _pod_get_unit_deep_bundle = (
    unitId: string,
    callback: Callback<UnitBundleSpec>
  ): void => {
    // console.log('Graph', '_pod_get_unit_deep_bundle', unitId)
    this._pod.$snapshotUnit({ unitId }, (memory) => {
      const bundle = this._get_unit_bundle(unitId)

      bundle.unit.memory = memory

      callback(bundle)
    })
  }

  private _pod_remove_unit_ghost = (
    unitId: string,
    nextUnitId: string,
    nextUnitSpec: GraphSpec,
    callback: Callback<{ specId: string; bundle: UnitBundleSpec }>
  ): void => {
    const { fork, bubble } = this.$props

    this._pod.$removeUnitGhost(
      { unitId, nextUnitId, nextUnitSpec, fork, bubble },
      callback
    )
  }

  private _pod_add_unit_ghost = (
    unitId: string,
    nextUnitId: string,
    nextUnitBundle: UnitBundleSpec,
    nextUnitPinMap: IOOf<Dict<string>>
  ): void => {
    const { fork, bubble } = this.$props

    this._pod.$addUnitGhost({
      unitId,
      nextUnitId,
      nextUnitBundle,
      nextUnitPinMap,
      fork,
      bubble,
    })
  }

  private _add_spec = (spec: GraphSpec): string => {
    const { id } = this.$system.newSpec(spec)

    return id
  }

  private _set_spec = (id: string, spec: GraphSpec): void => {
    // console.log('Graph', '_set_spec', id, spec)

    this._system.setSpec(id, spec)
  }

  private _fallback_new_spec_id = () => {
    return this._system.newSpecId()
  }

  private _fallback_has_spec = (id: string): boolean => {
    return this._system.hasSpec(id)
  }

  private _fallback_empty_spec = () => {
    return this._system.emptySpec()
  }

  private _fallback_new_spec = (spec: GraphSpec) => {
    return this._system.newSpec(spec)
  }

  private _fallback_set_spec = (spec_id: string, spec: GraphSpec) => {
    return this._system.setSpec(spec_id, spec)
  }

  private _fallback_get_spec = (id: string): Spec => {
    return this._system.getSpec(id)
  }

  private _fallback_delete_spec = (id: string) => {
    return this._system.deleteSpec(id)
  }

  private _fallback_fork_spec = (spec: GraphSpec) => {
    return this._system.forkSpec(spec)
  }

  private _fallback_inject_specs = (specs: GraphSpecs) => {
    return this._system.injectSpecs(specs)
  }

  private _fallback_register_unit = (id: string) => {
    return this._system.registerUnit(id)
  }

  private _fallback_unregister_unit = (id: string) => {
    return this._system.unregisterUnit(id)
  }

  private _register_unit = (
    spec_id: string,
    deep: boolean = true,
    branch: string[] = []
  ) => {
    // console.log('Graph', '_register_unit', spec_id, deep)

    this._register_spec(spec_id, deep, branch)
  }

  private _register_spec = (
    spec_id: string,
    deep: boolean = true,
    branch: string[] = []
  ) => {
    // console.log('Graph', '_register_spec', spec_id, deep)

    this.__register_spec(this._system, spec_id, deep, branch)
  }

  private __register_spec = (
    registry: Registry,
    spec_id: string,
    deep: boolean = true,
    branch: string[] = []
  ) => {
    if (branch.includes(spec_id)) {
      return
    }

    const spec = registry.getSpec(spec_id)

    if (!isBaseSpec(spec)) {
      registry.registerUnit(spec_id)

      this._mirror_spec(registry, spec_id)

      if (deep) {
        const { units = {} } = spec as GraphSpec

        for (const unitId in units) {
          const unit = units[unitId]

          this.__register_spec(registry, unit.id, deep, [...branch, spec_id])
        }
      }
    }
  }

  private _unregister_unit = (
    spec_id: string,
    deep: boolean = true,
    branch: string[] = []
  ) => {
    // console.log('Graph', '_unregister_unit', spec_id, deep)

    const { parent, getSpec, unregisterUnit } = this.$props

    if (branch.includes(spec_id)) {
      return
    }

    this._unregister_spec(spec_id, deep, branch)
  }

  private _unregister_spec = (
    spec_id: string,
    deep: boolean = true,
    branch: string[] = []
  ) => {
    // console.log('Editor', '_unregister_spec', spec_id, deep, branch)

    const { getSpec, unregisterUnit } = this.$props

    const spec = getSpec(spec_id)

    if (!isSystemSpec(spec)) {
      if (deep) {
        const { units = {} } = spec as GraphSpec

        for (const unitId in units) {
          const unit = units[unitId]

          this._unregister_unit(unit.id, deep, [...branch, spec_id])
        }
      }

      unregisterUnit(spec_id)
    }
  }

  private _get_unit_spec_name = (unit_id: string): string => {
    const { getSpec } = this.$props

    const id = this._get_unit_spec_id(unit_id)

    const spec = getSpec(id)

    const { name = '' } = spec

    return name
  }

  private _get_unit_name = (unit_id: string): string => {
    const spec_name = this._get_unit_spec_name(unit_id)
    const metadata = this._get_unit_metadata(unit_id)
    const { rename } = metadata
    return rename || spec_name
  }

  private _spec_get_merges = (): GraphMergesSpec => {
    const { merges } = this._spec

    return merges || {}
  }

  private _get_input = (input_id: string): GraphPinSpec => {
    const inputs = this._get_inputs()
    const input = inputs[input_id]
    return input
  }

  private _get_output = (input_id: string): GraphPinSpec => {
    const outputs = this._get_outputs()
    const output = outputs[input_id]
    return output
  }

  private _get_pin = (type: IO, pin_id: string) => {
    if (type === 'input') {
      return this._get_input(pin_id)
    } else {
      return this._get_output(pin_id)
    }
  }

  private _get_pins = (): IOOf<GraphPinsSpec> => {
    return {
      input: this._spec.inputs ?? {},
      output: this._spec.outputs ?? {},
    }
  }

  private _get_inputs = (): GraphPinsSpec => {
    const { inputs = {} } = this._spec
    return inputs
  }

  private _get_outputs = (): GraphPinsSpec => {
    const { outputs = {} } = this._spec
    return outputs
  }

  private _get_merge = (merge_node_id: string): GraphMergeSpec => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)
    return this._spec_get_merge(mergeId)
  }

  private _spec_has_merge = (merge_node_id: string): boolean => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    return !!this._spec_get_merge(mergeId)
  }

  private _spec_has_merge_pin = (
    mergeId: string,
    unitId: string,
    type: IO,
    pin_id: string
  ) => {
    return hasMergePin(this._spec, mergeId, unitId, type, pin_id)
  }

  private _spec_has_unit = (unit_id: string): boolean => {
    return !!this._get_unit(unit_id)
  }

  private __spec_has_merge = (merge_id: string): boolean => {
    return !!this._spec_get_merge(merge_id)
  }

  private _spec_get_merge = (merge_id: string): GraphMergeSpec => {
    const merges = this._spec_get_merges()

    return merges[merge_id]
  }

  private _get_merge_by_node_id = (merge_node_id: string): GraphMergeSpec => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    const merge = this._spec_get_merge(mergeId)

    return merge
  }

  // PERF _unit_to_merge
  private _get_unit_merges = (unit_id: string): GraphMergesSpec => {
    return getUnitMergesSpec(this._spec, unit_id)
  }

  private _get_unit_plugs = (unit_id: string): GraphUnitPlugs => {
    return findUnitPlugs(this._spec, unit_id)
  }

  private _get_graph_unit_pin_spec = (
    unit_id: string,
    type: IO,
    pin_id: string
  ): GraphUnitPinSpec => {
    const unit = this._get_unit(unit_id)

    const unit_pin_spec = (!!unit[type] && unit[type][pin_id]) || {}

    return unit_pin_spec
  }

  private _get_graph_unit_unit_spec = (
    graph_id: string,
    unit_id: string
  ): GraphSpec => {
    const { getSpec } = this.$props

    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    const { units } = graph_spec

    const unit = units[unit_id]

    const { id } = unit

    const spec = getSpec(id) as GraphSpec

    return spec
  }

  private _get_graph_unit_unit_merges = (graph_id: string, unit_id: string) => {
    const graph = this._get_unit_spec(graph_id) as GraphSpec

    return getUnitMergesSpec(graph, unit_id)
  }

  private _get_graph_unit_merge = (graph_id: string, merge_id: string) => {
    const graph = this._get_unit_spec(graph_id) as GraphSpec

    return getMerge(graph, merge_id)
  }

  private _has_graph_unit_merge = (graph_id: string, merge_id: string) => {
    const graph = this._get_unit_spec(graph_id) as GraphSpec

    return hasMerge(graph, merge_id)
  }

  private _has_graph_unit_merge_pin = (
    graph_id: string,
    merge_id: string,
    unitId: string,
    type: IO,
    pinId: string
  ) => {
    const graph = this._get_unit_spec(graph_id) as GraphSpec

    return hasMergePin(graph, merge_id, unitId, type, pinId)
  }

  private _get_graph_unit_unit_plugs = (graph_id: string, unit_id: string) => {
    const graph = this._get_unit_spec(graph_id) as GraphSpec

    return findUnitPlugs(graph, unit_id)
  }

  private _get_subgraph_unit_sub_component_parent_id = (
    unit_id: string,
    sub_component_id: string
  ): string | null => {
    // console.log('Graph', '_get_subgraph_unit_sub_component_parent_id', unit_id, sub_component_id)

    const subgraph = this._subgraph_cache[unit_id]

    const unit_graph_spec = subgraph.get_target_spec()

    // const unit_graph_spec = this._get_unit_spec(unit_id) as GraphSpec

    const graph_unit_sub_component_parent_id = getSubComponentParentId(
      unit_graph_spec,
      sub_component_id
    )

    return graph_unit_sub_component_parent_id
  }

  private _get_unit_pin_spec = (pin_node_id: string): PinSpec => {
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)
    const pin_spec = this.__get_unit_pin_spec(unitId, type, pinId)
    return pin_spec
  }

  private __get_unit_pin_spec = (
    unit_id: string,
    type: IO,
    pin_id: string
  ): PinSpec => {
    const { specs, getSpec } = this.$props

    let spec: Spec

    if (unit_id === this._search_unit_id) {
      spec = getSpec(this._search_unit_spec_id)
    } else {
      spec = this._get_unit_spec(unit_id)
    }

    if (type === 'output') {
      if (pin_id === SELF) {
        return {
          name: SELF,
          type: 'any',
          ref: true,
        }
      }
    }

    const pin_spec: PinSpec = spec[`${type}s`][pin_id]

    return pin_spec
  }

  private _get_unit_spec_id = (unit_id: string): string => {
    const unit = this._get_unit(unit_id)
    const { id } = unit
    return id
  }

  private _get_unit_spec = (unit_id: string): Spec => {
    const { getSpec } = this.$props

    const spec_id = this._get_unit_spec_id(unit_id)

    const spec = getSpec(spec_id)

    return spec
  }

  private _spec_get_sub_pin_spec = (
    type: IO,
    pin_id: string,
    sub_pin_id: string
  ) => {
    return getSubPinSpec(this._spec, type, pin_id, sub_pin_id)
  }

  private _get_unit_component_spec = (unit_id: string): ComponentSpec => {
    const { specs } = this.$props

    const spec_id = this._get_unit_spec_id(unit_id)

    const component = getComponentSpec(specs, spec_id)

    return component
  }

  private _get_pin_spec = (type: IO, pin_id: string): GraphPinSpec => {
    return (this._spec[`${type}s`] || {})[pin_id]
  }

  private _has_exposed_pin_named = (type: IO, pin_id: string): boolean => {
    return !!(this._spec[`${type}s`] || {})[pin_id]
  }

  private _has_exposed_input_named = (pin_id: string): boolean => {
    return this._has_exposed_pin_named('input', pin_id)
  }

  private _has_exposed_output_named = (pin_id: string): boolean => {
    return this._has_exposed_pin_named('output', pin_id)
  }

  private _spec_get_exposed_pin_specs = () => {
    return getExposedPinSpecs(this._spec)
  }

  private _get_exposed_sub_pin_spec = (
    type: IO,
    pin_id: string,
    sub_pin_id: string
  ): GraphSubPinSpec => {
    const exposed_pin_spec = this._get_pin_spec(type, pin_id)

    const { plug = {} } = exposed_pin_spec

    const sub_pin = plug[sub_pin_id]

    return sub_pin
  }

  private _spec_get_pin_node_plug_spec = (
    type: IO,
    pin_node_id: string
  ): GraphPlugSpec | null => {
    const is_merge = this._is_merge_node_id(pin_node_id)
    const is_link_pin = this._is_link_pin_node_id(pin_node_id)

    const pinSpecs = this._spec[`${type}s`]

    for (const pinId in pinSpecs) {
      const pinSpec = pinSpecs[pinId]

      const { plug } = pinSpec

      for (const subPinId in plug) {
        const subPinSpec = plug[subPinId]

        if (is_merge) {
          const { mergeId } = segmentMergeNodeId(pin_node_id)

          if (mergeId === subPinSpec.mergeId) {
            return { type, pinId, subPinId, pinSpec, subPinSpec }
          }
        } else if (is_link_pin) {
          const {
            unitId: pinUnitId,
            type: pinUnitType,
            pinId: pinUnitPinId,
          } = segmentLinkPinNodeId(pin_node_id)

          if (
            pinUnitId === subPinSpec.unitId &&
            pinUnitPinId === subPinSpec.pinId &&
            pinUnitType === (subPinSpec.kind ?? type)
          ) {
            return { type, pinId, subPinId, pinSpec, subPinSpec }
          }
        }
      }
    }

    return null
  }

  private _get_component_fallback_size = (): {
    width: number
    height: number
  } => {
    const { $height, $width } = this.$context

    return {
      width: $width / 9,
      height: $height / 9,
    }
  }

  private _get_component_spec(): GraphComponentSpec {
    const { component = {} } = this._spec
    return component
  }

  private _get_unit_sub_component_spec = (
    unitId: string
  ): GraphSubComponentSpec | null => {
    const component = this._get_component_spec()
    return (
      (component &&
        component.subComponents &&
        component.subComponents[unitId]) ||
      null
    )
  }

  private _get_unit_data = (unit_id: string): IOOf<Dict<TreeNode>> => {
    const data = emptyIO({}, {})

    this._for_each_unit_pin(
      unit_id,
      (pin_node_id: string, type: IO, pin_id: string) => {
        const pin_datum_tree = this._pin_datum_tree[pin_node_id]

        if (pin_datum_tree) {
          data[type][pin_id] = pin_datum_tree
        }
      }
    )

    return data
  }

  private _get_unit_metadata = (unit_id: string): GraphUnitMetadataSpec => {
    const unit = this._get_unit(unit_id)
    const { metadata = {} } = unit
    return metadata
  }

  private _get_unit_metadata_component = (
    unitId: string
  ): { width?: number; height?: number } => {
    const metadata = this._get_unit_metadata(unitId)
    const { component = {} } = metadata
    return component
  }

  private _get_unit_component_default_size = (unitId: string): Size => {
    const { width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT } =
      this._get_component_fallback_size()
    const component = this._get_unit_component_spec(unitId)
    const width =
      (component && (component as BaseComponentSpec).defaultWidth) ||
      DEFAULT_WIDTH
    const height =
      (component && (component as BaseComponentSpec).defaultHeight) ||
      DEFAULT_HEIGHT
    return { width, height }
  }

  private _get_unit_component_layout_size = (unit_id: string): Size => {
    const { width: defaultWidth, height: defaultHeight } =
      this._get_unit_component_default_size(unit_id)
    const component_metadata = this._get_unit_metadata_component(unit_id)
    const sub_component = this._get_unit_sub_component_spec(unit_id) || {}
    const width =
      sub_component.width || component_metadata.width || defaultWidth
    const height =
      sub_component.height || component_metadata.height || defaultHeight
    return { width, height }
  }

  private _get_unit_component_graph_size = (unit_id: string): Size => {
    const { width: defaultWidth, height: defaultHeight } =
      this._get_unit_component_default_size(unit_id)

    const component_metadata = this._get_unit_metadata_component(unit_id)

    const width = component_metadata.width || defaultWidth
    const height = component_metadata.height || defaultHeight

    return { width, height }
  }

  private _get_node_anchor_node_id = (node_id: string): string => {
    if (this._is_pin_node_id(node_id)) {
      return this._get_pin_anchor_node_id(node_id)
    } else if (this._is_int_node_id(node_id)) {
      return this._get_int_pin_anchor_node_id(node_id)
    } else {
      return node_id
    }
  }

  private _get_int_pin_anchor_node_id(node_id: string): string | null {
    const { type, pinId, subPinId } = segmentInternalNodeId(node_id)

    return this._get_exposed_pin_internal_node_id(type, pinId, subPinId)
  }

  private _get_merge_anchor_node_id = (merge_node_id: string): string => {
    const merge_unit_id = this._merge_to_ref_unit[merge_node_id]
    const merge_ref_output_id = this._merge_to_ref_output[merge_node_id]
    if (merge_unit_id) {
      return merge_unit_id
    } else if (merge_ref_output_id) {
      return merge_ref_output_id
    } else {
      return merge_node_id
    }
  }

  private _get_pin_anchor_node_id = (pin_node_id: string): string => {
    if (this._is_link_pin_node_id(pin_node_id)) {
      const pin_merge_node_id = this._pin_to_merge[pin_node_id]

      if (pin_merge_node_id) {
        return this._get_merge_anchor_node_id(pin_merge_node_id)
      } else {
        const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

        if (isSelfPin(type, pinId)) {
          return unitId
        } else {
          return pin_node_id
        }
      }
    } else {
      return this._get_merge_anchor_node_id(pin_node_id)
    }
  }

  public getDatumPin(
    datumId: string
  ): { unitId: string; type: IO; pinId: string } | null {
    const datum_node_id = getDatumNodeId(datumId)

    const datum_pin_node_id = this._datum_to_pin[datum_node_id]

    if (datum_pin_node_id) {
      return segmentLinkPinNodeId(datum_pin_node_id)
    }

    return null
  }

  private _get_datum_pin_anchor_node_id = (
    datum_node_id: string
  ): string | null => {
    let anchor_node_id: string | null = null

    const datum_pin_node_id = this._datum_to_pin[datum_node_id]

    if (datum_pin_node_id) {
      anchor_node_id = this._get_pin_anchor_node_id(datum_pin_node_id)
    }

    const datum_plug_node_id = this._datum_to_plug[datum_node_id]

    if (datum_plug_node_id) {
      anchor_node_id = datum_plug_node_id
    }

    return anchor_node_id
  }

  private _has_input_merge = (merge_node_id: string): boolean => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    return this._merge_input_count[mergeId] > 0
  }

  private _has_output_merge = (merge_node_id: string): boolean => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    return this._merge_output_count[mergeId] > 0
  }

  private _is_input_only_merge = (merge_node_id: string): boolean => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    return this._merge_output_count[mergeId] === 0
  }

  private _is_output_only_merge = (merge_node_id: string): boolean => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    return this._merge_input_count[mergeId] === 0
  }

  private _is_link_pin_merged = (pin_node_id: string): boolean => {
    const merge_node_id = this._pin_to_merge[pin_node_id]

    const merged = !!merge_node_id

    return merged
  }

  private _spec_is_link_pin_ignored = (pin_node_id: string): boolean => {
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    const pin_ignored = this.__spec_is_link_pin_ignored(unitId, type, pinId)

    return pin_ignored
  }

  private __spec_is_link_pin_ignored = (
    unit_id: string,
    type: IO,
    pin_id: string
  ): boolean => {
    const pin_spec: PinSpec = this.__get_unit_pin_spec(unit_id, type, pin_id)
    const ignored = this._get_graph_unit_pin_spec_ignored(unit_id, type, pin_id)

    const { defaultIgnored } = pin_spec

    let pin_ignored: boolean = false
    if (typeof ignored === 'boolean') {
      pin_ignored = ignored
    } else if (defaultIgnored === true) {
      pin_ignored = true
    }

    return pin_ignored
  }

  private _get_graph_unit_pin_spec_ignored = (
    unit_id: string,
    type: IO,
    pin_id: string
  ): boolean => {
    const unit_pin_spec: GraphUnitPinSpec = this._get_graph_unit_pin_spec(
      unit_id,
      type,
      pin_id
    )

    const { ignored } = unit_pin_spec

    return ignored
  }

  private _is_link_pin_ref = (pin_node_id: string): boolean => {
    const ref = this._get_link_pin_ref(pin_node_id)

    return !!ref
  }

  private __is_link_pin_ref = (unit_id: string, type: IO, pin_id: string) => {
    return this.__get_link_pin_ref(unit_id, type, pin_id)
  }

  private _is_link_pin_not_ref = (pin_node_id: string): boolean => {
    return !this._is_link_pin_ref(pin_node_id)
  }

  private _is_link_pin_init = (pin_node_id: string): boolean => {
    const init = this._get_link_pin_init(pin_node_id)

    return !!init
  }

  private _get_link_pin_init = (pin_node_id: string): string | undefined => {
    const pin_spec: PinSpec = this._get_unit_pin_spec(pin_node_id)

    const { init } = pin_spec

    return init
  }

  private _get_link_pin_merge_id = (pin_node_id: string): string => {
    const merge_node_id = this._pin_to_merge[pin_node_id]

    const { mergeId } = segmentMergeNodeId(merge_node_id)

    return mergeId
  }

  private _get_link_pin_ref = (pin_node_id: string): boolean | undefined => {
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    const pin_spec: PinSpec = this._get_unit_pin_spec(pin_node_id)
    const unit_pin_spec = this._get_graph_unit_pin_spec(unitId, type, pinId)

    const { ref = pin_spec.ref } = unit_pin_spec

    return ref
  }

  private __get_link_pin_ref = (
    unit_id: string,
    type: IO,
    pin_id: string
  ): boolean | undefined => {
    const pin_spec: PinSpec = this.__get_unit_pin_spec(unit_id, type, pin_id)

    const { ref } = pin_spec

    return ref
  }

  private _is_merge_ref = (merge_node_id: string): boolean => {
    return this._merge_ref[merge_node_id]
  }

  private _is_pin_node_ref = (pin_node_id: string): boolean => {
    if (this._is_link_pin_node_id(pin_node_id)) {
      return this._is_link_pin_ref(pin_node_id)
    } else if (this._is_merge_node_id(pin_node_id)) {
      return this._is_merge_ref(pin_node_id)
    } else {
      return false
    }
  }

  private _is_pin_ref = (type: IO, pin_id: string) => {
    const pin = this._get_pin(type, pin_id)

    const { ref = false } = pin

    return ref
  }

  private _is_input_pin_ref = (pin_node_id: string): boolean => {
    return (
      this._is_input_pin_node_id(pin_node_id) &&
      this._is_pin_node_ref(pin_node_id)
    )
  }

  private _is_link_pin_constant = (pin_node_id: string): boolean => {
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)
    const constant = this._spec_is_link_pin_constant(unitId, type, pinId)
    return !!constant
  }

  private _spec_is_link_pin_constant = (
    unitId: string,
    type: IO,
    pinId: string
  ): boolean => {
    const unit_pin_spec = this._get_graph_unit_pin_spec(unitId, type, pinId)
    const { constant } = unit_pin_spec
    return !!constant
  }

  private _is_same_subgraph = (a_id: string, b_id: string): boolean => {
    const a_sg_id = this._node_to_subgraph[a_id]
    const b_sg_id = this._node_to_subgraph[b_id]

    return a_sg_id === b_sg_id
  }

  private _fetching_bundle: boolean = false

  private _center_graph_frame: number

  private _reset_spec = (): void => {
    const { parent, injectSpecs } = this.$props

    if (!this._pod) {
      return
    }

    this._fetching_bundle = true

    this._pod.$getBundle({}, (bundle) => {
      const { spec, specs } = clone(bundle)

      this._fetching_bundle = false

      if (!parent) {
        injectSpecs(weakMerge(specs ?? {}, { [spec.id]: spec }))
      }

      this._recenter_graph_position(spec)

      this._reset(spec)
      this._setup_pod(this._pod)
    })
  }

  public reset() {
    super.reset()

    for (const sub_graph_id in this._subgraph_cache) {
      const subgraph = this._subgraph_cache[sub_graph_id]

      subgraph.reset()
    }

    this._reset(this._spec)
  }

  private _reset(spec: GraphSpec) {
    const { classes } = this.$system

    const { specs, parent } = this.$props

    const { zoom } = this._config()

    if (this._prevent_next_reset) {
      return
    }

    this._spec = spec

    this._destroy_subgraph_cache()

    this._cancel_fullwindow_animation()

    this._zoom_comp.removeChildren()
    this._zoom_comp_alt.removeChildren()

    this._layout_root.children.removeChildren()
    this._layout_root.layers.removeChildren()

    this._subgraph.removeChildren()

    this._unit_datum = {
      input: {},
      output: {},
    }

    this._subgraph_cache = {}

    this._layout_core = {}
    this._layout_layer = {}

    this._cancel_node_long_click = false

    this._layout_scroll_animation = undefined

    this._node_comp = {}
    this._node_content = {}
    this._node_selection = {}

    this._link_comp = {}
    this._link_base = {}
    this._link_base_area = {}
    this._link_base_text = {}
    this._link_text = {}
    this._link_text_value = {}
    this._link_text_path = {}
    this._link_marker_end = {}
    this._link_marker_start = {}

    this._node = {}
    this._node_fixed = {}
    this._node_draggable = {}

    this._node_type = {}
    this._link_type = {}

    this._selection_opt = {}

    this._link = {}
    this._pin_link = {}
    this._exposed_link = {}
    this._data_link = {}
    this._visible_data_link = {}
    this._type_link = {}
    this._collapse_link = {}
    this._search_link = {}
    this._ignored_link = {}
    this._err_link = {}

    this._unit_node = {}
    this._pin_node = {}
    this._normal_node = {}
    this._collapse_node = {}
    this._exposed_node = {}
    this._type_node = {}
    this._search_node = {}
    this._ignored_node = {}
    this._exposed_ext_node = {}
    this._exposed_int_node = {}
    this._visible_data_node = {}
    this._hidden_data_node = {}
    this._linked_data_node = {}
    this._unlinked_data_node = {}
    this._visible_linked_data_node = {}
    this._visible_unlinked_data_node = {}
    this._data_node = {}
    this._err_node = {}

    this._link_pin_ref_set = new Set()
    this._link_pin_input_set = new Set()
    this._link_pin_output_set = new Set()

    this._layer_node = []
    this._layer_node[LAYER_NONE] = {}
    this._layer_node[LAYER_NORMAL] = this._normal_node
    this._layer_node[LAYER_COLLAPSE] = this._collapse_node
    this._layer_node[LAYER_SEARCH] = this._search_node
    this._layer_node[LAYER_IGNORED] = this._ignored_node
    this._layer_node[LAYER_EXPOSED] = this._exposed_node
    this._layer_node[LAYER_DATA_LINKED] = this._visible_linked_data_node
    this._layer_node[LAYER_DATA] = this._visible_unlinked_data_node
    this._layer_node[LAYER_ERR] = this._err_node
    this._layer_node[LAYER_TYPE] = this._type_node

    this._layer_link = []
    this._layer_link[LAYER_NONE] = this._none_link
    this._layer_link[LAYER_NORMAL] = this._pin_link
    this._layer_link[LAYER_COLLAPSE] = this._collapse_link
    this._layer_link[LAYER_SEARCH] = this._search_link
    this._layer_link[LAYER_IGNORED] = this._ignored_link
    this._layer_link[LAYER_EXPOSED] = this._exposed_link
    this._layer_link[LAYER_DATA_LINKED] = this._visible_data_link
    this._layer_link[LAYER_ERR] = this._err_link
    this._layer_link[LAYER_TYPE] = this._type_link

    this._err = {}

    this._unit_to_unit = {}

    this._unit_count = 0

    this._unit_component_count = 0

    this._unit_active_pin_count = {}

    this._component_nodes = {}

    this._pressed_node_pointer_count = 0
    this._node_pressed_count = {}
    this._pressed_node_count = 0
    this._pressed_node_id_pointer_id = {}
    this._pointer_id_pressed_node_id = {}
    this._pointer_id_hover_link_id = {}

    this._link_id_hover_pointer_id = {}

    this._drag_count = 0
    this._drag_node_id = {}
    this._drag_node_pointer_id = {}
    this._drag_pointer_id_node = {}

    this._static = false
    this._static_position = {}
    this._static_count = {}
    this._static_subgraph_anchor = {}
    this._static_subgraph_anchor_count = {}

    this._node_charge = {}

    this._hover_node_count = 0
    this._hover_node_pointer_count = {}
    this._hover_node_id = {}
    this._hover_node_id_pointer_id = {}

    this._pointer_id_hover_node_id = {}

    this._selected_node_count = 0
    this._selected_pin_count = 0
    this._selected_node_id = {}

    this._selected_component_count = 0
    this._selected_component = {}

    this._compatible_node_id = {}
    this._compatible_node_count = 0

    this._resize_node_id_pointer_id = {}
    this._resize_pointer_id_node_id = {}

    this._fullwindow_component_set = new Set()
    this._fullwindow_component_ids = []

    this._datum_tree = {}

    this._datum_to_pin = {}
    this._pin_to_datum = {}

    this._plug_to_datum = {}
    this._datum_to_plug = {}

    this._pin_datum_tree = {}

    this._pin_to_int = emptyIO({}, {})
    this._pin_to_ext = emptyIO({}, {})

    this._pin_to_merge = {}
    this._merge_to_pin = {}
    this._merge_to_input = {}
    this._merge_to_output = {}

    this._merge_pin_count = {}
    this._merge_input_count = {}
    this._merge_output_count = {}
    this._merge_active_output_count = {}
    this._merge_active_input_count = {}
    this._merge_ref = {}

    this._merge_to_ref_unit = {}
    this._merge_to_ref_output = {}

    this._ref_unit_to_merge = {}

    this._ref_output_to_merge = {}
    this._ref_output_pin_icon = {}

    this._node_graph = {}

    this._node_to_subgraph = {}
    this._subgraph_to_node = {}

    this._node_layer = {}
    this._link_layer = {}

    this._layout_node = {}
    this._layout_target_node = {}
    this._layout_core_abort_animation = {}
    this._layout_core_animating = new Set()
    this._layout_core_children_counter = {}
    this._layout_path = []
    this._layout_component_count = {}
    this._layout_sub_component_parent = {}

    this._layout_drag_node = {}
    this._layout_drag_index = {}
    this._layout_drag_direction = {}
    this._layout_drag_start_scroll_top = {}
    this._layout_drag_start_scroll_height = {}
    this._layout_drag_swap = {}
    this._layout_drag_swap_index = {}
    this._layout_drag_start_children = {}
    this._layout_drag_start_position = {}
    this._layout_drag_init_position = {}

    this._pointer_down = {}
    this._pointer_down_position = {}
    this._pointer_down_count = 0
    this._pointer_position = {}
    this._pointer_down_move_count = {}

    this._long_press_pointer = new Set()
    this._long_press_count = 0
    this._long_press_screen_position = NULL_VECTOR

    this._long_press_background_pointer = new Set()
    this._long_press_background_count = 0

    this._collapsing = false
    this._collapse_pointer_to_unit = {}
    this._collapse_world_position = NULL_VECTOR

    this._simulation.nodes(this._node)
    this._simulation.links(this._link)

    this._core = {}
    this._core_content = {}
    this._core_area = {}
    this._core_icon = {}
    this._core_name = {}
    this._core_description = {}

    this._core_component_overlay = {}
    this._core_component_resize = {}

    this._core_component_frame = {}
    this._core_component_self = {}

    this._core_component_max_width = []
    this._core_component_max_height = []
    this._core_component_max_width_id = []
    this._core_component_max_height_id = []

    this._core_layout_core_unlisten = {}

    this._core_component_frame_context = {}

    this._core_component_unlocked = {}
    this._core_component_unlocked_count = 0

    this._pin = {}
    this._pin_name = {}

    this._pin_link_start_marker = {}
    this._pin_link_end_marker = {}

    this._link_pin_constant_count = 0
    this._link_pin_memory_count = 0

    this._exposed_pin_set_count = 0

    this._exposed_pin_plugged_count = 0
    this._exposed_pin_unplugged_count = 0

    this._exposed_link_start_marker = {}
    this._exposed_link_end_marker = {}
    this._int_to_node = {}
    this._ext_to_node = {}
    this._exposed_ext_unplugged = {}
    this._exposed_int_unplugged = {}
    this._ext_pin_name = {}

    this._merge = {}
    this._merge_input = {}
    this._merge_output = {}

    this._datum_container = {}
    this._datum_area = {}
    this._datum = {}
    this._datum_overlay = {}
    this._datum_unlisten = {}

    this._err_comp = {}
    this._err_area = {}
    this._err_overlay = {}

    this._edit_datum_id = null
    this._edit_datum_node_id = null
    this._edit_datum_path = null
    this._edit_datum_committed = false

    this._type_container = {}
    this._type = {}

    this._node_unlisten = {}
    this._link_unlisten = {}

    const {
      units = {},
      merges = {},
      data,
      inputs = {},
      outputs = {},
      metadata = {},
    } = spec

    this._simulation_prevent_restart = true

    for (const datum_id in data) {
      const datum_spec = data[datum_id]

      let value: string
      let position: Position

      if (typeof datum_spec === 'string') {
        value = datum_spec
        position = this._init_random_datum_position()
      } else {
        value = stringifyDataValue(datum_spec.value, specs, classes)
        position =
          datum_spec?.metadata?.position ?? this._init_random_datum_position()
      }

      this._add_datum(datum_id, value, position)
    }

    this._unit_to_unit = {}

    const center = this._jiggle_world_screen_center()

    for (const unit_id in units) {
      const unit: GraphUnitSpec = units[unit_id]
      const { metadata = {} } = unit
      const { position } = metadata

      const p = clone(center)

      if (position) {
        p.x += position.x
        p.y += position.y
      }

      this._sim_add_unit_core(unit_id, unit, p)

      if (!parent) {
        this._register_unit(unit.id, true)
      }

      if (this._is_unit_component(unit_id)) {
        const layout_position = NULL_VECTOR

        const parent_id = this._spec_get_sub_component_parent_id(unit_id)

        this._sim_add_core_component(unit_id, parent_id, layout_position)
        this._mem_add_unit_component(unit_id, {})

        this._connect_sub_component(unit_id)
      }

      const unit_pin_position = this._get_spec_init_unit_pin_position(
        spec,
        unit_id
      )

      const offset_unit_pin_position = mapObjVK(unit_pin_position, (map) => {
        return mapObjVK(map, (position) => {
          return addVector(center, position)
        })
      })

      this._sim_add_unit_pins(
        unit_id,
        unit,
        offset_unit_pin_position,
        position,
        false
      )
    }

    for (const unit_id in units) {
      if (this._is_unit_component(unit_id)) {
        this._mem_add_unit_component_parent(unit_id)

        if (this._is_fullwindow) {
          this._fullwindow_component_ids.push(unit_id)
          this._fullwindow_component_set.add(unit_id)

          if (this._in_component_control) {
            this._couple_sub_component(unit_id)
          }
        } else {
          if (this._in_component_control) {
            if (this._subgraph_unit_id !== unit_id) {
              this._enter_sub_component_frame(unit_id)
            }
          }
        }
      }
    }

    for (const merge_id in merges) {
      const merge: GraphMergeSpec = merges[merge_id]

      const p = clone(center)

      const { position: metadata_position = {} } = metadata
      const { merge: merge_position = {} } = metadata_position

      const position = merge_position[merge_id]

      if (position) {
        p.x += position.x
        p.y += position.y
      }

      this._sim_add_merge(merge_id, merge, p)
      this._sim_collapse_merge(merge_id)
    }

    forEachGraphSpecPin(spec, (type, pinId, pinSpec) => {
      const plug_positions = {}

      forEachGraphSpecPinOfType(spec, type, (pinId, pinSpec) => {
        const { plug = {} } = pinSpec

        for (const subPinId in plug) {
          const sub_pin_metadata_position =
            pinSpec.metadata?.position?.[subPinId]

          const sub_pin_position = {
            int:
              sub_pin_metadata_position?.int &&
              addVector(center, sub_pin_metadata_position.int),
            ext:
              sub_pin_metadata_position?.ext &&
              addVector(center, sub_pin_metadata_position.ext),
          }

          plug_positions[subPinId] = sub_pin_position
        }
      })

      this._sim_add_exposed_pin_set(type, pinId, pinSpec, plug_positions)
    })

    if (this._enabled()) {
      if (this._tree_layout) {
        //
      } else {
        this._set_minimap_to_graph()
      }
    }

    this._rebuild_subgraph()

    this._simulation_prevent_restart = false

    this._set_zoom(zoom)
    this._center_graph(true)
    this._start_graph_simulation(LAYER_NONE)
    this._start_debugger()
  }

  private _center_on_nodes = (
    nodes: Dict<GraphSimNode>,
    preventAnimation?: boolean
  ) => {
    const { animate } = this._config()

    const center = this.get_nodes_bounding_rect_center(nodes)

    if (animate && !preventAnimation) {
      this._animate_zoom_center_at(center.x, center.y)
    } else {
      this._zoom_center_at(center.x, center.y)
    }
  }

  private _center_graph = (preventAnimation?: boolean) => {
    if (this._node_count === 0) {
      return
    }

    this._center_on_nodes(this._unit_node, preventAnimation)
  }

  private _center_graph_on_selected = (preventAnimation?: boolean) => {
    const selected_node = {}

    for (const node_id in this._selected_node_id) {
      const node = this._node[node_id]

      selected_node[node_id] = node
    }

    this._center_on_nodes(selected_node)
  }

  private _get_spec_init_unit_pin_position = (
    spec: GraphSpec,
    unit_id: string,
    center: Point = NULL_VECTOR
  ): UnitPinPosition => {
    const { units = {} } = spec

    const unit: GraphUnitSpec = units[unit_id]

    const { id } = unit

    const pin_position: UnitPinPosition = emptyIO({}, {})

    this._for_each_spec_id_pin(id, (type: IO, pin_id: string) => {
      const pin = deepGetOrDefault(unit, [type, pin_id], {})

      const { metadata = {} } = pin
      const { position } = metadata

      if (position) {
        center = center ?? this._jiggle_world_screen_center()

        const p = addVector(center, position)

        pin_position[type][pin_id] = p
      }
    })

    return pin_position
  }

  public get_target_spec = (): GraphSpec => {
    if (this._subgraph_graph) {
      // subgraph is in control
      return this._subgraph_graph.get_target_spec()
    } else {
      return this._spec
    }
  }

  public get_spec = (): GraphSpec => {
    return this._spec
  }

  public get_max_component_graph_size_size(): Size {
    const { component } = this.$props

    const sub_component_ids = keys(component.$subComponent)

    const size = this.get_sub_components_max_graph_size(sub_component_ids)

    return size
  }

  public get_max_component_layout_size(): Size {
    const { component } = this.$props

    const sub_component_ids = keys(component.$subComponent)

    const size = this.get_sub_components_max_layout_size(sub_component_ids)

    return size
  }

  public get_sub_components_max_graph_size(sub_component_ids: string[]): Size {
    return this.get_sub_components_max_size__template(
      sub_component_ids,
      this._get_unit_component_graph_size
    )
  }

  public get_sub_components_max_layout_size(sub_component_ids: string[]): Size {
    return this.get_sub_components_max_size__template(
      sub_component_ids,
      this._get_unit_component_layout_size
    )
  }

  public get_sub_components_max_size__template(
    sub_component_ids: string[],
    get_size: (sub_component_id: string) => Size
  ): Size {
    let max_width = Number.MIN_SAFE_INTEGER
    let max_height = Number.MIN_SAFE_INTEGER

    for (const sub_component_id of sub_component_ids) {
      const { width, height } = get_size(sub_component_id)

      max_width = Math.max(max_width, width)
      max_height = Math.max(max_height, height)
    }

    return {
      width: max_width,
      height: max_height,
    }
  }

  public getZoom = (): Zoom => {
    return this._zoom
  }

  private _add_unit(
    unit_id: string,
    bundle: UnitBundleSpec,
    position: Position,
    pin_position: UnitPinPosition = {
      input: {},
      output: {},
    },
    layout_position: Position,
    parent_id: string | null,
    emit: boolean = true
  ): void {
    // console.trace('Graph', '_add_unit')

    const { specs } = this.$props

    this._state_add_unit(
      unit_id,
      bundle,
      position,
      {},
      pin_position,
      layout_position,
      parent_id
    )

    emit && this._pod_add_unit(unit_id, bundle)
  }

  private _state_add_unit(
    unit_id: string,
    bundle: UnitBundleSpec,
    position: Position,
    size: Partial<Size> = {},
    pin_position: UnitPinPosition = {
      input: {},
      output: {},
    },
    sub_component_layout_position: Position,
    sub_component_parent_id: string | null,
    sub_component_index?: number,
    register: boolean = true,
    deep: boolean = true
  ): void {
    // console.trace('Graph', '_add_unit')

    const { injectSpecs } = this.$props

    const { unit, specs = {} } = bundle

    const id_map = injectSpecs(specs)

    remapUnitBundle(bundle, id_map)

    this._spec_add_unit(unit_id, unit, register, deep)

    const is_component = this._is_unit_component(unit_id)

    if (is_component) {
      if (sub_component_index === undefined) {
        this._spec_append_component(sub_component_parent_id, unit_id)
      } else {
        this._spec_insert_component(
          sub_component_parent_id,
          unit_id,
          sub_component_index
        )
      }
    }

    if (is_component) {
      if (sub_component_parent_id) {
        this._mem_add_unit_component(unit_id, {})
        this._mem_insert_sub_component_child(
          sub_component_parent_id,
          unit_id,
          'default',
          sub_component_index
        )
      }
    }

    this._sim_add_unit(
      unit_id,
      unit,
      position,
      size,
      pin_position,
      sub_component_parent_id,
      sub_component_layout_position
    )

    this._start_graph_simulation(LAYER_NONE)
  }

  public add_unit(
    unit_id: string,
    bundle: UnitBundleSpec,
    position: Position,
    pin_position: UnitPinPosition = {
      input: {},
      output: {},
    },
    layout_position: Position,
    parent_id: string | null
  ): void {
    this._dispatch_action(
      makeAddUnitAction(
        unit_id,
        clone(bundle),
        position,
        pin_position,
        layout_position,
        parent_id,
        {}
      )
    )

    this._add_unit(
      unit_id,
      bundle,
      position,
      pin_position,
      layout_position,
      parent_id
    )
  }

  private _dispatch_add_unit_action = (
    unit_id: string,
    unit: GraphUnitSpec
  ): void => {
    const position = this._get_node_position(unit_id)
    const pin_position = this._get_unit_pin_position(unit_id)
    const is_component = this._is_unit_component(unit_id)
    const layout_position = is_component
      ? this._get_layout_node_screen_position(unit_id)
      : this._screen_center()
    const layout_parent_id = is_component
      ? this._spec_get_sub_component_parent_id(unit_id)
      : null

    const bundle = clone({ unit })

    this._dispatch_action(
      makeAddUnitAction(
        unit_id,
        bundle,
        position,
        pin_position,
        layout_position,
        layout_parent_id,
        {}
      )
    )
  }

  private _dispatch_swap_unit_action = (
    unit_id: string,
    unit_bundle: UnitBundleSpec,
    unit_merges: GraphUnitMerges,
    unit_plugs: GraphUnitPlugs,
    unit_parent_id: string | null,
    unit_index: number | null,
    new_unit_id: string,
    new_unit_bundle: UnitBundleSpec,
    new_unit_merges: GraphUnitMerges,
    new_unit_plugs: GraphUnitPlugs,
    new_unit_parent_id: string | null,
    new_unit_index: number | null
  ) => {
    const action = this._make_swap_unit_action(
      unit_id,
      unit_bundle,
      unit_merges,
      unit_plugs,
      unit_parent_id,
      unit_index,
      new_unit_id,
      new_unit_bundle,
      new_unit_merges,
      new_unit_plugs,
      new_unit_parent_id,
      new_unit_index
    )

    this._dispatch_action(action)
  }

  private _make_swap_unit_action = (
    unit_id: string,
    unit_bundle: UnitBundleSpec,
    unit_merges: GraphUnitMerges,
    unit_plugs: GraphUnitPlugs,
    unit_parent_id: string | null,
    unit_index: number | null,
    new_unit_id: string,
    new_unit_bundle: UnitBundleSpec,
    new_unit_merges: GraphUnitMerges,
    new_unit_plugs: GraphUnitPlugs,
    new_unit_parent_id: string | null,
    new_unit_index: number | null
  ) => {
    const remove_unit_actions = makeRemoveUnitAction(
      unit_id,
      unit_bundle,
      undefined,
      undefined,
      undefined,
      unit_parent_id,
      unit_merges,
      unit_plugs
    )
    const add_unit_action = makeAddUnitAction(
      new_unit_id,
      new_unit_bundle,
      undefined,
      undefined,
      undefined,
      new_unit_parent_id,
      new_unit_merges,
      new_unit_plugs
    )

    const actions: Action[] = [remove_unit_actions, add_unit_action]

    return makeBulkEditAction(actions)
  }

  private _dispatch_clone_unit_action = (
    unit_id: string,
    new_unit_id: string
  ): void => {}

  private _dispatch_action_add_merge = (
    merge_id: string,
    merge: GraphMergeSpec
  ): void => {
    const merge_node_id = getMergeNodeId(merge_id)

    const position = this._get_merge_position(merge_node_id)

    this._dispatch_action(makeAddMergeAction(merge_id, clone(merge), position))
  }

  private _make_remove_unit_action = (
    unit_id: string,
    bundle?: UnitBundleSpec,
    includeMerges: boolean = true,
    includePlugs: boolean = true
  ) => {
    const { specs } = this.$props

    const unit = this._get_unit(unit_id)
    bundle = bundle ?? unitBundleSpec(unit, specs)
    const position = this._get_node_position(unit_id)
    const pin_position = this._get_unit_pin_position(unit_id)
    const is_component = this._is_unit_component(unit_id)
    const layout_position = is_component
      ? this._get_layout_node_screen_position(unit_id)
      : this._screen_center()
    const layout_parent_id = is_component
      ? this._spec_get_sub_component_parent_id(unit_id)
      : null
    const merges = this._get_unit_merges(unit_id)
    const plugs = this._get_unit_plugs(unit_id)

    return clone(
      makeRemoveUnitAction(
        unit_id,
        bundle,
        position,
        pin_position,
        layout_position,
        layout_parent_id,
        includeMerges ? merges : undefined,
        includePlugs ? plugs : undefined
      )
    )
  }

  private _dispatch_action_remove_unit = (unit_id: string) => {
    const action = this._make_remove_unit_action(unit_id)

    this._dispatch_action(action)
  }

  private _dispatch_action_remove_merge = (merge_node_id: string): void => {
    this._dispatch_action(this._make_remove_merge_action(merge_node_id))
  }

  private _make_remove_merge_action = (merge_node_id: string) => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    const merge = this._get_merge(merge_node_id)

    const position = this._get_merge_position(merge_node_id)

    return makeRemoveMergeAction(mergeId, clone(merge), position)
  }

  private _enter_all_sub_component_frame(): void {
    for (const sub_component_id in this._component.$subComponent) {
      this._enter_sub_component_frame(sub_component_id)
    }
  }

  public _leave_all_sub_component_frame(): void {
    for (const unit_id in this._component_nodes) {
      this._leave_sub_component_frame(unit_id)
    }
  }

  private _get_sub_component = (unit_id: string): Component | undefined => {
    if (this._component) {
      return this._component.getSubComponent(unit_id)
    } else {
      return undefined
    }
  }

  private _get_sub_component_spec = (
    sub_component_id: string
  ): GraphSubComponentSpec => {
    const component_spec = this._get_component_spec()
    const { subComponents = {} } = component_spec
    const subComponent = subComponents[sub_component_id]
    return subComponent
  }

  private _spec_get_sub_component_children = (
    sub_component_id: string
  ): string[] => {
    const sub_component_spec =
      this._get_sub_component_spec(sub_component_id) ?? {}
    const { children = [] } = sub_component_spec
    return children
  }

  private _decompose_sub_component(
    unit_id: string,
    deep: boolean = true
  ): void {
    // console.log('Graph', '_decompose_sub_component', unit_id)

    const sub_component = this._get_sub_component(unit_id)

    sub_component.decompose(deep)
  }

  private _compose_sub_component(unit_id: string): void {
    // console.log('Graph', '_compose_sub_component', unit_id)

    const sub_component = this._get_sub_component(unit_id)

    sub_component.compose()
  }

  private _spec_add_unit = (
    unitId: string,
    unit: GraphUnitSpec,
    register: boolean = true,
    deep: boolean = true
  ) => {
    // console.log('Graph', '_spec_add_unit', unitId, unit)
    const { parent } = this.$props

    addUnit({ unitId, unit: clone(unit) }, this._spec)

    if (!parent) {
      if (register) {
        this._register_unit(unit.id, deep)
      }
    }

    this._spec_update_metadata_complexity()
  }

  private _mirror_spec = (registry: Registry, specId: string) => {
    // console.log('Graph', '_mirror_spec', specId)

    const spec = registry.getSpec(specId) as GraphSpec

    const mirrored_spec = clone(spec)

    registry.setSpec(spec.id, mirrored_spec)
  }

  private _spec_append_component = (
    parent_id: string | null,
    unit_id: string,
    sub_component_spec: GraphSubComponentSpec = { children: [] }
  ): void => {
    // console.log('Graph', '_spec_append_component', parent_id, id)

    this._spec.component = this._spec.component || { subComponents: {} }

    setSubComponent(
      { unitId: unit_id, subComponent: sub_component_spec },
      this._spec.component
    )

    if (parent_id) {
      appendSubComponentChild(
        { parentId: parent_id, childId: unit_id },
        this._spec.component
      )
    } else {
      appendRoot({ childId: unit_id }, this._spec.component)
    }

    const { width, height } = this._get_unit_component_graph_size(unit_id)

    this._update_max_component_size(unit_id, width, height)

    this._spec_component_set_default_size()
  }

  private _spec_insert_component(
    parent_id: string | null,
    unit_id: string,
    at: number
  ) {
    this._spec.component = this._spec.component || { subComponents: {} }

    const current_sub_component_spec =
      this._get_sub_component_spec(unit_id) ?? {}

    setSubComponent(
      {
        unitId: unit_id,
        subComponent: { ...current_sub_component_spec },
      },
      this._spec.component
    )

    if (parent_id) {
      insertSubComponentChild(
        { parentId: parent_id, childId: unit_id, at },
        this._spec.component
      )
    } else {
      insertRoot({ childId: unit_id, at }, this._spec.component)
    }

    const { width, height } = this._get_unit_component_graph_size(unit_id)

    this._update_max_component_size(unit_id, width, height)

    this._spec_component_set_default_size()
  }

  private _animate_all_current_layout_layer_node = (): void => {
    // console.log('Graph', '_animate_all_current_layout_layer_node')

    const current_layer = this._get_current_layout_layer_id()

    this._animate_all_layout_layer_node(current_layer)
  }

  private _animate_all_layout_layer = (): void => {
    this._animate_all_layout_layer_node(null)

    for (const layer of this._layout_path) {
      this._animate_all_layout_layer_node(layer)
    }
  }

  private _animate_all_layout_layer_node = (layer: string | null): void => {
    // console.log('Graph', '_animate_all_layout_layer_node', layer)

    const layer_children = this._spec_get_layout_layer_children(layer)

    for (const sub_component_id of layer_children) {
      if (this._layout_drag_node[sub_component_id]) {
        continue
      }

      const layout_node = this._layout_node[sub_component_id]

      this._animate_layout_core(
        sub_component_id,
        layout_node,
        () => {
          return this._layout_target_node[sub_component_id]
        },
        () => {}
      )
    }
  }

  private _spec_update_metadata_complexity = () => {
    const { specs } = this.$props

    const c = graphComplexity(specs, this._spec)

    setMetadata({ path: ['metadata', 'complexity'], value: c }, this._spec)
  }

  private _flush_debugger = (): void => {
    // console.log('Graph', '_flush_debugger')

    let cursor = this._debug_cursor + 1

    const input: Dict<Dict<any>> = {}

    const output: Dict<Dict<any>> = {}

    const merge: Dict<any> = {}

    const input_data_handler = (_data: GraphUnitPinDataMomentData) => {
      const { unitId, pinId, data } = _data
      input[unitId] = input[unitId] || {}
      input[unitId][pinId] = data
    }

    const input_drop_handler = (_data: GraphUnitPinDataMomentData) => {
      const { unitId, pinId } = _data
      input[unitId] = input[unitId] || {}
      input[unitId][pinId] = undefined
    }

    const output_data_handler = (_data: GraphUnitPinDataMomentData) => {
      const { unitId, pinId, data } = _data
      output[unitId] = output[unitId] || {}
      output[unitId][pinId] = data
    }

    const output_drop_handler = (_data: GraphUnitPinDataMomentData) => {
      const { unitId, pinId } = _data
      output[unitId] = output[unitId] || {}
      output[unitId][pinId] = undefined
    }

    const handler: Dict<Dict<Function>> = {
      ref_input: {
        data: input_data_handler,
        drop: input_drop_handler,
      },
      ref_output: {
        data: output_data_handler,
        drop: output_drop_handler,
      },
      input: {
        data: input_data_handler,
        drop: input_drop_handler,
      },
      output: {
        data: output_data_handler,
        drop: output_drop_handler,
      },
      merge: {
        data: (moment: GraphMoment) => {
          const { id, data } = moment
          merge[id] = data
        },
        drop: (moment: GraphMoment) => {
          const { id } = moment
          merge[id] = undefined
        },
      },
      unit: this._graph_moment_handler['unit'],
      graph: this._graph_moment_handler['graph'],
    }

    while (cursor < this._debug_buffer.length) {
      const moment = this._debug_buffer[cursor]

      const { event, type, data } = moment

      handler[type][event](data)

      cursor++
    }

    forIO({ input, output }, (type, pins) => {
      for (const unitId in pins) {
        const unit_pin = pins[unitId]

        for (const pinId in unit_pin) {
          const pin_node_id = getPinNodeId(unitId, type, pinId)

          const data = unit_pin[pinId]

          if (this._is_pin_active(pin_node_id)) {
            if (data === undefined) {
              this._graph_debug_drop_pin_data(pin_node_id)
            } else {
              this._on_graph_unit_pin_data_moment({
                unitId,
                type,
                pinId,
                data,
              })
            }
          } else {
            if (data === undefined) {
              //
            } else {
              this._on_graph_unit_pin_data_moment({
                unitId,
                type,
                pinId,
                data,
              })
            }
          }
        }
      }
    })

    for (const merge_id in merge) {
      const data = merge[merge_id]

      const merge_node_id = getMergeNodeId(merge_id)

      if (this._is_pin_active(merge_node_id)) {
        if (data === undefined) {
          this._graph_debug_drop_pin_data(merge_node_id)
        } else {
          this._graph_debug_set_pin_value(merge_node_id, data)
        }
      } else {
        if (data === undefined) {
          //
        } else {
          this._graph_debug_set_pin_value(merge_node_id, data)
        }
      }
    }

    this._clear_debugger()
  }

  private _pod_add_unit(
    unitId: string,
    bundle: UnitBundleSpec,
    subComponent: GraphSubComponentSpec | null = null
  ): void {
    // console.log('Graph', '_pod_add_unit', unitId, bundle, subComponent)

    const { fork, bubble } = this.$props

    this._pod.$addUnit({
      unitId,
      bundle,
      subComponent,
      fork,
      bubble,
    })
  }

  private _pod_clone_unit(unitId: string, newUnitId: string): void {
    const { fork, bubble } = this.$props

    this._pod.$cloneUnit({
      unitId,
      newUnitId,
      fork,
      bubble,
    })
  }

  private _connect_sub_component = (
    unit_id: string,
    deep: boolean = true
  ): void => {
    // console.log('Graph', '_connect_sub_component', unit_id, deep)

    const sub_component = this._get_sub_component(unit_id)

    const _ = getComponentInterface(sub_component)

    const sub_unit = this._pod.$refUnit({
      unitId: unit_id,
      _,
    }) as $Component

    sub_component.connect(sub_unit, deep)
  }

  private _disconnect_sub_component = (unit_id: string): void => {
    // console.log('Graph', '_disconnect_sub_component', unit_id)

    const sub_component = this._get_sub_component(unit_id)

    if (sub_component) {
      sub_component.disconnect()
    }
  }

  private _disconnect_all_sub_component = (): void => {
    // console.log('Graph', '_disconnect_all_sub_component')

    for (const component_id in this._component.$subComponent) {
      this._disconnect_sub_component(component_id)
    }
  }

  private _get_unit_radius = (
    unit_id: string,
    use_cache: boolean = true
  ): number => {
    const { classes } = this.$system
    const { specs } = this.$props

    const path = this._get_unit_spec_id(unit_id)

    const r = getSpecRadius(specs, classes, path, use_cache)

    return r
  }

  private _sim_add_pin_datum = (
    unit_id: string,
    type: IO,
    pin_id: string,
    datum_id: string,
    value: string,
    position?: Position,
    emit?: boolean
  ) => {
    // console.log('Graph', '_sim_add_pin_datum', unit_id, type, pin_id, datum_id, value)

    const pin_node_id = getPinNodeId(unit_id, type, pin_id)

    position = position ?? this._predict_pin_datum_initial_position(pin_node_id)

    const tree = _getValueTree__cached(value)

    this._sim_add_pin_datum_tree(
      unit_id,
      type,
      pin_id,
      datum_id,
      tree,
      position,
      emit
    )
  }

  private _sim_graph_unit_expose_pin_set = (
    unit_id: string,
    type: IO,
    pin_id: string,
    position: Position | undefined,
    center?: Position | undefined,
    emit?: boolean
  ): void => {
    // console.log(
    //   'Graph',
    //   '_sim_graph_unit_expose_pin_set',
    //   unit_id,
    //   type,
    //   pin_id,
    //   position
    // )

    const { classes } = this.$system
    const { specs } = this.$props

    center = center || this._jiggle_world_screen_center()

    const unit = this._get_unit(unit_id)

    const unit_pin_spec = deepGetOrDefault(
      unit,
      [type, pin_id],
      {}
    ) as GraphUnitPinSpec
    const pin_node_id = getPinNodeId(unit_id, type, pin_id)

    const merged = this._is_link_pin_merged(pin_node_id)

    if (!merged) {
      this._sim_add_link_pin_node(unit_id, type, pin_id, position)
    }

    this._sim_add_link_pin_link(unit_id, type, pin_id)

    let { data, metadata = {} } = unit_pin_spec

    if (data !== undefined) {
      const data_ref = evaluateDataValue(data, specs, classes)

      if (data_ref.data !== undefined) {
        const metadata_position = metadata.data?.position

        const datum_id = this._new_datum_id()

        const value = stringifyDataValue(data_ref, specs, classes)

        const datum_tree = getTree__cached(value)

        let position: Position

        if (metadata_position) {
          position = addVector(center, metadata_position)
        } else {
          position = this._predict_pin_datum_initial_position(pin_node_id)
        }

        this._sim_add_pin_datum_tree(
          unit_id,
          type,
          pin_id,
          datum_id,
          datum_tree,
          position,
          emit
        )
      }
    }
  }

  private _sim_add_pin_datum_tree = (
    unit_id: string,
    type: IO,
    pin_id: string,
    datum_id: string,
    tree: TreeNode,
    position: Position,
    emit: boolean
  ) => {
    // console.log('Graph', '_sim_add_pin_datum_tree', unit_id, type, pin_id, datum_id, tree)

    const pin_node_id = getPinNodeId(unit_id, type, pin_id)

    const datum_node_id = getDatumNodeId(datum_id)

    this.__sim_add_datum_node(datum_id, tree, position, emit)

    this._sim_add_pin_datum_link(datum_node_id, pin_node_id, emit)

    this._mem_set_pin_datum(pin_node_id, datum_id)
  }

  private _init_unit_pin_position = (
    unit_id: string,
    type: IO,
    pin_id: string,
    i: number,
    total: number
  ): Position => {
    const core_node = this._node[unit_id]

    const { x: core_x, y: core_y, r: core_r } = core_node

    const position = getUnitPinPosition(
      i,
      total,
      type,
      PIN_RADIUS,
      core_x,
      core_y,
      core_r,
      undefined,
      LINK_DISTANCE
    )

    return position
  }

  private _sim_add_unit_pins = (
    unit_id: string,
    unit: GraphUnitSpec,
    pin_position: UnitPinPosition = {
      input: {},
      output: {},
    },
    center: Position | undefined,
    emit: boolean = true
  ): void => {
    const spec = this._get_unit_spec(unit_id)

    const { inputs = {}, outputs = {} } = spec

    const _pin_position = (
      type: IO,
      pin_id: string,
      i: number,
      total: number
    ): Position | undefined => {
      const position: Position =
        pin_position?.[type]?.[pin_id] ||
        this._init_unit_pin_position(unit_id, type, pin_id, i, total)

      return position
    }

    const _sim_add_pins = (type: IO, pins: PinsSpecBase): void => {
      let i = 0

      const total: number = keys(pins).length

      for (const pin_id in pins) {
        const pin_node_id = getPinNodeId(unit_id, type, pin_id)

        const ignored = this._spec_is_link_pin_ignored(pin_node_id)

        const position: Position = _pin_position(type, pin_id, i, total)

        this._sim_graph_unit_expose_pin_set(
          unit_id,
          type,
          pin_id,
          position,
          center,
          emit
        )

        if (!ignored) {
          i++
        }
      }
    }

    _sim_add_pins('input', inputs)
    _sim_add_pins('output', outputs)
  }

  private _spec_get_unit_icon = (unit_id: string) => {
    const spec = this._get_unit_spec(unit_id)

    const icon = (spec.metadata && spec.metadata.icon) || undefined

    return icon
  }

  private _sim_add_unit(
    unit_id: string,
    unit: GraphUnitSpec,
    position: Position,
    size: { width?: number; height?: number } = {},
    pin_position: UnitPinPosition = {
      input: {},
      output: {},
    },
    parent_id: string | null,
    layout_position?: Position
  ): void {
    // console.log('Graph', '_sim_add_unit', unit_id, position, pin_position)

    this._sim_add_unit_core(unit_id, unit, position, size)

    if (this._is_unit_component(unit_id)) {
      layout_position = layout_position || NULL_VECTOR

      this._sim_add_core_component(unit_id, parent_id, layout_position)
    }

    this._sim_add_unit_pins(unit_id, unit, pin_position, position)
  }

  private _core_prevent_selection_unlisten: Dict<Unlisten> = {}

  private _enable_core_text_selection = (unit_id: string) => {
    const unlisten = this._core_prevent_selection_unlisten[unit_id]

    if (!this._core_prevent_selection_unlisten[unit_id]) {
      return
    }

    if (unlisten) {
      unlisten()

      delete this._core_prevent_selection_unlisten[unit_id]
    }
  }

  private _disable_core_text_selection = (unit_id: string) => {
    const core_content = this._core_content[unit_id]

    if (this._core_prevent_selection_unlisten[unit_id]) {
      return
    }

    this._core_prevent_selection_unlisten[unit_id] = callAll([
      core_content.preventDefault('mousedown'),
      core_content.preventDefault('touchdown'),
    ])
  }

  private _set_core_description_size = (
    unit_id: string,
    width: number,
    height: number
  ): void => {
    const description = this._core_description[unit_id]

    description.$element.style.width = `${width}px`
    description.$element.style.height = `${height + 3}px`
  }

  private _sim_add_unit_core = (
    unit_id: string,
    unit: GraphUnitSpec,
    position: Position | undefined,
    init_size: { width?: number; height?: number } = {}
  ): void => {
    // console.log('Graph', '_sim_add_core', unit_id, unit, position)

    const { classes } = this.$system

    const { config, specs, getSpec } = this.$props

    const { id } = unit

    const spec = getSpec(id)

    const is_base = isBaseSpec(spec)

    const is_component: boolean = isComponentId(specs, id)

    let r: number
    let width: number
    let height: number
    let shape: Shape

    if (is_component) {
      const size = this._get_unit_component_graph_size(unit_id)

      width = init_size.width ?? size.width + 2
      height = init_size.height ?? size.height + 2

      r = Math.max(width, height) / 2

      shape = 'rect'
    } else {
      r = getSpecRadius(specs, classes, id, true)

      width = init_size.width ?? 2 * r
      height = init_size.height ?? 2 * r

      shape = 'circle'
    }

    const { x, y } = position || this._jiggle_world_screen_center()

    this._sim_add_node(unit_id, {
      _x: x,
      _y: y,
      x,
      y,
      fx: undefined,
      fy: undefined,
      shape,
      r,
      width,
      height,
      vx: 0,
      vy: 0,
      ax: 0,
      ay: 0,
      hx: 0,
      hy: 0,
      layer: LAYER_NORMAL,
    })

    this._add_node_link_heap_node(unit_id)

    this._node_type[unit_id] = 'u'
    this._node_layer[unit_id] = LAYER_NORMAL

    const node = this._node[unit_id]

    this._unit_node[unit_id] = node
    this._normal_node[unit_id] = node

    const self_pin_node_id = getSelfPinNodeId(unit_id)

    this._node_type[self_pin_node_id] = 'p'

    const core_node = this._node_comp[unit_id]
    const core_node_content = this._node_content[unit_id]

    const core_selection = this._create_selection(unit_id, {
      width,
      height,
      shape,
      stroke: COLOR_NONE,
    })

    const core_area = this._create_touch_area({
      className: 'core-area',
      width,
      height,
      style: {
        borderRadius: is_component ? '0' : '50%',
        ...userSelect('none'),
      },
    })
    this._core_area[unit_id] = core_area

    let icon = this._spec_get_unit_icon(unit_id)

    if (icon === undefined) {
      if (is_base) {
        icon = 'question'
      } else {
        // core icon is not visible if graph is empty
        const unit_count = keyCount((spec as GraphSpec).units || {})
        if (unit_count > 0) {
          icon = 'question'
        }
      }
    }

    const { width: icon_width, height: icon_height } =
      this._get_core_icon_size(unit_id)

    const core_icon = new Icon(
      {
        icon,
        style: {
          position: 'absolute',
          width: `${icon_width}px`,
          height: `${icon_height}px`,
          top: '50%',
          left: '50%',
          display: is_component ? 'none' : 'block',
          // fill: this._theme.node,
          fill: 'transparent',
          stroke: this._theme.node,
          transform: 'translate(-50%, -50%)',
          ...userSelect('none'),
        },
      },
      this.$system
    )
    core_icon.preventDefault('touchstart')
    this._core_icon[unit_id] = core_icon

    const spec_name = spec.name || UNTITLED

    this._node_name[unit_id] = spec_name

    const { width: name_width, height: name_height } =
      this._get_node_name_size(unit_id)

    const core_name = new TextArea(
      {
        className: 'core-name',
        style: {
          position: 'relative',
          display: 'flex',
          fontSize: '12px',
          // backgroundColor: randomColorString(),
          borderWidth: '0px',
          borderStyle: 'solid',
          paddingTop: '1px',
          textDecoration: 'none',
          justifyContent: 'center',
          textAlign: 'center',
          pointerEvents: this._mode === 'info' ? 'inherit' : 'none',
          touchAction: 'none',
          color: this._theme.text,
          width: `${name_width + 2}px`,
          height: `${name_height + 4}px`,
          overflow: 'hidden',
          overflowWrap: 'break-word',
          wordBreak: 'break-word',
          left: `50%`,
          top: 'calc(100% + 3px)',
          transform: `translateX(-50%)`,
          visibility: config?.unitNames ? 'visible' : 'hidden',
          maxWidth:
            (UNIT_NAME_MAX_CHAR_LINE * UNIT_CORE_NAME_FONT_SIZE) / 2 + 'px',
          ...userSelect('none'),
        },
        value: formatUnitName(spec_name, UNIT_CORE_NAME_FONT_SIZE),
        attr: {
          maxLength: UNIT_NAME_MAX_SIZE,
          tabindex: -1,
        },
      },
      this.$system
    )
    core_name.$element.addEventListener('dragstart', (event) => {
      event.preventDefault()
    })

    this._sim_setup_node_name(unit_id, core_name)
    this._core_name[unit_id] = core_name

    const spec_description: string =
      (spec.metadata && spec.metadata.description) || '...'

    const { width: description_width, height: description_height } =
      getDivTextSize(spec_description, 10, 30)

    const core_description = new TextArea(
      {
        className: 'core-description',
        style: {
          position: 'relative',
          display: 'none',
          fontSize: '10px',
          borderColor: COLOR_NONE,
          borderWidth: '0px',
          borderStyle: 'solid',
          textDecoration: 'none',
          textAlign: 'center',
          touchAction: 'none',
          color: this._theme.pin_text,
          width: `${description_width}px`,
          height: `${description_height}px`,
          left: `50%`,
          top: `calc(100% + ${6}px)`,
          transform: `translateX(-50%)`,
          overflow: 'visible',
        },
        attr: {
          maxLength: UNIT_DESCRIPTION_MAX_SIZE,
          tabindex: -1,
        },
        value: spec_description,
      },
      this.$system
    )
    core_description.$element.addEventListener('dragstart', (event) => {
      event.preventDefault()
    })
    this._core_description[unit_id] = core_description

    this._sim_setup_core_description(unit_id, core_description)

    const core_content = new Div(
      {
        className: 'core-content',
        style: {
          position: 'absolute',
          height: '100%',
          width: '100%',
        },
      },
      this.$system
    )
    core_content.appendChild(core_selection)
    core_content.appendChild(core_area)
    core_content.appendChild(core_icon)
    core_content.appendChild(core_name)
    core_content.appendChild(core_description)

    this._core_content[unit_id] = core_content

    this._disable_core_text_selection(unit_id)

    const core = new Div(
      {
        className: 'core',
        style: {
          width: `${width}px`,
          height: `${height}px`,
          // position: 'relative',
          position: 'absolute',
          borderWidth: '1px',
          borderRadius: shape === 'circle' ? '50%' : '0',
          borderColor: this._theme.node,
          borderStyle: 'solid',
          boxSizing: 'border-box',
          // boxSizing: 'content-box',
          touchAction: 'none',
        },
      },
      this.$system
    )
    core.appendChild(core_content)

    this._core[unit_id] = core

    core_node_content.appendChild(core)

    this._zoom_comp.appendChild(core_node)

    this._unit_count++

    if (this._minimap) {
      this._minimap.tick()
    }

    if (this._unit_count === 1) {
      if (this._minimap_screen) {
        this._minimap_screen.$element.style.display = 'block'
      }
    }

    if (this._static) {
      if (!this._ascend_node_dict[unit_id]) {
        this._start_node_static(unit_id)
      }
    }

    this._refresh_core_border_color(unit_id)
  }

  private _on_core_name_focus = (unit_id: string): void => {
    // console.log('Graph', '_on_core_name_focus', unit_id)

    this._set_core_selection_to_name(unit_id)
  }

  private _on_plug_name_focus = (plug_node_id: string): void => {
    // console.log('Graph', '_on_plug_name_focus', plug_node_id)

    this._set_plug_selection_to_name(plug_node_id)
  }

  private _on_unit_pin_name_focus = (pin_node_id: string): void => {
    this._set_pin_selection_to_name(pin_node_id)
  }

  private _on_plug_name_blur = (plug_node_id: string): void => {
    // console.log('Graph', '_on_plug_name_blur', plug_node_id)

    this._set_node_selection_to_node(plug_node_id)

    const { type, pinId, subPinId } = segmentPlugNodeId(plug_node_id)

    const value = this._get_node_temp_name(plug_node_id)
    const valid = this._is_valid_plug_name(plug_node_id, value)

    let next_pin_id = pinId

    if (value !== pinId) {
      if (valid) {
        if (this._spec_has_pin_named(type, value)) {
          const new_sub_pin_id = this._new_sub_pin_id(type, value)

          const int_node_id = getIntNodeId(type, pinId, subPinId)

          const ext_position = this._get_anchor_node_position(plug_node_id)
          const int_position = this._get_anchor_node_position(int_node_id)

          this._remove_exposed_sub_pin_or_set(plug_node_id)

          this._add_exposed_pin(
            type,
            value,
            new_sub_pin_id,
            {},
            {
              int: int_position,
              ext: ext_position,
            }
          )
        } else {
          this._set_pin_name(plug_node_id, value)
        }

        next_pin_id = value
      } else {
        this._set_pin_name(plug_node_id, pinId)
      }

      const next_ext_node_id = getExtNodeId(type, next_pin_id, subPinId)

      if (this._mode === 'info') {
        this._enable_plug_name(next_ext_node_id)
      }
    }
  }

  private _pod_set_unit_pin_set_id = (
    unitId: string,
    type: IO,
    pinId: string,
    nextPinId: string
  ): void => {
    const { fork, bubble } = this.$props

    this._pod.$setUnitPinSetId({
      unitId,
      type,
      pinId,
      nextPinId,
      fork,
      bubble,
    })
  }

  private _on_unit_pin_name_blur = (pin_node_id: string) => {
    // console.log('Graph', '_on_unit_pin_name_blur', pin_node_id)

    this._set_node_selection_to_node(pin_node_id)

    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    const value = this._get_node_temp_name(pin_node_id)
    const valid = this._is_valid_pin_name_value(value)

    let next_pin_id = pinId

    if (value !== pinId) {
      if (valid) {
        this._on_graph_unit_set_pin_set_id({
          type,
          pinId,
          nextPinId: value,
          path: [unitId],
        })

        const subgraph = this._subgraph_cache[unitId]

        if (subgraph) {
          subgraph._state_set_exposed_pin_name(type, pinId, value)
        }

        this._pod_set_unit_pin_set_id(unitId, type, pinId, value)

        next_pin_id = value
      } else {
        this._set_node_temp_name(pin_node_id, pinId)

        const pin_name = this._pin_name[pin_node_id]

        if (pin_name) {
          pin_name.setProp('value', pinId)
        }
      }

      const next_pin_node_id = getPinNodeId(unitId, type, next_pin_id)

      if (this._mode === 'info') {
        this._enable_pin_name(next_pin_node_id)
      }
    }
  }

  private _set_plug_selection_to_name = (ext_node_id: string): void => {
    this._set_node_selection_to_name(ext_node_id, -2, 0)
  }

  private _set_pin_selection_to_name = (pin_node_id: string): void => {
    this._set_node_selection_to_name(pin_node_id, -1, 0, 0, -2)
  }

  private _set_core_selection_to_name = (unit_id: string): void => {
    this._set_node_selection_to_name(unit_id, 1, 0, 0, -2)
  }

  private __set_core_selection_to_description = (
    unit_id: string,
    value: string
  ): void => {
    const { width, height } = this._get_node_description_size(unit_id, value)

    const name_size = this._get_core_name_size(unit_id)

    this._set_node_selection_to_field(
      unit_id,
      6 + name_size.height,
      0,
      0,
      0,
      width,
      height
    )
  }

  private _get_node_description_size = (
    unit_id: string,
    value: string
  ): Size => {
    return getDivTextSize(
      replaceNodeName(value),
      UNIT_DESCRIPTION_FONT_SIZE,
      UNIT_DESCRIPTION_MAX_LINE_LENGTH
    )
  }

  private _set_node_selection_to_node = (unit_id: string): void => {
    const {
      width: node_width,
      height: node_height,
      shape: node_shape,
    } = this._node[unit_id]

    const selection = this._node_selection[unit_id]

    selection.setProp('y', 0)
    selection.setProp('shape', node_shape)

    if (this._is_node_selected(unit_id)) {
      this._enable_core_resize(unit_id)
    }

    this._resize_selection(unit_id, node_width, node_height)
  }

  private _set_node_selection_to_name = (
    node_id: string,
    dy: number = 0,
    dx: number = 0,
    dw: number = 0,
    dh: number = 0
  ): void => {
    // console.log('Graph', '_set_node_selection_to_name')

    const { width, height } = this._get_node_name_size(node_id)

    this._set_node_selection_to_field(node_id, dy, dx, dw, dh, width, height)
  }

  private _set_node_selection_to_field = (
    node_id: string,
    dy: number = 0,
    dx: number = 0,
    dw: number = 0,
    dh: number = 0,
    width: number,
    height: number
  ): void => {
    // console.log('Graph', '_set_node_selection_to_field')

    const { height: node_height } = this.get_node(node_id)

    const x = dx
    const y = node_height / 2 + dy + height / 2 + 3
    const shape = 'rect'

    this._set_selection_y(node_id, y)
    this._set_selection_x(node_id, x)
    this._set_selection_shape(node_id, shape)

    if (this._is_unit_node_id(node_id)) {
      this._disable_core_resize(node_id)
    }

    const _width = width + dw
    const _height = height + dh

    this._resize_selection(node_id, _width, _height)
  }

  private _set_selection_x = (node_id: string, x: number) => {
    const selection = this._node_selection[node_id]

    selection.setProp('x', x)
  }

  private _set_selection_y = (node_id: string, y: number) => {
    const selection = this._node_selection[node_id]

    selection.setProp('y', y)
  }

  private _set_selection_shape = (node_id: string, shape: Shape) => {
    const selection = this._node_selection[node_id]

    selection.setProp('shape', shape)
  }

  private _sim_add_core_component_frame = (unit_id: string): void => {
    const core_content = this._core_content[unit_id]

    const core_component_frame = new Frame(
      {
        className: 'core-component-frame',
        style: {
          position: 'absolute',
          top: '0',
          width: '100%',
          height: '100%',
        },
      },
      this.$system
    )

    stopAllPropagation(core_component_frame.$element)

    stopByPropagation(core_component_frame.$element, 'dragenter')
    stopByPropagation(core_component_frame.$element, 'dragleave')

    const { $$context } = core_component_frame

    this._core_component_frame[unit_id] = core_component_frame
    this._core_component_frame_context[unit_id] = $$context

    core_component_frame.addEventListener(
      makeDragLeaveListener(() => {
        if (this._unlock_drag_initiated) {
          if (this._core_component_unlocked[unit_id]) {
            this._lock_sub_component(unit_id)
          }
        }
      })
    )

    core_content.appendChild(core_component_frame)
  }

  private _sim_add_core_resize = (unit_id: string): void => {
    const core_content = this._core_content[unit_id]

    const core_resize = new Resize({ disabled: true, l: 21 }, this.$system)
    core_resize.addEventListener(
      makeCustomListener('resizestart', (data: IOResizeEvent) => {
        this._on_component_resize_start(unit_id, data)
      })
    )
    core_resize.addEventListener(
      makeCustomListener('resized', (data: IOResizeEvent) => {
        this._on_component_resize(unit_id, data)
      })
    )
    core_resize.addEventListener(
      makeCustomListener('resizeend', (data: {}) => {
        this._on_component_resize_end(unit_id, data)
      })
    )
    this._core_component_resize[unit_id] = core_resize
    core_content.appendChild(core_resize)
  }

  private _sim_add_layout_core_children_counter = (unit_id: string): void => {
    const { animate } = this._config()

    const layout_core = this._layout_core[unit_id]

    const component_children = this._spec_get_sub_component_children(unit_id)
    const component_children_count = component_children.length
    const component_children_counter = new Div(
      {
        style: {
          opacity: '0',
          position: 'absolute',
          width: 'auto',
          height: 'auto',
          left: '50%',
          top: '-24px',
          transform: 'translate(-50%)',
          pointerEvents: 'none',
          userSelect: 'none',
        },
        innerText: `${component_children_count}`,
      },
      this.$system
    )
    this._layout_core_children_counter[unit_id] = component_children_counter
    layout_core.appendChild(component_children_counter)
  }

  private _sim_add_core_component_overlay = (unit_id: string): void => {
    const core_content = this._core_content[unit_id]

    const core_overlay = this._create_overlay({ className: 'core-overlay' })

    this._core_component_overlay[unit_id] = core_overlay

    core_content.appendChild(core_overlay)

    core_overlay.addEventListeners([
      makeDragEnterListener(() => {
        this._unlock_drag_initiated = true

        this._lock_all_component_but(unit_id)
        this._unlock_sub_component(unit_id, false)
      }),
    ])
  }

  private _unlock_drag_initiated: boolean = false

  private _sim_add_core_component = (
    unit_id: string,
    parent_id: string | null,
    layout_position: Position
  ) => {
    // console.log('Graph', '_sim_add_core_component', unit_id, parent_id)

    this._unit_component_count++

    this._component_nodes[unit_id] = this._node[unit_id]

    this._sim_add_core_component_frame(unit_id)
    this._sim_add_core_resize(unit_id)
    this._sim_add_core_component_overlay(unit_id)

    this._sim_add_layout_core(unit_id, parent_id, layout_position)
    this._sim_add_layout_core_children_counter(unit_id)

    this._layout_sub_component_parent[unit_id] = parent_id

    if (this._tree_layout) {
      const layout_core = this._layout_core[unit_id]

      this._listen_layout_core(unit_id, layout_core)

      if (parent_id && !this._layout_path.includes(parent_id)) {
        //
      } else {
        this._move_core_content_graph_to_layout(unit_id)

        this._show_layout_core(unit_id)
      }
    }
  }

  private _refresh_current_layout_node_target_position = (): void => {
    const current_layout_layer = this._get_current_layout_layer_id()

    this._refresh_layout_node_target_position(current_layout_layer)
  }

  private _refresh_layout_root_node_size = () => {
    // console.log('Graph', '_refresh_layout_root_node_size')
    return this._refresh_layer_layout_target_node_size(null)
  }

  private _refresh_layer_layout_target_node_size = (layer: string): void => {
    // console.log('Graph', '_refresh_layout_target_node_size', layer)

    const { $width, $height } = this.$context

    const children = this._spec_get_layout_layer_children(layer)

    for (let i = 0; i < children.length; i++) {
      const child_id = children[i]

      const layout_size = this._get_unit_component_layout_size(child_id)

      let { width, height } = layout_size

      width = Math.min(width, $width - 2 * LAYOUT_HORIZONTAL_PADDING)
      height = Math.min(height, $height - 2 * LAYOUT_VERTICAL_PADDING)

      const layout_target_node = this._layout_target_node[child_id]

      layout_target_node.width = width
      layout_target_node.height = height
    }
  }

  private _refresh_all_layout_node_size = (): void => {
    this._refresh_layer_layout_target_node_size(null)

    for (const layer of this._layout_path) {
      this._refresh_layer_layout_target_node_size(layer)
    }
  }

  private _force_all_layout_node_traits = () => {
    this._force_layout_node_traits(null)

    for (const layer of this._layout_path) {
      this._force_layout_node_traits(layer)
    }
  }

  private _force_layout_node_traits = (parent_id: string | null): void => {
    // console.log('Graph', '_force_layout_node_traits', parent_id)

    const children =
      parent_id === null
        ? this._spec_get_component_children()
        : this._spec_get_sub_component_children(parent_id)

    for (const child of children) {
      const { x, y, width, height } = this._layout_target_node[child]

      this._set_layout_core_position(child, x, y)
      this.__resize_layout_core(child, width, height)
    }
  }

  private _search_vertical_padding = 2 * LAYOUT_VERTICAL_PADDING

  private _refresh_layout_node_target_position = (
    parent_id: string | null
  ): void => {
    // console.log('Graph', '_refresh_layout_node_target_position', parent_id)

    const { $width, $height } = this.$context

    const children =
      parent_id === null
        ? this._spec_get_component_children()
        : this._spec_get_sub_component_children(parent_id)

    const layout_component_ij = {}

    const row_total_width_sum: number[] = []
    const row_total_max_height: number[] = []

    let total_height: number = 0
    let row = 0
    let column = 0

    for (let i = 0; i < children.length; i++) {
      const child_id = children[i]

      const layout_node = this._layout_target_node[child_id]

      const { width, height } = layout_node

      if (row_total_width_sum[row] + width >= $width - 150) {
        total_height += (row_total_max_height[row] ?? 0) + 60
        row++
        column = 0
      }
      layout_component_ij[child_id] = [row, column]
      row_total_width_sum[row] = (row_total_width_sum[row] ?? 0) + width
      row_total_max_height[row] = Math.max(
        row_total_max_height[row] ?? 0,
        height
      )
      if (column > 0) {
        row_total_width_sum[row] += 60
      }
      column++
    }

    total_height += row_total_max_height[row]

    const partial_row_width_sum: number[] = []
    const partial_max_height_sum: number[] = []

    for (let i = 0; i < children.length; i++) {
      const child_id = children[i]

      const layout_node = this._layout_target_node[child_id]

      const [row, column] = layout_component_ij[child_id]

      const { width } = layout_node

      const row_partial_max_height_sum = partial_max_height_sum[row] ?? 0
      const row_row_total_max_height = row_total_max_height[row]

      const x =
        -row_total_width_sum[row] / 2 +
        (partial_row_width_sum[row] ?? 0) +
        column * 60 +
        width / 2

      let y: number

      if (total_height > $height - 120) {
        y =
          row_partial_max_height_sum +
          row * 60 -
          $height / 2 +
          60 +
          row_row_total_max_height / 2
      } else {
        y =
          row_partial_max_height_sum +
          row * 60 -
          total_height / 2 +
          row_row_total_max_height / 2
      }

      const candidate_height =
        total_height + 1 * LAYOUT_VERTICAL_PADDING + this._search_offset_y + 36

      const final_height = Math.max(candidate_height, $height)

      this._set_all_layout_heights(parent_id, final_height)

      const layout_target_node = this._layout_target_node[child_id]

      layout_target_node.x = x
      layout_target_node.y = y

      if (!partial_max_height_sum[row + 1]) {
        partial_max_height_sum[row + 1] =
          row_partial_max_height_sum + row_total_max_height[row]
      }

      partial_row_width_sum[row] = (partial_row_width_sum[row] ?? 0) + width
    }
  }

  private _search_offset_y: number = 0

  private _set_layout_search_offset_y = (
    layer_id: string,
    offset_y: number
  ): void => {
    this._search_offset_y = offset_y

    // this._ensure_layout_height_animation(layer_id)
  }

  private _ensure_layout_height_animation = (layer_id: string) => {
    if (!this._abort_layout_layer_height_animation[layer_id]) {
      this._start_layout_layer_height_animation(layer_id)
    }
  }

  private _abort_layout_layer_height_animation: Dict<Unlisten> = {}

  private _layout_layer_target_height: number = 0
  private _layout_layer_current_height: number = 0

  private _start_layout_layer_height_animation = (layer_id: string) => {
    const n0 = {
      height: this._layout_layer_current_height,
    }

    const n1 = () => {
      return {
        height: this._layout_layer_target_height,
      }
    }

    const ff = [['height', ANIMATION_DELTA_THRESHOLD]] as [string, number][]

    this._abort_layout_layer_height_animation[layer_id] =
      this._animate_simulate(
        n0,
        n1,
        ff,
        ({ height }) => {
          this._set_all_layout_heights(layer_id, height)
        },
        () => {
          return false
        }
      )
  }

  private _set_all_layout_heights = (layer_id: string, height: number) => {
    // console.log('Graph', '_set_all_layout_heights', layer_id, height)

    const layout_layer = this._get_layout_layer(layer_id)

    layout_layer.height.$element.style.height = `${height}px`
  }

  private _move_all_layout_node_target_position = (
    parent_id: string | null
  ) => {
    const { animate } = this._config()

    if (animate) {
      this._animate_all_layout_layer_node(parent_id)
    } else {
      this._set_all_layout_layer_core_position(parent_id)
    }
  }

  private _move_all_current_layout_node_target_position = () => {
    const current_layer = this._get_current_layout_layer_id()

    this._move_all_layout_node_target_position(current_layer)
  }

  private _clamp_layout_core_size = (size: Size): Size => {
    const { width, height } = size

    const max_width = this._get_layout_max_width()

    return {
      width: clamp(width, MIN_WIDTH, max_width),
      height,
    }
  }

  private _sim_add_layout_core = (
    unit_id: string,
    parent_id: string | null,
    layout_position: Position
  ): void => {
    const { x, y } = layout_position

    const layout_size = this._get_unit_component_layout_size(unit_id)

    const { width, height } = this._clamp_layout_core_size(layout_size)

    const color = hexToRgba(this._get_color())

    const layout_core = new Div(
      {
        style: {
          // display: 'none',
          opacity: '1',
          position: 'absolute',
          left: `calc(50% + ${x}px)`,
          top: `calc(50% + ${y}px)`,
          width: `${width + 2}px`,
          height: `${height + 2}px`,
          transform: 'translate(-50%, -50%)',
          borderWidth: '1px',
          borderStyle: 'solid',
          borderColor: 'currentColor',
          boxSizing: 'content-box',
          // boxSizing: 'border-box',
          touchAction: 'none',
          // margin: '30px',
        },
      },
      this.$system
    )
    this._layout_core[unit_id] = layout_core

    const fontSize = this.getFontSize()

    const layout_node: LayoutNode = {
      x,
      y,
      width,
      height,
      sx: 1,
      sy: 1,
      opacity: 1,
      fontSize,
      color,
    }

    this._layout_node[unit_id] = layout_node

    this._layout_target_node[unit_id] = clone(layout_node)

    if (parent_id) {
      const parent_layout_layer = this._ensure_layout_layer(parent_id)

      parent_layout_layer.children.appendChild(layout_core)
    } else {
      this._layout_root.children.appendChild(layout_core)
    }
  }

  private _search_adding_unit: boolean = false

  private _sim_add_sub_component = (
    unit_id: string,
    sub_component_map: Dict<Component> = {},
    at?: number,
    add_to_parent: boolean = true,
    element: IOElement = undefined
  ): void => {
    // console.log(
    //   'Graph',
    //   '_sim_add_unit_component',
    //   unit_id,
    //   sub_component_map,
    //   at,
    //   add_to_parent
    // )

    this._mem_add_unit_component(unit_id, sub_component_map, element)

    if (add_to_parent) {
      this._sim_add_sub_component_to_parent(unit_id, at)
    }
  }

  private _sim_add_sub_component_to_parent = (
    unit_id: string,
    at?: number
  ): void => {
    // console.log('Graph', '_sim_add_unit_component', unit_id, sub_component_map, at, add_to_parent)

    this._mem_add_unit_component_parent(unit_id)

    if (this._in_component_control) {
      this._place_sub_component(unit_id, at)
    }
  }

  private _set_sub_component_index = (
    sub_component_id: string,
    i: number
  ): void => {
    // console.log('Graph', '_set_sub_component_index', i)

    this._sub_component_index[sub_component_id] = i
  }

  private _sub_component: Dict<Component> = {}

  private _mem_add_unit_component = (
    unit_id: string,
    sub_component_map: Dict<Component>,
    element: IOElement = undefined
  ): void => {
    // console.log(
    //   'Graph',
    //   '_mem_add_unit_component',
    //   unit_id,
    //   sub_component_map,
    //   element
    // )

    const { components, classes } = this.$system

    const { specs } = this.$props

    this._search_adding_unit = true

    let sub_component = this._component.$subComponent[unit_id]

    if (sub_component) {
      //
    } else {
      if (this._subgraph_unit_id === unit_id) {
        sub_component = this._subgraph_graph._component
      } else {
        const spec_id = this._get_unit_spec_id(unit_id)

        const Class = componentClassFromSpecId(
          components,
          specs,
          spec_id,
          {},
          sub_component_map,
          element
        )

        sub_component = new Class({}, this.$system)
      }

      this._component.setSubComponent(unit_id, sub_component)
    }

    this._sub_component[unit_id] = sub_component

    const index = this._get_sub_component_tree_index(unit_id)

    this._set_tree_sub_component_index(unit_id, index)

    this._search_adding_unit = false
  }

  private _set_sub_component_controlled = (
    sub_component_id: string,
    controlled: boolean
  ) => {
    const sub_component = this._get_sub_component(sub_component_id)

    sub_component.setControlled(controlled)
  }

  private _mem_add_unit_component_parent = (unit_id: string): void => {
    // console.log('Graph', '_mem_add_unit_component_parent', unit_id)

    const sub_component = this._get_sub_component(unit_id)

    const parent_id = this._spec_get_sub_component_parent_id(unit_id)

    if (parent_id) {
      const parent = this._get_sub_component(parent_id)

      if (!parent.$parentRoot.includes(sub_component)) {
        parent.pushParentRoot(sub_component, 'default')
      }

      this._mem_layout_push_parent_root(parent_id, unit_id, 'default')
    } else {
      if (!this._component.$root.includes(sub_component)) {
        this._component.pushRoot(sub_component)
      }
    }
  }

  private _node_name: Dict<string> = {}

  private _is_valid_unit_name = (value: string): boolean => {
    if (value.length === 0) {
      return false
    }

    if (value.match(/\n/g)) {
      return false
    }

    if (value.length > UNIT_NAME_MAX_SIZE) {
      return false
    }

    return true
  }

  private _get_node_temp_name = (node_id: string): string => {
    return this._node_name[node_id] ?? ''
  }

  private _mem_set_node_temp_name = (node_id: string, value: string) => {
    // console.log('Graph', '_mem_set_node_temp_name', node_id, value)

    if (this._is_unit_node_id(node_id)) {
      this._node_name[node_id] = replaceNodeName(value)
    } else {
      this._node_name[node_id] = value
    }
  }

  private _set_unit_temp_description = (unit_id: string, value: string) => {
    // console.log('Graph', '_set_unit_temp_description', unit_id, value)

    let _value = replaceNodeName(value)

    const core_description = this._core_description[unit_id]

    const { selectionStart, selectionEnd } = core_description.$element

    if (_value.length > UNIT_DESCRIPTION_MAX_SIZE) {
      _value = _value.substring(0, UNIT_DESCRIPTION_MAX_SIZE)

      // this._mem_set_node_temp_name(unit_id, _value)
    }

    const dom_value = formatUnitName(_value, UNIT_DESCRIPTION_MAX_LINE_LENGTH)

    this._dom_set_core_temp_description(unit_id, dom_value)

    core_description.$element.setSelectionRange(selectionStart, selectionEnd)

    const { width, height } = this._get_node_description_size(unit_id, _value)

    this._refresh_unit_description_color(unit_id)

    this._set_core_description_size(unit_id, width, height)
  }

  private _set_unit_temp_name = (unit_id: string, value: string): void => {
    // console.log('Graph', '_set_unit_temp_name', unit_id, value)

    let _value = replaceNodeName(value)

    const dom_value = formatUnitName(_value, UNIT_CORE_NAME_FONT_SIZE)

    const core_name = this._core_name[unit_id]

    const { selectionStart, selectionEnd } = core_name.$element

    if (_value.length > UNIT_NAME_MAX_SIZE) {
      _value = _value.substring(0, UNIT_NAME_MAX_SIZE)

      this._mem_set_node_temp_name(unit_id, _value)
    }

    this._dom_set_core_temp_name(unit_id, dom_value)

    core_name.$element.setSelectionRange(selectionStart, selectionEnd)

    this._set_core_selection_to_name(unit_id)

    this._refresh_core_name_color(unit_id)
    this._refresh_core_name_size(unit_id)
  }

  private _dom_set_core_temp_name = (unit_id: string, value: string) => {
    // console.log(
    //   'Graph',
    //   '_dom_set_core_temp_name',
    //   unit_id,
    //   JSON.stringify(value)
    // )

    const core_name = this._core_name[unit_id]

    core_name.setProp('value', value)
  }

  private _dom_set_core_temp_description = (unit_id: string, value: string) => {
    // console.log('Graph', '_dom_set_core_temp_description', unit_id)

    const core_description = this._core_description[unit_id]

    core_description.setProp('value', value)
  }

  private _refresh_core_name_color = (unit_id: string) => {
    const value = this._get_node_temp_name(unit_id)

    const _value = replaceNodeName(value)

    const valid = this._is_valid_unit_name(_value)

    if (valid) {
      this._set_core_name_caret_color(unit_id, 'currentColor')
    } else {
      const err_color = this._get_err_color()

      this._set_core_name_caret_color(unit_id, err_color)
    }
  }

  private _get_err_color = (): string => {
    return COLOR_OPAQUE_RED
  }

  private _get_mode_color = (mode: Mode): string => {
    const { $theme } = this.$context

    const color = getThemeModeColor($theme, mode, 'currentColor')

    return color
  }

  private _set_core_name_caret_color = (
    unit_id: string,
    caretColor: string
  ): void => {
    const core_name = this._core_name[unit_id]

    this._set_name_comp_caret_color(core_name, caretColor)
  }

  private _set_name_comp_caret_color = (
    name_comp: TextArea,
    caretColor: string
  ): void => {
    name_comp.$element.style.caretColor = caretColor
  }

  private _should_core_name_be_selectable = (unit_id: string) => {
    if (this._mode === 'info') {
      return true
    }

    return false
  }

  private _set_core_name_user_select_none = (unit_id: string) => {
    const core_name = this._core_name[unit_id]

    core_name.$element.style.userSelect = 'none'
  }

  private _set_core_name_user_select_inherit = (unit_id: string) => {
    const core_name = this._core_name[unit_id]

    core_name.$element.style.userSelect = 'none'
  }

  private _refresh_core_name_user_select = (unit_id: string) => {
    if (this._should_core_name_be_selectable(unit_id)) {
      this._set_core_name_user_select_inherit(unit_id)
    } else {
      this._set_core_name_user_select_none(unit_id)
    }
  }

  private _get_core_name_size = (node_id: string): Size => {
    // console.log('Graph', '_get_core_name_size', unit_id, value)

    const value = this._node_name[node_id]

    const _value = replaceNodeName(value)

    const size = getDivTextSize(
      _value,
      UNIT_CORE_NAME_FONT_SIZE,
      UNIT_NAME_MAX_CHAR_LINE
    )

    return size
  }

  private _get_node_name_size = (node_id: string): Size => {
    // console.log('Graph', '_get_node_name_size', unit_id, value)

    if (this._is_unit_node_id(node_id)) {
      return this._get_core_name_size(node_id)
    } else if (this._is_ext_node_id(node_id)) {
      return this._get_plug_name_size(node_id)
    } else if (this._is_link_pin_node_id(node_id)) {
      return this._get_pin_name_size(node_id)
    } else {
      throw new ShouldNeverHappenError()
    }
  }

  private _refresh_core_name_size = (unit_id: string) => {
    // console.log('Graph', '_refresh_core_name_size', unit_id)

    const { width, height } = this._get_node_name_size(unit_id)

    const core_name = this._core_name[unit_id]

    core_name.$element.style.width = `${width + 2}px`
    core_name.$element.style.height = `${height + 4}px`
  }

  private _get_plug_name_size = (ext_node_id: string): Size => {
    return this._get_pin_name_size(ext_node_id)
  }

  private _get_pin_name_size = (pin_node_id: string) => {
    // console.log('Graph', '_get_pin_name_size', pin_node_id)

    const value = this._node_name[pin_node_id]

    const size = getDivTextSize(
      value,
      PLUG_NAME_FONT_SIZE,
      PLUG_NAME_MAX_CHAR_LINE
    )

    return size
  }

  private _refresh_plug_name_size = (ext_node_id: string) => {
    // console.log('Graph', '_refresh_plug_name_size', ext_node_id)

    const { width, height } = this._get_plug_name_size(ext_node_id)

    const _width = Math.max(width, 6)
    const _height = Math.max(height, 6)

    this._set_plug_name_style_attr(ext_node_id, 'width', `${_width}px`)
    this._set_plug_name_style_attr(ext_node_id, 'height', `${_height}px`)

    this._set_plug_selection_to_name(ext_node_id)
  }

  private _set_unit_name = (unit_id: string, name: string): string => {
    // console.log('Graph', '_set_unit_name', unit_id, name)

    // this._spec_set_unit_spec_name(unit_id, name)

    const new_unit_id = this._state_set_unit_name(unit_id, name)

    this._pod_set_unit_name(unit_id, new_unit_id, name)

    if (this._is_unit_component(new_unit_id)) {
      this._connect_sub_component(new_unit_id)
    }

    return new_unit_id
  }

  private _spec_set_unit_spec_name = (unit_id: string, name: string): void => {
    // console.log('Graph', '_spec_set_unit_name', unit_id, name)

    const { setSpec } = this.$props

    const spec = this._get_unit_spec(unit_id) as GraphSpec

    const next_spec = clone(spec)

    deepSet(next_spec, ['name'], name)

    setSpec(next_spec.id, next_spec)
  }

  private _state_set_unit_name = (unit_id: string, value: string): string => {
    const { forkSpec } = this.$props

    const spec = this._get_unit_spec(unit_id) as GraphSpec

    const new_spec = clone(spec)

    const new_unit_id = this._new_unit_id(new_spec.id)

    const unit_data = this._get_unit_data(unit_id)

    const {
      valid_pin_match,
      merged_pin_ids,
      merge_pin_index,
      exposed_pin_ids,
      exposed_pin_index,
    } = this._generate_identity_matches(unit_id)

    this._state_swap_unit(
      unit_id,
      new_unit_id,
      new_spec.id,
      new_spec,
      valid_pin_match,
      merged_pin_ids,
      merge_pin_index,
      exposed_pin_ids,
      exposed_pin_index
    )

    forIOObjKV(unit_data, (type, pin_id, pin_data) => {
      const pin_node_id = getPinNodeId(new_unit_id, type, pin_id)

      this._graph_debug_set_pin_data_tree(pin_node_id, pin_data)
    })

    return new_unit_id
  }

  private _pod_set_unit_name = (
    unit_id: string,
    new_unit_id: string,
    name: string
  ): void => {
    const { fork, bubble } = this.$props

    this._pod.$setUnitId({
      unitId: unit_id,
      newUnitId: new_unit_id,
      name,
      fork,
      bubble,
    })
  }

  private _set_unit_pin_temp_name = (
    pin_node_id: string,
    value: string
  ): void => {
    const valid = this._is_valid_pin_name_value(value)

    if (valid) {
      this._set_pin_name_caret_color(pin_node_id, 'currentColor')
    } else {
      this._set_pin_name_caret_color(pin_node_id, this._get_err_color())
    }

    this._refresh_pin_name_size(pin_node_id)
  }

  private _set_pin_name_caret_color = (pin_node_id: string, color: string) => {
    this._set_pin_name_style_attr(pin_node_id, 'caretColor', color)
  }

  private _refresh_pin_name_size = (pin_node_id: string) => {
    const { width, height } = this._get_pin_name_size(pin_node_id)

    const _width = Math.max(width, 6)
    const _height = Math.max(height, 6)

    this._set_pin_name_style_attr(pin_node_id, 'width', `${_width}px`)
    this._set_pin_name_style_attr(pin_node_id, 'height', `${_height}px`)

    this._set_pin_selection_to_name(pin_node_id)
  }

  private _set_unit_pin_name = (pin_node_id: string, value: string): void => {
    this._spec_set_unit_pin_metadata_rename(pin_node_id, value)
  }

  private _spec_set_unit_pin_metadata_rename = (
    pin_node_id: string,
    value: string
  ): void => {
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    setMetadata(
      { path: ['units', unitId, type, pinId, 'metadata', 'rename'], value },
      this._spec
    )
  }

  private _set_pin_name = (exposed_pin_node_id: string, name: string): void => {
    const { type, pinId } = segmentPlugNodeId(exposed_pin_node_id)

    this._state_set_exposed_pin_name(type, pinId, name)
    this._pod_set_pin_set_id(type, pinId, name)
  }

  private _state_set_exposed_pin_name = (
    type: IO,
    pinId: string,
    nextPinId: string
  ): void => {
    // console.log('Graph', '_state_set_exposed_pin_name', type, pinId, nextPinId)

    const has_next_pin_id = hasPinNamed(this._spec, type, nextPinId)

    const pin_spec = this._get_pin_spec(type, pinId)
    const plug_position = this._get_pin_plug_position(type, pinId)
    const plug_datum = this._get_pin_plug_datum(type, pinId)
    const plug_datum_position = mapObjKV(
      plug_datum,
      (sub_pin_id, datum_node_id: string) => {
        const datum_position = this._get_node_position(datum_node_id)

        return datum_position
      }
    )

    const data = this._unit_datum[type][pinId]

    this._sim_cover_pin_set(type, pinId)

    if (has_next_pin_id) {
      const { plug = {} } = pin_spec

      for (const sub_pin_id in plug) {
        const sub_pin = plug[sub_pin_id]

        const next_sub_pin_id = this._new_sub_pin_id(type, nextPinId)

        const sub_pin_position = plug_position[sub_pin_id]

        this._state_add_exposed_pin(
          type,
          nextPinId,
          next_sub_pin_id,
          sub_pin,
          sub_pin_position
        )
      }
    } else {
      this._spec_set_exposed_pin_name(type, pinId, nextPinId)
      this._sim_add_exposed_pin_set(type, nextPinId, pin_spec, plug_position)
    }

    if (data !== undefined) {
      this._sim_set_pin_set_data(
        type,
        nextPinId,
        data,
        undefined,
        plug_datum_position
      )
    }
  }

  private _spec_set_exposed_pin_name = (
    type: IO,
    pinId: string,
    nextPinId: string
  ): void => {
    // console.log('Graph', '_spec_set_exposed_pin_name', type, pinId, nextPinId)

    setPinSetId({ type, pinId, nextPinId }, this._spec)
  }

  private _get_pin_plug_position = (
    type: IO,
    pin_id: string
  ): Dict<{ int: Position; ext: Position }> => {
    const position_map: Dict<{ int: Position; ext: Position }> = {}

    this._for_each_plug(type, pin_id, (sub_pin_id) => {
      const ext_pin_node_id = getExtNodeId(type, pin_id, sub_pin_id)
      const int_pin_node_id = getIntNodeId(type, pin_id, sub_pin_id)

      const ext_anchor_node_id = this._get_node_anchor_node_id(ext_pin_node_id)
      const int_anchor_node_id = this._get_node_anchor_node_id(int_pin_node_id)

      const ext = this._get_node_position(ext_anchor_node_id)
      const int = this._get_node_position(int_anchor_node_id)

      position_map[sub_pin_id] = {
        ext,
        int,
      }
    })

    return position_map
  }

  private _get_pin_plug_datum = (type: IO, pinId: string): Dict<string> => {
    const pin_spec = this._get_pin_spec(type, pinId)

    const plug_datum: Dict<string> = {}

    const { plug } = pin_spec

    for (const sub_pin_id in plug) {
      const plug_node_id = getExtNodeId(type, pinId, sub_pin_id)

      const datum_node_id = this._plug_to_datum[plug_node_id]

      if (datum_node_id) {
        plug_datum[sub_pin_id] = datum_node_id
      }
    }

    return plug_datum
  }

  private _sim_set_exposed_pin_name = (
    type: IO,
    pinId: string,
    new_id: string
  ): void => {
    const pin_spec = this._get_pin_spec(type, pinId)

    const plug_position = this._get_pin_plug_position(type, pinId)
    const plug_datum = this._get_pin_plug_datum(type, pinId)

    for (const sub_pin_id in plug_datum) {
      this._sim_remove_plug_datum_link(type, pinId, sub_pin_id)
    }

    this._sim_cover_pin_set(type, pinId)

    this._sim_add_exposed_pin_set(type, new_id, pin_spec, plug_position)
  }

  private _pod_set_pin_set_id = (
    type: IO,
    pinId: string,
    nextPinId: string
  ): void => {
    const { fork, bubble } = this.$props

    this._pod.$setPinSetId({ type, pinId, nextPinId, fork, bubble })
  }

  private _get_err_size = (err: string): Size => {
    const { width, height } = getDivTextSize(err, 12, 18)

    const MAX_ERR_HEIGHT = 48 + 1

    const clamped_height = Math.min(height + 2, MAX_ERR_HEIGHT)

    return { width, height: clamped_height }
  }

  private _sim_add_unit_err = (unit_id: string, err: string): void => {
    // console.log('Graph', '_sim_add_unit_err')
    const err_node_id = getErrNodeId(unit_id)

    // const escaped_err = escape(err)
    const escaped_err = err

    const { width, height } = this._get_err_size(err)

    const r = Math.max(width, height) / 2

    // const unit_node = this._node[unit_id]
    // const { x, y } = randomInRadius(unit_node.x, unit_node.y, LINK_DISTANCE)
    const { x, y } = this._err_initial_position(unit_id)

    const shape = 'rect'

    const err_node = this._sim_add_node(err_node_id, {
      _x: x,
      _y: y,
      x,
      y,
      fx: undefined,
      fy: undefined,
      shape,
      r,
      width,
      height,
      vx: 0,
      vy: 0,
      ax: 0,
      ay: 0,
      hx: 0,
      hy: 0,
      layer: LAYER_ERR,
    })
    this._node_type[err_node_id] = 'x'
    this._node_layer[err_node_id] = LAYER_ERR

    const node = this._node[err_node_id]
    this._err_node[err_node_id] = node

    const node_content = this._node_content[err_node_id]

    const err_selection = this._create_selection(err_node_id, {
      width,
      height,
      shape,
      stroke: COLOR_NONE,
    })

    const err_area = this._create_touch_area({
      className: 'err-area',
      width,
      height,
    })
    this._err_area[err_node_id] = err_area

    const err_comp = new Div(
      {
        className: 'err',
        style: {
          width: `${width}px`,
          height: `${height}px`,
          fontSize: '12px',
          textAlign: 'center',
          wordBreak: 'break-word',
          overflowWrap: 'break-word',
          overflow: 'auto',
          color: COLOR_OPAQUE_RED,
          ...userSelect('auto'),
        },
        innerText: escaped_err,
      },
      this.$system
    )
    err_comp.stopPropagation('wheel')
    this._err_comp[unit_id] = err_comp

    const err_overlay = this._create_overlay({
      className: 'err-overlay',
    })
    this._err_overlay[err_node_id] = err_overlay

    node_content.appendChild(err_area)
    node_content.appendChild(err_selection)
    node_content.appendChild(err_comp)
    node_content.appendChild(err_overlay)

    const source_id = unit_id
    const target_id = err_node_id
    const link_id = getLinkId(unit_id, err_node_id)
    const d = LINK_DISTANCE_ERR

    const err_link = this._sim_add_link(
      link_id,
      {
        source_id,
        target_id,
        l: d,
        s: 1,
        padding: {
          source: -6,
          target: -6,
        },
        detail: {
          type: 'x',
          head: 0,
        },
      },
      {
        stroke: COLOR_OPAQUE_RED,
        strokeWidth: 1,
      }
    )

    this._err_link[link_id] = this._link[link_id]
    this._link_layer[link_id] = LAYER_ERR

    this._zoom_comp.appendChild(err_node)

    this._zoom_comp.appendChild(err_link, 'svg')

    this._start_graph_simulation(LAYER_ERR)
  }

  private _pod_take_unit_err = (unitId: string): void => {
    const $unit = this._pod.$refUnit({
      unitId,
      _: ['U'],
      detached: false,
    }) as $U

    $unit.$takeErr({})
  }

  private _sim_remove_unit_err = (unit_id: string): void => {
    delete this._err[unit_id]

    this._sim_remove_unit_err_link(unit_id)
    this._sim_remove_unit_err_node(unit_id)
  }

  private _sim_remove_unit_err_link = (unit_id: string): void => {
    const err_node_id = getErrNodeId(unit_id)

    const link_id = getLinkId(unit_id, err_node_id)

    delete this._err_link[link_id]

    this._sim_remove_link(link_id)

    delete this._err[unit_id]
  }

  private _sim_remove_unit_err_node = (unit_id: string): void => {
    // console.log('Graph', '_sim_remove_unit_err_node', unit_id)

    const err_node_id = getErrNodeId(unit_id)

    delete this._err[unit_id]
    delete this._err_comp[unit_id]
    delete this._err_area[err_node_id]
    delete this._err_node[err_node_id]

    this._sim_remove_node(err_node_id)
  }

  private _sim_set_unit_err = (unit_id: string, err: string): void => {
    this._err[unit_id] = err

    const err_node_id = getErrNodeId(unit_id)

    const err_component = this._err_comp[unit_id]

    const { width, height } = this._get_err_size(err)

    this._resize_node(err_node_id, width, height)
    this._resize_selection(err_node_id, width, height)

    err_component.$element.style.width = `${width}px`
    err_component.$element.style.height = `${height}px`

    const escaped_err = escape(err)

    err_component.setProp('innerText', escaped_err)
  }

  public add_exposed_pin_set = (
    type: IO,
    pin_id: string,
    pin_spec: GraphPinSpec,
    data: string,
    position: Dict<{ int?: Position; ext?: Position }> = {}
  ) => {
    this._dispatch_action(makeExposePinSetAction(type, pin_id, pin_spec, data))

    this._expose_pin_set(type, pin_id, pin_spec, data, position)
  }

  private _expose_pin_set = (
    type: IO,
    pin_id: string,
    pin_spec: GraphPinSpec,
    data: string | undefined,
    position: Dict<{ int?: Position; ext?: Position }> = {},
    emit: boolean = true
  ) => {
    // console.log('Graph', '_add_exposed_pin_set', type, pin_id, pin_spec)

    this._state_add_exposed_pin_set(type, pin_id, pin_spec, position)
    emit && this._pod_expose_pin_set(type, pin_id, clone(pin_spec), data)

    if (data !== undefined) {
      this._sim_set_pin_set_data(type, pin_id, data)
    }
  }

  private _state_add_exposed_pin_set = (
    type: IO,
    pin_id: string,
    pin_spec: GraphPinSpec,
    position: Dict<{ int?: Position; ext?: Position }> = {}
  ) => {
    // console.log('Graph', '_state_add_exposed_pin_set', type, pin_id, pin_spec)

    this._spec_add_exposed_pin_set(type, pin_id, pin_spec)
    this._sim_add_exposed_pin_set(type, pin_id, pin_spec, position)
  }

  private _spec_add_exposed_pin_set = (
    type: IO,
    pinId: string,
    pinSpec: GraphPinSpec
  ) => {
    // console.log('_spec_add_exposed_pin_set', type, pinId, pinSpec)

    exposePinSet({ pinId, type, pinSpec }, this._spec)

    this._spec_refresh_exposed_pin_set_type(type, pinId)
  }

  private _spec_refresh_exposed_pin_set_type = (type: IO, pinId: string) => {
    const dataType = this.__get_ext_pin_type_value(type, pinId)

    setPinSetDataType({ pinId, type, dataType }, this._spec)
  }

  private _pod_expose_pin_set = (
    type: IO,
    pinId: string,
    pin: GraphPinSpec,
    data?: string
  ): void => {
    // console.log('Graph', '_pod_expose_pin_set', id, type, pin)

    const { fork, bubble } = this.$props

    this._pod.$exposePinSet({
      type,
      pinId,
      pinSpec: clone(pin),
      data,
      fork,
      bubble,
    })
  }

  private _pod_expose_unit_pin_set = (
    unitId: string,
    type: IO,
    pinId: string,
    pinSpec: GraphPinSpec
  ): void => {
    const { fork, bubble } = this.$props

    const $unit = this._pod.$refUnit({
      unitId,
      _: UCGEE,
      detached: false,
    }) as $Graph

    $unit.$exposePinSet({
      type,
      pinId,
      pinSpec,
      fork,
      bubble,
    })
  }

  private _sim_add_exposed_pin_set = (
    type: IO,
    pin_id: string,
    pin_spec: GraphPinSpec,
    position: Dict<{ int?: Position; ext?: Position }> = {}
  ): void => {
    // console.log(
    //   'Graph',
    //   '_sim_add_exposed_pin_set',
    //   type,
    //   pin_id,
    //   pin_spec,
    //   position
    // )

    const { plug } = pin_spec

    this._exposed_pin_set_count++

    for (const sub_pin_id in plug) {
      const p = position[sub_pin_id]

      const sub_pin_spec = plug[sub_pin_id]

      this._sim_add_exposed_pin(type, pin_id, sub_pin_id, sub_pin_spec, p)
    }
  }

  public add_exposed_pin = (
    type: IO,
    pin_id: string,
    pin_spec: GraphPinSpec,
    sub_pin_id: string,
    sub_pin_spec: GraphSubPinSpec,
    position: { int?: Point; ext?: Point }
  ): void => {
    // console.log(
    //   'Graph',
    //   'add_exposed_pin',
    //   type,
    //   pin_id,
    //   pin_spec,
    //   sub_pin_id,
    //   sub_pin_spec
    // )

    this._dispatch_action(
      makeExposePinAction(type, pin_id, sub_pin_id, sub_pin_spec)
    )

    this._add_exposed_pin(type, pin_id, sub_pin_id, sub_pin_spec, position)
  }

  private _add_exposed_pin = (
    type: IO,
    pin_id: string,
    sub_pin_id: string,
    sub_pin_spec: GraphSubPinSpec,
    position: { int?: Point; ext?: Point }
  ): void => {
    this._state_add_exposed_pin(
      type,
      pin_id,
      sub_pin_id,
      sub_pin_spec,
      position
    )
    this._pod_add_exposed_pin(type, pin_id, sub_pin_id, sub_pin_spec)
  }

  private _spec_add_exposed_pin = (
    type: IO,
    pinId: string,
    subPinId: string,
    subPinSpec: GraphSubPinSpec
  ) => {
    // console.log(
    //   'Graph',
    //   '_spec_add_exposed_pin',
    //   type,
    //   pinId,
    //   subPinId,
    //   subPinSpec
    // )

    exposePin(
      {
        pinId,
        type,
        subPinId,
        subPinSpec,
      },
      this._spec
    )
  }

  private _state_add_exposed_pin = (
    type: IO,
    pin_id: string,
    sub_pin_id: string,
    sub_pin_spec: GraphSubPinSpec,
    position: { int?: Point; ext?: Point }
  ): void => {
    this._spec_add_exposed_pin(type, pin_id, sub_pin_id, sub_pin_spec)
    this._sim_add_exposed_pin(type, pin_id, sub_pin_id, sub_pin_spec, position)
  }

  private _sim_setup_core_description = (
    unit_id: string,
    description: Component
  ) => {
    this._unlisten_core_description[unit_id] = description.addEventListeners([
      makePointerDownListener(() => {
        this._name_to_be_focused = true
      }),
      makeFocusListener(() => {
        this._on_core_description_focus(unit_id)
      }),
      makeBlurListener(() => {
        this._on_core_description_blur(unit_id)
      }),
      makeInputListener((value: string) => {
        this._on_core_description_input(unit_id, value)
      }),
      makeKeydownListener((event, _event) => {
        this._on_core_description_keydown(unit_id, event, _event)
      }),
    ])
  }

  private _on_core_description_focus = (unit_id: string) => {
    // console.log('_on_core_description_focus', unit_id)

    const value = this._get_core_description_value(unit_id)

    this.__set_core_selection_to_description(unit_id, value)

    this._on_node_field_focus(unit_id)
  }

  private _get_core_description_value = (unit_id: string) => {
    const description = this._core_description[unit_id]

    const { value } = description.$element

    return value
  }

  private _is_valid_unit_description = (value: string) => {
    return value.length >= 3
  }

  private _on_core_description_blur = (unit_id: string) => {
    this._on_node_field_blur()

    const value = this._get_core_description_value(unit_id)

    if (this._is_valid_unit_description(value)) {
      this._set_unit_description(unit_id, value)
    } else {
      this._set_unit_temp_description(unit_id, '...')
    }

    this._set_node_selection_to_node(unit_id)
  }

  private _set_unit_description = (unit_id: string, description: string) => {
    this._pod_set_unit_description(unit_id, description)
  }

  private _pod_set_unit_description = (
    unitId: string,
    description: string
  ): void => {
    const $unit = this._pod.$refUnit({
      unitId,
      _: UCGEE,
      detached: false,
    }) as $Graph

    const { fork, bubble } = this.$props

    $unit.$setMetadata({
      path: ['description'],
      data: description,
      fork,
      bubble,
    })
  }

  private _on_core_description_input = (unit_id: string, value: string) => {
    this._set_unit_temp_description(unit_id, value)
    this.__set_core_selection_to_description(unit_id, value)
  }

  private _on_core_description_keydown = (
    node_id: string,
    event: IOKeyboardEvent,
    _event: KeyboardEvent
  ) => {
    this._on_node_field_keydown(node_id, event, _event)
  }

  private _on_node_name_keydown = (
    node_id: string,
    event: IOKeyboardEvent,
    _event: KeyboardEvent
  ) => {
    this._on_node_field_keydown(node_id, event, _event)
  }

  private _on_node_field_keydown = (
    node_id: string,
    event: IOKeyboardEvent,
    _event: KeyboardEvent
  ) => {
    if (event.key === 'Enter') {
      _event.preventDefault()

      this.focus()
    } else if (
      event.key === 'q' &&
      this._q_was_pressed_before_name_focus &&
      !this._q_first_repeat_prevented
    ) {
      _event.preventDefault()

      this._q_first_repeat_prevented = true
    }
  }

  private _unlisten_node_name: Dict<Unlisten> = {}
  private _unlisten_core_description: Dict<Unlisten> = {}

  private _sim_setup_node_name = (
    node_id: string,
    name_component: Component
  ) => {
    this._unlisten_node_name[node_id] = name_component.addEventListeners([
      makePointerDownListener(() => {
        this._name_to_be_focused = true
      }),
      makeFocusListener(() => {
        this._on_node_name_focus(node_id)
      }),
      makeBlurListener(() => {
        this._on_node_name_blur(node_id)
      }),
      makeInputListener((value: string) => {
        this._on_node_name_input(node_id, value)
      }),
      makeKeydownListener((event, _event) => {
        this._on_node_name_keydown(node_id, event, _event)
      }),
    ])
  }

  private _on_node_field_focus = (node_id: string) => {
    const selected = this._is_node_selected(node_id)

    this._edit_node_name_id = node_id
    this._edit_node_name_was_selected = selected

    this._q_first_repeat_prevented = false
    this._q_was_pressed_before_name_focus = this._is_key_pressed('q')

    if (!selected) {
      this._select_node(node_id)
    }

    this._disable_crud()
    this._disable_keyboard()
  }

  private _on_node_name_focus = (node_id: string): void => {
    // console.log('Graph', '_on_node_name_focus', node_id)

    this._on_node_field_focus(node_id)

    if (this._is_unit_node_id(node_id)) {
      this._on_core_name_focus(node_id)
    } else if (this._is_ext_node_id(node_id)) {
      this._on_plug_name_focus(node_id)
    } else if (this._is_link_pin_node_id(node_id)) {
      this._on_unit_pin_name_focus(node_id)
    }
  }

  private _on_node_field_blur = () => {
    // console.log('_on_node_field_blur')

    this._enable_crud()
    this._enable_keyboard()

    this._edit_node_name_id = null

    if (this._mode === 'info') {
      if (this._q_was_pressed_before_name_focus && !this._name_to_be_focused) {
        this._q_was_pressed_before_name_focus = false

        this._set_crud_mode('none')
      }
    }
  }

  private _on_node_name_blur = (node_id: string): void => {
    if (this._is_unit_node_id(node_id)) {
      this._on_core_name_blur(node_id)
    } else if (this._is_ext_node_id(node_id)) {
      this._on_plug_name_blur(node_id)
    } else if (this._is_link_pin_node_id(node_id)) {
      this._on_unit_pin_name_blur(node_id)
    }

    this._on_node_field_blur()
  }

  private _on_core_name_blur = (unit_id: string): void => {
    const temp_name = this._node_name[unit_id]

    const valid = this._is_valid_unit_name(temp_name)

    const current_name = this._get_unit_name(unit_id)

    let name: string

    let next_unit_id = unit_id

    if (temp_name === unit_id) {
      //
    } else {
      if (valid) {
        name = temp_name.trim()

        if (name !== current_name) {
          next_unit_id = this._set_unit_name(unit_id, temp_name)
        }
      } else {
        name = this._get_unit_name(unit_id)
      }

      const core_name = this._core_name[next_unit_id]

      this._mem_set_node_temp_name(next_unit_id, name)

      core_name.$element.style.caretColor = 'currentColor'

      core_name.deselect()
      core_name.blur()

      const formatted_name = formatUnitName(name, UNIT_NAME_MAX_CHAR_LINE)

      core_name.setProp('value', formatted_name)

      this._refresh_core_name_size(next_unit_id)
    }

    if (this._edit_node_name_was_selected) {
      this._select_node(next_unit_id)
    }

    this._set_node_selection_to_node(next_unit_id)
  }

  private _on_node_name_input = (node_id: string, value: string): void => {
    // console.log('Graph', '_on_node_name_input', node_id, value)

    this._set_node_temp_name(node_id, value)
  }

  private _set_node_temp_name = (node_id: string, value: string): void => {
    const _value = value

    this._mem_set_node_temp_name(node_id, _value)

    if (this._is_unit_node_id(node_id)) {
      this._set_unit_temp_name(node_id, _value)
    } else if (this._is_link_pin_node_id(node_id)) {
      this._set_unit_pin_temp_name(node_id, _value)
    } else if (this._is_ext_node_id(node_id)) {
      this._set_plug_temp_name(node_id, _value)
    }
  }

  private _is_valid_pin_name_value = (value: string) => {
    if (value.length === 0) {
      return false
    }

    if (value.length > 12) {
      return false
    }

    return true
  }

  private __is_valid_plug_name = (
    type: IO,
    pinId: string,
    subPinId: string,
    value: string
  ) => {
    return this._is_valid_pin_name_value(value)
  }

  private _is_valid_plug_name = (plug_node_id: string, value: string) => {
    const { type, pinId, subPinId } = segmentPlugNodeId(plug_node_id)

    const valid = this.__is_valid_plug_name(type, pinId, subPinId, value)

    return valid
  }

  private _set_plug_name_caret_color = (
    plug_node_id: string,
    caretColor: string
  ): void => {
    this._set_plug_name_style_attr(plug_node_id, 'caretColor', caretColor)
  }

  private _set_plug_temp_name = (ext_node_id: string, value: string): void => {
    // console.log(
    //   'Graph',
    //   '_set_plug_temp_name',
    //   ext_node_id,
    //   JSON.stringify(value)
    // )

    const valid = this._is_valid_plug_name(ext_node_id, value)

    if (valid) {
      this._set_plug_name_caret_color(ext_node_id, 'currentColor')
    } else {
      this._set_plug_name_caret_color(ext_node_id, this._get_err_color())
    }

    this._refresh_plug_name_size(ext_node_id)
  }

  private _sim_add_exposed_pin = (
    type: IO,
    pin_id: string,
    sub_pin_id: string,
    sub_pin_spec: GraphSubPinSpec,
    position: { int?: Position; ext?: Position } = {}
  ): void => {
    // console.log(
    //   'Graph',
    //   '_sim_add_exposed_pin',
    //   type,
    //   pin_id,
    //   sub_pin_id,
    //   sub_pin_spec,
    //   position
    // )

    const { config } = this.$props

    const ext_node_id = getExtNodeId(type, pin_id, sub_pin_id)
    const int_node_id = getIntNodeId(type, pin_id, sub_pin_id)

    const functional = this.__is_exposed_pin_functional(type, pin_id)
    const default_ignored = this._is_pin_default_ignored(type, pin_id)

    const pin_spec = this._get_pin_spec(type, pin_id)

    const { metadata = {} } = pin_spec

    this._exposed_pin_unplugged_count++

    const { unitId, pinId, mergeId, kind = type } = sub_pin_spec

    let fallback_position = randomInRect(
      this._width / 4,
      this._height / 4,
      (3 * this._width) / 4,
      (3 * this._height) / 4
    )

    if (unitId && pinId) {
      const pin_node_id = getPinNodeId(unitId, kind, pinId)

      if (kind === 'output' && pinId === SELF) {
        const unit_node = this.get_node(unitId)

        const u = randomUnitVector()

        if (unit_node.shape === 'rect') {
          fallback_position = pointInRectangle(
            unit_node.x,
            unit_node.y,
            unit_node.width,
            unit_node.height,
            u,
            LINK_DISTANCE
          )
        } else {
          fallback_position = pointInCircle(
            unit_node.x,
            unit_node.y,
            unit_node.r,
            u,
            LINK_DISTANCE
          )
        }
      } else {
        const anchor_node_id = this._get_node_anchor_node_id(pin_node_id)

        fallback_position = this._pin_line_position(
          anchor_node_id,
          LINK_DISTANCE
        )
      }
    } else if (mergeId) {
      const merge_node_id = getMergeNodeId(mergeId)

      const is_merge_ref = this._is_merge_ref(merge_node_id)

      if (is_merge_ref) {
        const ref_merge_unit_id = this._merge_to_ref_unit[merge_node_id]

        if (ref_merge_unit_id) {
          const unit_node = this._node[ref_merge_unit_id]

          const u = { x: 0, y: -1 }

          fallback_position = pointInRectangle(
            unit_node.x,
            unit_node.y,
            unit_node.width,
            unit_node.height,
            u,
            LINK_DISTANCE
          )
        } else {
          fallback_position = this._get_merge_position(merge_node_id)
        }
      } else {
        fallback_position = this._pin_line_position(
          merge_node_id,
          LINK_DISTANCE
        )
      }
    }

    const { x, y } = position.ext || fallback_position

    const r = config?.geometryOverride ? metadata.r ?? PIN_RADIUS : PIN_RADIUS

    const width = 2 * r
    const height = 2 * r

    const input = type === 'input'
    const output = type === 'output'

    const active = false

    const shape = 'circle'

    const color = this._get_exposed_sub_pin_color(type)

    this._sim_add_node(ext_node_id, {
      _x: x,
      _y: y,
      x,
      y,
      fx: undefined,
      fy: undefined,
      shape,
      r,
      width,
      height,
      vx: 0,
      vy: 0,
      ax: 0,
      ay: 0,
      hx: 0,
      hy: 0,
      layer: LAYER_EXPOSED,
    })
    this._node_type[ext_node_id] = 'e'
    this._node_layer[ext_node_id] = LAYER_EXPOSED

    const node = this._node[ext_node_id]

    this._exposed_node[ext_node_id] = node
    this._exposed_ext_node[ext_node_id] = node

    const pin_node = this._node_comp[ext_node_id]
    const pin_node_content = this._node_content[ext_node_id]

    const opacity = default_ignored ? DEFAULT_IGNORED_PIN_SET_OPACITY : 1

    const pin = this._create_pin({
      className: classnames('pin', type),
      r,
      style: {
        borderColor: active ? this._theme.data : color,
        backgroundColor: input ? 'none' : active ? this._theme.data : color,
        opacity: `${opacity}`,
      },
      shape,
    })
    this._pin[ext_node_id] = pin
    pin_node_content.appendChild(pin)

    const icon_width = r
    const icon_height = r

    const icon = metadata.icon || ''

    const pin_icon = new Icon(
      {
        icon,
        style: {
          position: 'absolute',
          width: `${icon_width}px`,
          height: `${icon_height}px`,
          top: '50%',
          left: '50%',
          // display: config?.enable?.plugIcons ? 'block' : 'none',
          fill: 'transparent',
          stroke: input ? this._theme.node : this._theme.background,
          strokeWidth: '2',
          transform: 'translate(-50%, -50%)',
          ...userSelect('none'),
        },
      },
      this.$system
    )
    pin_icon.preventDefault('touchstart')
    pin.appendChild(pin_icon)

    const pin_selection = this._create_selection(ext_node_id, {
      width,
      height,
      shape,
      stroke: COLOR_NONE,
    })
    pin.appendChild(pin_selection)

    const pin_area = this._create_touch_area({
      className: 'pin-area',
      width,
      height,
      style: {
        borderRadius: '50%',
      },
    })
    pin.appendChild(pin_area)

    const pin_name = this._create_pin_name({
      className: 'exposed-pin-name',
      r,
      dx: 0,
      dy: -1,
      style: {
        color,
        ...userSelect('inherit'),
        pointerEvents: 'none',
        opacity: `${opacity}`,
        visibility: config?.plugNames ? 'visible' : 'hidden',
      },
      name: pin_id,
    })

    pin_name.addEventListener(
      makePointerDownListener(() => {
        this._name_to_be_focused = true
      })
    )

    this._sim_setup_node_name(ext_node_id, pin_name)

    this._ext_pin_name[ext_node_id] = pin_name

    this._node_name[ext_node_id] = pin_id

    pin_node_content.appendChild(pin_name)

    this._zoom_comp.appendChild(pin_node)

    let anchor_node_id: string

    let plugged = false

    if (unitId && pinId) {
      plugged = true

      if (pinId === SELF) {
        anchor_node_id = unitId
      } else {
        anchor_node_id = getPinNodeId(unitId, kind, pinId)

        this._pin_to_int[type][anchor_node_id] = int_node_id
        this._pin_to_ext[type][anchor_node_id] = ext_node_id
      }

      this._ext_to_node[ext_node_id] = anchor_node_id
      this._int_to_node[int_node_id] = anchor_node_id

      this._pin_to_int[type][anchor_node_id] = int_node_id
      this._pin_to_ext[type][anchor_node_id] = ext_node_id

      this._node_to_ext[anchor_node_id] =
        this._node_to_ext[anchor_node_id] ?? new Set()
      this._node_to_ext[anchor_node_id].add(ext_node_id)
    } else if (mergeId) {
      const merge_node_id = getMergeNodeId(mergeId)

      plugged = !this._empty_merge_node[merge_node_id]

      anchor_node_id = this._get_merge_anchor_node_id(merge_node_id)

      this._ext_to_node[ext_node_id] = anchor_node_id
      this._int_to_node[int_node_id] = anchor_node_id

      this._node_to_ext[anchor_node_id] =
        this._node_to_ext[anchor_node_id] ?? new Set()
      this._node_to_ext[anchor_node_id].add(ext_node_id)

      this._pin_to_int[type][anchor_node_id] = int_node_id
      this._pin_to_ext[type][anchor_node_id] = ext_node_id

      const merge_pin_count = this._merge_pin_count[mergeId]

      if (merge_pin_count === 0) {
        this._set_node_layer(merge_node_id, LAYER_EXPOSED)
      }
    } else {
      const int_pin_position =
        position.int || randomInRadius(x, y, LINK_DISTANCE)

      this._sim_add_internal_pin(type, pin_id, sub_pin_id, int_pin_position)

      anchor_node_id = int_node_id

      this._exposed_ext_unplugged[ext_node_id] = true
      this._exposed_int_unplugged[int_node_id] = true
    }

    this._node_type[int_node_id] = 'i'

    const link_id_source_id = input ? ext_node_id : int_node_id
    const link_id_target_id = input ? int_node_id : ext_node_id
    const link_id = getLinkId(link_id_source_id, link_id_target_id)

    const source_id = input ? ext_node_id : anchor_node_id
    const target_id = input ? anchor_node_id : ext_node_id

    const anchor_shape = this._get_node_shape(anchor_node_id)
    const anchor_r = this._get_node_r(anchor_node_id)

    const arrow_share = describeArrowShape(anchor_shape, anchor_r)

    let start_marker: SVGPath | null = null
    let end_marker: SVGPath | null = null

    const marker_style = {
      fill: 'none',
      strokeWidth: '1',
      stroke: color,
    }

    if (input) {
      const end_d = `${functional ? ARROW_MEMORY : ''}${arrow_share}`
      end_marker = new SVGPath(
        { d: end_d, style: marker_style, attr: { 'stroke-linecap': 'normal' } },
        this.$system
      )
    } else {
      const start_d = arrow_share
      start_marker = new SVGPath(
        {
          d: start_d,
          style: marker_style,
          attr: { 'stroke-linecap': 'normal' },
        },
        this.$system
      )
    }

    this._exposed_link_start_marker[ext_node_id] = start_marker
    this._exposed_link_end_marker[ext_node_id] = end_marker

    const padding = {
      target: input ? -1.5 : output ? 0 : 0,
      source: input ? 0 : output ? -1.5 : 0,
    }

    const d = plugged
      ? LINK_DISTANCE_EXPOSED / LINK_DISTANCE_EXPOSED_PLUGGED_FACTOR
      : LINK_DISTANCE_EXPOSED
    const s = 2

    const pin_link = this._sim_add_link(
      link_id,
      {
        source_id,
        target_id,
        l: d,
        s,
        padding,
        detail: {
          type: 'e',
          head: 1.5,
        },
      },
      {
        text: '',
        opacity,
        stroke: color,
        strokeWidth: 1,
        strokeDasharray: 0,
        startMarker: start_marker,
        endMarker: end_marker,
      }
    )

    this._exposed_link[link_id] = this._link[link_id]
    this._link_layer[link_id] = LAYER_EXPOSED

    this._zoom_comp.appendChild(pin_link, 'svg')

    this._start_graph_simulation(LAYER_EXPOSED)
  }

  private _sim_add_internal_pin = (
    type: IO,
    pin_id: string,
    sub_pin_id: string,
    { x, y }: Position
  ): void => {
    const int_node_id = getIntNodeId(type, pin_id, sub_pin_id)

    const r = PIN_RADIUS

    const width = 2 * r
    const height = 2 * r

    const shape = 'circle'

    this._sim_add_node(int_node_id, {
      _x: x,
      _y: y,
      x,
      y,
      fx: undefined,
      fy: undefined,
      shape,
      r,
      width,
      height,
      vx: 0,
      vy: 0,
      ax: 0,
      ay: 0,
      hx: 0,
      hy: 0,
      layer: LAYER_EXPOSED,
    })
    this._node_type[int_node_id] = 'i'
    this._node_layer[int_node_id] = LAYER_EXPOSED

    const node = this._node[int_node_id]

    this._exposed_node[int_node_id] = node
    this._exposed_int_node[int_node_id] = node

    const internal_pin_node = this._node_comp[int_node_id]
    const internal_pin_node_content = this._node_content[int_node_id]

    const internal_pin_el = this._create_pin({
      className: classnames('pin', type),
      r,
      style: {},
      shape,
    })
    this._pin[int_node_id] = internal_pin_el
    internal_pin_node_content.appendChild(internal_pin_el)

    const internal_pin_area = this._create_touch_area({
      className: 'pin-area',
      width,
      height,
      style: {
        borderRadius: '50%',
      },
    })
    internal_pin_el.appendChild(internal_pin_area)

    const internal_pin_selection = this._create_selection(int_node_id, {
      width,
      height,
      shape,
      stroke: COLOR_NONE,
    })
    internal_pin_el.appendChild(internal_pin_selection)

    this._zoom_comp.appendChild(internal_pin_node)
  }

  private _pod_add_exposed_pin = (
    type: IO,
    pinId: string,
    subPinId: string,
    subPin: GraphSubPinSpec
  ): void => {
    const { fork, bubble } = this.$props

    this._pod.$exposePin({
      type,
      pinId,
      subPinId,
      subPinSpec: clone(subPin),
      fork,
      bubble,
    })
  }

  private _state_swap_unit = (
    unit_id: string,
    new_unit_id: string,
    new_unit_spec_id: string,
    new_unit_spec: Spec,
    valid_pin_matches: IOOf<{
      ref: [number, number][]
      data: [number, number][]
    }>,
    merged_pin_ids: IOOf<{ data: string[]; ref: string[] }> = {
      input: {
        data: [],
        ref: [],
      },
      output: {
        data: [],
        ref: [],
      },
    },
    merged_pin_index: IOOf<{ data: Dict<number>; ref: Dict<number> }> = {
      input: {
        data: {},
        ref: {},
      },
      output: {
        data: {},
        ref: {},
      },
    },
    exposed_pin_ids: IOOf<{
      data: Dict<[string, string, IO]>
      ref: Dict<[string, string, IO]>
    }>,
    exposed_pin_index: IOOf<{ data: Dict<number>; ref: Dict<number> }> = {
      input: {
        data: {},
        ref: {},
      },
      output: {
        data: {},
        ref: {},
      },
    },
    next_sub_component_index?: number
  ): {
    next_swap_merges: GraphMergesSpec
    next_ref_merge_id: string | null
    next_ref_merge: GraphMergeSpec | null
    next_merged_pin_ids: {
      input: { data: string[]; ref: string[] }
      output: { data: string[]; ref: string[] }
    }
    next_merged_pin_index: IOOf<{ data: Dict<number>; ref: Dict<number> }>
    next_exposed_pin_index: IOOf<{ data: Dict<number>; ref: Dict<number> }>
  } => {
    // console.log('Graph', '_sim_swap_unit', {
    //   merged_pin_ids,
    //   valid_pin_matches,
    //   exposed_pin_ids,
    // })

    const { specs } = this.$props

    const next_merged_pin_ids = {
      input: { data: [], ref: [] },
      output: { data: [], ref: [] },
    }

    const next_merged_pin_index = {
      input: { data: {}, ref: {} },
      output: { data: {}, ref: {} },
    }

    const next_exposed_pin_index = {
      input: { data: {}, ref: {} },
      output: { data: {}, ref: {} },
    }

    const pin_id_merge_swap: {
      input: Dict<string>
      output: Dict<string>
    } = {
      input: {},
      output: {},
    }

    const unit = this._get_unit(unit_id)
    const unit_spec = this._get_unit_spec(unit_id)

    const { inputs: unit_inputs = {}, outputs: unit_outputs = {} } = unit_spec

    const is_component = this._is_unit_component(unit_id)

    let component_index: number

    if (is_component) {
      component_index = this._get_sub_component_index(unit_id)
    }

    const pin_bag = {
      input: clone(unit_inputs),
      output: clone(unit_outputs),
    }

    const exposed_input_ids = exposed_pin_ids['input']
    const exposed_output_ids = exposed_pin_ids['output']

    const exposed_input_data_ids = exposed_input_ids.data
    const exposed_input_ref_ids = exposed_input_ids.ref
    const exposed_output_data_ids = exposed_output_ids.data
    const exposed_output_ref_ids = exposed_output_ids.ref

    const exposed_pin_bag = {
      input: {
        data: exposed_input_data_ids,
        ref: exposed_input_ref_ids,
      },
      output: {
        data: exposed_output_data_ids,
        ref: exposed_output_ref_ids,
      },
    }

    const position = this._get_node_position(unit_id)

    let layout_position = position

    if (this._is_unit_component(unit_id)) {
      layout_position = this._layout_node[unit_id]
    }

    const unit_pin_position = this._get_unit_pin_position(unit_id)

    const { inputs: swap_inputs = {}, outputs: swap_outputs = {} } =
      new_unit_spec

    const filterObjRef = (obj: Dict<{ ref?: boolean }>, _ref: boolean) => {
      return filterObj(obj, ({ ref }) => !!ref === _ref)
    }

    const swap_data_inputs = filterObjRef(clone(swap_inputs), false)
    const swap_ref_inputs = filterObjRef(clone(swap_inputs), true)

    const swap_data_outputs = filterObjRef(clone(swap_outputs), false)
    const swap_ref_outputs = filterObjRef(clone(swap_outputs), true)

    const swap_input_data_ids = keys(swap_data_inputs)
    const swap_input_ref_ids = keys(swap_ref_inputs)

    const swap_output_data_ids = keys(swap_data_outputs)
    const swap_output_ref_ids = keys(swap_ref_outputs)

    const swap_pin_ids = {
      input: {
        data: swap_input_data_ids,
        ref: swap_input_ref_ids,
      },
      output: {
        data: swap_output_data_ids,
        ref: swap_output_ref_ids,
      },
    }

    const swap_pin_bag = {
      input: {
        data: clone(swap_data_inputs),
        ref: clone(swap_ref_inputs),
      },
      output: {
        data: clone(swap_data_outputs),
        ref: clone(swap_ref_outputs),
      },
    }

    const exposed_swap_pin_bag = {
      input: {
        data: clone(swap_data_inputs),
        ref: clone(swap_ref_inputs),
      },
      output: {
        data: clone(swap_data_outputs),
        ref: clone(swap_ref_outputs),
      },
    }

    const new_unit_pin_position: UnitPinPosition = {
      input: {},
      output: {},
    }

    const next_swap_merges: GraphMergesSpec = {}

    const set_merge_swap = (type: IO, ref: boolean): void => {
      const tag = ref ? 'ref' : 'data'

      const valid_type_match = valid_pin_matches[type][tag]

      for (let i = 0; i < valid_type_match.length; i++) {
        const current_valid_type_match = valid_type_match[i]

        const [a, b] = current_valid_type_match

        for (
          let pin_index = 0;
          pin_index < merged_pin_ids[type][tag].length;
          pin_index++
        ) {
          const pin_id = merged_pin_ids[type][tag][pin_index]

          const _pin_index = merged_pin_index[type][tag][pin_id]

          if (_pin_index === a) {
            const swap_pin_id = swap_pin_ids[type][tag][b]

            pin_id_merge_swap[type][pin_id] = swap_pin_id
            new_unit_pin_position[type][swap_pin_id] =
              unit_pin_position[type][pin_id]

            next_merged_pin_ids[type][tag][a] = swap_pin_id
            next_merged_pin_index[type][tag][swap_pin_id] = pin_index

            delete pin_bag[type][pin_id]
            delete swap_pin_bag[type][tag][swap_pin_id]
          }
        }
      }
    }

    set_merge_swap('input', false)
    set_merge_swap('input', true)
    set_merge_swap('output', false)
    set_merge_swap('output', true)

    function set_bag_swap(search_type: IO, swap_type: IO, tag: 'ref' | 'data') {
      for (const pin_id in pin_bag[search_type]) {
        const swap_pin_id = getObjSingleKey(swap_pin_bag[swap_type][tag])

        if (swap_pin_id) {
          new_unit_pin_position[swap_type][swap_pin_id] =
            unit_pin_position[search_type][pin_id]

          delete swap_pin_bag[swap_type][tag][swap_pin_id]
        } else {
          break
        }
      }
    }

    set_bag_swap('input', 'input', 'data')
    set_bag_swap('input', 'input', 'ref')
    set_bag_swap('output', 'output', 'data')
    set_bag_swap('output', 'output', 'ref')
    set_bag_swap('input', 'output', 'data')
    set_bag_swap('input', 'output', 'ref')
    set_bag_swap('output', 'input', 'data')
    set_bag_swap('output', 'input', 'ref')

    const replace_merges = (type: IO): void => {
      for (const pin_id in pin_id_merge_swap[type]) {
        const pin_node_id = getPinNodeId(unit_id, type, pin_id)

        const merge_node_id = this._pin_to_merge[pin_node_id]

        if (merge_node_id) {
          const { mergeId } = segmentMergeNodeId(merge_node_id)

          if (!next_swap_merges[mergeId]) {
            const merge_spec = this._spec_get_merge(mergeId)

            const swap_merge_spec = clone(merge_spec)

            delete swap_merge_spec[unit_id][type][pin_id]
            delete swap_merge_spec[unit_id][type]
            delete swap_merge_spec[unit_id]

            const swap_pin_id = pin_id_merge_swap[type][pin_id]

            deepSet(swap_merge_spec, [new_unit_id, type, swap_pin_id], true)

            next_swap_merges[mergeId] = swap_merge_spec
          }
        }
      }
    }

    replace_merges('input')
    replace_merges('output')

    const merge_position: Dict<Position> = {}

    for (const merge_id in next_swap_merges) {
      const merge_node_id = getMergeNodeId(merge_id)

      merge_position[merge_id] = this._get_merge_position(merge_node_id)
    }

    const ref_merge_node_id = this._ref_unit_to_merge[unit_id]
    let next_ref_merge_id: string | null = null
    let next_ref_merge: GraphMergeSpec | null = null
    if (ref_merge_node_id) {
      next_ref_merge_id = getIdFromMergeNodeId(ref_merge_node_id)
      next_ref_merge = clone(this._spec_get_merge(next_ref_merge_id))
    }

    const is_unit_component = this._is_unit_component(unit_id)

    const unit_parent_id =
      (is_unit_component && this._spec_get_sub_component_parent_id(unit_id)) ||
      null

    const is_swap_unit_component = isComponentSpec(new_unit_spec)

    if (is_unit_component && this._search_unit_id !== unit_id) {
      this._disconnect_sub_component(unit_id)
    }

    const graph_unit_spec: GraphUnitSpec = { id: new_unit_spec_id }

    forIOObjKV(unit, (type, pinId, pinSpec = {}) => {
      const merge_swap_pin_id = pin_id_merge_swap[type][pinId]

      const { ignored, constant } = pinSpec

      if (merge_swap_pin_id) {
        //
      } else {
        if (hasPinId(new_unit_spec, type, pinId)) {
          deepSet(graph_unit_spec, [type, pinId, 'constant'], constant)
          deepSet(graph_unit_spec, [type, pinId, 'ignored'], ignored)
        } else {
          //
        }
      }
    })

    if (is_unit_component && is_swap_unit_component) {
      deepSet(
        graph_unit_spec,
        ['metadata', 'component'],
        deepGetOrDefault(unit, ['metadata', 'component'], undefined)
      )
    }

    let next_sub_component_parent_id =
      (is_swap_unit_component && unit_parent_id) || null

    let next_sub_component_parent_index =
      (is_unit_component &&
        is_swap_unit_component &&
        this._get_sub_component_index(unit_id)) ??
      null

    const bundle = unitBundleSpec(graph_unit_spec, specs)

    const should_unregister =
      unit_id !== this._search_unit_id && unit_spec.id !== bundle.unit.id

    this._state_remove_unit(unit_id, should_unregister)

    this._state_add_unit(
      new_unit_id,
      bundle,
      position,
      {},
      new_unit_pin_position,
      layout_position,
      next_sub_component_parent_id,
      next_sub_component_parent_index,
      should_unregister
    )

    if (
      this._is_unit_component(new_unit_id) &&
      this._search_unit_id !== unit_id
    ) {
      this._sim_add_sub_component(
        new_unit_id,
        {},
        next_sub_component_index,
        true
      )

      this._refresh_layout_node_target_position(unit_parent_id)
    }

    const replace_exposed = (kind: IO, tag: 'ref' | 'data'): void => {
      const exposed_pins = exposed_pin_ids[kind][tag]

      const opposite_tag = tag === 'ref' ? 'data' : 'ref'

      const valid_type_match = valid_pin_matches[kind][tag]

      for (const pin_id in exposed_pins) {
        const exposed_pin = exposed_pins[pin_id]

        const [pinId, subPinId, type] = exposed_pin

        const pin_index = exposed_pin_index[kind][tag][pin_id]

        for (let i = 0; i < valid_type_match.length; i++) {
          const _valid_pin_match = valid_type_match[i]

          const [a, b] = _valid_pin_match

          if (pin_index === a) {
            const swap_pin_id =
              swap_pin_ids[kind][tag][b] ?? swap_pin_ids[kind][opposite_tag][b]

            const sub_pin_spec = {
              unitId: new_unit_id,
              pinId: swap_pin_id,
              kind,
            }

            delete exposed_swap_pin_bag[kind][tag][swap_pin_id]

            next_exposed_pin_index[kind][tag][pin_id] = pin_index

            const swap_pin_node_id = getPinNodeId(
              new_unit_id,
              kind,
              swap_pin_id
            )

            if (
              this.__spec_is_link_pin_ignored(new_unit_id, kind, swap_pin_id)
            ) {
              this._state_set_link_pin_ignored(swap_pin_node_id, false)
            }

            this._state_plug_exposed_pin(type, pinId, subPinId, sub_pin_spec)
          } else {
            //
          }
        }
      }
    }

    replace_exposed('input', 'data')
    replace_exposed('input', 'ref')
    replace_exposed('output', 'data')
    replace_exposed('output', 'ref')

    if (next_ref_merge_id && next_ref_merge) {
      if (new_unit_id !== unit_id) {
        next_ref_merge[new_unit_id] = clone(next_ref_merge[unit_id])

        delete next_ref_merge[unit_id]
      }

      this._state_add_merge(next_ref_merge_id, next_ref_merge, position)
      this._sim_collapse_merge(next_ref_merge_id)
    }

    if (this._is_unit_component(new_unit_id)) {
      if (this._search_unit_component_size) {
        const { width, height } = this._search_unit_component_size

        this.resize_sub_component(new_unit_id, width, height)
      }
    }

    for (const merge_id in next_swap_merges) {
      const merge = next_swap_merges[merge_id]

      const merge_node_id = getMergeNodeId(merge_id)

      const position = merge_position[merge_id]

      // const has_merge = this.__spec_has_merge(merge_id)
      const has_merge = this._has_node(merge_node_id)

      if (!has_merge) {
        forEachPinOnMerge(merge, (unitId, type, pinId) => {
          const pin_node_id = getPinNodeId(unitId, type, pinId)
          const ignored = this.__spec_is_link_pin_ignored(unitId, type, pinId)

          if (ignored) {
            this._state_set_link_pin_ignored(pin_node_id, false)
          }
        })

        this._spec_add_merge(merge_id, merge)
        this._sim_add_merge(merge_id, merge, position)
        this._sim_collapse_merge(merge_id)
      }

      forEachPinOnMerge(merge, (unit_id: string, type, pin_id) => {
        const pin_node_id = getPinNodeId(unit_id, type, pin_id)

        if (
          this._has_node(pin_node_id) &&
          !this._is_link_pin_merged(pin_node_id)
        ) {
          if (this._spec_is_link_pin_ignored(pin_node_id)) {
            this._state_set_link_pin_ignored(pin_node_id, false)
          }

          this._state_add_link_pin_to_merge(merge_id, unit_id, type, pin_id)

          if (unit_id === new_unit_id) {
            this._refresh_pin_color(pin_node_id)
          }
        }
      })
    }

    return {
      next_swap_merges,
      next_ref_merge_id,
      next_ref_merge,
      next_merged_pin_ids,
      next_merged_pin_index,
      next_exposed_pin_index,
    }
  }

  private _merge_pin_line_vector = (merge_node_id: string): Position => {
    const merge_node = this._node[merge_node_id]
    const merge_to_pin = this._merge_to_pin[merge_node_id]

    const { _x: x, _y: y } = merge_node

    let count = 0
    let sx = 0
    let sy = 0

    for (const merge_pin_node_id in merge_to_pin) {
      const { unitId } = segmentLinkPinNodeId(merge_pin_node_id)

      const unit = this._node[unitId]

      const p = unitVector(unit._x, unit._y, x, y)

      sx += p.x
      sy += p.y

      count++
    }

    if (count === 0) {
      return { x: 0, y: -1 }
    }

    const mx = sx / count
    const my = sy / count

    const m = { x: mx, y: my }

    if (mx === 0 && my === 0) {
      return { x: 0, y: -1 }
    }

    const u = normalize(m)

    return u
  }

  private _link_pin_line_vector = (pin_node_id: string): Position => {
    const { unitId } = segmentLinkPinNodeId(pin_node_id)

    const unit_node = this._node[unitId]
    const pin_node = this._node[pin_node_id]

    const u = unitVector(unit_node._x, unit_node._y, pin_node._x, pin_node._y)

    return u
  }

  private _plug_line_vector = (plug_node_id: string): Position => {
    const { type, pinId, subPinId } = segmentPlugNodeId(plug_node_id)

    const int_node_id = getIntNodeId(type, pinId, subPinId)
    const ext_node_id = getExtNodeId(type, pinId, subPinId)

    const int_anchor_node_id = this._get_int_pin_anchor_node_id(int_node_id)

    const int_node = this.get_node(int_anchor_node_id)
    const ext_node = this.get_node(ext_node_id)

    if (!int_node || !ext_node) {
      return randomUnitVector()
    }

    const u = pointUnitVector(int_node, ext_node)

    return u
  }

  private _node_line_vector = (node_id: string): Position => {
    if (this._is_merge_node_id(node_id)) {
      return this._merge_pin_line_vector(node_id)
    } else if (this._is_link_pin_node_id(node_id)) {
      return this._link_pin_line_vector(node_id)
    } else if (this._is_ext_node_id(node_id)) {
      return this._plug_line_vector(node_id)
    } else if (this._is_unit_node_id(node_id)) {
      return this._random_unit_line_vector(node_id)
    } else {
      throw new InvalidStateError()
    }
  }

  private _random_unit_line_vector = (unit_id: string) => {
    const node = this._node[unit_id]

    const u = randomUnitVector()

    return u
  }

  private _pin_line_position = (pin_node_id: string, D: number): Position => {
    const anchor_node_id = this._get_node_anchor_node_id(pin_node_id)
    const u = this._node_line_vector(anchor_node_id)
    const pin = this._node[pin_node_id]
    const x = pin.x + u.x * D
    const y = pin.y + u.y * D
    return { x, y }
  }

  private _err_initial_position = (unit_id: string): Position => {
    const { x, y, height } = this._node[unit_id]
    return { x, y: y - height / 2 - LINK_DISTANCE_ERR }
  }

  private _predict_pin_datum_initial_position = (
    pin_node_id: string
  ): Position => {
    const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)

    return this._pin_line_position(anchor_node_id, LINK_DISTANCE_DATA)
  }

  private _init_random_datum_position = () => {
    return randomInRect(
      this._width / 4,
      this._height / 4,
      (3 * this._width) / 4,
      (3 * this._height) / 4
    )
  }

  private _predict_plug_initial_position = (
    plug_node_id: string
  ): Position | null => {
    const { type, pinId, subPinId } = segmentPlugNodeId(plug_node_id)

    return this.__predict_plug_initial_position(type, pinId, subPinId)
  }

  private __predict_plug_initial_position = (
    type: IO,
    pinId: string,
    subPinId: string
  ): Position | null => {
    const plug_spec = this._get_exposed_sub_pin_spec(type, pinId, subPinId)

    if (plug_spec.unitId && plug_spec.pinId) {
      const pin_node_id = getPinNodeId(plug_spec.unitId, type, plug_spec.pinId)

      return this._get_node_position(pin_node_id)
    } else if (plug_spec.mergeId) {
      const merge_node_id = getMergeNodeId(plug_spec.mergeId)

      return this._get_node_position(merge_node_id)
    } else {
      return null
    }
  }

  private _predict_pin_type_initial_position = (
    pin_node_id: string
  ): Position => {
    const anchor_node_id = this._get_node_anchor_node_id(pin_node_id)
    const u = this._node_line_vector(anchor_node_id)

    const { x, y } = this._node[pin_node_id]

    const type_tree: TreeNode = this._get_pin_type(pin_node_id)

    const { width, height } = this._get_datum_tree_size(type_tree)

    const S = centerToSurfaceDistance(
      {
        width,
        height,
        x,
        y,
        r: width / 2,
        shape: 'rect',
      },
      u
    )

    const R = randomUnitVector()

    const d = LINK_DISTANCE_TYPE + S

    return jigglePoint(
      {
        x: x,
        y: y - d - R.y,
      },
      1
    )
  }

  private _predict_plug_type_initial_position = (
    plug_node_id: string
  ): Position => {
    const u = this._node_line_vector(plug_node_id)
    const { x, y } = this._get_node_position(plug_node_id)
    const type_tree: TreeNode = this._get_plug_type(plug_node_id)
    const { width, height } = this._get_datum_tree_size(type_tree)

    const S = centerToSurfaceDistance(
      {
        width,
        height,
        x,
        y,
        r: width / 2,
        shape: 'rect',
      },
      u
    )

    const d = LINK_DISTANCE_TYPE + S

    const position = addVector({ x, y }, resizeVector(u, d))

    return position
  }

  private _predict_plug_data_initial_position = (
    plug_node_id: string,
    data_tree: TreeNode
  ): Position => {
    const u = this._node_line_vector(plug_node_id)
    const { x, y } = this._get_node_position(plug_node_id)

    const { width, height } = this._get_datum_tree_size(data_tree)

    const S = centerToSurfaceDistance(
      {
        width,
        height,
        x,
        y,
        r: width / 2,
        shape: 'rect',
      },
      u
    )

    const d = LINK_DISTANCE_TYPE + S

    const position = addVector({ x, y }, resizeVector(u, d))

    return position
  }

  private _find_merge_pin = (
    merge_node_id: string,
    predicate: (pin_node_id: string) => boolean = () => true
  ): string | null => {
    const pins = this._merge_to_pin[merge_node_id]
    for (const pin_node_id in pins) {
      if (predicate(pin_node_id)) {
        return pin_node_id
      }
    }
    return null
  }

  private _pin_type_of_kind = (pin_node_id: string, kind: IO): TreeNode => {
    if (
      this._is_merge_node_id(pin_node_id) ||
      this._merge_to_ref_output[pin_node_id]
    ) {
      return this._get_merge_pin_type(pin_node_id, kind)
    } else {
      return this._link_pin_type(pin_node_id)
    }
  }

  private _get_merge_pin_type = (merge_node_id: string, kind: IO): TreeNode => {
    const merge_ref_unit = this._merge_to_ref_unit[merge_node_id]

    const { mergeId } = segmentMergeNodeId(merge_node_id)

    const merge = this._spec_get_merge(mergeId)

    return this._get_merge_spec_type(merge, kind)
  }

  private _get_merges_spec = (): GraphMergesSpec => {
    return this._spec.merges
  }

  private _get_merge_spec_type = (
    merge: GraphMergeSpec,
    kind: IO
  ): TreeNode => {
    let type: TreeNode = ANY_TREE
    forEachPinOnMerge(merge, (unit_id, _kind, pin_id) => {
      if (_kind === kind) {
        const pin_node_id = getPinNodeId(unit_id, kind, pin_id)
        // const pin_type = this.__link_pin_type(unit_id, _kind, pin_id)
        const pin_type = this._runtime_pin_type(pin_node_id, kind)

        type = _mostSpecific(type, pin_type)
      }
    })
    return type
  }

  private _link_pin_type = (pin_node_id: string): TreeNode => {
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    return this.__link_pin_type(unitId, type, pinId)
  }

  private _clear_type_cache_for_spec_id = (spec_id: string) => {
    // console.log('_clear_type_cache_for_spec_id', spec_id)

    const { typeCache } = this.$props

    delete typeCache[spec_id]
  }

  private _refresh_type_cache_for_spec_id = (spec_id: string) => {
    // console.log('_refresh_type_cache_for_spec_id', spec_id)

    this._clear_type_cache_for_spec_id(spec_id)

    this._refresh_type_graph_map()
  }

  private _refresh_type_graph_map = () => {
    this._graph_type_map = this._get_graph_type_map()
  }

  private _get_graph_type_map = () => {
    const { specs, typeCache } = this.$props

    return _getGraphTypeMap(this._spec, specs, typeCache)
  }

  private _ensure_graph_type_map = () => {
    this._graph_type_map = this._graph_type_map ?? this._get_graph_type_map()
  }

  private _graph_type_map: TypeTreeMap

  private __link_pin_type = (
    unit_id: string,
    kind: IO,
    pin_id: string
  ): TreeNode => {
    if (pin_id === SELF) {
      return this._get_unit_type(unit_id)
    }

    this._ensure_graph_type_map()

    let graph_pin_type = deepGetOrDefault(
      this._graph_type_map,
      [unit_id, kind, pin_id],
      undefined
    )

    if (!graph_pin_type) {
      this._refresh_type_graph_map()

      graph_pin_type = deepGet(this._graph_type_map, [unit_id, kind, pin_id])
    }

    return graph_pin_type
  }

  private _get_pin_type = (pin_node_id: string): TreeNode => {
    let type_tree: TreeNode

    if (this._is_link_pin_node_id(pin_node_id)) {
      return this._get_link_pin_type(pin_node_id)
    } else {
      type_tree =
        this._pin_type_of_kind(pin_node_id, 'input') ||
        this._pin_type_of_kind(pin_node_id, 'output')
    }

    return type_tree ?? ANY_TREE
  }

  private _get_plug_type = (
    ext_node_id: string,
    ignoreData: boolean = false
  ): TreeNode => {
    const { type, pinId } = segmentPlugNodeId(ext_node_id)

    let pin_type = this.__get_ext_pin_type(type, pinId, ignoreData)

    return pin_type
  }

  private __get_ext_pin_type = (
    type: IO,
    pinId: string,
    ignoreData: boolean = false
  ): TreeNode => {
    const pin = this._get_pin_spec(type, pinId)

    const { plug = {} } = pin

    let type_tree = getTree('any')

    for (const sub_pin_id in plug) {
      const sub_pin_spec = plug[sub_pin_id]

      const ext_node_id = getExtNodeId(type, pinId, sub_pin_id)

      const { unitId, mergeId, kind = type } = sub_pin_spec

      if (mergeId || (unitId && kind === type)) {
        const pin_spec_anchor_node_id = getSubPinSpecNodeId(type, sub_pin_spec)

        const anchor_node_id = this._get_pin_anchor_node_id(
          pin_spec_anchor_node_id
        )

        let sub_pin_type: TreeNode

        if (isUnitNodeId(anchor_node_id)) {
          sub_pin_type = this._get_unit_type(anchor_node_id)
        } else {
          sub_pin_type = this._get_pin_type(anchor_node_id)
        }

        type_tree = _mostSpecific(type_tree, sub_pin_type)
      }

      if (!ignoreData) {
        const datum_node_id = this._plug_to_datum[ext_node_id]

        if (datum_node_id) {
          const datum_type = this._get_datum_type(datum_node_id)

          type_tree = _mostSpecific(type_tree, datum_type)
        }
      }
    }

    return type_tree ?? ANY_TREE
  }

  private __get_ext_pin_type_value = (type: IO, pinId: string): string => {
    const tree = this.__get_ext_pin_type(type, pinId)

    const { value } = tree

    return value
  }

  private _get_link_pin_type = (pin_node_id: string): TreeNode => {
    const { type, pinId } = segmentLinkPinNodeId(pin_node_id)
    if (isSelfPin(type, pinId)) {
      return ANY_TREE
    }
    const type_tree = this._pin_type_of_kind(pin_node_id, type)
    return type_tree
  }

  private _sim_add_pin_type = (
    pin_node_id: string,
    position: Position
  ): void => {
    const tree: TreeNode = this._get_pin_type(pin_node_id)

    this._sim_add_node_type(pin_node_id, tree, position)
  }

  private _sim_add_node_type = (
    node_id: string,
    tree: TreeNode,
    { x, y }: Position
  ): void => {
    // console.log('Graph', '_sim_add_node_type', node_id, tree)
    const type_node_id = getTypeNodeId(node_id)

    const shape = 'rect'

    const { width, height } = this._get_datum_tree_size(tree)
    const r = width / 2

    const type_node_el = this._sim_add_node(type_node_id, {
      _x: x,
      _y: y,
      x,
      y,
      fx: undefined,
      fy: undefined,
      shape,
      r,
      width,
      height,
      vx: 0,
      vy: 0,
      ax: 0,
      ay: 0,
      hx: 0,
      hy: 0,
      layer: LAYER_TYPE,
    })
    this._node_type[type_node_id] = 't'
    this._node_layer[type_node_id] = LAYER_TYPE

    const node = this._node[type_node_id]
    this._type_node[type_node_id] = node

    const type_datum = new DataTree(
      {
        style: {
          fontSize: `${DATUM_FONT_SIZE}px`,
        },
        data: tree,
        fontSize: DATUM_FONT_SIZE,
      },
      this.$system
    )
    this._type[type_node_id] = type_datum

    const type_container = new Div(
      {
        className: 'graph-type',
        style: {
          width: `${width}px`,
          height: `${height}px`,
          overflow: 'hidden',
          color: this._theme.type,
          pointerEvents: 'none',
        },
      },
      this.$system
    )
    type_container.appendChild(type_datum)
    this._type_container[type_node_id] = type_container

    const node_content = this._node_content[type_node_id]

    const type_selection = this._create_selection(type_node_id, {
      width,
      height,
      shape,
      stroke: COLOR_NONE,
    })

    node_content.appendChild(type_selection)
    node_content.appendChild(type_container)

    this._zoom_comp.appendChild(type_node_el)

    const link_id = getLinkId(type_node_id, node_id)

    const anchor_node_id = this._get_pin_anchor_node_id(node_id)

    const hidden = false

    const d = LINK_DISTANCE_TYPE

    const type_link = this._sim_add_link(
      link_id,
      {
        source_id: type_node_id,
        target_id: anchor_node_id,
        l: d,
        s: 1,
        padding: {
          source: -6,
          target: -6,
        },
        detail: {
          type: 't',
          head: 0,
        },
      },
      {
        stroke: this._theme.sub_text,
        strokeWidth: 1,
        hidden,
        style: {
          pointerEvents: 'none',
        },
      }
    )

    const link_comp = this._link_comp[link_id]
    link_comp.$element.style.pointerEvents = 'none'

    this._type_link[link_id] = this._link[link_id]
    this._link_layer[link_id] = LAYER_TYPE

    this._zoom_comp.appendChild(type_link, 'svg')

    this._start_graph_simulation(LAYER_TYPE)
  }

  private _create_layout_layer = ({
    className,
    style = {},
  }: {
    className: string
    style: Dict<any>
  }): LayoutLayer => {
    const layer = new Div(
      {
        className,
        style: {
          position: 'absolute',
          alignItems: 'center',
          justifyContent: 'center',
          top: '0',
          left: '0',
          flexWrap: 'wrap',
          boxSizing: 'border-box',
          overflowY: 'hidden',
          overflowX: 'hidden',
          pointerEvents: 'none',
          width: '100%',
          height: '100%',
          ...style,
        },
      },
      this.$system
    )

    const content = new Div(
      {
        className: `${className}-content`,
        style: {
          position: 'absolute',
          width: '100%',
          height: '100%',
          overflow: 'auto',
        },
      },
      this.$system
    )
    layer.appendChild(content)

    const foreground = new Div(
      {
        className: `${className}-foreground`,
        style: {
          position: 'absolute',
          top: '0',
          left: '0',
          overflowY: 'hidden',
          overflowX: 'hidden',
          pointerEvents: 'none',
          width: '100%',
          height: '100%',
        },
      },
      this.$system
    )
    layer.appendChild(foreground)

    const child_foreground = new Div(
      {
        className: `${className}-child-foreground`,
        style: {
          position: 'absolute',
          top: '0',
          left: '0',
          overflowY: 'hidden',
          overflowX: 'hidden',
          pointerEvents: 'none',
          width: '100%',
          height: '100%',
        },
      },
      this.$system
    )
    layer.appendChild(child_foreground)

    const height = new Div(
      {
        className: `${className}-height`,
        style: {
          position: 'absolute',
          pointerEvents: 'none',
          width: '100%',
          height: '100%',
        },
      },
      this.$system
    )
    content.appendChild(height)

    const children = new Div(
      {
        className: `${className}-children`,
        style: {
          zIndex: '0',
          opacity: '0',
          position: 'absolute',
          overflowY: 'hidden',
          overflowX: 'hidden',
          transition: `opacity ${ANIMATION_T_S}s linear`,
          pointerEvents: 'none',
          width: '100%',
          height: '100%',
        },
      },
      this.$system
    )
    content.appendChild(children)

    const layers = new Div(
      {
        className: `${className}-layers`,
        style: {
          position: 'absolute',
          pointerEvents: 'none',
          width: '100%',
          height: '100%',
        },
      },
      this.$system
    )
    layer.appendChild(layers)

    return {
      layer,
      content,
      foreground,
      child_foreground,
      height,
      children,
      layers,
    }
  }

  private _create_touch_area = ({
    className,
    width,
    height,
    style,
  }: AreaOpt): Div => {
    const area = new Div(
      {
        className,
        style: {
          width: `${width + NODE_PADDING}px`,
          height: `${height + NODE_PADDING}px`,
          zIndex: '-1',
          backgroundColor: COLOR_NONE,
          // backgroundColor: setAlpha(randomColorString(), 0.5),
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          userSelect: 'none',
          ...style,
        },
      },
      this.$system
    )
    return area
  }

  private _get_pin_node_size = (
    unit_id: string,
    type: IO,
    pin_id: string
  ): Size => {
    const pin_node_id = getPinNodeId(unit_id, type, pin_id)

    const input = type === 'input'
    const output = !input

    const ref = this._is_link_pin_ref(pin_node_id)
    const init = this._is_link_pin_init(pin_node_id)

    let r = PIN_RADIUS

    if (init) {
      r -= 2
    }

    const ref_output = ref && output

    if (ref_output) {
      r = 0.8 * UNIT_MIN_RADIUS
    }

    const width = 2 * r
    const height = 2 * r

    return { width, height }
  }

  private _get_unit_pin_icon_name = (
    unit_id: string,
    type: IO,
    pin_id: string,
    pin_node_id?: string
  ): string => {
    const { specs } = this.$props

    pin_node_id = pin_node_id ?? getPinNodeId(unit_id, type, pin_id)

    const input = type === 'input'
    const output = !input
    const ref = this._is_link_pin_ref(pin_node_id)

    const ref_output = ref && output

    let pin_icon_name: string | null

    if (ref_output) {
      const spec = this._get_unit_spec(unit_id)

      pin_icon_name = getSpecPinIcon(specs, spec, 'output', pin_id)
    }

    return pin_icon_name
  }

  private _should_hide_ignored = (): boolean => {
    return this._mode === 'add' && this._pressed_node_count === 0
  }

  private _sim_add_link_pin_node = (
    unit_id: string,
    type: IO,
    pin_id: string,
    { x, y }: Position
  ): void => {
    // console.log('Graph', '_sim_add_link_pin_node', unit_id, type, pin_id, {
    //   x,
    //   y,
    // })

    const { config } = this.$props

    const pin_node_id = getPinNodeId(unit_id, type, pin_id)

    const input = type === 'input'
    const output = !input
    const ignored = this._spec_is_link_pin_ignored(pin_node_id)
    const ref = this._is_link_pin_ref(pin_node_id)

    const shape: Shape = 'circle'

    const ref_output = ref && output

    const pin_icon_name: string | null = this._get_unit_pin_icon_name(
      unit_id,
      type,
      pin_id
    )

    const { width, height } = this._get_pin_node_size(unit_id, type, pin_id)

    const datum_node_id = this._pin_to_datum[pin_node_id]
    const merge_node_id = this._pin_to_merge[pin_node_id]

    const active = !!datum_node_id || (merge_node_id && ref)

    let layer = ignored ? LAYER_IGNORED : LAYER_NORMAL

    if (ignored) {
      layer = LAYER_IGNORED
    } else {
      if (this._collapse_next_unit_id === unit_id) {
        layer = LAYER_NONE
      }

      if (this._collapse_init_node_id_set.has(unit_id)) {
        layer = LAYER_COLLAPSE
      }
    }

    if (this._is_freeze_mode() && this._pressed_node_id_pointer_id[unit_id]) {
      layer = -layer
    }

    const r = width / 2

    this._sim_add_node(pin_node_id, {
      _x: x,
      _y: y,
      x,
      y,
      fx: undefined,
      fy: undefined,
      shape,
      r,
      width,
      height,
      vx: 0,
      vy: 0,
      ax: 0,
      ay: 0,
      hx: 0,
      hy: 0,
      layer,
    })

    this._add_node_link_heap_node(pin_node_id)

    this._node_layer[pin_node_id] = layer
    this._node_type[pin_node_id] = 'p'

    const node = this._node[pin_node_id]

    this._pin_node[pin_node_id] = node

    if (ref) {
      this._link_pin_ref_set.add(pin_node_id)
    }

    if (ignored) {
      this._ignored_node[pin_node_id] = node
    } else {
      this._normal_node[pin_node_id] = node
    }

    const pin_node = this._node_comp[pin_node_id]
    const pin_node_content = this._node_content[pin_node_id]

    const opacity = ignored ? (this._should_hide_ignored() ? '0.5' : `0`) : `1`

    const pin_border_color =
      ref && input ? COLOR_NONE : active ? this._theme.data : this._theme.node

    const pin_background_color =
      input || ref_output
        ? 'none'
        : active
          ? this._theme.data
          : this._theme.node

    const pin = this._create_pin({
      className: classnames('pin', type),
      r,
      style: {
        borderColor: pin_border_color,
        backgroundColor: pin_background_color,
        opacity,
      },
      shape,
    })
    this._pin[pin_node_id] = pin
    pin_node_content.appendChild(pin)

    pin.preventDefault('mousedown')
    pin.preventDefault('touchdown')

    const pin_name = this._create_pin_name({
      className: 'pin-name',
      r,
      style: {
        color: this._theme.pin_text,
        visibility: config?.pinNames ? 'visible' : 'hidden',
        opacity,
      },
      name: pin_id,
    })
    this._pin_name[pin_node_id] = pin_name
    pin_node_content.appendChild(pin_name)
    pin_name.addEventListener(
      makePointerDownListener(() => {
        this._name_to_be_focused = true
      })
    )

    this._node_name[pin_node_id] = pin_id

    this._sim_setup_node_name(pin_node_id, pin_name)

    if (ref_output) {
      const ref_output_pin_icon = new Icon(
        {
          icon: pin_icon_name,
          className: 'pin-icon',
          style: {
            position: 'absolute',
            width: `${r}px`,
            height: `${r}px`,
            top: '50%',
            left: '50%',
            stroke: 'currentColor',
            color: 'currentColor',
            transform: 'translate(-50%, -50%)',
          },
        },
        this.$system
      )
      this._ref_output_pin_icon[pin_node_id] = ref_output_pin_icon
      pin.appendChild(ref_output_pin_icon)
    }

    const pin_selection = this._create_selection(pin_node_id, {
      width,
      height,
      shape,
      stroke: COLOR_NONE,
      className: 'pin-selection',
    })
    pin.appendChild(pin_selection)

    const pin_area = this._create_touch_area({
      className: 'pin-area',
      width,
      height,
      style: {
        borderRadius: '50%',
      },
    })
    pin.appendChild(pin_area)

    this._zoom_comp.appendChild(pin_node)

    this._start_graph_simulation(LAYER_NONE)
  }

  private _hide_datum = (datum_node_id: string): void => {
    if (this._hidden_data_node[datum_node_id]) {
      return
    }

    // console.log('Graph', '_hide_datum', datum_node_id)

    this._hidden_data_node[datum_node_id] = this._node[datum_node_id]

    delete this._visible_data_node[datum_node_id]

    const datum_node_content = this._node_content[datum_node_id]

    datum_node_content.$element.style.display = 'none'

    const pin_node_id = this._datum_to_pin[datum_node_id]

    if (pin_node_id) {
      const datum_link_id = getLinkId(datum_node_id, pin_node_id)

      delete this._visible_data_link[datum_link_id]
      delete this._visible_linked_data_node[datum_node_id]
      delete this._visible_unlinked_data_node[datum_node_id]

      const datum_link_comp = this._link_comp[datum_link_id]

      datum_link_comp.$element.style.display = 'none'
    }
  }

  private _refresh_pin_datum_visible = (pin_node_id: string): void => {
    // console.log('Graph', '_refresh_pin_datum_visible', pin_node_id)

    const datum_node_id = this._get_pin_datum_node_id(pin_node_id)

    if (datum_node_id) {
      this._refresh_datum_visible(datum_node_id)
    }
  }

  private _refresh_datum_visible = (datum_node_id: string): void => {
    // console.log('Graph', '_refresh_datum_visible', datum_node_id)

    if (this._should_hide_datum(datum_node_id)) {
      this._hide_datum(datum_node_id)
    } else {
      this._show_datum(datum_node_id)
    }
  }

  private _refresh_all_visible_datum = (): void => {
    // console.log('Graph', '_refresh_all_visible_datum')

    for (const datum_node_id in { ...this._visible_data_node }) {
      this._refresh_datum_visible(datum_node_id)
    }
  }

  private _refresh_all_invisible_datum = (): void => {
    // console.log('Graph', '_refresh_all_invisible_datum')

    for (const datum_node_id in { ...this._hidden_data_node }) {
      this._refresh_datum_visible(datum_node_id)
    }
  }

  private _show_datum = (datum_node_id: string): void => {
    if (!this._hidden_data_node[datum_node_id]) {
      return
    }

    // console.log('Graph', '_show_datum', datum_node_id)

    const pin_node_id = this._datum_to_pin[datum_node_id]

    if (this._invalid_datum_node_id[datum_node_id]) {
      const data = this._invalid_datum_data[datum_node_id]

      delete this._invalid_datum_data[datum_node_id]
      delete this._invalid_datum_node_id[datum_node_id]

      if (pin_node_id) {
        this.__graph_debug_set_pin_data(pin_node_id, datum_node_id, data)
      }
    }

    delete this._hidden_data_node[datum_node_id]
    this._visible_data_node[datum_node_id] = this._node[datum_node_id]

    const datum_node_content = this._node_content[datum_node_id]

    datum_node_content.$element.style.display = 'block'

    if (pin_node_id) {
      const datum_link_id = getLinkId(datum_node_id, pin_node_id)

      this._visible_data_link[datum_link_id] = this._link[datum_link_id]
      this._link_layer[datum_link_id] = LAYER_DATA_LINKED

      const datum_node = this._node[datum_node_id]
      if (this._linked_data_node[datum_node_id]) {
        this._visible_linked_data_node[datum_node_id] = datum_node
        this._set_node_layer(datum_node_id, LAYER_DATA_LINKED)
      } else {
        this._visible_unlinked_data_node[datum_node_id] = datum_node
        this._set_node_layer(datum_node_id, LAYER_DATA)
      }

      const datum_link_comp = this._link_comp[datum_link_id]
      datum_link_comp.$element.style.display = 'block'
    }

    this._start_graph_simulation(LAYER_NONE)
  }

  private _get_link_pin_props = (unit_id: string, type: IO, pin_id: string) => {
    const pin_node_id = getPinNodeId(unit_id, type, pin_id)

    const { config } = this.$props

    const ignored = this._spec_is_link_pin_ignored(pin_node_id)
    const ref = this._is_link_pin_ref(pin_node_id)
    const init = this._is_link_pin_init(pin_node_id)

    const unit_pin_spec: GraphUnitPinSpec = this._get_graph_unit_pin_spec(
      unit_id,
      type,
      pin_id
    )
    const { constant, ref: memory } = unit_pin_spec

    if (constant) {
      this._link_pin_constant_count++
    }

    if (memory) {
      this._link_pin_memory_count++
    }

    const pin_spec_name: string = pin_id

    const input = type === 'input'
    const output = !input

    const datum_node_id = this._pin_to_datum[pin_node_id]

    const merge_node_id = this._pin_to_merge[pin_node_id]
    const merge_unit_id =
      merge_node_id && this._merge_to_ref_unit[merge_node_id]

    const active = !!datum_node_id || (merge_unit_id && ref)

    const stroke = active
      ? ref || init
        ? this._theme.data
        : this._theme.data_link
      : ref || init
        ? this._theme.node
        : this._theme.link

    const merged = this._is_link_pin_merged(pin_node_id)

    const pin_link_text = pin_spec_name
    const pin_link_text_hidden = !merged
    const pin_link_stroke_dash_array = constant ? 3 : 0
    const pin_link_stroke = stroke
    const pin_link_text_visibility = config?.pinNames ? 'visible' : 'hidden'
    const pin_link_stroke_width = ref || memory || init ? 1 : 3
    const pin_link_opacity = ignored
      ? this._should_hide_ignored()
        ? 0.5
        : 0
      : 1
    const pin_link_start_marker_d = ref && input ? ARROW_SEMICIRCLE : ''
    const pin_link_start_marker_hidden = ref && input && merge_unit_id
    const pin_link_start_marker = new SVGPath(
      {
        d: pin_link_start_marker_d,
        style: {
          display: pin_link_start_marker_hidden ? 'none' : 'block',
          fill: 'none',
          strokeWidth: '1',
          stroke,
        },
        attr: { 'stroke-linecap': 'normal' },
      },
      this.$system
    )
    this._pin_link_start_marker[pin_node_id] = pin_link_start_marker

    const pin_link_end_marker_d = init
      ? ARROW_NONE
      : ref || memory
        ? ARROW_MEMORY
        : ARROW_NORMAL

    const pin_link_end_marker_fill = ref || memory ? 'none' : pin_link_stroke
    const pin_link_end_marker_stroke = ref || memory ? pin_link_stroke : 'none'
    const pin_link_end_marker_stroke_width = ref || memory ? '1px' : '0'
    const pin_link_end_marker = new SVGPath(
      {
        d: pin_link_end_marker_d,
        style: {
          fill: pin_link_end_marker_fill,
          stroke: pin_link_end_marker_stroke,
          strokeWidth: pin_link_end_marker_stroke_width,
        },
        attr: { 'stroke-linecap': 'normal' },
      },
      this.$system
    )
    this._pin_link_end_marker[pin_node_id] = pin_link_end_marker

    // const d = LINK_DISTANCE
    let d = ignored ? LINK_DISTANCE_IGNORED : LINK_DISTANCE

    if (init) {
      d /= 2
    }

    const padding = {
      source: 0.5,
      target: -5.75,
    }

    // if (ref && input && !merged) {
    if (ref && input) {
      padding.source = -1.5
    }

    if (ref || memory) {
      padding.target = -1
    }

    if (init) {
      padding.target = 0
    }

    if (output && merged) {
      const output_merge = this._is_output_only_merge(merge_node_id)

      if (!output_merge) {
        padding.target = -6
      }
    }

    return {
      pin_link_end_marker_d,
      pin_link_end_marker_fill,
      pin_link_end_marker_stroke,
      pin_link_end_marker_stroke_width,
      pin_link_start_marker_d,
      pin_link_start_marker_hidden,
      stroke,
      pin_link_text,
      pin_link_text_hidden,
      pin_link_text_visibility,
      pin_link_stroke,
      pin_link_stroke_width,
      pin_link_stroke_dash_array,
      pin_link_opacity,
    }
  }

  private _sim_add_link_pin_link = (
    unit_id: string,
    type: IO,
    pin_id: string
  ): void => {
    // console.log('Graph', '_sim_add_link_pin_link', unit_id, type, pin_id)

    const pin_node_id = getPinNodeId(unit_id, type, pin_id)

    const ignored = this._spec_is_link_pin_ignored(pin_node_id)
    const ref = this._is_link_pin_ref(pin_node_id)
    const init = this._is_link_pin_init(pin_node_id)

    const unit_pin_spec: GraphUnitPinSpec = this._get_graph_unit_pin_spec(
      unit_id,
      type,
      pin_id
    )
    const { constant, ref: memory } = unit_pin_spec

    if (constant) {
      this._link_pin_constant_count++
    }

    if (memory) {
      this._link_pin_memory_count++
    }

    if (type === 'input') {
      this._link_pin_input_set.add(pin_node_id)
    } else {
      this._link_pin_output_set.add(pin_node_id)
    }

    const pin_spec_name: string = pin_id

    const input = type === 'input'
    const output = !input

    const merge_node_id = this._pin_to_merge[pin_node_id]

    const anchor_id = this._get_pin_anchor_node_id(pin_node_id)
    const source_id = input ? anchor_id : unit_id
    const target_id = input ? unit_id : anchor_id

    const merged = this._is_link_pin_merged(pin_node_id)

    const {
      stroke,
      pin_link_end_marker_d,
      pin_link_end_marker_fill,
      pin_link_end_marker_stroke,
      pin_link_end_marker_stroke_width,
      pin_link_start_marker_d,
      pin_link_start_marker_hidden,
      pin_link_text,
      pin_link_text_hidden,
      pin_link_text_visibility,
      pin_link_stroke,
      pin_link_stroke_width,
      pin_link_stroke_dash_array,
      pin_link_opacity,
    } = this._get_link_pin_props(unit_id, type, pin_id)

    const pin_link_start_marker = new SVGPath(
      {
        d: pin_link_start_marker_d,
        style: {
          display: pin_link_start_marker_hidden ? 'none' : 'block',
          fill: 'none',
          strokeWidth: '1',
          stroke,
        },
        attr: { 'stroke-linecap': 'normal' },
      },
      this.$system
    )
    this._pin_link_start_marker[pin_node_id] = pin_link_start_marker

    const pin_link_end_marker = new SVGPath(
      {
        d: pin_link_end_marker_d,
        style: {
          fill: pin_link_end_marker_fill,
          stroke: pin_link_end_marker_stroke,
          strokeWidth: pin_link_end_marker_stroke_width,
        },
        attr: { 'stroke-linecap': 'normal' },
      },
      this.$system
    )
    this._pin_link_end_marker[pin_node_id] = pin_link_end_marker

    // const d = LINK_DISTANCE
    let d = ignored ? LINK_DISTANCE_IGNORED : LINK_DISTANCE

    if (init) {
      d /= 2
    }

    const padding = {
      source: 0.5,
      target: -5.75,
    }

    // if (ref && input && !merged) {
    if (ref && input) {
      padding.source = -1.5
    }

    if (ref || memory) {
      padding.target = -1
    }

    if (init) {
      padding.target = 0
    }

    if (output && merged) {
      const output_merge = this._is_output_only_merge(merge_node_id)
      if (!output_merge) {
        padding.target = -6
      }
    }

    const link_id = getLinkId(
      input ? pin_node_id : unit_id,
      input ? unit_id : pin_node_id
    )

    const s = 1

    const pin_link = this._sim_add_link(
      link_id,
      {
        source_id,
        target_id,
        l: d,
        s,
        padding,
        detail: {
          type: 'p',
          head: 5.25,
        },
      },
      {
        text: pin_link_text,
        textHidden: pin_link_text_hidden,
        textVisibility: pin_link_text_visibility,
        stroke: pin_link_stroke,
        strokeWidth: pin_link_stroke_width,
        strokeDasharray: pin_link_stroke_dash_array,
        startMarker: pin_link_start_marker,
        endMarker: pin_link_end_marker,
        opacity: pin_link_opacity,
      }
    )

    this._link_force_count_k[pin_node_id] =
      this._link_force_count_k[pin_node_id] || 0
    this._link_force_count_k[pin_node_id]++

    const link = this._link[link_id]

    if (ignored) {
      this._ignored_link[link_id] = link
      this._link_layer[link_id] = LAYER_IGNORED
    } else {
      this._pin_link[link_id] = link
      this._link_layer[link_id] = LAYER_NORMAL
    }

    this._zoom_comp.appendChild(pin_link, 'svg')

    this._tick_link(link_id)
  }

  private _sim_add_node = (node_id: string, node: GraphSimNode): Div => {
    // console.log('Graph', '_sim_add_node', node_id, node)

    this._node_count++

    const { x, y, width, height } = node

    const node_comp = new Div(
      {
        className: 'node',
        style: {
          position: 'absolute',
          transform: `translate(${x}px, ${y}px)`,
          width: '0',
          height: '0',
        },
      },
      this.$system
    )

    this._node_unlisten[node_id] = this._listen_node(node_id, node_comp)

    this._node_comp[node_id] = node_comp

    const node_content = new Div(
      {
        className: 'node-content',
        style: {
          position: 'absolute',
          width: 'fit-content',
          height: 'fit-content',
          transform: `translate(-${width / 2}px, -${height / 2}px)`,
        },
      },
      this.$system
    )
    this._node_content[node_id] = node_content

    node_comp.appendChild(node_content)

    this._node[node_id] = node

    this._node_link_count[node_id] = 0

    add_node_to_graph(this._node_graph, node_id)

    this._rebuild_subgraph()

    return node_comp
  }

  private _node_link_heap_predicative = (
    a: { count: number; id: string },
    b: { count: number; id: string }
  ): boolean => {
    return a.count > b.count
  }

  private _add_node_link_heap_node = (node_id: string): void => {
    // console.log('Graph', '_add_node_link_heap_node', node_id)

    const heap_node: Heap<{ count: number; id: string }> = {
      value: { count: 0, id: node_id },
      parent: null,
      left: null,
      right: null,
    }

    this._node_link_heap[node_id] = heap_node
    this._node_link_heap_root = addHeapNode(
      this._node_link_heap_root,
      heap_node,
      this._node_link_heap_predicative
    )
  }

  private _remove_node_link_heap = (node_id: string) => {
    // console.log('Graph', '_remove_node_link_heap', node_id)

    const heap_node = this._node_link_heap[node_id]

    this._node_link_heap_root = removeHeapNode(
      heap_node,
      this._node_link_heap_predicative
    )

    delete this._node_link_heap[node_id]
  }

  private _set_node_link_heap_count = (
    node_id: string,
    count: number
  ): void => {
    // console.log('Graph', '_set_node_link_heap_count', node_id, count)
    const heap_node = this._node_link_heap[node_id]
    this._node_link_heap_root = setHeapNode(
      heap_node,
      { count, id: node_id },
      this._node_link_heap_predicative
    )
  }

  public add_merge = (
    merge_id: string,
    merge: GraphMergeSpec,
    position: Position
  ): void => {
    this._dispatch_action(makeAddMergeAction(merge_id, clone(merge), position))

    this._add_merge(merge_id, merge, position, true)
  }

  private _add_merge = (
    merge_id: string,
    merge: GraphMergeSpec,
    position?: Position,
    emit: boolean = true
  ): void => {
    // console.log('Graph', '_add_merge', merge_id, merge, position, emit)

    position = position || this._init_merge_spec_position(merge)

    const merge_node_id = getMergeNodeId(merge_id)

    this._state_add_merge(merge_id, merge, position)
    emit && this._pod_add_merge(merge_id, merge)

    this._refresh_ref_merge_active(merge_node_id)
  }

  private _refresh_ref_merge_active = (merge_node_id: string): void => {
    const merge_unit_id = this._merge_to_ref_unit[merge_node_id]

    if (merge_unit_id) {
      this._refresh_core_border_color(merge_unit_id)
    }

    const merge_pin_node_id = this._merge_to_pin[merge_node_id]

    for (const pin_node_id in merge_pin_node_id) {
      const { unitId, type } = segmentLinkPinNodeId(pin_node_id)

      if (type === 'input') {
        this._refresh_link_pin_link_color(pin_node_id)
      }
      this._refresh_core_border_color(unitId)
    }
  }

  private _spec_add_merge = (mergeId: string, merge: GraphMergeSpec): void => {
    // console.log('Graph', '_spec_add_merge', mergeId, merge)

    addMerge({ mergeId, mergeSpec: merge }, this._spec)

    forEachPinOnMerge(merge, (unitId, type, pinId) => {
      this._spec_add_link_pin_to_merge(mergeId, unitId, type, pinId)
    })
  }

  private _state_add_merge = (
    merge_id: string,
    merge: GraphMergeSpec,
    position: Position
  ): void => {
    // console.log('Graph', '_state_add_merge', merge_id, merge)

    this._spec_add_merge(merge_id, merge)
    this._sim_add_merge(merge_id, merge, position)
  }

  private _sim_add_merge = (
    merge_id: string,
    merge: GraphMergeSpec,
    position: Position
  ): void => {
    // console.log('Graph', '_sim_add_merge', merge_id, merge)

    const merge_node_id = getMergeNodeId(merge_id)

    let merge_ref = false
    let merge_unit_id: string | undefined

    this._merge_to_pin[merge_node_id] = {}
    this._merge_to_input[merge_node_id] = {}
    this._merge_to_output[merge_node_id] = {}

    this._merge_pin_count[merge_id] = 0
    this._merge_input_count[merge_id] = 0
    this._merge_output_count[merge_id] = 0

    const merge_input_unit: Dict<boolean> = {}
    const merge_output_unit: Dict<boolean> = {}

    let merge_ref_output_id: string | null = null

    for (const unit_id in merge) {
      const unit = merge[unit_id]
      const { input = {}, output = {} } = unit

      if (keys(input).length > 0) {
        merge_input_unit[unit_id] = true
      }
      if (keys(output).length > 0) {
        merge_output_unit[unit_id] = true
      }

      for (const input_id in input) {
        const input_node_id = getPinNodeId(unit_id, 'input', input_id)

        if (!merge_ref) {
          const input_ref = this._is_link_pin_ref(input_node_id)

          merge_ref = merge_ref || input_ref
        }
      }

      for (const output_id in output) {
        const output_node_id = getPinNodeId(unit_id, 'output', output_id)

        if (output_id === SELF) {
          merge_unit_id = unit_id

          merge_ref = true

          this._merge_to_ref_unit[merge_node_id] = merge_unit_id
          this._ref_unit_to_merge[merge_unit_id] = merge_node_id
        } else {
          if (!merge_ref_output_id) {
            const output_ref = this._is_link_pin_ref(output_node_id)
            if (output_ref) {
              merge_ref_output_id = output_node_id
              merge_ref = true

              this._ref_output_to_merge[merge_ref_output_id] = merge_node_id
              this._merge_to_ref_output[merge_node_id] = merge_ref_output_id
            }
          }
        }
      }
    }

    this._merge_ref[merge_node_id] = merge_ref
    this._node_type[merge_node_id] = 'm'

    if (!merge_unit_id && !merge_ref_output_id) {
      this._sim_add_merge_pin_node(merge_id, position)
    }

    this._start_graph_simulation(LAYER_NONE)
  }

  private __spec_is_empty_merge = (merge_id: string) => {
    const merge = this._spec_get_merge(merge_id)

    const merge_pin_count = getMergePinCount(merge)

    return merge_pin_count === 0
  }

  private _spec_is_empty_merge = (merge_node_id: string) => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    return this.__spec_is_empty_merge(mergeId)
  }

  private _sim_add_merge_pin_node = (merge_id: string, { x, y }: Position) => {
    // console.log('Graph', '_sim_add_merge_pin_node', merge_id, { x, y })

    const merge_node_id = getMergeNodeId(merge_id)

    const r = PIN_RADIUS
    const width = 2 * r
    const height = 2 * r

    const input_count = this._merge_input_count[merge_id]
    const output_count = this._merge_output_count[merge_id]

    const input_merge = output_count === 0
    const output_merge = input_count === 0

    const spot_output = false
    const spot_input = false

    const shape = 'circle'
    // const shape = "rect"

    const layer = LAYER_NORMAL

    this._sim_add_node(merge_node_id, {
      _x: x,
      _y: y,
      x,
      y,
      fx: undefined,
      fy: undefined,
      shape,
      r,
      width,
      height,
      vx: 0,
      vy: 0,
      ax: 0,
      ay: 0,
      hx: 0,
      hy: 0,
      layer,
    })

    this._add_node_link_heap_node(merge_node_id)

    this._node_layer[merge_node_id] = LAYER_NORMAL

    const node = this._node[merge_node_id]

    this._node_type[merge_node_id] = 'm'
    this._pin_node[merge_node_id] = node
    this._normal_node[merge_node_id] = node

    const is_empty_merge = this.__spec_is_empty_merge(merge_id)

    if (is_empty_merge) {
      this._set_merge_empty(merge_node_id)
    }

    const merge_node = this._node_comp[merge_node_id]
    const merge_node_content = this._node_content[merge_node_id]

    const merge_ref = this._merge_ref[merge_node_id]

    const merge = new Div(
      {
        className: 'pin',
        style: {
          position: 'relative',
          width: `${width}px`,
          height: `${height}px`,
          borderRadius: shape === 'circle' ? '50%' : '0',
          boxSizing: 'border-box',
        },
      },
      this.$system
    )
    this._merge[merge_node_id] = merge
    merge_node_content.appendChild(merge)

    const pin_name = this._create_pin_name({
      className: 'merge-pin-name',
      r,
      style: {
        color: this._theme.pin_text,
        ...userSelect('inherit'),
        pointerEvents: 'none',
        opacity: `1`,
        visibility: 'visible',
      },
      name: '',
    })
    merge_node_content.appendChild(pin_name)

    this._merge_name[merge_node_id] = pin_name
    this._node_name[merge_node_id] = 'merge'

    const merge_selection = this._create_selection(merge_node_id, {
      width,
      height,
      shape,
      stroke: COLOR_NONE,
    })
    merge.appendChild(merge_selection)

    const merge_input_visibility = output_merge ? 'hidden' : 'visible'
    const merge_input_color = merge_ref ? COLOR_NONE : this._theme.node
    const merge_input = this._create_pin({
      className: 'merge-input',
      style: {
        visibility: merge_input_visibility,
        borderColor: merge_input_color,
      },
      r,
      shape,
    })
    this._merge_input[merge_node_id] = merge_input
    merge.appendChild(merge_input)

    const merge_output_reduced = !spot_output && !output_merge && !merge_ref
    const merge_output_visibility = input_merge ? 'hidden' : 'visible'
    const merge_output_r = merge_output_reduced ? r - 2 : r
    const merge_output_color = this._theme.node
    const merge_output = this._create_pin({
      className: 'merge-output',
      style: {
        // position: 'absolute',
        visibility: merge_output_visibility,
        backgroundColor: merge_output_color,
        color: merge_output_color,
        borderColor: merge_output_color,
        transform: merge_output_reduced ? `translate(${2}px, ${2}px)` : '',
      },
      r: merge_output_r,
      shape,
    })
    this._merge_output[merge_node_id] = merge_output
    merge.appendChild(merge_output)

    const merge_area = this._create_touch_area({
      className: 'merge-area',
      width,
      height,
      style: {
        borderRadius: '50%',
      },
    })
    merge.appendChild(merge_area)

    merge_area.preventDefault('mousedown')
    merge_area.preventDefault('touchdown')

    this._zoom_comp.appendChild(merge_node)
  }

  private _pod_add_merge = (merge_id: string, merge: GraphMergeSpec): void => {
    // console.log('Graph', '_pod_add_merge', merge_id)

    const { fork, bubble } = this.$props

    this._pod.$addMerge({
      mergeId: merge_id,
      mergeSpec: clone(merge),
      fork,
      bubble,
    })
  }

  private _has_datum = (datum_id: string): boolean => {
    return !!this._datum_tree[datum_id]
  }

  public add_datum = (
    datum_id: string,
    value: string,
    position: Position,
    emit: boolean
  ) => {
    this._dispatch_action(makeAddDatumAction(datum_id, value))

    this._add_datum(datum_id, value, position, undefined, emit)
  }

  public add_new_datum = (
    value: string,
    position: Position,
    emit: boolean
  ): string => {
    const datum_id = this._new_datum_id()

    this.add_datum(datum_id, value, position, emit)

    return datum_id
  }

  public add_new_datum_tree = (
    value: string,
    position: Position,
    emit: boolean
  ) => {
    const datum_id = this._new_datum_id()

    this.add_datum(datum_id, value, position, emit)
  }

  private _add_datum = (
    datum_id: string,
    value: string,
    position: Position,
    tree?: TreeNode,
    emit?: boolean
  ) => {
    this._sim_add_datum_node(datum_id, value, position, tree, emit)
  }

  private _sim_add_datum_node = (
    datum_id: string,
    value: string,
    position: Position,
    tree?: TreeNode,
    emit?: boolean
  ): void => {
    // console.log('Graph', '_sim_add_datum_node', datum_id, value, position)

    tree = tree ?? getTree__cached(value)

    return this.__sim_add_datum_node(datum_id, tree, position, emit)
  }

  private __sim_add_datum_node = (
    datum_id: string,
    tree: TreeNode,
    { x, y }: Position,
    emit: boolean
  ): void => {
    // console.log('Graph', '__sim_add_datum_node', datum_id, tree.value)

    const { specs } = this.$props

    this._datum_tree[datum_id] = tree

    const datum_node_id = getDatumNodeId(datum_id)

    const shape = this._get_datum_tree_shape(tree)

    const { width, height } = this._get_datum_tree_size(tree)

    const r = width / 2

    const datum_node = this._sim_add_node(datum_node_id, {
      _x: x,
      _y: y,
      x,
      y,
      fx: undefined,
      fy: undefined,
      shape,
      r,
      width,
      height,
      vx: 0,
      vy: 0,
      ax: 0,
      ay: 0,
      hx: 0,
      hy: 0,
      layer: LAYER_DATA,
    })
    const node = this._node[datum_node_id]

    this._node_type[datum_node_id] = 'd'
    this._node_layer[datum_node_id] = LAYER_DATA
    this._data_node[datum_node_id] = node

    this._visible_data_node[datum_node_id] = node

    this._unlinked_data_node[datum_node_id] = node
    this._visible_unlinked_data_node[datum_node_id] = node

    const valid = _isValidValue(tree)

    const color = valid ? this._theme.data : this._theme.type

    const datum_class_literal: boolean = tree.type === TreeNodeType.Unit

    const datum_container = new Div(
      {
        className: classnames('graph-datum', {
          valid,
        }),
        style: {
          display: 'flex',
          width: `${width}px`,
          height: `${height}px`,
          overflow: 'hidden',
          // scrollbarColor: color,
          color,
          touchAction: 'none',
          overscrollBehavior: 'none',
        },
      },
      this.$system
    )
    // datum_container.addEventListener(makeFocusInListener(() => {
    //   console.log('focusin')
    // }))
    // datum_container.addEventListener(makeFocusOutListener(() => {
    //   console.log('focusout')
    // }))
    this._datum_container[datum_node_id] = datum_container

    const node_content = this._node_content[datum_node_id]

    const datum_selection = this._create_selection(datum_node_id, {
      width,
      height,
      shape,
      stroke: COLOR_NONE,
    })

    const datum_area = this._create_touch_area({
      className: 'datum-area',
      width,
      height,
    })
    this._datum_area[datum_node_id] = datum_area

    datum_area.preventDefault('mousedown')
    datum_area.preventDefault('touchdown')

    let datum: Datum | any

    if (datum_class_literal) {
      const bundle = evaluateBundleStr(tree.value, specs, this.$system.classes)

      const {
        unit: { id },
      } = bundle

      datum = new ClassDatum(
        {
          id,
          style: {
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
          },
          specs: weakMerge(specs, bundle.specs ?? {}),
        },
        this.$system
      )

      const unlisten = NOOP

      this._datum_unlisten[datum_id] = unlisten
    } else {
      datum = new Datum(
        {
          style: {
            fontSize: `${DATUM_FONT_SIZE}px`,
            ...userSelect('none'),
          },
          fontSize: DATUM_FONT_SIZE,
          data: tree,
        },
        this.$system
      )
      const unlisten = datum.addEventListeners([
        makeKeydownListener((event) => {
          const { key } = event

          if (key === 'Enter') {
            this._edit_datum_last_manually_committed = true

            this._commit_data_value(
              datum_id,
              this.__get_datum_tree(datum_id),
              false
            )
          }
        }),
        makeCustomListener('datumchange', (event) => {
          this._edit_datum_committed = false
          this._edit_datum_last_manually_committed = false

          this._on_datum_change(datum_id, event)
        }),
        makeCustomListener('datumblur', (event) => {
          this._on_datum_blur(datum_id, event)
        }),
        makeCustomListener('datumfocus', (event) => {
          this._on_datum_focus(datum_id, event)
        }),
        makeCustomListener('leafpointerdown', () => {
          this._datum_to_be_focused_by_click = true
        }),
      ])
      this._datum_unlisten[datum_id] = unlisten
    }
    datum.stopPropagation('wheel')
    datum.stopPropagation('focus')

    this._datum[datum_node_id] = datum

    const datum_overlay = this._create_overlay({
      className: 'datum-overlay',
    })
    this._datum_overlay[datum_node_id] = datum_overlay
    datum_overlay.preventDefault('pointerdown')

    datum_container.setChildren([datum_area, datum, datum_overlay])

    node_content.appendChild(datum_selection)
    node_content.appendChild(datum_container)

    this._zoom_comp.appendChild(datum_node)

    this._refresh_datum_color(datum_node_id)

    if (this._mode === 'none') {
      //
    } else {
      this._enable_datum_overlay(datum_node_id)
    }

    if (emit) {
      this._dispatch_data_added(datum_id, tree.value)
    }

    this._start_graph_simulation(LAYER_DATA_LINKED)
  }

  private _inc_merge_input_active = (merge_node_id: string): void => {
    this._merge_active_input_count[merge_node_id] =
      this._merge_active_input_count[merge_node_id] || 0
    this._merge_active_input_count[merge_node_id]++

    // console.log(
    //   'Graph',
    //   '_inc_merge_input_active',
    //   merge_node_id,
    //   this._merge_active_input_count[merge_node_id]
    // )

    if (!this._is_merge_ref(merge_node_id)) {
      this._refresh_merge_pin_pin_color(merge_node_id, 'input')
    }
  }

  private _dec_merge_input_active = (merge_node_id: string): void => {
    this._merge_active_input_count[merge_node_id]--

    // console.log(
    //   'Graph',
    //   '_dec_merge_input_active',
    //   merge_node_id,
    //   this._merge_active_input_count[merge_node_id]
    // )

    if (!this._is_merge_ref(merge_node_id)) {
      this._refresh_merge_pin_pin_color(merge_node_id, 'input')
    }

    if (this._merge_active_input_count[merge_node_id] === 0) {
      const datum_node_id = this._pin_to_datum[merge_node_id]

      if (datum_node_id) {
        this._sim_remove_datum(datum_node_id)
      }
    }
  }

  private _inc_merge_output_active = (merge_node_id: string): void => {
    this._merge_active_output_count[merge_node_id] =
      this._merge_active_output_count[merge_node_id] || 0
    this._merge_active_output_count[merge_node_id]++

    // console.log(
    //   'Graph',
    //   '_inc_merge_output_active',
    //   merge_node_id,
    //   this._merge_active_output_count[merge_node_id]
    // )

    if (!this._is_merge_ref(merge_node_id)) {
      this._refresh_merge_pin_pin_color(merge_node_id, 'output')
    }
  }

  private _dec_merge_output_active = (merge_node_id: string): void => {
    this._merge_active_output_count[merge_node_id]--

    // console.log(
    //   'Graph',
    //   '_dec_merge_output_active',
    //   merge_node_id,
    //   this._merge_active_output_count[merge_node_id]
    // )

    if (!this._is_merge_ref(merge_node_id)) {
      this._refresh_merge_pin_pin_color(merge_node_id, 'output')
    }
  }

  private _inc_unit_pin_active = (unit_id: string): void => {
    // console.log('Graph', '_inc_unit_pin_active', unit_id)
    this._unit_active_pin_count[unit_id] =
      this._unit_active_pin_count[unit_id] || 0
    this._unit_active_pin_count[unit_id]++
    this._refresh_core_border_color(unit_id)
  }

  private _dec_unit_pin_active = (unit_id: string): void => {
    // console.log('Graph', '_dec_unit_pin_active', unit_id)
    this._unit_active_pin_count[unit_id]--
    if (this._unit_active_pin_count[unit_id] === 0) {
      delete this._unit_active_pin_count[unit_id]
      this._refresh_core_border_color(unit_id)
    }
  }

  private _inc_merge_input_count = (merge_id: string): void => {
    this._merge_input_count[merge_id] = this._merge_input_count[merge_id] || 0
    this._merge_input_count[merge_id]++
  }

  private _dec_merge_input_count = (merge_id: string): void => {
    this._merge_input_count[merge_id] = this._merge_input_count[merge_id] || 0
    this._merge_input_count[merge_id]--
  }

  private _inc_merge_output_count = (merge_id: string): void => {
    this._merge_output_count[merge_id]++
  }

  private _dec_merge_output_count = (merge_id: string): void => {
    this._merge_output_count[merge_id]--
  }

  private _inc_merge_pin_count = (merge_id: string): void => {
    // console.log(
    //   'Graph',
    //   '_inc_merge_pin_count',
    //   merge_id,
    //   this._merge_pin_count[merge_id] + 1
    // )

    this._merge_pin_count[merge_id] = this._merge_pin_count[merge_id] || 0
    this._merge_pin_count[merge_id]++
  }

  private _dec_merge_pin_count = (merge_id: string): void => {
    // console.log('Graph', '_dec_merge_pin_count', merge_id, this._merge_pin_count[merge_id])

    this._merge_pin_count[merge_id]--
  }

  private _refresh_core_border_color = (unit_id: string): void => {
    if (
      this._is_node_hovered(unit_id) ||
      this._is_node_dragged(unit_id) ||
      this._is_node_selected(unit_id)
    ) {
      this._set_core_mode_color(unit_id)
    } else {
      this._reset_core_border_color(unit_id)
    }
  }

  private _set_merge_pin_color = (
    merge_node_id: string,
    type: IO,
    color: string
  ): void => {
    // console.log('Graph', '_set_merge_pin_color', merge_node_id, type, color)
    if (type === 'input') {
      this._set_merge_input_color(merge_node_id, color)
    } else {
      this._set_merge_output_color(merge_node_id, color)
    }

    this._set_merge_name_color(merge_node_id, color)
  }

  private _set_merge_name_color = (
    merge_node_id: string,
    color: string
  ): void => {
    const merge_name = this._merge_name[merge_node_id]

    if (!merge_name) {
      return
    }

    merge_name.$element.style.color = color
  }

  private _set_merge_name = (merge_node_id: string, name: string): void => {
    // console.log('Graph', '_set_merge_name', merge_node_id, name)

    const merge_name = this._merge_name[merge_node_id]

    if (!merge_name) {
      return
    }

    merge_name.setProp('value', name)
    merge_name.$element.style.width = `${name.length * 6}px`
  }

  private _reset_merge_name_color = (merge_node_id: string): void => {
    const merge_name = this._merge_name[merge_node_id]

    if (!merge_name) {
      return
    }

    merge_name.$element.style.color = this._theme.pin_text
  }

  private _set_output_r = (pin_node_id: string, r: number): void => {
    if (this._is_merge_node_id(pin_node_id)) {
      this._set_merge_output_r(pin_node_id, r)
    } else {
      this._set_link_output_r(pin_node_id, r)
    }
  }

  private _set_output_reduced = (
    pin_node_id: string,
    reduced: boolean
  ): void => {
    if (reduced) {
      this._set_output_r(pin_node_id, PIN_RADIUS - 2)
    } else {
      this._set_output_r(pin_node_id, PIN_RADIUS)
    }
  }

  private _set_link_output_r = (link_pin_node_id: string, r: number): void => {
    // console.log('Graph', '_set_link_output_r', link_pin_node_id, r)
    const pin = this._pin[link_pin_node_id]
    const d = 2 * r
    const t = PIN_RADIUS - r

    pin.$element.style.width = `${d}px`
    pin.$element.style.height = `${d}px`
    pin.$element.style.transform = `translate(${t}px, ${t}px)`
  }

  private _set_merge_output_r = (merge_node_id: string, r: number): void => {
    // console.log('Graph', '_set_merge_output_r', merge_node_id, r)
    const d = 2 * r
    const t = PIN_RADIUS - r
    const merge_output = this._merge_output[merge_node_id]

    merge_output.$element.style.width = `${d}px`
    merge_output.$element.style.height = `${d}px`
    merge_output.$element.style.transform = `translate(${t}px, ${t}px)`
  }

  private _set_merge_input_active = (merge_node_id: string): void => {
    if (this._is_merge_ref(merge_node_id)) {
      const merge_unit_id = this._merge_to_ref_unit[merge_node_id]
      if (merge_unit_id) {
        this._set_core_border_color(merge_unit_id, this._theme.data)
      }
    } else {
      this._set_merge_input_color(merge_node_id, this._theme.data)
    }
  }

  private _set_merge_input_color = (
    merge_node_id: string,
    borderColor: string
  ): void => {
    // console.log('Graph', '_set_merge_input_color', merge_node_id, borderColor)

    const merge_input = this._merge_input[merge_node_id]

    merge_input.$element.style.borderColor = borderColor
  }

  private _set_merge_input_visibility = (
    merge_node_id: string,
    visibility: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_set_merge_input_visibility',
    //   merge_node_id,
    //   visibility
    // )

    const merge_input = this._merge_input[merge_node_id]

    merge_input.$element.style.visibility = visibility
  }

  private _set_merge_input_inactive = (merge_node_id: string): void => {
    // console.log('Graph', '_set_merge_input_inactive')
    if (this._is_merge_ref(merge_node_id)) {
      const merge_unit_id = this._merge_to_ref_unit[merge_node_id]
      const { mergeId } = segmentMergeNodeId(merge_node_id)
      if (merge_unit_id && this._merge_input_count[mergeId] === 0) {
        this._set_core_border_color(merge_unit_id, this._theme.node)
      }
    } else {
      this._set_merge_input_color(merge_node_id, this._theme.node)
    }
  }

  private _set_merge_output_active = (merge_node_id: string): void => {
    this._set_merge_output_color(merge_node_id, this._theme.data)
  }

  private _set_merge_output_visibility = (
    merge_node_id: string,
    visibility: string
  ): void => {
    const merge_output = this._merge_output[merge_node_id]

    merge_output.$element.style.visibility = visibility
  }

  private _set_merge_output_color = (
    merge_node_id: string,
    color: string
  ): void => {
    // console.log('Graph', '_set_merge_output_color', merge_node_id, color)
    const merge_output = this._merge_output[merge_node_id]

    merge_output.$element.style.borderColor = color
    merge_output.$element.style.backgroundColor = color
  }

  private _set_merge_output_inactive = (merge_node_id: string): void => {
    this._set_merge_output_color(merge_node_id, this._theme.node)
  }

  private _sim_add_pin_datum_link = (
    datum_node_id: string,
    pin_node_id: string,
    emit: boolean
  ): void => {
    // console.log('Graph', '_sim_add_pin_datum_link', datum_node_id, pin_node_id)

    this._sim_add_datum_node_link(datum_node_id, pin_node_id, emit)
  }

  private _sim_add_datum_node_link = (
    datum_node_id: string,
    node_id: string,
    emit: boolean
  ): void => {
    // console.log('Graph', '_sim_add_datum_link', datum_node_id, node_id)

    const { datumId } = segmentDatumNodeId(datum_node_id)

    const datum_node = this._data_node[datum_node_id]

    this._linked_data_node[datum_node_id] = datum_node

    if (this._visible_data_node[datum_node_id]) {
      this._visible_linked_data_node[datum_node_id] = datum_node

      this._set_node_layer(datum_node_id, LAYER_DATA_LINKED)
    }

    delete this._unlinked_data_node[datum_node_id]
    delete this._visible_unlinked_data_node[datum_node_id]

    const anchor_node_id = this._get_pin_anchor_node_id(node_id)

    const link_id = getLinkId(datum_node_id, node_id)

    const d = LINK_DISTANCE_DATA

    const valid = this._is_datum_valid(datum_node_id)

    const stroke = valid ? this._theme.data_link : this._theme.type

    const data_link = this._sim_add_link(
      link_id,
      {
        source_id: datum_node_id,
        target_id: anchor_node_id,
        l: d,
        s: 1,
        padding: {
          source: -6,
          target: -6,
        },
        detail: {
          type: 'd',
          head: 0,
        },
      },
      {
        stroke,
        strokeWidth: 1,
      }
    )

    const link = this._link[link_id]

    this._data_link[link_id] = link
    this._visible_data_link[link_id] = link
    this._link_layer[link_id] = LAYER_DATA_LINKED

    this._zoom_comp.appendChild(data_link, 'svg')

    if (this._is_pin_node_id(node_id)) {
      this._sim_after_add_pin_datum_link(datum_node_id, node_id)
    }

    this._refresh_datum_visible(datum_node_id)

    if (emit) {
      this._dispatch_data_removed(datumId)
    }

    this._start_graph_simulation(LAYER_DATA_LINKED)
  }

  private _sim_after_add_pin_datum_link = (
    datum_node_id: string,
    pin_node_id: string
  ): void => {
    // console.log('Graph', '_sim_after_add_pin_datum_link', datum_node_id, pin_node_id)

    this._datum_to_pin[datum_node_id] = pin_node_id
    this._pin_to_datum[pin_node_id] = datum_node_id

    if (this._is_link_pin_node_id(pin_node_id)) {
      const { unitId } = segmentLinkPinNodeId(pin_node_id)

      this._refresh_link_pin_color(pin_node_id)
      this._refresh_core_border_color(unitId)
    } else if (this._is_merge_node_id(pin_node_id)) {
      const merge_to_pin = this._merge_to_pin[pin_node_id]

      for (const merge_pin_node_id in merge_to_pin) {
        const merge_pin_datum_node_id = this._pin_to_datum[merge_pin_node_id]
        if (merge_pin_datum_node_id) {
          this._refresh_datum_visible(merge_pin_datum_node_id)
        }
      }
    }
  }

  private _mem_set_pin_datum = (
    pin_node_id: string,
    datum_id: string
  ): void => {
    // console.log('Graph', '_mem_set_pin_datum', pin_node_id, datum_id)

    const pin_datum_tree = this._datum_tree[datum_id]

    const prev_pin_datum_tree = this._pin_datum_tree[pin_node_id]

    this._pin_datum_tree[pin_node_id] = pin_datum_tree

    if (!prev_pin_datum_tree) {
      if (this._is_link_pin_node_id(pin_node_id)) {
        if (!this._spec_is_link_pin_ignored(pin_node_id)) {
          const { unitId, type } = segmentLinkPinNodeId(pin_node_id)

          this._inc_unit_pin_active(unitId)

          const pin_merge_node_id = this._pin_to_merge[pin_node_id]
          if (pin_merge_node_id) {
            if (type === 'input') {
              this._inc_merge_input_active(pin_merge_node_id)
            } else {
              this._inc_merge_output_active(pin_merge_node_id)
            }
          }
        }
      } else if (this._is_merge_node_id(pin_node_id)) {
        // this._inc_merge_input_active(pin_node_id)
      }

      this._refresh_pin_color(pin_node_id)
    }
  }

  private _segregate_node_id = (
    node_ids: Dict<any>
  ): {
    units: string[]
    links: string[]
    merges: string[]
    data: string[]
    inputs: string[]
    outputs: string[]
  } => {
    const units: string[] = []
    const links: string[] = []
    const merges: string[] = []
    const data: string[] = []
    const inputs: string[] = []
    const outputs: string[] = []

    for (const node_id in node_ids) {
      if (this._is_unit_node_id(node_id)) {
        units.push(node_id)
      } else if (this._is_link_pin_node_id(node_id)) {
        links.push(node_id)
      } else if (this._is_merge_node_id(node_id)) {
        merges.push(node_id)
      } else if (this._is_datum_node_id(node_id)) {
        data.push(node_id)
      } else if (this._is_plug_node_id(node_id)) {
        //
      }
    }

    return { units, links, merges, data, inputs, outputs }
  }

  private _int_node_locked: Dict<string> = {}

  private _tick_node = (node_id: string): void => {
    const node = this.get_node(node_id)

    if (!node) {
      return
    }

    const { x, y } = node

    const node_comp = this._node_comp[node_id]

    node_comp.$element.style.transform = `translate(${x}px, ${y}px)`

    if (this._collapsing) {
      if (this._collapse_node_id.has(node_id)) {
        if (this._collapse_next_unit_id) {
          const collapse_unit_node = this._node[this._collapse_next_unit_id]

          if (this._is_pin_node_id(node_id)) {
            if (isInside(node, collapse_unit_node, 2 * node.r)) {
              this._long_press_collapse_node(node_id)
            }
          } else if (this._is_datum_node_id(node_id)) {
            if (
              isInside(node, collapse_unit_node, 2) ||
              this._node_node_center_distance(
                node_id,
                this._collapse_next_unit_id
              ) <
                2 + 2
            ) {
              this._long_press_collapse_node(node_id)
            }
          } else {
            if (node.shape === 'rect') {
              if (pointDistance(node, collapse_unit_node) < 3) {
                this._long_press_collapse_node(node_id)
              }
            } else {
              if (isInside(node, collapse_unit_node, 2 + 6)) {
                this._long_press_collapse_node(node_id)
              }
            }
          }
        } else {
          const { x: cx, y: cy } = this._collapse_world_position

          const dx = x - cx
          const dy = y - cy

          const r = Math.sqrt(dx * dx + dy * dy)

          if (r < 3 + node.r) {
            this._long_press_collapse_node(node_id)
          }
        }
      }
    }

    for (const node_id in this._node_target) {
      const a_id = node_id
      const t_id = this._node_target[node_id]

      const a = this._node[a_id]
      const t = this._node[this._get_node_anchor_node_id(t_id)]

      const { l, d } = surfaceDistance(a, t)

      const on_plug_target_end = (
        int_node_id,
        int_node,
        target_id,
        target_node
      ) => {
        const { type } = segmentInternalNodeId(int_node_id)

        const b_id = getExtNodeIdFromIntNodeId(int_node_id)

        const is_close = isInside(int_node, target_node, 3)
        const is_inside = isInside(int_node, target_node, 1)

        this._set_plug_marker_to_default(type, b_id, int_node_id)

        if (is_close) {
          this._set_exposed_pin_marker_to_node(
            type,
            b_id,
            int_node_id,
            int_node_id,
            3 - l
          )
        }

        if (is_inside) {
          this._on_plug_target_end(int_node_id, target_id)
        }
      }

      if (this._is_pin_node_id(node_id)) {
        if (this._is_pin_node_id(t_id)) {
          const ref = this._is_pin_node_ref(t_id)

          const min_d = ref ? 6 : 3

          if (d < min_d) {
            this._on_pin_pin_target_end(node_id, t_id)
          }
        } else if (this._is_unit_node_id(t_id)) {
          if (l < -2 * PIN_RADIUS) {
            this._on_pin_unit_target_end(node_id, t_id)
          }
        } else {
          on_plug_target_end(t_id, t, node_id, a)
        }
      } else if (this._is_int_node_id(node_id)) {
        on_plug_target_end(node_id, a, t_id, t)
      } else if (this._is_datum_node_id(node_id)) {
        if (d < 1) {
          this._on_node_target_end(node_id, t_id)
        }
      }
    }

    if (this._drag_ext_node_count > 0) {
      for (const ext_node_id of this._drag_ext_node_id) {
        const { type, pinId, subPinId } = segmentPlugNodeId(ext_node_id)

        const a_id = getIntNodeId(type, pinId, subPinId)

        const a = this._node[a_id]

        if (!a) {
          continue
        }

        const b_id = ext_node_id

        const b = this._node[b_id]

        const { x: b_x, y: b_y, r: b_r } = b

        if (this._compatible_node_count > 0) {
          let closest_compatible_node_id = null

          let closest_l = Number.MAX_SAFE_INTEGER
          let closest_l_a = Number.MAX_SAFE_INTEGER
          let closest_l_b = Number.MAX_SAFE_INTEGER

          for (const comp_node_id in this._compatible_node_id) {
            const comp_node = this._node[comp_node_id]

            const { l: l_a } = surfaceDistance(a, comp_node)
            const { l: l_b } = surfaceDistance(b, comp_node)

            const comp_closest_l = Math.min(l_a, l_b)

            if (comp_closest_l < 3 * LINK_DISTANCE) {
              if (comp_closest_l < closest_l) {
                closest_l = comp_closest_l
                closest_l_a = l_a
                closest_l_b = l_b
                closest_compatible_node_id = comp_node_id
              }
            }
          }

          if (closest_compatible_node_id) {
            const c = this._node[closest_compatible_node_id]

            const { x: c_x, y: c_y, r: c_r } = c

            if (closest_l_a + a.r < 3) {
              this._set_exposed_pin_marker_to_node(
                type,
                b_id,
                a_id,
                a_id,
                3 - (closest_l_a + a.r)
              )
            } else {
              this._set_plug_marker_to_default(type, b_id, a_id)
            }

            if (closest_l_b < 1) {
              this._set_exposed_pin_marker_to_node(
                type,
                b_id,
                a_id,
                closest_compatible_node_id,
                0
              )

              if (closest_l_a + 2 * PIN_RADIUS < 0) {
                if (closest_l_a > -3) {
                  this._int_node_locked[a_id] = closest_compatible_node_id

                  a.r = c_r
                  a.width = c.width
                  a.height = c.height
                  a.shape = c.shape
                  a.x = c_x
                  a.y = c_y
                  a.fx = c_x
                  a.fy = c_y
                }
              } else {
                if (closest_l_a < 3) {
                  this._int_node_locked[a_id] = closest_compatible_node_id

                  a.r = c_r
                  a.width = c.width
                  a.height = c.height
                  a.shape = c.shape
                  a.x = c_x
                  a.y = c_y
                  a.fx = c_x
                  a.fy = c_y
                }
              }
            } else {
              if (
                closest_l_a + 2 * PIN_RADIUS < 1 &&
                closest_l_b < SURFACE_UNPLUG_DISTANCE
              ) {
                this._set_exposed_pin_marker_to_node(
                  type,
                  b_id,
                  a_id,
                  closest_compatible_node_id,
                  0
                )

                if (closest_l_a < 1) {
                  this._int_node_locked[a_id] = closest_compatible_node_id

                  a.r = c_r
                  a.width = c.width
                  a.height = c.height
                  a.shape = c.shape
                  a.x = c_x
                  a.y = c_y
                  a.fx = c_x
                  a.fy = c_y
                }
              } else {
                if (this._int_node_locked[a_id]) {
                  delete this._int_node_locked[a_id]

                  const u = unitVector(c_x, c_y, b_x, b_y)
                  const c_d = centerToSurfaceDistance(c, u)

                  const x = c_x + (c_d + 2) * u.x
                  const y = c_y + (c_d + 2) * u.y

                  a.r = PIN_RADIUS
                  a.width = 2 * PIN_RADIUS
                  a.height = 2 * PIN_RADIUS
                  a.shape = 'circle'
                  a.x = x
                  a.y = y
                  a.fx = undefined
                  a.fy = undefined
                }
              }
            }
          }
        }
      }
    }
  }

  private _node_max_link_length_heap: Dict<Heap<MaxLinkHeapValue>> = {}
  private _node_link_heap_node: Dict<Dict<Heap<MaxLinkHeapValue>>> = {}

  private _add_link_to_max_l_heap = (
    node_id: string,
    link_id: string,
    l: number,
    t: number
  ): void => {
    if (!this._node_link_heap_node[node_id]) {
      this._node_link_heap_node[node_id] = {}
    }

    if (!this._node_link_heap_node[node_id][link_id]) {
      const node = {
        parent: null,
        value: { link_id, l, t },
        left: null,
        right: null,
      }

      deepSet(this._node_link_heap_node, [node_id, link_id], node)

      if (this._node_max_link_length_heap[node_id]) {
        this._node_max_link_length_heap[node_id] = addHeapNode(
          this._node_max_link_length_heap[node_id],
          node,
          (a, b) => a.l >= b.l
        )
      } else {
        this._node_max_link_length_heap[node_id] = node
      }
    } else {
      const node = this._node_link_heap_node[node_id][link_id]

      this._node_max_link_length_heap[node_id] = setHeapNode(
        node,
        { link_id, l, t },
        (a, b) => a.l >= b.l
      )
    }
  }

  private _remove_max_link_length_to_node_heap = (
    node_id: string,
    link_id: string
  ): void => {
    const node = this._node_link_heap_node[node_id]?.[link_id]

    if (!node) {
      return
      // throw new Error('node not found in heap')
    }

    this._node_max_link_length_heap[node_id] = removeHeapNode(
      node,
      (a, b) => a.l >= b.l
    )

    delete this._node_link_heap_node[node_id][link_id]
  }

  private _tick_link = (link_id: string): void => {
    const link = this._link[link_id]

    if (!link) {
      return
    }

    const {
      source_id,
      target_id,
      padding = { source: 0, target: 0 },
      detail: { head },
    } = link

    const source = this._node[source_id]
    const target = this._node[target_id]

    const { l, u, d } = surfaceDistance(source, target)

    const link_base = this._link_base[link_id]
    const link_base_area = this._link_base_area[link_id]
    const link_base_text = this._link_base_text[link_id]

    if (this._is_node_id(source_id) && this._is_node_id(target_id)) {
      this._add_link_to_max_l_heap(source_id, link_id, l, link.l)
      this._add_link_to_max_l_heap(target_id, link_id, l, link.l)
    }

    // if (d < 3 || l === 0) {
    //   link_base.setProp('d', '')
    //   link_base_area.setProp('d', '')
    //   return
    // }

    const link_marker_start = this._link_marker_start[link_id]
    const link_marker_end = this._link_marker_end[link_id]

    const nu = { x: -u.x, y: -u.y }

    const sl = Math.sign(l)

    let padding_source = sl * padding.source
    let padding_target = sl * padding.target

    if (link_marker_start) {
      link_marker_start.$element.style.opacity = '1'

      if (l < head) {
        link_marker_start.$element.style.transform = `scaleX(-1)`

        if (l < 0) {
          padding_source += sl * 3
        }
      } else {
        link_marker_start.$element.style.transform = 'scaleX(1)'
      }
    }

    if (link_marker_end) {
      link_marker_end.$element.style.opacity = '1'

      if (l < head) {
        link_marker_end.$element.style.transform = `scaleX(-1)`

        if (l < 0) {
          padding_target += sl * 3
        }
      } else {
        link_marker_end.$element.style.transform = 'scaleX(1)'
      }
    }

    // if (Math.abs(l) <= Math.abs(padding_source - padding_target)) {
    //   link_marker_start && (link_marker_start.$element.style.opacity = '0')
    //   link_marker_end && (link_marker_end.$element.style.opacity = '0')
    //   padding_source = 0
    //   padding_target = 0
    // } else {
    //   link_marker_start && (link_marker_start.$element.style.opacity = '1')
    //   link_marker_end && (link_marker_end.$element.style.opacity = '1')
    // }

    // if (is_inside(source, target)) {
    //   padding_source = -padding_source
    //   u.x = -u.x
    //   u.y = -u.y
    // }

    // if (is_inside(target, source)) {
    //   padding_target = -padding_target
    //   nu.x = -nu.x
    //   nu.y = -nu.y
    // }

    const { x: x0, y: y0 } = pointInNode(source, u, padding_source)
    const { x: x1, y: y1 } = pointInNode(target, nu, padding_target)

    const path_d = `M ${x0} ${y0} L ${x1} ${y1}`
    const path_inverted_d = `M ${x1} ${y1} L ${x0} ${y0}`

    link_base.$element.setAttribute('d', path_d)
    link_base_area.$element.setAttribute('d', path_d)

    // -1 to avoid flickering
    if (x1 > x0 - 1) {
      link_base_text.$element.setAttribute('d', path_d)
    } else {
      link_base_text.$element.setAttribute('d', path_inverted_d)
    }

    // const link_start_marker_id = this._link_start_marker_id(link_id)
    // const link_end_marker_id = this._link_end_marker_id(link_id)

    // link_base.$element.setAttribute(
    //   'marker-start',
    //   `url(#${link_start_marker_id})`
    // )
    // link_base.$element.setAttribute(
    //   'marker-end',
    //   `url(#${link_end_marker_id})`
    // )

    // if (x1 > x0 - 1) {
    //   // link_base_text.$element.setAttribute('d', _d)
    //   link_base.$element.setAttribute(
    //     'marker-start',
    //     `url(#${link_start_marker_id})`
    //   )
    //   link_base.$element.setAttribute(
    //     'marker-end',
    //     `url(#${link_end_marker_id})`
    //   )
    // } else {
    //   // link_base_text.$element.setAttribute('d', __d)
    //   link_base.$element.setAttribute(
    //     'marker-start',
    //     `url(#${link_end_marker_id})`
    //   )
    //   link_base.$element.setAttribute(
    //     'marker-end',
    //     `url(#${link_start_marker_id})`
    //   )
    // }

    const link_text_value = this._link_text_value[link_id]
    const link_text_value_width = getTextWidth(
      link_text_value,
      LINK_TEXT_FONT_SIZE,
      Infinity
    )
    const link_text = this._link_text[link_id]
    if (link_text_value_width > l - 4) {
      link_text.setProp('dx', `${-(l - 4) / 2}`)
    } else {
      link_text.setProp('dx', `${-link_text_value_width / 2}`)
    }
  }

  private _tick_minimap = () => {
    if (this._control_lock) {
      if (!this._input_disabled) {
        if (this._minimap) {
          this._minimap.tick()
        }
      }
    }
  }

  private _inc_node_node_link_count = (
    source_id: string,
    target_id: string
  ): void => {
    if (!this._is_node_id(source_id) || !this._is_node_id(target_id)) {
      return
    }
    // console.log('Graph', '_inc_node_node_link_count')

    this._node_link_count[source_id]++
    this._node_link_count[target_id]++

    this._set_node_link_heap_count(source_id, this._node_link_count[source_id])
    this._set_node_link_heap_count(target_id, this._node_link_count[target_id])

    this._refresh_simulation_stability()
  }

  private _dec_node_node_link_count = (
    source_id: string,
    target_id: string
  ): void => {
    if (!this._is_node_id(source_id) || !this._is_node_id(target_id)) {
      return
    }
    // console.log('Graph', '_dec_node_node_link_count', source_id, target_id)

    this._node_link_count[source_id]--
    this._node_link_count[target_id]--

    this._set_node_link_heap_count(source_id, this._node_link_count[source_id])
    this._set_node_link_heap_count(target_id, this._node_link_count[target_id])

    this._refresh_simulation_stability()
  }

  private _swap_node_node_link_count = (
    prev_source_id: string,
    source_id: string
  ): void => {
    if (!this._is_node_id(prev_source_id) || !this._is_node_id(source_id)) {
      return
    }
    // console.log('Graph', '_swap_node_node_link_count', prev_source_id, source_id)

    this._node_link_count[prev_source_id]--
    this._node_link_count[source_id]++

    this._set_node_link_heap_count(
      prev_source_id,
      this._node_link_count[prev_source_id]
    )
    this._set_node_link_heap_count(source_id, this._node_link_count[source_id])

    this._refresh_simulation_stability()
  }

  private _sim_add_link = (
    link_id: string,
    sim_link: GraphSimLink,
    link_opt: LinkProps = {}
  ): SVGG => {
    const link = this._create_link(link_id, link_opt)

    this._link_comp[link_id] = link

    this._link[link_id] = sim_link

    this._link_unlisten[link_id] = this._listen_link(link_id, link)

    const { source_id, target_id } = sim_link

    this._inc_node_node_link_count(source_id, target_id)

    add_link_to_graph(this._node_graph, source_id, target_id)

    this._rebuild_subgraph()

    return link
  }

  private _set_node_hovered = (
    node_id: string,
    pointer_id: number,
    hovered: boolean
  ) => {
    // console.log('Graph', '_set_node_hovered', node_id, hovered)

    if (hovered) {
      if (
        !this._hover_node_id_pointer_id[node_id] ||
        !this._hover_node_id_pointer_id[node_id][pointer_id]
      ) {
        if (this._hover_node_pointer_count[node_id] === undefined) {
          this._hover_node_pointer_count[node_id] = 0
        }
        this._hover_node_pointer_count[node_id]++
        if (this._hover_node_id_pointer_id[node_id] === undefined) {
          this._hover_node_id_pointer_id[node_id] = {}
        }
        this._hover_node_id_pointer_id[node_id][pointer_id] = true
        this._pointer_id_hover_node_id[pointer_id] = node_id

        if (this._hover_node_pointer_count[node_id] === 1) {
          this._hover_node_id[node_id] = true
          this._hover_node_count++

          if (this._has_node(node_id)) {
            this._refresh_node_selection(node_id)
          }

          if (this._is_merge_node_id(node_id)) {
            const merge_datum_node_id = this._get_merge_datum_node_id(node_id)
            if (merge_datum_node_id) {
              this._refresh_datum_visible(merge_datum_node_id)
            }
          } else if (this._is_link_pin_node_id(node_id)) {
            const pin_datum_node_id = this._pin_to_datum[node_id]
            if (pin_datum_node_id) {
              this._refresh_datum_visible(pin_datum_node_id)
            }
          } else if (this._is_unit_node_id(node_id)) {
            //
          }

          if (this._mode === 'info') {
            if (this._is_node_infoable(node_id)) {
              if (!this._is_node_selected(node_id)) {
                if (this._hover_node_count === 1 && !this._edit_node_name_id) {
                  this._set_all_nodes_links_opacity(0.2)

                  for (const selected_node_id in this._selected_node_id) {
                    this._hide_node_info(selected_node_id)
                  }
                }

                this._show_node_info(node_id)
              }
            }
          }

          this._refresh_node_color(node_id)
          this._refresh_all_selected_node_color()
        }
      }
    } else {
      if (
        this._hover_node_id_pointer_id[node_id] &&
        this._hover_node_id_pointer_id[node_id][pointer_id]
      ) {
        this._hover_node_pointer_count[node_id]--

        delete this._hover_node_id_pointer_id[node_id][pointer_id]
        delete this._pointer_id_hover_node_id[pointer_id]

        if (this._hover_node_pointer_count[node_id] === 0) {
          delete this._hover_node_id[node_id]

          this._hover_node_count--

          if (this._has_node(node_id)) {
            this._refresh_node_selection(node_id)
          }

          if (this._is_merge_node_id(node_id)) {
            const merge_datum_node_id = this._get_merge_datum_node_id(node_id)

            if (merge_datum_node_id) {
              this._refresh_datum_visible(merge_datum_node_id)
            }
          } else if (this._is_link_pin_node_id(node_id)) {
            const pin_datum_node_id = this._pin_to_datum[node_id]

            if (pin_datum_node_id) {
              this._refresh_datum_visible(pin_datum_node_id)
            }
          } else if (this._is_datum_node_id(node_id)) {
            this._refresh_datum_visible(node_id)

            if (this._edit_datum_node_id !== node_id) {
              if (
                this._unlocked_datum.has(node_id) &&
                this._core_component_unlocked_count > 0
              ) {
                this._lock_datum(node_id)
                this._blur_datum(node_id)
              }
            }
          }

          if (this._mode === 'info') {
            if (this._is_node_infoable(node_id)) {
              if (!this._is_node_selected(node_id)) {
                this._refresh_node_info(node_id)

                if (
                  this._hover_node_count === 0 &&
                  (!this._edit_node_name_id ||
                    this._edit_node_name_id === node_id ||
                    (this._is_int_node_id(node_id) &&
                      getExtNodeIdFromIntNodeId(node_id) ===
                        this._edit_node_name_id))
                ) {
                  if (this._selected_node_count > 0) {
                    this._set_all_nodes_links_opacity(0.2)

                    for (const selected_node_id in this._selected_node_id) {
                      this._show_node_info(selected_node_id)
                    }
                  } else {
                    this._set_all_nodes_links_opacity(1)
                  }
                }
              }
            }
          }

          if (!this._drag_node_id[node_id]) {
            if (this._is_link_pin_node_id(node_id)) {
              const { unitId } = segmentLinkPinNodeId(node_id)

              if (!this._drag_node_id[unitId]) {
                const merge_node_id = this._pin_to_merge[node_id]

                if (merge_node_id) {
                  const merge_anchor_node_id =
                    this._get_merge_anchor_node_id(merge_node_id)

                  this._refresh_node_color(merge_anchor_node_id)
                  this._refresh_link_pin_link_color(node_id)
                } else {
                  this._refresh_node_color(node_id)
                }
              }
            } else {
              this._refresh_node_group_color(node_id)
            }
          }

          this._refresh_all_selected_node_color()
        }
      }
    }
  }

  private _is_node_mode_colorable = (
    node_id: string,
    mode: string
  ): boolean => {
    switch (mode) {
      case 'add':
        return this._is_node_duplicatable(node_id)
      case 'change':
        return this._is_node_changeable(node_id)
      case 'remove':
        return this._is_node_removable(node_id)
      case 'data':
        return this._is_node_dataable(node_id)
      default:
        return false
    }
  }

  private _set_core_mode_color = (unit_id: string): void => {
    const { $theme } = this.$context

    const color = this._get_color()

    if (
      this._mode === 'none' ||
      this._mode === 'multiselect' ||
      this._mode === 'info'
    ) {
      this._reset_core_border_color(unit_id)
    } else {
      if (this._is_node_mode_colorable(unit_id, this._mode)) {
        const mode_color = getThemeModeColor($theme, this._mode, color)

        this._set_core_and_layout_core_border_color(unit_id, mode_color)
      }
    }
  }

  private _set_node_mode_color = (node_id: string): void => {
    this.__set_node_mode_color(node_id, this._mode)
  }

  private _is_link_pin_displayed = (pin_node_id: string): boolean => {
    const { unitId } = segmentLinkPinNodeId(pin_node_id)

    return (
      this._is_node_displayed(pin_node_id) || this._is_node_displayed(unitId)
    )
  }

  private _is_node_displayed = (node_id: string): boolean => {
    if (this._is_node_hovered(node_id) || this._is_node_dragged(node_id)) {
      return true
    } else if (this._is_node_selected(node_id)) {
      if (this._hover_node_count > 0) {
        let hover_selected_count = 0

        for (const hover_node_id in this._hover_node_id) {
          if (this._is_node_selected(hover_node_id)) {
            hover_selected_count += 1

            break
          }
        }

        if (hover_selected_count > 0) {
          return true
        }

        return false
      }

      return true
    }
  }

  private __set_node_mode_color = (node_id: string, mode: Mode): void => {
    // console.log('Graph', '__set_node_mode_color', node_id, mode)

    const { $theme } = this.$context

    const color = this._get_color()

    if (this.__is_mode_colored(mode)) {
      // if (this._is_node_mode_colorable(node_id, mode)) {
      const mode_color = getThemeModeColor($theme, mode, color)
      const mode_link_color = getThemeLinkModeColor($theme, mode)

      const mode_text_color = mode_link_color
      const mode_pin_icon_color = mode_color

      if (this._is_unit_node_id(node_id)) {
        const unit_id = node_id

        this._set_unit_color(
          unit_id,
          mode_color,
          mode_link_color,
          mode_text_color,
          mode_pin_icon_color
        )

        if (mode === 'remove') {
          if (this._err[unit_id]) {
            const err_node_id = getErrNodeId(unit_id)

            this._set_err_color(err_node_id, mode_color)
          }

          this._for_each_unit_pin(unit_id, (pin_node_id) => {
            const datum_node_id = this._pin_to_datum[pin_node_id]

            if (datum_node_id) {
              this._set_datum_color(datum_node_id, mode_color, mode_link_color)
            }
          })
        } else if (mode === 'add') {
          this._for_each_unit_pin(unit_id, (pin_node_id) => {
            if (
              this._is_input_pin_node_id(pin_node_id) &&
              this._is_link_pin_constant(pin_node_id)
            ) {
              const datum_node_id = this._get_pin_datum_node_id(pin_node_id)

              if (datum_node_id) {
                this._set_datum_color(datum_node_id, mode_color, mode_color)
              }
            }
          })
        } else if (mode === 'data') {
          this._for_each_unit_pin(unit_id, (pin_node_id) => {
            const datum_node_id = this._get_pin_datum_node_id(pin_node_id)

            if (datum_node_id) {
              this._set_datum_color(datum_node_id, mode_color, mode_color)
            }
          })
        }
      } else if (this._is_link_pin_node_id(node_id)) {
        this._set_link_pin_color(
          node_id,
          mode_color,
          mode_link_color,
          mode_text_color,
          mode_pin_icon_color
        )
        if (mode === 'remove') {
          const datum_node_id = this._pin_to_datum[node_id]

          if (datum_node_id) {
            this._set_datum_color(datum_node_id, mode_color, mode_link_color)
          }
        }
      } else if (this._is_merge_node_id(node_id)) {
        if (mode === 'data') {
          this._set_merge_input_color(node_id, mode_color)

          const merge_inputs = this._merge_to_input[node_id]
          const merge_outputs = this._merge_to_output[node_id]

          let output_displayed_count = 0

          for (const output_node_id in merge_outputs) {
            if (this._is_link_pin_displayed(output_node_id)) {
              output_displayed_count++
            }
          }

          if (output_displayed_count > 0) {
            this._set_merge_output_color(node_id, mode_color)
          }

          for (const input_node_id in merge_inputs) {
            this._set_link_pin_link_color(input_node_id, mode_link_color)
          }
        } else {
          const merge_inputs = this._merge_to_input[node_id]
          for (const input_node_id in merge_inputs) {
            if (this._is_link_pin_displayed(input_node_id)) {
              this._set_merge_input_color(node_id, mode_color)

              break
            }
          }
          const merge_outputs = this._merge_to_output[node_id]
          for (const output_node_id in merge_outputs) {
            if (this._is_link_pin_displayed(output_node_id)) {
              this._set_merge_output_color(node_id, mode_color)

              break
            }
          }
        }
      } else if (this._is_datum_node_id(node_id)) {
        this._set_datum_color(node_id, mode_color, mode_link_color)
      } else if (this._is_err_node_id(node_id)) {
        this._set_err_color(node_id, mode_color)
      } else if (this._is_plug_node_id(node_id)) {
        const { type, pinId, subPinId } = segmentPlugNodeId(node_id)

        if (mode === 'change') {
          this._set_exposed_pin_set_color(type, pinId, mode_color)
        } else {
          this._set_exposed_sub_pin_color(type, pinId, subPinId, mode_color)
        }
      }
      // }
    }
  }

  private _should_color_selected_node = () => {
    let hovered_not_selected_count = this._hover_node_count

    for (const hovered_node_id in this._hover_node_id) {
      if (this._is_node_selected(hovered_node_id)) {
        hovered_not_selected_count--
      }
    }

    return hovered_not_selected_count === 0 && this._search_hidden
  }

  private _refresh_all_selected_node_color = (): void => {
    this._reset_selected_node_color()

    if (this._should_color_selected_node()) {
      this._set_all_selected_node_color(this._mode)
    }
  }

  private _set_all_selected_node_color = (mode: Mode): void => {
    for (const selected_node_id in this._selected_node_id) {
      this.__set_node_mode_color(selected_node_id, mode)
    }
  }

  private _reset_selected_node_color = (): void => {
    for (const selected_node_id in this._selected_node_id) {
      this._reset_node_color(selected_node_id)
    }
  }

  private _reset_node_color = (node_id: string): void => {
    // console.log('Graph', '_reset_node_color', node_id)

    if (this._is_unit_node_id(node_id)) {
      this._reset_unit_color(node_id)

      this._for_each_unit_pin(node_id, (pin_node_id, type) => {
        const datum_node_id = this._pin_to_datum[pin_node_id]
        if (datum_node_id) {
          this._refresh_datum_color(datum_node_id)
        }

        const { pinId, subPinId } =
          this._spec_get_pin_node_plug_spec(type, pin_node_id) ?? {}

        if (pinId && subPinId) {
          this._refresh_exposed_sub_pin_color(type, pinId, subPinId)
        }
      })
    } else if (this._is_link_pin_node_id(node_id)) {
      this._reset_link_pin_color(node_id)
    } else if (this._is_merge_node_id(node_id)) {
      this._reset_merge_pin_pin_color(node_id, 'input')
      this._reset_merge_pin_pin_color(node_id, 'output')

      this._reset_merge_name_color(node_id)

      const merge_inputs = this._merge_to_input[node_id]

      for (const input_node_id in merge_inputs) {
        this._refresh_link_pin_link_color(input_node_id)
      }
    } else if (this._is_datum_node_id(node_id)) {
      this._reset_datum_color(node_id)
    } else if (this._is_err_node_id(node_id)) {
      this._reset_err_color(node_id)
    } else if (this._is_plug_node_id(node_id)) {
      const { type, pinId, subPinId } = segmentPlugNodeId(node_id)

      this._reset_exposed_sub_pin_color(type, pinId, subPinId)
    }
  }

  private _is_mode_colored = (): boolean => {
    return this.__is_mode_colored(this._mode)
  }

  private __is_mode_colored = (mode: Mode): boolean => {
    return (
      mode === 'add' ||
      mode === 'remove' ||
      mode === 'change' ||
      mode === 'data'
    )
  }

  private _is_node_reachable = (node_id: string) => {
    if (this._tree_layout) {
      if (this._is_unit_node_id(node_id)) {
        if (this._is_unit_component(node_id)) {
          const current_layer_id = this._get_current_layout_layer_id()
          const parent_id = this._spec_get_sub_component_parent_id(node_id)

          if (current_layer_id === parent_id) {
            return true
          } else {
            return false
          }
        } else {
          return false
        }
      } else {
        return false
      }
    } else {
      return true
    }
  }

  private _is_node_moded = (node_id: string): boolean => {
    if (!this._is_node_reachable(node_id)) {
      return false
    }

    if (
      this._is_node_hovered(node_id) ||
      this._is_node_dragged(node_id) ||
      (this._is_node_selected(node_id) &&
        (!this._ascend_z_count || this._is_node_ascend(node_id))) ||
      this._is_node_ascend(node_id)
    ) {
      return true
    } else {
      if (this._is_link_pin_node_id(node_id)) {
        const { unitId } = segmentLinkPinNodeId(node_id)

        if (this._is_node_moded(unitId)) {
          return true
        }
      } else if (this._is_datum_node_id(node_id)) {
        const datum_pin_node_id = this._datum_to_pin[node_id]

        if (datum_pin_node_id) {
          if (
            this._is_node_moded(datum_pin_node_id) &&
            this._mode === 'remove'
          ) {
            return true
          }
        }
      }

      return false
    }
  }

  private _refresh_node_group_color = (node_id: string): void => {
    // console.log('Graph', '_refresh_node_group_color', node_id)

    if (this._is_plug_node_id(node_id)) {
      const { type, pinId } = segmentLinkPinNodeId(node_id)

      this._refresh_exposed_pin_set_color(type, pinId)
    } else {
      this._refresh_node_color(node_id)
    }
  }

  private _refresh_node_color = (node_id: string): void => {
    // console.log('Graph', '_refresh_node_color', node_id)

    this._reset_node_color(node_id)

    if (this._is_mode_colored() && this._search_hidden) {
      if (this._is_node_moded(node_id)) {
        this._set_node_mode_color(node_id)
      }
    }
  }

  private _reset_unit_color = (unit_id: string): void => {
    // console.log('Graph', '_reset_unit_color', unit_id)

    if (this._search_unit_id === unit_id) {
      const { $theme } = this.$context

      let _mode =
        this._mode === 'multiselect' || this._mode === 'info'
          ? 'add'
          : this._mode

      const node_color = getThemeModeColor($theme, _mode, 'currentColor')
      const link_color = getThemeLinkModeColor($theme, _mode)

      const pin_icon_color = node_color

      this._set_unit_color(
        unit_id,
        node_color,
        link_color,
        link_color,
        pin_icon_color
      )
    } else {
      this._for_each_unit_pin(unit_id, (pin_node_id: string, type: IO) => {
        const merge_node_id = this._pin_to_merge[pin_node_id]

        if (merge_node_id) {
          const merge = this._get_merge(merge_node_id)

          this._refresh_link_pin_color(pin_node_id)

          const merge_unit_id = this._merge_to_ref_unit[merge_node_id]
          const merge_output_ref = this._merge_to_ref_output[merge_node_id]

          if (this._search_unit_id && merge[this._search_unit_id]) {
            //
          } else {
            if (merge_unit_id) {
              //
            } else if (merge_output_ref === pin_node_id) {
              //
            } else {
              this._refresh_merge_pin_pin_color(merge_node_id, type)
            }
          }
        } else {
          this._refresh_link_pin_color(pin_node_id)
        }
      })

      this._reset_core_border_color(unit_id)
      this._reset_soul_color(unit_id)

      if (this._err[unit_id]) {
        const err_node_id = getErrNodeId(unit_id)

        this._reset_err_color(err_node_id)
      }
    }
  }

  private _refresh_merge_pin_color = (merge_node_id: string): void => {
    // console.log('Graph', '_refresh_merge_pin_color', merge_node_id)

    this._refresh_merge_pin_pin_color(merge_node_id, 'input')
    this._refresh_merge_pin_pin_color(merge_node_id, 'output')
  }

  private _refresh_merge_pin_pin_color = (merge_node_id: string, type: IO) => {
    if (this._is_mode_colored()) {
      if (this._is_node_displayed(merge_node_id)) {
        this._refresh_node_color(merge_node_id)
      } else {
        const merge_input_node_ids = this._merge_to_input[merge_node_id]

        for (const merge_input_node_id in merge_input_node_ids) {
          if (this._is_link_pin_displayed(merge_input_node_id)) {
            this._refresh_node_color(merge_node_id)

            return
          }
        }

        this._reset_merge_pin_pin_color(merge_node_id, type)
      }
    } else {
      this._reset_merge_pin_pin_color(merge_node_id, type)
    }
  }

  private _reset_merge_pin_pin_color = (merge_node_id: string, type: IO) => {
    // console.log('Graph', '_reset_merge_pin_pin_color', merge_node_id)

    const merge_ref_output_id = this._merge_to_ref_output[merge_node_id]

    if (merge_ref_output_id) {
      return
    }

    if (type === 'input') {
      this._reset_merge_input_pin_color(merge_node_id)
    } else {
      this._reset_merge_output_pin_color(merge_node_id)
    }

    this._reset_merge_name_color(merge_node_id)
  }

  private _reset_merge_input_pin_color = (merge_node_id: string): void => {
    // console.log('Graph', '_reset_merge_input_pin_color', merge_node_id)

    const { mergeId } = segmentMergeNodeId(merge_node_id)

    const search_unit_merge_pins = this._search_unit_merges[mergeId]

    if (
      search_unit_merge_pins &&
      search_unit_merge_pins[this._search_unit_id] &&
      search_unit_merge_pins[this._search_unit_id]['input'] &&
      keyCount(search_unit_merge_pins[this._search_unit_id]['input']) > 0
    ) {
      const { $theme } = this.$context

      const node_color = getThemeModeColor($theme, this._mode, 'currentColor')

      this._set_merge_input_color(merge_node_id, node_color)
    } else if (this._merge_active_input_count[merge_node_id] > 0) {
      this._set_merge_input_active(merge_node_id)
    } else {
      this._set_merge_input_inactive(merge_node_id)
    }
  }

  private _reset_merge_output_pin_color = (merge_node_id: string): void => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    const reset = () => {
      if (this._merge_active_output_count[merge_node_id] > 0) {
        this._set_merge_output_active(merge_node_id)
      } else {
        this._set_merge_output_inactive(merge_node_id)
      }
    }

    if (this._search_unit_id) {
      const search_unit_merge_pins = this._search_unit_merges[mergeId]

      const search_unit_merge_outputs = deepGetOrDefault(
        search_unit_merge_pins ?? {},
        [this._search_unit_id, 'output'],
        {}
      )

      if (keyCount(search_unit_merge_outputs) > 0) {
        const { $theme } = this.$context
        const node_color = getThemeModeColor($theme, this._mode, 'currentColor')
        this._set_merge_output_color(merge_node_id, node_color)
      } else {
        reset()
      }
    } else {
      reset()
    }
  }

  private _set_all_nodes_links_opacity = (opacity: number): void => {
    this._set_nodes_links_opacity(opacity, this._node, this._link)
  }

  private _set_nodes_opacity = (nodes: string[], opacity: number): void => {
    for (const node_id of nodes) {
      this._set_node_opacity(node_id, opacity)
    }
  }

  private _set_nodes_links_opacity = (
    opacity: number,
    nodes: Dict<any>,
    links: Dict<any>
  ): void => {
    for (const node_id in nodes) {
      this._set_node_opacity(node_id, opacity)
    }

    for (const link_id in links) {
      this._set_link_opacity(link_id, opacity)
    }
  }

  private _info_node_id: Set<string> = new Set()

  private _show_node_info = (node_id: string): void => {
    // console.log('Graph', '_show_node_info', node_id)

    this._info_node_id.add(node_id)

    if (this._is_unit_node_id(node_id)) {
      this._show_unit_info(node_id)

      this._for_each_unit_pin(node_id, (pin_node_id: string) => {
        if (!this._spec_is_link_pin_ignored(pin_node_id)) {
          this.__show_pin_info(pin_node_id)
        }
      })
    } else if (this._is_link_pin_node_id(node_id)) {
      if (!this._spec_is_link_pin_ignored(node_id)) {
        this._show_pin_info(node_id)
      }
    } else if (this._is_merge_node_id(node_id)) {
      this.__show_pin_info(node_id)

      const merge_to_pin = this._merge_to_pin[node_id]

      for (const pin_node_id in merge_to_pin) {
        this._show_pin_info(pin_node_id)
      }
    } else if (this._is_ext_node_id(node_id)) {
      this._show_ext_info(node_id)
    } else if (this._is_int_node_id(node_id)) {
      const ext_node_id = getExtNodeIdFromIntNodeId(node_id)
      this._show_ext_info(ext_node_id)
    } else if (this._is_datum_node_id(node_id)) {
      this._show_datum_info(node_id)
    }
  }

  private _show_pin_info = (pin_node_id: string): void => {
    this.__show_pin_info(pin_node_id)

    const { unitId } = segmentLinkPinNodeId(pin_node_id)
    this._set_node_opacity(unitId, 1)
    this._for_each_unit_pin(unitId, (pin_node_id: string) => {
      if (!this._spec_is_link_pin_ignored(pin_node_id)) {
        this._show_pin_info_opacity(pin_node_id)
      }
    })
  }

  private _show_unit_info = (unit_id: string): void => {
    this._set_node_opacity(unit_id, 1)
    this._show_core_description(unit_id)
  }

  private _set_node_opacity = (node_id: string, opacity: number): void => {
    const node_comp = this._node_content[node_id]

    node_comp.$element.style.opacity = `${opacity}`
  }

  private _set_link_opacity = (link_id: string, opacity: number): void => {
    const link_comp = this._link_comp[link_id]

    link_comp.$element.style.opacity = `${opacity}`
  }

  private __show_pin_info = (pin_node_id: string): void => {
    // console.log('Graph', '__show_pin_info', pin_node_id)

    this._show_pin_info_opacity(pin_node_id)

    const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)

    if (this._is_pin_node_id(anchor_node_id)) {
      const { x, y } = this._predict_pin_type_initial_position(anchor_node_id)

      const type_node_id = getTypeNodeId(anchor_node_id)

      if (!this._has_node(type_node_id)) {
        this._sim_add_pin_type(anchor_node_id, { x, y })
      }
    }
  }

  private _show_pin_info_opacity = (pin_node_id: string): void => {
    if (this._is_link_pin_node_id(pin_node_id)) {
      const link_id = getPinLinkIdFromPinNodeId(pin_node_id)
      this._set_link_opacity(link_id, 1)
    }

    const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)

    if (this._is_pin_node_id(anchor_node_id)) {
      this._set_node_opacity(anchor_node_id, 1)

      const type_node_id = getTypeNodeId(anchor_node_id)
      if (this._has_node(type_node_id)) {
        this._set_node_opacity(type_node_id, 1)

        // const type_link_id = getLinkId(type_node_id, pin_node_id)
        const type_link_id = getLinkId(type_node_id, anchor_node_id)
        this._set_link_opacity(type_link_id, 1)
      }

      const pin_datum_node_id = this._pin_to_datum[anchor_node_id]

      if (pin_datum_node_id) {
        const datum_link_id = getLinkId(pin_datum_node_id, anchor_node_id)

        this._set_node_opacity(pin_datum_node_id, 1)
        this._set_link_opacity(datum_link_id, 1)
      }
    }
  }

  private _show_ext_info = (ext_node_id: string): void => {
    const { pinId, type, subPinId } = segmentPlugNodeId(ext_node_id)

    const int_node_id = getIntNodeId(type, pinId, subPinId)

    if (this._has_node(ext_node_id)) {
      this._set_node_opacity(ext_node_id, 1)
    }
    if (this._has_node(int_node_id)) {
      this._set_node_opacity(int_node_id, 1)
    }

    const source_id = type === 'output' ? int_node_id : ext_node_id
    const target_id = type === 'output' ? ext_node_id : int_node_id

    const link_id = getLinkId(source_id, target_id)

    this._set_link_opacity(link_id, 1)

    this._show_ext_pin_type(ext_node_id, int_node_id)
  }

  private _show_datum_info = (datum_node_id: string) => {
    // console.log('Graph', '_show_datum_info', datum_node_id)

    this._set_node_opacity(datum_node_id, 1)

    let datum_type_tree = this._get_datum_type(datum_node_id)

    if (datum_type_tree.type === TreeNodeType.Invalid) {
      datum_type_tree = getTree('invalid')
    }

    const { x, y, width, height } = this.get_node(datum_node_id)

    const position = randomInPaddedRect(
      x,
      y,
      x + width,
      y + height,
      LINK_DISTANCE_TYPE
    )

    this._sim_add_node_type(datum_node_id, datum_type_tree, position)
  }

  private _show_ext_pin_type = (ext_node_id: string, int_node_id: string) => {
    // console.log('Graph', '_show_ext_pin_type', ext_node_id, int_node_id)

    const type_node_id = getTypeNodeId(ext_node_id)

    if (this._has_node(type_node_id)) {
      return
    }

    const type_tree = this._get_plug_type(ext_node_id)

    const ext_node = this.get_node(ext_node_id)

    const position = this._predict_plug_type_initial_position(ext_node_id)

    this._sim_add_node_type(ext_node_id, type_tree, position)
  }

  private _show_link_pin_name = (pin_node_id: string): void => {
    // console.log('Graph', '_show_link_pin_name', pin_node_id)

    const pin_name = this._pin_name[pin_node_id]

    pin_name.$element.style.display = 'block'
  }

  private _hide_link_pin_name = (pin_node_id: string): void => {
    // console.log('Graph', '_hide_link_pin_name', pin_node_id)

    const pin_name = this._pin_name[pin_node_id]

    pin_name.$element.style.display = 'none'
  }

  private _should_show_node_info = (node_id: string): boolean => {
    return this._is_node_hovered(node_id) || this._is_node_selected(node_id)
  }

  private _refresh_node_info = (node_id: string): void => {
    // console.log('Graph', '_refresh_node_info', node_id)

    if (this._mode === 'info') {
      if (this._should_show_node_info(node_id)) {
        this._show_node_info(node_id)
      } else {
        if (this._is_link_pin_node_id(node_id)) {
          const { unitId } = segmentLinkPinNodeId(node_id)
          if (this._should_show_node_info(unitId)) {
            this._show_node_info(node_id)
          } else {
            this._hide_node_info(node_id)
          }
        } else if (this._is_unit_node_id(node_id)) {
          if (this._should_show_node_info(node_id)) {
            this._show_node_info(node_id)
          } else {
            this._hide_node_info(node_id)
          }
        } else {
          this._hide_node_info(node_id)
        }
      }
    } else {
      this._hide_node_info(node_id)
    }
  }

  private _hide_node_info = (node_id: string): void => {
    // console.log('Graph', '_hide_node_info', node_id)

    this._info_node_id.delete(node_id)

    if (this._is_unit_node_id(node_id)) {
      this._hide_unit_info(node_id)
      this._for_each_unit_pin(node_id, (pin_node_id: string) => {
        if (!this._spec_is_link_pin_ignored(pin_node_id)) {
          this._refresh_node_info(pin_node_id)
        }
      })
    } else if (this._is_link_pin_node_id(node_id)) {
      this._hide_pin_info(node_id)
    } else if (this._is_merge_node_id(node_id)) {
      this._hide_pin_info(node_id)
    } else if (this._is_ext_node_id(node_id)) {
      this._hide_ext_info(node_id)
    } else if (this._is_int_node_id(node_id)) {
      this._hide_int_info(node_id)
    } else if (this._is_datum_node_id(node_id)) {
      this._hide_datum_info(node_id)
    }
  }

  private _set_merge_empty(merge_node_id: string) {
    // console.log('Graph', '_set_merge_empty', merge_node_id)

    this._empty_merge_node_count++

    const node = this._node[merge_node_id]

    this._empty_merge_node[merge_node_id] = node

    this._set_node_layer(merge_node_id, LAYER_EXPOSED)
  }

  private _remove_merge_empty = (merge_node_id: string) => {
    // console.log('Graph', '_remove_merge_empty', merge_node_id)

    delete this._empty_merge_node[merge_node_id]

    this._empty_merge_node_count--

    if (this._has_node(merge_node_id)) {
      this._refresh_node_layer(merge_node_id)
    }
  }

  private _hide_ext_info(ext_node_id: string): void {
    // console.log('Graph', '_hide_ext_info', ext_node_id)

    this._sim_remove_node_type(ext_node_id)
  }

  private _hide_int_info(int_node_id: string): void {
    const ext_node_id = getExtNodeIdFromIntNodeId(int_node_id)

    this._hide_ext_info(ext_node_id)
  }

  private _hide_datum_info(datum_node_id: string): void {
    // console.log('Graph', '_hide_datum_info', datum_node_id)

    this._sim_remove_node_type(datum_node_id)
  }

  private _hide_unit_info = (unit_id: string): void => {
    this._hide_core_description(unit_id)
  }

  private _hide_pin_info = (pin_node_id: string) => {
    // console.log('Graph', '_hide_pin_info')
    const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)
    const type_node_id = getTypeNodeId(anchor_node_id)
    if (this._has_node(type_node_id)) {
      this._sim_remove_pin_type(anchor_node_id)
    }
  }

  private _refresh_class_literal_datum_node_selection = (
    datum_node_id: string
  ) => {
    const { datumId } = segmentDatumNodeId(datum_node_id)

    const node_selection = this._node_selection[datum_node_id]
    const tree = this._datum_tree[datumId]
    const { width, height } = this._get_datum_tree_size(tree)
    const shape = this._get_datum_tree_shape(tree)
    node_selection.setProp('shape', shape)
    node_selection.setProp('width', width + 6)
    node_selection.setProp('height', height + 6)
  }

  private _hide_link = (link_id: string): void => {
    const link_base = this._link_base[link_id]
    const link_base_area = this._link_base_area[link_id]

    link_base.$element.style.display = 'none'
    link_base_area.$element.style.display = 'none'
  }

  private _show_link = (link_id: string): void => {
    const link_base = this._link_base[link_id]
    const link_base_area = this._link_base_area[link_id]

    link_base.$element.style.display = 'block'
    link_base_area.$element.style.display = 'block'
  }

  private _set_link_pin_color = (
    pin_node_id: string,
    node_color: string,
    link_color: string,
    text_color: string,
    icon_color: string
  ): void => {
    // console.log('Graph', '_set_link_pin_color', pin_node_id, node_color)

    const merge_node_id = this._pin_to_merge[pin_node_id]

    if (merge_node_id) {
      const merge_ref_output_id = this._merge_to_ref_output[merge_node_id]

      if (merge_ref_output_id === pin_node_id) {
        this._set_link_pin_pin_color(pin_node_id, node_color, icon_color)
        this._set_link_pin_pin_text_color(pin_node_id, text_color)
      } else {
        if (!this._is_merge_ref(merge_node_id)) {
          const { type } = segmentLinkPinNodeId(pin_node_id)

          this._set_merge_pin_color(merge_node_id, type, node_color)
        }
      }
    } else {
      this._set_link_pin_pin_color(pin_node_id, node_color, icon_color)
      this._set_link_pin_pin_text_color(pin_node_id, text_color)
    }

    this._set_link_pin_link_color(pin_node_id, link_color)
    this._set_link_pin_link_text_color(pin_node_id, text_color)
  }

  private _reset_link_pin_pin_color = (pin_node_id: string): void => {
    // console.log('Graph', '_reset_link_pin_pin_color', pin_node_id)
    const { type, unitId } = segmentLinkPinNodeId(pin_node_id)

    if (this._search_unit_id === unitId) {
      const { $theme } = this.$context
      const link_color = getThemeLinkModeColor($theme, this._mode)
      const node_color = getThemeModeColor($theme, this._mode, 'currentColor')
      const icon_color = node_color
      this._set_link_pin_color(
        pin_node_id,
        node_color,
        link_color,
        link_color,
        icon_color
      )
    } else {
      const pin_datum_tree = this._pin_datum_tree[pin_node_id]
      if (pin_datum_tree) {
        this._set_link_pin_pin_color(
          pin_node_id,
          this._theme.data,
          this._theme.node
        )
        this._set_link_pin_pin_text_color(pin_node_id, this._theme.pin_text)
      } else {
        const default_pin_color = this._default_pin_color(pin_node_id)
        this._set_link_pin_pin_color(
          pin_node_id,
          default_pin_color,
          default_pin_color
        )
        this._set_link_pin_pin_text_color(pin_node_id, this._theme.pin_text)
      }
    }
  }

  private _refresh_link_pin_datum_color_if_visible = (
    pin_node_id: string
  ): void => {
    const pin_datum_node_id = this._pin_to_datum[pin_node_id]

    if (pin_datum_node_id) {
      this._refresh_datum_color(pin_datum_node_id)
    }
  }

  private _default_pin_color = (pin_node_id: string): string => {
    const color = this._theme.node
    return color
  }

  private _default_link_color = (pin_node_id: string): string => {
    const ref = this._is_link_pin_ref(pin_node_id)
    const init = this._is_link_pin_init(pin_node_id)
    const color = ref || init ? this._theme.node : this._theme.link
    return color
  }

  private _refresh_link_pin_link_color = (pin_node_id: string): void => {
    // console.log('Graph', '_refresh_link_pin_link_color')
    if (this._is_mode_colored()) {
      if (this._is_link_pin_displayed(pin_node_id)) {
        this._refresh_node_color(pin_node_id)
      } else {
        this._reset_link_pin_link_color(pin_node_id)
      }
    } else {
      this._reset_link_pin_link_color(pin_node_id)
    }
  }

  private _reset_link_pin_link_color = (pin_node_id: string): void => {
    // console.log('Graph', '_reset_link_pin_link_color')

    const datum_tree = this._pin_datum_tree[pin_node_id]
    const merge_node_id = this._pin_to_merge[pin_node_id]

    const { unitId } = segmentLinkPinNodeId(pin_node_id)

    const set_data_color = () => {
      // console.log('set_data_color', pin_node_id)
      this._set_link_pin_link_color(pin_node_id, this._theme.data_link)
      this._set_link_pin_link_text_color(pin_node_id, this._theme.pin_text)

      const datum_node_id = this._get_pin_datum_node_id(pin_node_id)

      if (datum_node_id) {
        this._refresh_datum_color(datum_node_id)
      }
    }

    const set_default_color = () => {
      // console.log('set_default_color', pin_node_id)
      this._set_link_pin_link_color(
        pin_node_id,
        this._default_link_color(pin_node_id)
      )
      this._set_link_pin_link_text_color(pin_node_id, this._theme.pin_text)
    }

    if (this._search_unit_id === unitId) {
      const { $theme } = this.$context
      const link_color = getThemeLinkModeColor($theme, this._mode)
      this._set_link_pin_link_color(pin_node_id, link_color)
      this._set_link_pin_link_text_color(pin_node_id, link_color)
    } else if (datum_tree) {
      set_data_color()
    } else {
      set_default_color()
    }
  }

  private _is_link_pin_visible = (pin_node_id: string): boolean => {
    return (
      this._is_link_pin_present(pin_node_id) &&
      (!this._spec_is_link_pin_ignored(pin_node_id) || this._mode === 'add')
    )
  }

  private _is_pin_visible = (pin_node_id: string) => {
    if (this._is_link_pin_node_id(pin_node_id)) {
      return this._is_link_pin_visible(pin_node_id)
    } else {
      return this._is_merge_pin_visible(pin_node_id)
    }
  }

  private _is_merge_pin_visible = (merge_node_id: string): boolean => {
    return this._has_node(merge_node_id)
  }

  private _is_link_pin_present = (pin_node_id: string): boolean => {
    const { type, pinId } = segmentLinkPinNodeId(pin_node_id)

    if (!this._is_link_pin_merged(pin_node_id) && !isSelfPin(type, pinId)) {
      return true
    }

    if (this._is_output_pin_node_id(pin_node_id)) {
      if (this._is_link_pin_ref(pin_node_id)) {
        if (pinId !== SELF) {
          return true
        }
      }
    }

    return false
  }

  private _reset_link_pin_color = (pin_node_id: string): void => {
    // console.log('Graph', '_reset_link_pin_color', pin_node_id)
    if (this._is_link_pin_present(pin_node_id)) {
      this._reset_link_pin_pin_color(pin_node_id)
    }
    this._reset_link_pin_link_color(pin_node_id)
  }

  private _reset_core_border_color = (unit_id: string): void => {
    const { $theme } = this.$context

    if (this._search_unit_id === unit_id) {
      const color = getThemeModeColor($theme, this._mode, 'currentColor')
      this._set_core_and_layout_core_border_color(unit_id, color)
    } else if (this._err[unit_id]) {
      this._set_core_and_layout_core_border_color(unit_id, COLOR_OPAQUE_RED)
    } else if (this._unit_active_pin_count[unit_id] > 0) {
      this._set_core_border_color(unit_id, this._theme.data)
      this._set_layout_core_border_color(unit_id, this._theme.node)
    } else if (this._ref_unit_to_merge[unit_id]) {
      this._set_core_border_color(unit_id, this._theme.data)
      this._set_layout_core_border_color(unit_id, this._theme.node)
    } else {
      const spec = this._get_unit_spec(unit_id)

      const { inputs = {} } = spec

      let has_merged_ref_input: boolean = false

      for (const input_id in inputs) {
        const input = inputs[input_id]
        const { ref } = input
        if (ref) {
          const input_node_id = getInputNodeId(unit_id, input_id)
          const merge_node_id = this._pin_to_merge[input_node_id]
          if (merge_node_id) {
            const merge_unit_id = this._merge_to_ref_unit[merge_node_id]
            if (merge_unit_id) {
              has_merged_ref_input = true
              break
            }
          }
        }
      }

      if (has_merged_ref_input) {
        this._set_core_border_color(unit_id, this._theme.data)
        this._set_layout_core_border_color(unit_id, this._theme.node)
      } else {
        this._set_core_border_color(unit_id, this._theme.node)
        this._set_layout_core_border_color(unit_id, this._theme.node)
      }
    }
  }

  private _reset_soul_color = (unit_id: string): void => {
    this._set_core_icon_color(unit_id, this._theme.node)
    this._set_core_name_color(unit_id, this._theme.node)
    this._set_core_description_color(unit_id, this._theme.sub_text)
  }

  private _reset_datum_color = (datum_node_id: string): void => {
    // console.log('_reset_datum_color', datum_node_id)

    const { $theme } = this.$context

    if (this._search_unit_datum_node_id === datum_node_id) {
      const node_color = getThemeModeColor($theme, this._mode, 'currentColor')
      const link_color = getThemeLinkModeColor($theme, this._mode)

      this._set_datum_color(datum_node_id, node_color, link_color)
    } else {
      const valid = this._is_datum_valid(datum_node_id)

      if (valid) {
        this._set_datum_color(
          datum_node_id,
          this._theme.data,
          this._theme.data_link
        )
      } else {
        this._set_datum_color(datum_node_id, this._theme.type, this._theme.type)
      }
    }
  }

  private _is_datum_valid = (datum_node_id: string): boolean => {
    const datum_pin_node_id = this._datum_to_pin[datum_node_id]

    if (datum_pin_node_id) {
      return this._is_datum_pin_type_match(datum_node_id, datum_pin_node_id)
    }

    const datum_plug_node_id = this._datum_to_plug[datum_node_id]

    if (datum_plug_node_id) {
      return this._is_datum_plug_type_match(datum_node_id, datum_plug_node_id)
    }

    return this._is_datum_tree_valid(datum_node_id)
  }

  private _reset_err_color = (err_node_id: string): void => {
    this._set_err_color(err_node_id, COLOR_OPAQUE_RED)
  }

  private _set_drag_node = (
    node_id: string,
    pointer_id: number,
    dragged: boolean
  ) => {
    // console.log('Graph', '_set_drag_node', node_id, pointer_id, dragged)

    const was_dragged = this._drag_node_id[node_id]

    if (was_dragged && !dragged) {
      this._drag_count--

      delete this._drag_node_id[node_id]

      if (this._is_ext_node_id(node_id)) {
        if (this._drag_ext_node_id.has(node_id)) {
          this._drag_ext_node_id.delete(node_id)
          this._drag_ext_node_count--
        }
      }

      delete this._drag_node_pointer_id[node_id]

      this._drag_pointer_id_node[pointer_id].delete(node_id)
      if (!this._drag_pointer_id_node[pointer_id].size) {
        delete this._drag_pointer_id_node[pointer_id]
      }
    } else if (!was_dragged && dragged) {
      this._drag_count++
      this._drag_node_id[node_id] = true
      this._drag_node_pointer_id[node_id] = pointer_id
      this._drag_pointer_id_node[pointer_id] =
        this._drag_pointer_id_node[pointer_id] ?? new Set()
      this._drag_pointer_id_node[pointer_id].add(node_id)

      if (this._is_ext_node_id(node_id)) {
        if (!this._drag_ext_node_id.has(node_id)) {
          this._drag_ext_node_id.add(node_id)
          this._drag_ext_node_count++
        }
      }
    }

    if (this._collapsing) {
      //
    } else {
      if (this._drag_count === 1) {
        this._start_static()
      } else if (this._drag_count === 0) {
        this._stop_static()
      }
    }

    if (this._drag_count === 1) {
      this._simulation.alphaDecay(0)
    }

    if (this._drag_count === 0) {
      this._simulation.alphaDecay(SIMULATION_DEFAULT_ALPHA_DECAY)
    }
  }

  public resize_sub_component = (
    unit_id: string,
    width: number,
    height: number
  ) => {
    // console.log('Graph', 'resize_sub_component', unit_id, width, height)

    if (this._tree_layout) {
      this._state_layout_resize_sub_component(unit_id, width, height)
    } else {
      this._state_set_unit_size(unit_id, width, height)
    }
  }

  private _state_layout_resize_sub_component = (
    unit_id: string,
    width: number,
    height: number
  ) => {
    this._spec_component_set_unit_graph_size(unit_id, width, height)
    this._sim_layout_resize_sub_component(unit_id, width, height)
  }

  private _state_set_unit_size = (
    unit_id: string,
    width: number,
    height: number
  ) => {
    this._sim_set_unit_size(unit_id, width, height)
    this._spec_set_unit_size(unit_id, width, height)
  }

  private _spec_set_unit_size = (
    unit_id: string,
    width: number,
    height: number
  ): void => {
    // console.log('Graph', '_spec_set_unit_size', unit_id, width, height)

    setUnitMetadata(
      { id: unit_id, path: ['component', 'width'], value: Math.round(width) },
      this._spec
    )
    setUnitMetadata(
      { id: unit_id, path: ['component', 'height'], value: Math.round(height) },
      this._spec
    )

    this._update_max_component_size(unit_id, width, height)
  }

  private _update_max_component_size = (
    unit_id: string,
    width: number,
    height: number
  ): void => {
    const component_max_width_length = this._core_component_max_width.length

    if (component_max_width_length === 0) {
      this._core_component_max_width = [width]
      this._core_component_max_width_id = [unit_id]
    } else {
      for (let i = 0; i < component_max_width_length; i++) {
        if (width > this._core_component_max_width[i]) {
          this._core_component_max_width.splice(i, 0, width)
          this._core_component_max_width_id.splice(i, 0, unit_id)
          break
        }
      }
    }

    const component_max_height_length = this._core_component_max_height.length

    if (component_max_height_length === 0) {
      this._core_component_max_height = [height]
      this._core_component_max_height_id = [unit_id]
    } else {
      for (let i = 0; i < component_max_height_length; i++) {
        if (height > this._core_component_max_height[i]) {
          this._core_component_max_height.splice(i, 0, height)
          this._core_component_max_height_id.splice(i, 0, unit_id)
          break
        }
      }
    }
  }

  private _spec_component_set_default_size = (): void => {
    // console.log('Graph', '_spec_component_set_default_size')

    const defaultWidth = Math.round(
      this._core_component_max_width[this._core_component_max_width.length - 1]
    )
    const defaultHeight = Math.round(
      this._core_component_max_height[
        this._core_component_max_height.length - 1
      ]
    )

    this._spec.component = this._spec.component || {}
    this._spec.component = setSize(
      {
        defaultWidth,
        defaultHeight,
      },
      this._spec.component
    )
  }

  private _pod_component_set_default_size = (): void => {
    // console.log('Graph', '_pod_component_set_default_size')
  }

  private _spec_component_set_unit_graph_size = (
    unit_id: string,
    width: number,
    height: number
  ) => {
    // console.log(
    //   'Graph',
    //   '_spec_component_set_unit_graph_size',
    //   unit_id,
    //   width,
    //   height
    // )

    width = Math.floor(width)
    height = Math.floor(height)

    this._spec.component = this._spec.component || {}

    setSubComponentSize({ unitId: unit_id, width, height }, this._spec)

    this._spec_component_set_default_size()
  }

  private _sim_set_unit_size = (
    unit_id: string,
    width: number,
    height: number
  ): void => {
    // console.log('Graph', '_sim_resize_sub_component', unit_id, width, height)

    this._resize_node(unit_id, width, height)
    this._resize_core(unit_id, width, height)

    const parent_id = this._spec_get_sub_component_parent_id(unit_id)

    this._update_max_component_size(unit_id, width, height)

    this._refresh_layer_layout_target_node_size(parent_id)
    this._refresh_selection_dasharray(unit_id)
  }

  private _resize_layout_core = (
    sub_component_id: string,
    width: number,
    height: number
  ) => {
    // console.log('Graph', '_resize_layout_core', sub_component_id, width, height)

    this.__resize_layout_core(sub_component_id, width, height)

    this._refresh_current_layout_node_target_position()

    this._animate_all_current_layout_layer_node()
  }

  private _scale_layout_core_x = (unit_id: string, sx: number): void => {
    // console.log('Graph', '_scale_layout_core_x', width, height, sx)

    const layout_node = this._layout_node[unit_id]

    layout_node.sx = sx

    this._refresh_layout_core_transform(unit_id)
  }

  private _scale_layout_core_y = (unit_id: string, sy: number): void => {
    // console.log('Graph', '_scale_layout_core_y', width, height)

    const layout_node = this._layout_node[unit_id]

    layout_node.sy = sy

    this._refresh_layout_core_transform(unit_id)
  }

  private _refresh_layout_core_transform = (unit_id): void => {
    // console.log('Graph', '_refresh_layout_core_transform', unit_id)

    const layout_node = this._layout_node[unit_id]
    const layout_core = this._layout_core[unit_id]

    const { sx, sy } = layout_node

    layout_core.$element.style.transform = `translate(-50%, -50%) scale(${sx}, ${sy})`
  }

  private __resize_layout_core = (
    unit_id: string,
    width: number,
    height: number
  ): void => {
    // console.log('Graph', '__resize_layout_core', width, height)

    this._set_layout_core_size(unit_id, width, height)

    if (this._tree_layout) {
      this._resize_core_area(unit_id, width, height)
      this._resize_core_selection(unit_id, width, height)
    }
  }

  private __resize_layout_core_width = (
    unit_id: string,
    width: number
  ): void => {
    // console.log('Graph', '__resize_layout_core_width', width, height)

    this._set_layout_core_size_width(unit_id, width)
    this._resize_core_area_width(unit_id, width)
    this._resize_core_selection_width(unit_id, width)
  }

  private __resize_layout_core_height = (unit_id: string, height: number) => {
    this._set_layout_core_size_height(unit_id, height)
    this._resize_core_area_height(unit_id, height)
    this._resize_core_selection_height(unit_id, height)
  }

  private _set_layout_core_size = (
    sub_component_id: string,
    width: number,
    height: number
  ): void => {
    const layout_core = this._layout_core[sub_component_id]

    this._set_layout_core_size_width(sub_component_id, width)
    this._set_layout_core_size_height(sub_component_id, height)

    layout_core.$element.style.width = `${width}px`
    layout_core.$element.style.height = `${height}px`

    const layout_node = this._layout_node[sub_component_id]

    layout_node.width = width
    layout_node.height = height

    if (this._control_lock) {
      if (this._minimap) {
        this._tick_minimap()
      }
    }
  }

  private _set_layout_core_size_width = (
    sub_component_id: string,
    width: number
  ): void => {
    const layout_core = this._layout_core[sub_component_id]

    const width_ = Math.floor(width)

    layout_core.$element.style.width = `${width_}px`

    const layout_node = this._layout_node[sub_component_id]

    layout_node.width = width
  }

  private _set_layout_core_size_height = (
    sub_component_id: string,
    height: number
  ): void => {
    const layout_core = this._layout_core[sub_component_id]
    const layout_node = this._layout_node[sub_component_id]

    const height_ = Math.floor(height)

    layout_core.$element.style.height = `${height_}px`

    layout_node.height = height
  }

  private _resize_core = (
    unit_id: string,
    width: number,
    height: number
  ): void => {
    // console.log('Graph', '_resize_core', unit_id, width, height)

    this._resize_core_width(unit_id, width)
    this._resize_core_height(unit_id, height)
  }

  private _resize_core_width = (unit_id: string, width: number): void => {
    // console.log('Graph', '_resize_core_width', unit_id, width)

    const core = this._core[unit_id]

    core.$element.style.width = `${width}px`

    this._resize_core_area_width(unit_id, width)
    this._resize_core_selection_width(unit_id, width)
  }

  private _resize_core_height = (unit_id: string, height: number): void => {
    // console.log('Graph', '_resize_core_height', unit_id, height)

    const core = this._core[unit_id]

    core.$element.style.height = `${height}px`

    this._resize_core_area_height(unit_id, height)
    this._resize_core_selection_height(unit_id, height)
  }

  private _resize_core_selection = (
    unit_id: string,
    width: number,
    height: number
  ): void => {
    this._resize_selection(unit_id, width + 2, height + 2)
  }

  private _resize_core_selection_width = (
    unit_id: string,
    width: number
  ): void => {
    const selection_opt = this._get_selection_opt(unit_id)

    const selection = this._node_selection[unit_id]

    const { paddingX } = selection_opt

    const _width = width + paddingX

    selection.setProp('width', _width)

    selection_opt.width = width
  }

  private _resize_core_selection_height = (
    unit_id: string,
    height: number
  ): void => {
    const selection_opt = this._get_selection_opt(unit_id)

    const selection = this._node_selection[unit_id]

    const { paddingY } = selection_opt

    const _height = height + paddingY

    selection.setProp('height', _height)

    selection_opt.height = height
  }

  private _resize_core_area = (
    unit_id: string,
    width: number,
    height: number
  ) => {
    const core_area = this._core_area[unit_id]

    this._resize_core_area_width(unit_id, width)
    this._resize_core_area_height(unit_id, height)
  }

  private _resize_core_area_width = (unit_id: string, width: number) => {
    const core_area = this._core_area[unit_id]

    core_area.$element.style.width = `${width + NODE_PADDING + 2}px`
  }

  private _resize_core_area_height = (unit_id: string, height: number) => {
    const core_area = this._core_area[unit_id]

    core_area.$element.style.height = `${height + NODE_PADDING + 2}px`
  }

  private _sim_layout_resize_sub_component = (
    unit_id: string,
    width: number,
    height: number
  ): void => {
    // console.log('Graph', '_layout_resize_component', unit_id, width, height)

    this._resize_layout_core(unit_id, width, height)

    const layout_target_node = this._layout_target_node[unit_id]

    layout_target_node.width = width
    layout_target_node.height = height

    this._refresh_selection_dasharray(unit_id)
  }

  private _resize_node = (
    node_id: string,
    width: number,
    height: number
  ): void => {
    // console.log('Graph', '_resize_node', node_id, width, height)

    this._resize_node_width(node_id, width)
    this._resize_node_height(node_id, height)
  }

  private _resize_node_width = (node_id: string, width: number): void => {
    // console.log('Graph', '_resize_node_width', node_id, width)

    const node = this.get_node(node_id)

    node.r = width / 2
    node.width = width

    const node_content = this._node_content[node_id]

    node_content.$element.style.transform = `translate(-${width / 2}px, -${
      node.height / 2
    }px)`

    if (this._minimap) {
      this._tick_minimap()
    }
  }

  private _resize_node_height = (node_id: string, height: number): void => {
    // console.log('Graph', '_resize_node_height', node_id, height)

    const node = this.get_node(node_id)

    node.r = height / 2
    node.height = height

    const node_content = this._node_content[node_id]

    node_content.$element.style.transform = `translate(-${node.width / 2}px, -${
      height / 2
    }px)`

    if (this._minimap) {
      this._tick_minimap()
    }
  }

  private _resize_datum = (
    datum_node_id: string,
    width: number,
    height: number
  ) => {
    this._resize_node(datum_node_id, width, height)

    const datum_container = this._datum_container[datum_node_id]

    datum_container.$element.style.width = `${width}px`
    datum_container.$element.style.height = `${height}px`

    const datum_area = this._datum_area[datum_node_id]

    datum_area.$element.style.width = `${width + NODE_PADDING}px`
    datum_area.$element.style.height = `${height + NODE_PADDING}px`

    this._resize_selection(datum_node_id, width, height)
    this._refresh_datum_overflow(datum_node_id)
    this._start_graph_simulation(LAYER_DATA_LINKED)
  }

  private _get_node_selection_length = (
    node_id: string,
    paddingX: number,
    paddingY: number
  ): number => {
    const node = this.get_node(node_id)
    const { shape } = node
    const padding = paddingX + paddingY
    if (shape === 'circle') {
      const { r } = node
      return 2 * Math.PI * (r + padding / 4)
    } else {
      const { width, height } = node
      return 2 * (width + height + padding)
    }
  }

  private _get_node_selection_dashoffset = (
    node_id: string,
    paddingX: number,
    paddingY: number
  ): number => {
    const l = this._get_node_selection_length(node_id, paddingX, paddingY)

    const node = this.get_node(node_id)

    const { shape } = node

    if (shape === 'circle') {
      return -l / 16
    } else {
      return 0
    }
  }

  private _create_selection = (
    node_id: string,
    selection_opt: SelectionOpt
  ): Selection => {
    let { strokeDasharray } = selection_opt

    const {
      width,
      height,
      shape,
      stroke = '#00000000',
      strokeWidth = 1,
      paddingX = 6,
      paddingY = 6,
    } = selection_opt

    const strokeDashOffset = this._get_node_selection_dashoffset(
      node_id,
      paddingX,
      paddingY
    )
    strokeDasharray =
      strokeDasharray ||
      this._get_node_selection_dasharray(node_id, paddingX, paddingY)

    const selection = new Selection(
      {
        width: width + paddingX,
        height: height + paddingY,
        shape,
        stroke,
        strokeWidth,
        strokeDasharray,
        strokeDashOffset,
        style: {
          ...userSelect('none'),
        },
      },
      this.$system
    )

    this._node_selection[node_id] = selection
    this._selection_opt[node_id] = selection_opt

    return selection
  }

  private _resize_selection = (
    node_id: string,
    width: number,
    height: number
  ): void => {
    // console.log('Graph', '_resize_selection', node_id, width, height)

    const selection_opt = this._get_selection_opt(node_id)

    const selection = this._node_selection[node_id]

    const {
      paddingX = DEFAULT_SELECTION_PADDING,
      paddingY = DEFAULT_SELECTION_PADDING,
    } = selection_opt

    const _width = width + paddingX
    const _height = height + paddingY

    selection.setProp('width', _width)
    selection.setProp('height', _height)

    selection_opt.width = width
    selection_opt.height = height

    this._refresh_selection_dasharray(node_id)
    this._refresh_selection_dashoffset(node_id)
  }

  private _create_overlay = ({
    className,
  }: { className?: string } = {}): Div => {
    const overlay_el = new Div(
      {
        className,
        style: {
          position: 'absolute',
          top: '0',
          width: 'calc(100% + 2px)',
          height: 'calc(100% + 2px)',
          zIndex: `${MAX_Z_INDEX - 1}`,
          transform: 'translate(-1px, -1px)',
          ...userSelect('none'),
        },
      },
      this.$system
    )
    return overlay_el
  }

  private _id: string = `${i++}`

  private _link_start_marker_id = (link_id: string): string => {
    return `${this._id}-link-start-${hashCode(link_id)}`
  }

  private _link_end_marker_id = (link_id: string): string => {
    return `${this._id}-link-end-${hashCode(link_id)}-end`
  }

  private _create_pin = ({
    className,
    style,
    r,
    shape = 'circle',
  }: {
    className: string
    style: Dict<string>
    r: number
    shape: Shape
  }): Div => {
    const width = 2 * r
    const height = 2 * r

    const pin = new Div(
      {
        className,
        style: {
          position: 'absolute',
          width: `${width}px`,
          height: `${height}px`,
          borderRadius: shape === 'circle' ? '50%' : '0',
          borderWidth: '1px',
          borderColor: COLOR_NONE,
          borderStyle: 'solid',
          backgroundColor: COLOR_NONE,
          boxSizing: 'border-box',
          ...style,
        },
      },
      this.$system
    )

    pin.preventDefault('mousedown')
    pin.preventDefault('touchdown')

    return pin
  }

  private _create_pin_name = ({
    className,
    name,
    r,
    dx = 0,
    dy = 0,
    style,
  }: {
    className: string
    r: number
    dx?: number
    dy?: number
    style: Dict<string>
    name: string
  }): TextField => {
    const pin_name = new TextField(
      {
        className,
        value: name,
        style: {
          position: 'absolute',
          borderWidth: '0px',
          borderStyle: 'solid',
          borderColor: COLOR_NONE,
          // backgroundColor: setAlpha(randomColorString(), 0.5),
          fontSize: `${PIN_NAME_FONT_SIZE}px`,
          textAlign: 'center',
          justifyContent: 'center',
          width: `${name.length * 6}px`,
          height: 'auto',
          left: `${r + dx}px`,
          top: `${2 * r + 2 + dy}px`,
          transform: 'translateX(-50%)',
          overflowY: 'hidden',
          overflowX: 'hidden',
          pointerEvents: 'none',
          touchAction: 'none',
          ...userSelect('none'),
          ...style,
          border: '1px solid red',
        },
        attr: {
          tabIndex: -1,
        },
        maxLength: PIN_NAME_MAX_SIZE,
      },
      this.$system
    )

    return pin_name
  }

  private _create_link = (link_id: string, link_opt: LinkProps) => {
    const {
      style,
      hidden = false,
      stroke = this._theme.link,
      strokeWidth = 3,
      strokeDasharray = 0,
      text = '',
      textHidden = true,
      textVisibility = 'visible',
      textOpacity = 1,
      startMarker = null,
      startMarkerX = 0,
      endMarker = null,
      endMarkerX = 0,
      opacity = 1,
    } = link_opt

    const link_start_start_id = this._link_start_marker_id(link_id)
    const link_start_start = this._create_link_marker(link_start_start_id, {
      component: startMarker,
      x: startMarkerX,
    })
    if (startMarker) {
      this._link_marker_start[link_id] = startMarker
    }
    const link_end_id = this._link_end_marker_id(link_id)
    const link_end_end = this._create_link_marker(link_end_id, {
      component: endMarker,
      x: endMarkerX,
    })
    if (endMarker) {
      this._link_marker_end[link_id] = endMarker
    }
    const link_defs = new SVGDefs({}, this.$system)
    link_defs.appendChild(link_start_start)
    link_defs.appendChild(link_end_end)

    const link_base_id = `${this._id}-link-base-${link_id}`
    const link_base = new SVGPath(
      {
        // id: link_base_id,
        className: 'link-base',
        attr: {
          'marker-start': `url(#${link_start_start_id})`,
          'marker-end': `url(#${link_end_id})`,
          'stroke-linecap': 'normal',
        },
        style: {
          display: hidden ? 'none' : 'block',
          strokeWidth: `${strokeWidth}`,
          stroke,
          strokeDasharray: `${strokeDasharray}px`,
          opacity: `${opacity}`,
        },
      },
      this.$system
    )
    this._link_base[link_id] = link_base

    const link_base_area = new SVGPath(
      {
        // id: link_base_id,
        className: 'link-base-area',
        style: {
          display: hidden ? 'none' : 'block',
          strokeWidth: `${6 + strokeWidth}`,
          stroke: COLOR_NONE,
        },
        attr: { 'stroke-linecap': 'normal' },
      },
      this.$system
    )
    this._link_base_area[link_id] = link_base_area
    this._link_text_value[link_id] = text

    const link_base_text = new SVGPath(
      {
        id: link_base_id,
        className: 'link-base-text',
        style: {
          strokeWidth: `${strokeWidth}`,
          stroke: COLOR_NONE,
          ...userSelect('none'),
        },
        attr: { 'stroke-linecap': 'normal' },
      },
      this.$system
    )
    this._link_base_text[link_id] = link_base_text

    const link_text_path = new SVGTextPath(
      {
        href: `#${link_base_id}`,
        startOffset: '50%',
        spacing: 'auto',
        lengthAdjust: 'spacingAndGlyphs',
        textContent: text,
        style: {
          strokeWidth: '0px',
        },
        ...userSelect('none'),
      },
      this.$system
    )
    this._link_text_path[link_id] = link_text_path

    const link_text = new SVGText(
      {
        dy: '12',
        dx: '0',
        textAnchor: 'start',
        style: {
          display: textHidden ? 'none' : 'block',
          opacity: `${textOpacity}`,
          visibility: textVisibility,
          fill: this._theme.pin_text,
          fontSize: `${LINK_TEXT_FONT_SIZE}px`,
          ...userSelect('none'),
        },
      },
      this.$system
    )

    link_text.appendChild(link_text_path)

    this._link_text[link_id] = link_text

    const link = new SVGG(
      {
        className: 'link',
        style,
      },
      this.$system
    )

    link.appendChild(link_defs)
    link.appendChild(link_base)
    link.appendChild(link_base_area)
    link.appendChild(link_base_text)
    link.appendChild(link_text)

    return link
  }

  private _create_link_marker = (
    id: string,
    { component, x = 0 }: LinkMarkerOpt
  ): SVGMarker => {
    const marker = new SVGMarker(
      {
        id,
        markerHeight: 30,
        markerWidth: 30,
        refX: 0 + x,
        refY: 1,
        orient: 'auto-start-reverse',
        style: {
          overflow: 'visible',
          transformOrigin: '0px 0px',
        },
      },
      this.$system
    )
    if (component) {
      marker.appendChild(component)
    }
    return marker
  }

  private _simulation_prevent_restart: boolean = false

  private _start_graph_simulation = (layer: number): void => {
    // console.log('Graph', '_start_simulation', layer)

    if (this._simulation_prevent_restart) {
      return
    }

    if (this._simulation_end) {
      this._simulation_layer = layer
    } else {
      this._simulation_layer = Math.min(this._simulation_layer, layer)
    }

    this._simulation_end = false

    this._simulation.alpha(0.25)
    this._simulation.start()
  }

  private _stop_graph_simulation = (): void => {
    // console.log('Graph', '_stop_simulation')

    this._simulation.stop()
  }

  private _get_current_layout_layer_id = (): string | null => {
    const current_layout_layer_id = last(this._layout_path) || null

    return current_layout_layer_id
  }

  private _get_current_layout_layer = (): LayoutLayer => {
    const layout_id = this._get_current_layout_layer_id()

    return this._get_layout_layer(layout_id)
  }

  private _get_layout_layer = (parent_id: string | null): LayoutLayer => {
    if (parent_id) {
      return this._layout_layer[parent_id]
    } else {
      return this._layout_root
    }
  }

  private _spec_get_layout_layer_children = (
    layer: string | null
  ): string[] => {
    if (layer) {
      return this._spec_get_sub_component_children(layer)
    } else {
      return this._spec_get_component_children()
    }
  }

  private _get_layout_layer_parent_children = (
    sub_component_id: string
  ): string[] => {
    const parent_id =
      this._layout_sub_component_parent[sub_component_id] || null
    return this._spec_get_layout_layer_children(parent_id)
  }

  private _get_current_layout_layer_children = (): string[] => {
    const current_layout_layer = this._get_current_layout_layer_id()

    return this._spec_get_layout_layer_children(current_layout_layer)
  }

  private _high_zoom: boolean = false

  private _set_zoom = (zoom: Zoom) => {
    // console.log('Graph', '_set_zoom', zoom)

    const {
      zoom: { maxZoom, minZoom },
    } = this._config()

    const { $height, $width } = this.$context

    this._zoom = zoom

    const { z, x, y } = zoom

    this._zoom_comp.setProp('zoom', zoom)
    this._zoom_comp_alt.setProp('zoom', zoom)

    if (this._tree_layout) {
      //
    } else {
      if (this._minimap_screen) {
        this._minimap_screen.setProp('x', x - 4.5)
        this._minimap_screen.setProp('y', y - 4.5)
        this._minimap_screen.setProp('width', $width / z)
        this._minimap_screen.setProp('height', $height / z)
      }
    }

    // if (k > 3) {
    //   this._main.$element.opacity = `${(6 - k) / 3}`
    // } else if (k < 1) {
    //   this._main.$element.opacity = `${k - 0.5}`
    // } else {
    //   this._main.$element.opacity = '1'
    // }

    if (z > 0.75 * maxZoom) {
      if (!this._high_zoom) {
        this._on_high_zoom()
      }
    } else {
      if (this._high_zoom) {
        this._on_low_zoom()
      }
    }

    this._maybe_refresh_simulation_by_drag()
  }

  public set_zoom = (zoom: Zoom) => {
    // console.log('Graph', '_set_zoom', zoom)

    const dx = zoom.x - this._zoom.x
    const dy = zoom.y - this._zoom.y
    const dk = zoom.z - this._zoom.z

    this._zoom = zoom

    const { z, x, y } = zoom

    this._set_zoom(zoom)

    this.dispatchEvent('zoom', { z, x, y, dk, dx, dy }, false)
  }

  private _on_high_zoom = () => {
    this._high_zoom = true
    // console.log('_on_high_zoom')
    // for (const pin_node_id in this._pin_name) {
    //   const pin_name = this._pin_name[pin_node_id]
    // }
    // for (const unit_id in this._core_name) {
    //   const core_name = this._core_name[unit_id]
    // }
  }

  private _on_low_zoom = (): void => {
    this._high_zoom = false
    // console.log('_on_low_zoom')
    // for (const pin_node_id in this._pin_name) {
    //   const pin_name = this._pin_name[pin_node_id]
    // }
    // for (const unit_id in this._core_name) {
    //   const core_name = this._core_name[unit_id]
    // }
  }

  private _on_zoom_start = () => {
    // console.log('Graph', '_on_zoom_start')
  }

  private _on_zoom_end = () => {
    const {
      api: {
        animation: { requestAnimationFrame, cancelAnimationFrame },
      },
    } = this.$system

    if (this._zoom.z < 1 && this._pointer_down_count < 2) {
      const zoom_spring_frame = () => {
        const { $width, $height } = this.$context
        this._zoom_in(-100, $width / 2, $height / 2)
        if (this._zoom.z < 1) {
          requestAnimationFrame(zoom_spring_frame)
        }
      }
      requestAnimationFrame(zoom_spring_frame)
    }
  }

  private _on_pointer_leave = (event: UnitPointerEvent) => {
    // console.log('Graph', '_on_pointer_leave')

    const { pointerId } = event

    this.__on_pointer_leave(pointerId)
  }

  private __on_pointer_leave = (pointerId: number) => {
    // console.log('Graph', '_on_pointer_leave')

    const pointer_hover_node_id = this._pointer_id_hover_node_id[pointerId]

    // AD HOC
    // Safari (iOS) might not dispatch node "pointerleave" event,
    // possibly due to forced pointer swap
    if (pointer_hover_node_id) {
      this.__on_node_pointer_leave(pointer_hover_node_id, pointerId)
    }

    this.__on_pointer_up(pointerId)
  }

  private _pointer_inside: Dict<boolean> = {}

  private _on_pointer_enter = (event: UnitPointerEvent): void => {
    // console.log('Graph', '_on_pointer_enter')
  }

  private _on_pointer_cancel = (event: UnitPointerEvent) => {
    // console.log('Graph', '_on_pointer_cancel')

    this._on_pointer_up(event)
  }

  private _screen_center = (): Position => {
    return {
      x: this._width / 2,
      y: this._height / 2,
    }
  }

  private _world_screen_center = (
    offset_x: number = 0,
    offset_y: number = 0
  ): Position => {
    const { x, y } = this._screen_center()

    const world_screen_center = this._screen_to_world(
      x + offset_x,
      y + offset_y
    )

    return world_screen_center
  }

  private _screen_to_world = (x: number, y: number): Position => {
    const position = {
      x: x / this._zoom.z + this._zoom.x,
      y: y / this._zoom.z + this._zoom.y,
    }
    return position
  }

  private _world_to_screen = (x: number, y: number): Position => {
    const position = {
      x: (x - this._zoom.x) * this._zoom.z,
      y: (y - this._zoom.y) * this._zoom.z,
    }
    return position
  }

  public jiggle_world_screen_center = (): Position => {
    return this._jiggle_world_screen_center()
  }

  private _jiggle_world_screen_center = (
    offset_x: number = 0,
    offset_y: number = 0
  ): Position => {
    const screen_center = this._world_screen_center(offset_x, offset_y)
    const jiggled_screen_center = jigglePoint(screen_center)
    return jiggled_screen_center
  }

  private _distance_to_center = (point: Point): number => {
    const center = this._world_screen_center()
    const d = pointDistance(point, center)
    return d
  }

  private _set_node_position = (node_id: string, position: Position): void => {
    // console.log('Graph', '_set_node_position', node_id, position)
    const node = this.get_node(node_id)
    const { x, y } = position
    node.x = x
    node.y = y
    if (node.fx !== undefined) {
      node.fx = x
    }
    if (node.fy !== undefined) {
      node.fy = y
    }
  }

  private _set_node_x = (node_id: string, x: number): void => {
    // console.log('Graph', '_set_node_x', node_id, x)

    const node = this.get_node(node_id)

    node.x = x

    if (node.fx !== undefined) {
      node.fx = x
    }
  }

  private _set_node_y = (node_id: string, y: number): void => {
    // console.log('Graph', '_set_node_y', node_id, y)

    const node = this.get_node(node_id)

    node.y = y

    if (node.fy !== undefined) {
      node.fy = y
    }
  }

  private _set_node_layer = (node_id: string, layer: number): void => {
    // console.log('Graph', '_set_node_layer', node_id, layer)

    const node = this.get_node(node_id)

    const { layer: prev_layer } = node

    delete this._layer_node[Math.abs(prev_layer)][node_id]

    this._node_layer[node_id] = layer

    this._layer_node[Math.abs(layer)][node_id] = node

    node.layer = layer
  }

  private _set_link_layer = (link_id: string, layer: number): void => {
    // console.log('Graph', '_set_link_layer', link_id, layer)

    const prev_layer = this._link_layer[link_id]

    delete this._layer_link[Math.abs(prev_layer)][link_id]

    const link = this._link[link_id]

    this._layer_link[Math.abs(layer)][link_id] = link

    this._link_layer[link_id] = layer
  }

  public get_node = (node_id: string): GraphSimNode => {
    const node = this._node[node_id]

    return node
  }

  public get_layout_node = (node_id: string): LayoutNode => {
    const node = this._layout_node[node_id]

    return node
  }

  public get_nodes = (): GraphSimNodes => {
    return this._node
  }

  private _get_node_position = (node_id: string): Position => {
    const node = this.get_node(node_id)

    const { x, y } = node

    return { x, y }
  }

  private _get_anchor_node = (node_id: string): SimNode => {
    const anchor_node_id = this._get_node_anchor_node_id(node_id)

    return this.get_node(anchor_node_id)
  }

  private _get_anchor_node_position = (node_id: string): Position => {
    const anchor_node_id = this._get_node_anchor_node_id(node_id)

    return this._get_node_position(anchor_node_id)
  }

  private __get_merge_node_position = (merge_id: string): Position => {
    const merge_node_id = getMergeNodeId(merge_id)

    const merge_anchor_node_id = this._get_merge_anchor_node_id(merge_node_id)

    return this._get_node_position(merge_anchor_node_id)
  }

  private _get_node_screen_position = (node_id: string): Position => {
    const node = this.get_node(node_id)

    const { x: _x, y: _y, width, height } = node

    const { x, y } = this._world_to_screen(_x - width / 2, _y - height / 2)

    return { x, y }
  }

  private _get_node_size = (node_id: string): Size => {
    const node = this.get_node(node_id)

    const { width, height } = node

    return { width, height }
  }

  private _get_node_shape = (node_id: string): Shape => {
    const node = this.get_node(node_id)
    const { shape } = node
    return shape
  }

  private _get_node_r = (node_id: string): number => {
    const node = this.get_node(node_id)
    const { r } = node
    return r
  }

  private _on_search_item_selected = ({ id }: { id: string }) => {
    // console.log('Graph', '_on_search_item_selected', id)

    if (!this._control_lock) {
      return
    }

    if (!this._search_hidden) {
      this._state_swap_search_unit(id)
    }

    this._refresh_search_list_height_offset()

    if (this._tree_layout) {
      this._layout_scroll_search_unit_into_view()
    }
  }

  private _layout_scroll_search_unit_into_view = () => {
    if (this._search_unit_id) {
      // console.log('Graph', '_layout_scroll_search_unit_into_view')

      const unit_id = this._search_unit_id

      if (this._is_unit_component(unit_id)) {
        const layout_target_node = this._layout_target_node[unit_id]

        const { $height } = this.$context

        const { y } = layout_target_node

        const layer_id = this._get_current_layout_layer_id()

        this._layout_set_layer_scroll_top(layer_id, y + $height / 2)
      }
    }
  }

  private _layout_set_layer_scroll_top = (
    layer_id: string,
    top: number
  ): void => {
    // console.log('Graph', '_layout_set_layer_scroll_top', layer_id, top)

    const layout_layer = this._get_layout_layer(layer_id)

    layout_layer.content.$element.scrollTop = top
  }

  private _refresh_search_list_height_offset = () => {
    // console.log('Graph', '_refresh_search_list_height_offset')

    if (this._search) {
      const search_rect = this._search._list.getRect()

      const { $x, $y, $width, $height } = this.$context

      const { x, y, width, height } = search_rect

      let offset_y = Math.min(height, $y + $height - y)

      if ($y + $height < y) {
        offset_y = 0
      }

      const current_layer_id = this._get_current_layout_layer_id()

      this._set_layout_search_offset_y(current_layer_id, offset_y)
    }
  }

  private _state_swap_search_unit = (id: string, next_unit_id?: string) => {
    if (this._search_start_spec_id !== id) {
      this._search_unit_spec_id_changed = true
    }

    if (
      this._mode === 'add' ||
      this._mode === 'multiselect' ||
      this._mode === 'remove'
    ) {
      this._state_swap_add_search_unit(id)
    } else if (this._mode === 'change') {
      this._state_swap_change_search_unit(id, next_unit_id)
    } else if (this._mode === 'data') {
      this._state_swap_data_search_unit(id)
    }
  }

  private _state_swap_add_search_unit = (id: string): void => {
    // console.log('Graph', '_state_swap_add_search_unit', id)

    const { specs } = this.$props

    const search_unit_id = this._search_unit_id

    let position: Position

    if (this._search_unit_graph_position) {
      position = this._search_unit_graph_position
    } else {
      const screen_center = this._world_screen_center()

      const u = randomUnitVector()

      position = {
        x:
          screen_center.x + u.x + this._search_dock_offset_x / this._zoom.z / 2,
        y:
          screen_center.y + u.y - this._search_dock_offset_y / this._zoom.z / 2,
      }
    }

    const is_component = isComponentId(specs, id)

    let layout_node: Position

    if (this._search_unit_id) {
      if (is_component) {
        if (this._is_unit_component(this._search_unit_id)) {
          layout_node = this._layout_node[this._search_unit_id]
        }
      }

      this._state_remove_search_unit()
    } else {
      if (this._mode === 'add') {
        this._search_fallback_position = this._world_screen_center()
      }
    }

    const unit_id = this._new_unit_id(id)

    const pin_position = emptyIO({}, {})

    this._add_search_unit(unit_id, id, position, pin_position, layout_node)

    if (this._is_unit_component(unit_id)) {
      if (this._search_unit_component_size) {
        const { width, height } = this._search_unit_component_size

        this.resize_sub_component(unit_id, width, height)
      }
    }

    const current_layout_layer_id = this._get_current_layout_layer_id()

    this._refresh_layout_node_target_position(current_layout_layer_id)

    this._refresh_node_color(unit_id)
  }

  private _state_swap_change_search_unit = (
    spec_id: string,
    next_unit_id?: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_state_swap_change_search_unit',
    //   spec_id,
    //   next_unit_id
    // )

    const { getSpec } = this.$props

    if (this._search_unit_spec_id !== spec_id) {
      this._flush_debugger()

      const search_unit_id = this._search_unit_id

      if (search_unit_id) {
        const new_unit_id = next_unit_id ?? this._new_unit_id(spec_id)

        const search_option_valid_pin_matches =
          this._search_option_valid_pin_matches[spec_id]

        const {
          input: valid_input_matches = { ref: [], data: [] },
          output: valid_output_matches = { ref: [], data: [] },
        } = search_option_valid_pin_matches

        const valid_pin_match_selection = 0

        const valid_input_data_match: [number, number][] =
          valid_input_matches.data[valid_pin_match_selection] || []
        const valid_output_data_match =
          valid_output_matches.data[valid_pin_match_selection] || []

        const valid_input_ref_match =
          valid_input_matches.ref[valid_pin_match_selection] || []
        const valid_output_ref_match =
          valid_output_matches.ref[valid_pin_match_selection] || []

        const valid_pin_match: IOOf<{
          ref: [number, number][]
          data: [number, number][]
        }> = {
          input: {
            data: valid_input_data_match,
            ref: valid_input_ref_match,
          },
          output: {
            data: valid_output_data_match,
            ref: valid_output_ref_match,
          },
        }

        const spec = getSpec(spec_id)

        const {
          next_swap_merges,
          next_merged_pin_ids,
          next_ref_merge_id,
          next_ref_merge,
          next_merged_pin_index,
          next_exposed_pin_index,
        } = this._state_swap_unit(
          search_unit_id,
          new_unit_id,
          spec_id,
          spec,
          valid_pin_match,
          this._search_unit_merged_pin_ids,
          this._search_unit_merged_pin_index,
          this._search_unit_exposed_pin_ids,
          this._search_unit_exposed_pin_index,
          this._search_start_component_index
        )

        this._search_unit_id = new_unit_id
        this._search_unit_merges = next_swap_merges
        this._search_unit_merged_pin_ids = next_merged_pin_ids
        this._search_unit_merged_pin_index = next_merged_pin_index
        this._search_unit_exposed_pin_index = next_exposed_pin_index
        this._search_unit_spec_id = spec_id
        this._search_unit_ref_merge_id = next_ref_merge_id
        this._search_unit_ref_merge = next_ref_merge

        this._refresh_node_color(new_unit_id)

        if (this._tree_layout) {
          this._refresh_search_list_height_offset()
          this._refresh_all_layout_node_target_position()
          this._force_all_layout_node_traits()
          this._layout_scroll_search_unit_into_view()
        }
      }
    }
  }

  private _data_search_unit = (unit_id: string, id: string): void => {
    // console.log('Graph', '_data_search_unit')
  }

  private _add_data_search_unit = (
    spec_id: string,
    position: Position
  ): void => {
    const { datum_id, datum_node_id } = this._add_data_unit(
      { unit: { id: spec_id } },
      position
    )

    this._search_unit_datum_id = datum_id
    this._search_unit_datum_node_id = datum_node_id
    this._search_unit_datum_start_position =
      this._get_node_position(datum_node_id)
    this._search_unit_datum_spec_id = spec_id
  }

  private _add_data_unit = (
    bundle: UnitBundleSpec,
    position: Position
  ): { datum_id; datum_node_id } => {
    const datum_id = this._new_datum_id()

    const datum_node_id = getDatumNodeId(datum_id)

    const value = `$${stringify(bundle)}`

    this._add_datum(datum_id, value, position)

    return { datum_id, datum_node_id }
  }

  private _remove_data_search_unit = (): void => {
    if (this._search_unit_datum_node_id) {
      this._remove_datum(this._search_unit_datum_node_id)

      this._mem_remove_search_datum()
    }
  }

  private _state_swap_data_search_unit = (id: string): void => {
    // console.log('Graph', '_state_swap_data_search_unit')

    if (this._search_unit_datum_id) {
      this._remove_data_search_unit()
    }
    const position = this._jiggle_world_screen_center()
    this._add_data_search_unit(id, position)
  }

  private _new_unit_id = (
    spec_id: string,
    blacklist: Set<string> = new Set(),
    specs: Specs = this.$props.specs ?? {}
  ): string => {
    return newUnitId(specs, this._spec, spec_id, blacklist)
  }

  private _new_merge_id = (blacklist: Set<string> = new Set()): string => {
    return newMergeIdInSpec(this._spec, blacklist)
  }

  private _new_datum_id = (blacklist: Set<string> = new Set()): string => {
    let datum_id: string
    do {
      datum_id = randomIdNotIn(this._datum_tree)
    } while (blacklist.has(datum_id))
    return datum_id
  }

  private _new_pin_id = (
    type: IO,
    pin_id: string,
    blacklist: Set<string> = new Set()
  ): string => {
    let new_pin_id: string = pin_id
    let i = 0
    while (
      this._has_exposed_pin_named(type, new_pin_id) ||
      blacklist.has(new_pin_id)
    ) {
      new_pin_id = `${pin_id}${i}`
      i++
    }
    return new_pin_id
  }

  private _new_input_id = (
    input_id: string,
    blacklist: Set<string> = new Set()
  ): string => {
    return this._new_pin_id('input', input_id, blacklist)
  }

  private _new_output_id = (
    output_id: string,
    blacklist: Set<string> = new Set()
  ): string => {
    return this._new_pin_id('output', output_id, blacklist)
  }

  private _new_sub_pin_id = (
    type: IO,
    pin_id: string,
    blacklist: Set<string> = new Set()
  ): string => {
    const exposed_pin_spec = this._get_pin_spec(type, pin_id)

    if (!exposed_pin_spec) {
      return newSubPinId({}, blacklist)
    }

    const id = newSubPinId(exposed_pin_spec, blacklist)

    return id
  }

  private _state_remove_search_unit = (): void => {
    // console.log('Graph', '_state_remove_search_unit')

    if (this._search_unit_id) {
      this._state_remove_unit(this._search_unit_id, false)

      this._mem_remove_search_unit_id()
    }
  }

  private _get_sub_component_target_parent_id = (): string | null => {
    let parent_id: string | null = null

    if (this._tree_layout) {
      const current_layout_layer = this._get_current_layout_layer_id()

      if (current_layout_layer) {
        parent_id = current_layout_layer
      }
    }

    return parent_id
  }

  private _refresh_unit_description_color = (unit_id: string): void => {
    const { $theme } = this.$context

    if (this._search_unit_id === unit_id) {
      let mode_ = this._mode

      if (mode_ === 'multiselect' || mode_ === 'info') {
        mode_ = 'add'
      }

      this._set_core_description_color(
        unit_id,
        getThemeModeColor($theme, mode_, 'currentcolor')
      )
    } else {
      this._set_core_description_color(unit_id, this._theme.sub_text)
    }
  }

  private _add_search_unit = (
    unit_id: string,
    spec_id: string,
    position: Position,
    pin_position: UnitPinPosition = {
      input: {},
      output: {},
    },
    layout_position: Position
  ): void => {
    // console.log('Graph', '_add_search_unit', unit_id, spec_id)

    const { specs, getSpec } = this.$props

    const { $theme } = this.$context

    this._search_unit_id = unit_id
    this._search_unit_spec_id = spec_id

    // set ignored true if defaultIgnored is true

    const spec = getSpec(spec_id)

    const { inputs = {}, outputs = {} } = spec

    const input = {}
    for (const inputId in inputs) {
      input[inputId] = {}
      const inputSpec = inputs[inputId]
      const { defaultIgnored } = inputSpec
      if (defaultIgnored === true) {
        input[inputId].ignored = true
      }
    }
    const output = {}
    for (const outputId in outputs) {
      output[outputId] = {}
      const outputSpec = outputs[outputId]
      const { defaultIgnored } = outputSpec
      if (defaultIgnored === true) {
        output[outputId].ignored = true
      }
    }

    const unit_spec: GraphUnitSpec = {
      id: spec_id,
      input,
      output,
    }

    this._spec_add_unit(unit_id, unit_spec, false)

    let parent_id: string | null = null

    const is_component = this._is_unit_component(unit_id)

    if (is_component) {
      parent_id = this._get_sub_component_target_parent_id()

      this._spec_append_component(parent_id, unit_id)
    }

    this._sim_add_unit(
      unit_id,
      unit_spec,
      position,
      {},
      pin_position,
      parent_id,
      layout_position
    )

    this._show_core_description(unit_id)

    this._refresh_unit_description_color(unit_id)

    const link_color = getThemeLinkModeColor($theme, this._mode)
    const node_color = getThemeModeColor($theme, this._mode, 'currentColor')

    const pin_icon_color = node_color

    this._set_unit_color(
      unit_id,
      node_color,
      link_color,
      link_color,
      pin_icon_color
    )

    if (this._mode === 'add' || this._mode === 'remove') {
      this._set_unit_layer(unit_id, LAYER_SEARCH)
    }

    this._refresh_layout_node_target_position(parent_id)

    if (is_component) {
      if (this._tree_layout) {
        this._move_all_layout_node_target_position(parent_id)
      }
    }

    this._set_zoom_target(unit_id)

    this._refresh_search_list_height_offset()
    this._refresh_layout_node_target_position(parent_id)

    if (this._tree_layout) {
      this._layout_scroll_search_unit_into_view()
    }
  }

  private _set_unit_layer = (unit_id: string, layer: number): void => {
    // console.log('Graph', '_set_unit_layer', unit_id, layer)

    this._set_node_layer(unit_id, layer)

    this._for_each_unit_pin(unit_id, (pin_node_id: string, type: IO) => {
      if (!this._spec_is_link_pin_ignored(pin_node_id)) {
        if (
          (!this._is_link_pin_merged(pin_node_id) ||
            (this._is_output_pin_node_id(pin_node_id) &&
              this._is_link_pin_ref(pin_node_id))) &&
          !this._collapse_node_id.has(pin_node_id)
        ) {
          this._set_node_layer(pin_node_id, layer)

          const link_id = getPinLinkIdFromPinNodeId(pin_node_id)

          this._set_link_layer(link_id, layer)
        }

        const datum_node_id = this._pin_to_datum[pin_node_id]

        if (datum_node_id) {
          this._set_node_layer(datum_node_id, layer)
        }
      }

      const ext_node_id = this._pin_to_ext[type][pin_node_id]

      if (ext_node_id) {
        this._set_node_layer(ext_node_id, layer)
      }
    })
  }

  private _set_core_icon = (unit_id: string, icon: string): void => {
    const core_icon = this._core_icon[unit_id]

    core_icon.setProp('icon', icon)
  }

  private _show_core_icon = (unit_id: string): void => {
    const core_icon = this._core_icon[unit_id]

    core_icon.$element.style.display = 'block'
  }

  private _hide_core_icon = (unit_id: string): void => {
    const core_icon = this._core_icon[unit_id]

    core_icon.$element.style.display = 'none'
  }

  private _set_unit_core_opacity = (unit_id: string, opacity: number): void => {
    this._set_node_opacity(unit_id, opacity)
  }

  private _set_unit_pins_opacity = (unit_id: string, opacity: number): void => {
    this._for_each_unit_pin(unit_id, (pin_node_id, type) => {
      if (!this._spec_is_link_pin_ignored(pin_node_id)) {
        this._set_link_pin_opacity(pin_node_id, opacity)
      }
    })
  }

  private _set_unit_opacity = (unit_id: string, opacity: number): void => {
    // console.log('Graph', '_set_unit_opacity', opacity)

    this._set_unit_core_opacity(unit_id, opacity)
    this._set_unit_pins_opacity(unit_id, opacity)
  }

  private _set_core_icon_color = (unit_id: string, fill: string): void => {
    const core_icon = this._core_icon[unit_id]

    core_icon.$element.style.stroke = fill
  }

  private _set_core_name_color = (unit_id: string, color: string): void => {
    const core_name = this._core_name[unit_id]

    core_name.$element.style.color = color
  }

  private _set_core_description_color = (
    unit_id: string,
    color: string
  ): void => {
    const core_description = this._core_description[unit_id]

    core_description.$element.style.color = color
  }

  private _set_unit_core_color = (
    unit_id: string,
    node_color: string
  ): void => {
    // console.log('Graph', '_set_unit_core_color', unit_id, node_color)

    this._set_unit_core_shell_color(unit_id, node_color)
    this._set_unit_core_ghost_color(unit_id, node_color)
  }

  private _set_unit_core_shell_color = (
    unit_id: string,
    color: string
  ): void => {
    this._set_core_and_layout_core_border_color(unit_id, color)
  }

  private _set_unit_core_ghost_color = (
    unit_id: string,
    node_color: string
  ): void => {
    this._set_core_icon_color(unit_id, node_color)
    this._set_core_name_color(unit_id, node_color)
  }

  private _set_unit_color = (
    unit_id: string,
    node_color: string,
    link_color: string,
    text_color: string,
    pin_icon_color: string
  ): void => {
    // console.log('Graph', '_set_unit_color')
    this._set_unit_core_color(unit_id, node_color)
    this._set_unit_pins_color(
      unit_id,
      node_color,
      link_color,
      text_color,
      pin_icon_color
    )
  }

  private _disable_unit_pointer_events = (unit_id: string) => {
    this._set_unit_style_attr(unit_id, 'pointer-events', 'none')
  }

  private _enable_unit_pointer_events = (unit_id: string) => {
    this._set_unit_style_attr(unit_id, 'pointer-events', 'inherit')
  }

  private _set_unit_style_attr = (
    unit_id: string,
    name: string,
    value: string
  ): void => {
    // console.log('Graph', '_set_unit_color')
    this._set_unit_core_style_attr(unit_id, name, value)
    this._set_unit_pins_style_attr(unit_id, name, value)
  }

  private _set_unit_pins_style_attr = (
    unit_id: string,
    name: string,
    value: string
  ) => {
    this._for_each_unit_pin(unit_id, (pin_node_id, type, pinId) => {
      const pin_link_id = getPinLinkId(unit_id, type, pinId)

      const pin_node = this._node_comp[pin_node_id]
      const pin_link = this._link_comp[pin_link_id]

      if (pin_node) {
        pin_node.$element.style[name] = value
      }
      if (pin_link) {
        pin_link.$element.style[name] = value
      }
    })
  }

  private _set_unit_pins_color = (
    unit_id: string,
    node_color: string,
    link_color: string,
    text_color: string,
    pin_icon_color: string
  ) => {
    this._set_unit_pins_shell_color(
      unit_id,
      node_color,
      link_color,
      text_color,
      pin_icon_color
    )
    this._set_unit_pins_ghost_color(
      unit_id,
      node_color,
      link_color,
      text_color,
      pin_icon_color
    )
  }

  private _set_unit_shell_color = (
    unit_id: string,
    node_color: string,
    link_color: string,
    text_color: string,
    pin_icon_color: string
  ): void => {
    this._set_unit_core_shell_color(unit_id, node_color)
    this._set_unit_pins_shell_color(
      unit_id,
      node_color,
      link_color,
      text_color,
      pin_icon_color
    )
  }

  private _set_unit_pins_shell_color = (
    unit_id: string,
    node_color: string,
    link_color: string,
    text_color: string,
    pin_icon_color: string
  ): void => {
    this._for_each_unit_pin(unit_id, (pin_node_id, type) => {
      const merge_node_id = this._pin_to_merge[pin_node_id]
      if (merge_node_id) {
        if (this._is_link_pin_visible(pin_node_id)) {
          this._set_link_pin_pin_color(pin_node_id, node_color, pin_icon_color)
        } else {
          if (!this._is_merge_ref(merge_node_id)) {
            this._set_merge_pin_color(merge_node_id, type, node_color)
          }
        }
      } else {
        this._set_link_pin_pin_color(pin_node_id, node_color, pin_icon_color)
      }
      const ref = this._is_link_pin_ref(pin_node_id)
      this._set_link_pin_link_color(pin_node_id, ref ? node_color : link_color)
      this._set_pin_text_color(pin_node_id, text_color)
    })
  }

  private _set_unit_inputs_color = (
    unit_id: string,
    node_color: string,
    link_color: string,
    text_color: string,
    pin_icon_color: string
  ): void => {
    this._for_each_unit_input(unit_id, (pin_node_id) => {
      this._set_unit_pin_color(
        pin_node_id,
        node_color,
        link_color,
        text_color,
        pin_icon_color
      )
    })
  }

  private _set_unit_inputs_shell_color = (
    unit_id: string,
    node_color: string,
    link_color: string,
    text_color: string,
    pin_icon_color: string
  ): void => {
    this._for_each_unit_input(unit_id, (input_node_id) => {
      this._set_unit_pin_shell_color(
        input_node_id,
        node_color,
        link_color,
        text_color,
        pin_icon_color
      )
    })
  }

  private _set_unit_pin_color = (
    pin_node_id: string,
    node_color: string,
    link_color: string,
    text_color: string,
    pin_icon_color: string
  ) => {
    if (!this._spec_is_link_pin_ignored(pin_node_id)) {
      this._set_unit_pin_ghost_color(
        pin_node_id,
        node_color,
        link_color,
        text_color,
        pin_icon_color
      )
      this._set_unit_pin_shell_color(
        pin_node_id,
        node_color,
        link_color,
        text_color,
        pin_icon_color
      )
    }
  }

  private _set_unit_pin_ghost_color = (
    pin_node_id: string,
    node_color: string,
    link_color: string,
    text_color: string,
    pin_icon_color: string
  ) => {
    this._set_pin_text_color(pin_node_id, text_color)
  }

  private _set_unit_pin_shell_color = (
    pin_node_id: string,
    node_color: string,
    link_color: string,
    text_color: string,
    pin_icon_color: string
  ) => {
    const { type } = segmentLinkPinNodeId(pin_node_id)
    const merge_node_id = this._pin_to_merge[pin_node_id]
    if (merge_node_id) {
      if (!this._is_merge_ref(merge_node_id)) {
        this._set_merge_pin_color(merge_node_id, type, node_color)
      }
    } else {
      this._set_link_pin_pin_color(pin_node_id, node_color, pin_icon_color)
    }
    const ref = this._is_link_pin_ref(pin_node_id)
    this._set_link_pin_link_color(pin_node_id, ref ? node_color : link_color)
  }

  private _set_unit_ghost_color = (
    unit_id: string,
    node_color: string,
    link_color: string,
    text_color: string,
    pin_icon_color: string
  ): void => {
    this._set_unit_core_ghost_color(unit_id, node_color)
    this._set_unit_pins_ghost_color(
      unit_id,
      node_color,
      link_color,
      text_color,
      pin_icon_color
    )
  }

  private _set_unit_pins_ghost_color = (
    unit_id: string,
    node_color: string,
    link_color: string,
    text_color: string,
    pin_icon_color: string
  ): void => {
    this._for_each_unit_pin(unit_id, (pin_node_id, type) => {
      // if (!this._is_link_pin_ignored(pin_node_id)) {
      this._set_unit_pin_ghost_color(
        pin_node_id,
        node_color,
        link_color,
        text_color,
        pin_icon_color
      )
      // }
    })
  }

  private _set_datum_node_style = (
    datum_node_id: string,
    name: string,
    value: string
  ) => {
    const datum_container = this._datum_container[datum_node_id]

    datum_container.$element.style[name] = value
  }

  private _set_datum_link_style = (
    datum_link_id: string,
    name: string,
    value: string
  ) => {
    // console.log('_set_datum_link_style', link_id, color)

    const link_base = this._link_base[datum_link_id]

    link_base.$element.style[name] = value
  }

  private _set_datum_color = (
    datum_node_id: string,
    color: string,
    link_color: string
  ) => {
    // console.log('Graph', '_set_datum_color', color, datum_node_id)

    this._set_datum_node_style(datum_node_id, 'color', color)

    const datum_pin_node_id = this._datum_to_pin[datum_node_id]

    if (datum_pin_node_id) {
      this._set_datum_pin_link_color(
        datum_node_id,
        datum_pin_node_id,
        link_color
      )
    }

    const datum_plug_node_id = this._datum_to_plug[datum_node_id]

    if (datum_plug_node_id) {
      this._set_datum_plug_link_color(
        datum_node_id,
        datum_plug_node_id,
        link_color
      )
    }
  }

  private _set_datum_pin_link_color = (
    datum_node_id: string,
    datum_pin_node_id: string,
    color: string
  ): void => {
    const datum_link_id = getLinkId(datum_node_id, datum_pin_node_id)

    this._set_link_color(datum_link_id, color)
  }

  private _set_datum_plug_link_color = (
    datum_node_id: string,
    datum_plug_node_id: string,
    color: string
  ): void => {
    const datum_link_id = getLinkId(datum_node_id, datum_plug_node_id)

    this._set_link_color(datum_link_id, color)
  }

  private _set_datum_opacity = (datum_node_id: string, opacity: number) => {
    this._set_datum_node_opacity(datum_node_id, opacity)
    this._set_datum_link_opacity(datum_node_id, opacity)
  }

  private _set_datum_node_opacity = (
    datum_node_id: string,
    opacity: number
  ) => {
    this._set_datum_node_style(datum_node_id, 'opacity', `${opacity}`)
  }

  private _set_datum_link_opacity = (
    datum_node_id: string,
    opacity: number
  ) => {
    const datum_pin_node_id = this._datum_to_pin[datum_node_id]

    if (datum_pin_node_id) {
      const datum_link_id = getLinkId(datum_node_id, datum_pin_node_id)

      this._set_datum_link_style(datum_link_id, 'opacity', `${opacity}`)
    }
  }

  private _set_err_color = (err_node_id: string, color: string): void => {
    const { unitId } = segmentErrNodeId(err_node_id)

    const err_component = this._err_comp[unitId]

    err_component.$element.style.color = color

    const err_link_id = getLinkId(unitId, err_node_id)

    this._set_link_color(err_link_id, color)
  }

  private _set_err_opacity = (err_node_id: string, opacity: number): void => {
    const { unitId } = segmentErrNodeId(err_node_id)

    const err_component = this._err_comp[unitId]

    err_component.$element.style.opacity = `${opacity}`

    const err_link_id = getLinkId(unitId, err_node_id)

    this._set_link_opacity(err_link_id, opacity)
  }

  private _on_search_item_pick = ({ id }: { id: string }) => {
    // console.log('Graph', '_on_search_item_pick', id)

    if (!this._control_lock) {
      return
    }

    const search_unit_id = this._search_unit_id
    const search_unit_datum_id = this._search_unit_datum_id

    if (search_unit_id) {
      this._commit_shift_search()

      // commit might've removed search unit
      if (this._has_node(search_unit_id)) {
        this._refresh_node_color(search_unit_id)

        this._for_each_unit_input(search_unit_id, (pin_node_id: string) => {
          this._refresh_node_color(pin_node_id)
        })
      }
    } else if (search_unit_datum_id) {
      this._commit_shift_search()
    }
  }

  private _on_search_empty = (): void => {
    // console.log('Graph', '_on_search_empty')

    if (this._search_unit_id) {
      if (this._mode === 'add') {
        this._state_remove_search_unit()
      }
    }
  }

  private _on_search_shape = ({ shape }: { shape: Shape }): void => {
    // console.log('Graph', '_on_search_shape', shape)

    if (this._tree_layout && shape === 'circle') {
      this._leave_tree_layout()
    } else if (!this._tree_layout && shape === 'rect') {
      this._enter_tree_layout()
    }
  }

  private _show_core_name = (unit_id: string): void => {
    const core_name = this._core_name[unit_id]

    core_name.$element.style.display = 'flex'
  }

  private _hide_core_name = (unit_id: string): void => {
    const core_name = this._core_name[unit_id]

    core_name.$element.style.display = 'none'
  }

  private _commit_search = () => {
    // console.log('Graph', '_commit_search_unit')

    const { fork } = this.$props

    const { specs, bubble } = this.$props

    const { animate } = this._config()

    this._search_fallback_position = this._world_screen_center()

    const search_start_unit_id = this._search_start_unit_id
    const search_start_spec_id = this._search_start_spec_id
    const search_start_unit_merges = this._search_start_unit_merges
    const search_start_unit_plugs = this._search_start_unit_plugs
    const search_start_unit_parent_id = this._search_start_unit_parent_id
    const search_start_unit_index = this._search_start_unit_index

    const search_unit_id = this._search_unit_id
    // const search_spec_id = this._search_unit_spec_id

    if (search_unit_id) {
      this._refresh_unit_layer(search_unit_id)

      if (
        this._mode === 'add' ||
        this._mode === 'change' ||
        this._mode === 'multiselect' ||
        this._mode === 'info'
      ) {
        this._set_unit_color(
          search_unit_id,
          this._theme.node,
          this._theme.link,
          this._theme.pin_text,
          this._theme.node
        )

        this._hide_core_description(search_unit_id)
        this._set_core_description_color(search_unit_id, this._theme.sub_text)

        const unit = this._get_unit(search_unit_id)

        const search_unit_bundle = unitBundleSpec(unit, specs)

        let did_spec_id_change =
          this._search_unit_spec_id !== this._search_start_spec_id

        let should_add_component = false

        if (
          this._mode === 'add' ||
          this._mode === 'multiselect' ||
          this._mode === 'info'
        ) {
          let parent_id = null

          if (this._tree_layout) {
            parent_id = this._get_current_layout_layer_id()
          }

          const actions: Action[] = [
            makeAddUnitAction(
              search_unit_id,
              search_unit_bundle,
              undefined,
              undefined,
              undefined,
              parent_id
            ),
          ]

          const bulk_action = makeBulkEditAction(actions)

          this._dispatch_action(bulk_action)

          this._pod.$bulkEdit({ actions, fork, bubble })

          this._download_pod_data()

          should_add_component = true
        } else if (this._mode === 'change') {
          if (this._search_start_unit_id) {
            const is_component = isComponentId(specs, search_start_spec_id)

            const search_start_unit_bundle = unitBundleSpec(
              this._search_start_graph_unit_spec,
              specs
            )

            const search_unit_merges = clone(
              this._get_unit_merges(search_unit_id)
            )
            const search_unit_plugs = clone(
              this._get_unit_plugs(search_unit_id)
            )

            this._dispatch_swap_unit_action(
              search_start_unit_id,
              search_start_unit_bundle,
              search_start_unit_merges,
              search_start_unit_plugs,
              search_start_unit_parent_id,
              search_start_unit_index,
              search_unit_id,
              search_unit_bundle,
              search_unit_merges,
              search_unit_plugs,
              search_start_unit_parent_id,
              search_start_unit_index
            )

            if (did_spec_id_change) {
              this._pod_remove_unit(search_start_unit_id, is_component)
              this._pod_add_unit(search_unit_id, search_unit_bundle)
            }
          } else {
            this._dispatch_add_unit_action(search_unit_id, unit)

            this._pod_add_unit(search_unit_id, search_unit_bundle)
          }

          this._setup_pod(this._pod)

          should_add_component = this._search_unit_spec_id_changed
        }

        if (this._mode === 'change') {
          if (did_spec_id_change) {
            this._unregister_spec(this._search_start_spec_id, true, [])
            this._register_spec(this._search_unit_spec_id, true)
          }
        } else if (this._mode === 'add') {
          this._register_spec(this._search_unit_spec_id, true)
        }

        if (did_spec_id_change) {
          for (const merge_id in this._search_unit_merges) {
            const merge_node_id = getMergeNodeId(merge_id)

            const merge = this._search_unit_merges[merge_id]
            const merge_pin_count = this._merge_pin_count[merge_id]

            if (merge_pin_count > 2) {
              let type: IO
              let pin_id: string

              const merge_unit = merge[search_unit_id]

              if (merge_unit['input'] && keyCount(merge_unit['input']) > 0) {
                type = 'input'

                pin_id = getObjSingleKey(merge_unit.input || {})
              } else {
                type = 'output'

                pin_id = getObjSingleKey(merge_unit.output || {})
              }

              this.__pod_add_pin_to_merge(
                merge_id,
                search_unit_id,
                type,
                pin_id
              )
            } else {
              this._pod_add_merge(merge_id, merge)
            }

            if (!this._is_merge_ref(merge_node_id)) {
              this._refresh_merge_pin_pin_color(merge_node_id, 'input')
              this._refresh_merge_pin_pin_color(merge_node_id, 'output')
            }
          }

          if (this._search_unit_ref_merge_id) {
            this._pod_add_merge(
              this._search_unit_ref_merge_id,
              this._search_unit_ref_merge
            )
          }
        }

        if (should_add_component) {
          if (this._is_unit_component(search_unit_id)) {
            this._sim_add_sub_component(search_unit_id)
            this._connect_sub_component(search_unit_id)
          }
        }

        this._refresh_unit_compatibility(search_unit_id)

        this._start_graph_simulation(LAYER_NONE)

        if (this._tree_layout) {
          const parent_id =
            this._layout_sub_component_parent[search_unit_id] || null

          this._move_all_layout_node_target_position(parent_id)
        }
      } else if (this._mode === 'remove') {
        this.copy_single_node(search_unit_id, false)

        this._state_remove_search_unit()
      }
    }

    const datum_node_id = this._search_unit_datum_node_id

    if (datum_node_id) {
      if (this._mode === 'remove') {
        this.copy_single_node(datum_node_id, false)

        this._remove_data_search_unit()
      } else {
        this._mem_remove_search_datum()
      }

      this._refresh_datum_color(datum_node_id)
    }
  }

  private _shift_search = (): void => {
    // console.log('Graph', '_shift_search')

    if (this._is_shift_pressed() || this._mode === 'multiselect') {
      const position = this._jiggle_world_screen_center(
        this._search_dock_offset_x / 2,
        this._search_dock_offset_y / 2
      )

      const layout_position = { x: 0, y: 0 }

      const spec_id = this._search_unit_spec_id

      const new_unit_id = this._new_unit_id(spec_id)

      const pin_position = emptyIO({}, {})

      this._add_search_unit(
        new_unit_id,
        spec_id,
        position,
        pin_position,
        layout_position
      )

      this._refresh_node_color(new_unit_id)
    } else {
      const search_next_unit_id = this._search_unit_id

      this._mem_remove_search_unit_id()

      this._hide_search()

      this._refresh_node_color(search_next_unit_id)
    }
  }

  private _set_node_compatible = (node_id: string): void => {
    // console.log('Graph', '_set_node_compatible', node_id)

    this._compatible_node_id[node_id] = true
    this._compatible_node_count++
  }

  private _set_node_not_compatible = (node_id: string): void => {
    if (this._compatible_node_id[node_id]) {
      delete this._compatible_node_id[node_id]
      this._compatible_node_count--
    }
  }

  private _refresh_unit_compatibility = (unit_id: string) => {
    const display_node_id = this._get_display_node_id()
    if (display_node_id.length > 0) {
      const { all_pin, all_pin_ref, all_pin_ref_unit, all_data } =
        this._is_all_node(display_node_id)

      if (all_pin) {
        if (all_pin_ref) {
          if (!all_pin_ref_unit[unit_id]) {
            this._set_node_compatible(unit_id)
            this._refresh_node_fixed(unit_id)
            this._refresh_node_selection(unit_id)
          }
        } else {
          this._for_each_unit_pin(unit_id, (pin_node_id: string) => {
            if (this._is_pin_all_pin_match(pin_node_id, display_node_id)) {
              this._set_node_compatible(pin_node_id)
              this._refresh_node_fixed(pin_node_id)
              this._refresh_node_selection(pin_node_id)
            }
          })
        }
      } else if (all_data) {
        this._for_each_unit_pin(unit_id, (pin_node_id: string) => {
          if (this._is_pin_all_datum_match(pin_node_id, display_node_id)) {
            this._set_node_compatible(pin_node_id)
            this._refresh_node_fixed(pin_node_id)
            this._refresh_node_selection(pin_node_id)
          }
        })
      }
    }
  }

  private _set_all_visible_output_pin_opacity = (opacity: number): void => {
    for (const pin_node_id of this._link_pin_output_set) {
      if (!this._spec_is_link_pin_ignored(pin_node_id)) {
        this._set_link_pin_opacity(pin_node_id, opacity)
      }
    }
  }

  private _set_all_ref_pin_opacity = (opacity: number): void => {
    for (const pin_node_id of this._link_pin_ref_set) {
      if (!this._spec_is_link_pin_ignored(pin_node_id)) {
        this._set_link_pin_opacity(pin_node_id, opacity)
      }
    }
  }

  private _set_all_literal_datum_opacity = (opacity: number): void => {
    for (const datum_node_id in this._visible_data_node) {
      if (!this._is_datum_class_literal(datum_node_id)) {
        this._set_datum_opacity(datum_node_id, opacity)
      }
    }
  }

  private _on_search_list_shown = () => {
    // console.log('Graph', '_on_search_list_shown')

    const { animate } = this._config()

    this._search_hidden = false

    if (!this._control_lock) {
      return
    }

    if (this._mode === 'none' || this._mode === 'info') {
      this._mode_just_set_by_keyboard = true
      this._mode_set_by_keyboard = true

      this._set_crud_mode('add')
    }

    this._disable_keyboard()

    this._start_graph_simulation(LAYER_NONE)

    if (this._tree_layout) {
      this._refresh_search_list_height_offset()
      this._refresh_all_layout_node_target_position()
      this._layout_scroll_search_unit_into_view()

      if (animate) {
        this._animate_all_current_layout_layer_node()
      } else {
        this._set_all_current_layout_layer_core_position()
      }

      this._animate_current_layer_offset_if_overflown()
    }

    this._refresh_all_selected_node_color()
  }

  private _animate_current_layer_offset_if_overflown() {
    // TODO
  }

  private _search_filter_true = () => true

  private _search_filter: (id: string) => boolean = this._search_filter_true

  private _mem_remove_search_unit_id = (): void => {
    // console.log('Graph', '_mem_remove_search_unit_id')

    this._search_unit_id = null
    this._search_unit_spec_id = null
    this._search_unit_graph_position = null
    this._search_unit_component_size = null
    this._search_unit_merges = {}

    this._search_start_unit_id = null
    this._search_start_spec_id = null
    this._search_start_unit_position = null
    this._search_start_unit_merges = null
    this._search_start_unit_plugs = null
    this._search_start_unit_data = null
    this._search_start_graph_unit_spec = null
    this._search_start_component_index = null

    this._search_unit_spec_id_changed = false

    this._stop_zoom_target_animation()
  }

  private _mode_set_by_keyboard: boolean = true
  private _mode_just_set_by_keyboard: boolean = false

  private _mem_remove_search_datum = () => {
    // console.log('Graph', '_mem_remove_search_datum')

    this._search_unit_datum_id = null
    this._search_unit_datum_node_id = null
    this._search_unit_datum_start_position = null

    this._stop_zoom_target_animation()
  }

  private _on_search_list_hidden = (): void => {
    // console.log('Graph', '_on_search_list_hidden')

    const { specs } = this.$props

    this._search_hidden = true

    if (!this._control_lock) {
      return
    }

    this._abort_search_unit()

    if (this._mode_set_by_keyboard) {
      this._set_crud_mode('none')
    }

    const search_start_unit_id = this._search_start_unit_id

    if (this._search_filter !== this._search_filter_true) {
      this._set_search_filter(this._search_filter_true)
    }

    this.focus()

    this._refresh_node_color(search_start_unit_id)

    this._enable_keyboard()
    // this._enable_crud()

    if (this._search_fallback_position) {
      const { x, y } = this._search_fallback_position

      this._zoom_center_at(x, y)
    }

    this._refresh_search_list_height_offset()

    if (this._tree_layout) {
      this._refresh_layout_node_target_position(null)
    }
  }

  private _abort_search_unit = () => {
    const { specs } = this.$props

    const search_adding_unit = this._search_adding_unit
    const search_unit_id = this._search_unit_id
    const search_start_unit_id = this._search_start_unit_id
    const search_start_spec_id = this._search_start_spec_id
    const search_unit_start_data = this._search_start_unit_data
    const search_unit_datum_node_id = this._search_unit_datum_node_id
    const search_unit_spec_id = this._search_unit_spec_id
    const search_unit_spec_id_changed = this._search_unit_spec_id_changed

    if (!search_adding_unit) {
      if (search_unit_id) {
        if (
          this._mode === 'add' ||
          this._mode === 'multiselect' ||
          this._mode === 'none' ||
          this._mode === 'remove'
        ) {
          this._state_remove_unit(search_unit_id, false)
        } else if (this._mode === 'change') {
          this._state_swap_search_unit(
            search_start_spec_id,
            search_start_unit_id
          )

          if (search_unit_spec_id_changed) {
            if (isComponentId(specs, search_start_spec_id)) {
              this._sim_add_sub_component(search_start_unit_id, {})
              this._connect_sub_component(search_start_unit_id)
            }

            forIOObjKV(search_unit_start_data, (type, pin_id, data) => {
              const pin_node_id = getPinNodeId(search_unit_id, type, pin_id)

              this._graph_debug_set_pin_data_tree(pin_node_id, data)
            })
          }
        }
      }

      this._mem_remove_search_unit_id()

      this._refresh_node_color(search_start_unit_id)
    }

    if (search_unit_datum_node_id) {
      this._remove_datum(search_unit_datum_node_id)

      this._mem_remove_search_datum()
    }
  }

  private _enable_unit_pin_names = (unit_id: string) => {
    this._for_each_unit_pin(unit_id, (pin_node_id: string) => {
      if (this._has_node(pin_node_id)) {
        this._enable_pin_name(pin_node_id)
      }
    })
  }

  private _disable_unit_pin_names = (unit_id: string) => {
    this._for_each_unit_pin(unit_id, (pin_node_id: string) => {
      if (this._has_node(pin_node_id)) {
        this._disable_pin_name(pin_node_id)
      }
    })
  }

  private _enable_all_node_name = () => {
    for (const unit_id in this._unit_node) {
      if (!this._is_unit_base(unit_id)) {
        this._enable_core_name(unit_id)
        this._enable_unit_pin_names(unit_id)
      }
    }

    for (const ext_node_id in this._exposed_ext_node) {
      this._enable_plug_name(ext_node_id)
    }
  }

  private _is_minimap_drag_and_drop_mode = (mode: Mode) => {
    return mode === 'add'
  }

  private _disable_all_node_name = () => {
    // console.log('Graph', '_disable_all_node_name')

    for (const unit_id in this._unit_node) {
      if (!this._is_unit_base(unit_id)) {
        this._disable_core_name(unit_id)
        this._disable_unit_pin_names(unit_id)
      }
    }

    for (const ext_node_id in this._exposed_ext_node) {
      this._disable_plug_name(ext_node_id)
    }
  }

  private _on_enter_mode = ({ mode }: { mode: Mode }) => {
    // console.log('Graph', '_on_enter_mode', mode)

    const { getSpec } = this.$props

    const { $theme } = this.$context

    const prev_mode = this._mode

    this._mode = mode

    if (!this._mode_just_set_by_keyboard) {
      this._mode_set_by_keyboard = false
    }

    if (this._search_hidden) {
      if (
        this.__is_freeze_mode(prev_mode) &&
        !this.__is_freeze_mode(this._mode)
      ) {
        for (const node_id in this._drag_node_id) {
          this._descend_node(node_id)
        }
      }

      const mode_node = (node_id: string): void => {
        this._refresh_node_color(node_id)
      }

      const propagate_to_selected = (only_to_same_component_layer: boolean) => {
        const current_layer_id = this._get_current_layout_layer_id()

        for (const selected_node_id in this._selected_node_id) {
          if (!this._collapse_node_id.has(selected_node_id)) {
            if (only_to_same_component_layer) {
              if (
                this._spec_get_sub_component_parent_id(selected_node_id) ===
                current_layer_id
              ) {
                mode_node(selected_node_id)
              }
            } else {
              mode_node(selected_node_id)
            }
          }
        }
      }

      if (this._hover_node_count > 0) {
        let selected_count = 0

        for (const hovered_node_id in this._hover_node_id) {
          const anchor_node_id = this._get_node_anchor_node_id(hovered_node_id)

          mode_node(hovered_node_id)
          mode_node(anchor_node_id)

          if (this._is_node_selected(anchor_node_id)) {
            selected_count++
          }
        }

        if (selected_count > 0) {
          propagate_to_selected(this._tree_layout)
        }
      } else if (this._selected_node_count > 0) {
        propagate_to_selected(this._tree_layout)
      }

      const clone_drag_pressed_node_id = (deep: boolean) => {
        for (const pressed_node_id in this._pressed_node_id_pointer_id) {
          const pointer_id = getObjSingleKey(
            this._pressed_node_id_pointer_id[pressed_node_id]
          )

          const pointer_position =
            this._pointer_position[pointer_id] ?? NULL_VECTOR

          if (pressed_node_id === this._clone_drag_clone_id) {
            this._on_node_clone_drag_end(this._clone_drag_clone_id)
          }

          const node_ids = [
            pressed_node_id,
            ...(this._drag_along_node[pressed_node_id] ?? []),
          ]

          this._on_node_clone_drag_start(
            pressed_node_id,
            node_ids,
            Number.parseInt(pointer_id, 10),
            pointer_position.x,
            pointer_position.y,
            deep
          )
        }
      }

      const start_drag_node_ids = keys(this._drag_node_id)

      if (prev_mode !== 'none' && this._mode === 'none') {
        for (const selected_node_id in this._selected_node_id) {
          if (this._is_unit_node_id(selected_node_id)) {
            this._enable_core_resize(selected_node_id)
          } else if (this._is_datum_node_id(selected_node_id)) {
            //
          }
        }

        if (this._drag_and_drop) {
          this._drag_and_drop_cancel()
        }
      } else if (prev_mode === 'none' && this._mode !== 'none') {
        for (const selected_node_id in this._selected_node_id) {
          if (this._is_unit_node_id(selected_node_id)) {
            this._disable_core_resize(selected_node_id)
          } else if (this._is_datum_node_id(selected_node_id)) {
            this._enable_datum_overlay(selected_node_id)
          }
        }
      }

      if (prev_mode !== 'data' && this._mode === 'data') {
        this._set_all_visible_output_pin_opacity(0.5)

        clone_drag_pressed_node_id(true)
      } else if (prev_mode === 'data' && this._mode !== 'data') {
        this._set_all_visible_output_pin_opacity(1)

        if (this._clone_drag) {
          this._on_node_clone_drag_end(this._clone_drag_clone_id)
        }
      }

      if (prev_mode !== 'add' && this._mode === 'add') {
        const units = this.get_units()

        if (this._drag_count === 0) {
          for (const unit_id in units) {
            this._show_unit_ignored_pins(unit_id)
          }
        }

        clone_drag_pressed_node_id(false)

        this._start_graph_simulation(LAYER_NONE)
      } else if (prev_mode === 'add' && this._mode !== 'add') {
        const units = this.get_units()

        for (const unit_id in units) {
          this._hide_unit_ignored_pins(unit_id)
        }

        if (this._clone_drag) {
          this._on_node_clone_drag_end(this._clone_drag_clone_id)
        }
      }

      if (prev_mode !== 'info' && this._mode === 'info') {
        this._enable_all_node_name()

        if (this._hover_node_count > 0) {
          this._set_all_nodes_links_opacity(0.2)

          for (const hovered_node_id in this._hover_node_id) {
            this._show_node_info(hovered_node_id)
          }
        } else if (this._selected_node_count > 0) {
          this._set_all_nodes_links_opacity(0.2)

          for (const selected_node_id in this._selected_node_id) {
            this._show_node_info(selected_node_id)
          }
        }
      } else if (prev_mode === 'info' && this._mode !== 'info') {
        this._disable_all_node_name()

        if (this._info_node_id.size > 0) {
          this._set_all_nodes_links_opacity(1)

          for (const info_node_id of this._info_node_id) {
            this._hide_node_info(info_node_id)
          }

          forEachSpecPin(this._spec, (type, pinId) => {
            if (this._is_pin_default_ignored(type, pinId)) {
              this._set_pin_set_opacity(
                type,
                pinId,
                DEFAULT_IGNORED_PIN_SET_OPACITY
              )
            }
          })
        }
      }

      if (prev_mode !== 'change' && this._mode === 'change') {
        for (const drag_node_id of start_drag_node_ids) {
          const pointer_ids = this._pressed_node_id_pointer_id[drag_node_id]

          for (const pointer_id in pointer_ids) {
            this._on_node_blue_drag_start(
              drag_node_id,
              Number.parseInt(pointer_id, 10)
            )
          }
        }
      } else if (prev_mode === 'change' && this._mode !== 'change') {
        if (this._blue_drag_hover_unit_id) {
          this._abort_blue_drag_hover()
        }

        if (this._blue_drag_init_id) {
          this._abort_blue_drag(this._blue_drag_init_id)
        }

        for (const ext_pin_node_id in this._exposed_ext_node) {
          const { type, pinId } = segmentPlugNodeId(ext_pin_node_id)

          const hover_pointer_ids =
            this._hover_node_id_pointer_id[ext_pin_node_id] ?? {}

          if (keyCount(hover_pointer_ids) > 0) {
            this._refresh_exposed_pin_set_color(type, pinId)
          }
        }
      }

      if (prev_mode !== 'remove' && this._mode === 'remove') {
        for (const pointer_id in this._pointer_id_pressed_node_id) {
          const pressed_node_id = this._pointer_id_pressed_node_id[pointer_id]
          const drag_node_ids = [
            ...(this._drag_pointer_id_node[pointer_id] ?? []),
          ]

          this._on_node_red_drag_start(
            pressed_node_id,
            Number.parseInt(pointer_id, 10),
            drag_node_ids
          )
        }
      } else if (prev_mode === 'remove' && this._mode !== 'remove') {
        for (const drag_node_id of start_drag_node_ids) {
          this._on_node_red_drag_end(drag_node_id)

          this._refresh_node_color(drag_node_id)
        }

        if (this._drag_and_drop) {
          const pointerId = this._drag_and_drop_pointer
          const bundle = this._drag_and_drop_bundle

          const position = this._pointer_position[pointerId]

          const _position = this._screen_to_world(position.x, position.y)

          this.paste_bundle(bundle, _position, true, true, false)

          this._cancel_drag_and_drop()

          this.focus()
        }
      }

      if (prev_mode !== 'multiselect' && this._mode === 'multiselect') {
        if (this._long_press_count > 0) {
          if (this._pointer_down_count === 1) {
            const pointer_id = Number.parseInt(
              getObjSingleKey(this._pointer_down)
            )

            const pointer_node_id =
              this._pointer_id_pressed_node_id[pointer_id] || null

            const all_selected_node_ids = this._get_all_selected_node_ids()

            if (pointer_node_id) {
              if (this._is_unit_node_id(pointer_node_id)) {
                if (this._tree_layout) {
                  //
                } else {
                  if (this._is_node_selected(pointer_node_id)) {
                    if (this._is_unit_base(pointer_node_id)) {
                      //
                    } else {
                      const unit_spec = this._get_unit_spec(
                        pointer_node_id
                      ) as GraphSpec

                      const {
                        map_unit_id,
                        map_merge_id,
                        map_plug_id,
                        selected_node_ids,
                      } = buildGraphRemap(
                        unit_spec,
                        getSpec,
                        this._new_unit_id,
                        this._new_merge_id,
                        this._new_sub_pin_id,
                        this._new_datum_id
                      )

                      this._explode_unit(
                        pointer_node_id,
                        map_unit_id,
                        map_merge_id,
                        map_plug_id,
                        selected_node_ids
                      )
                    }

                    this._cancel_long_click = true
                  } else {
                    this._start_long_press_collapse(
                      pointer_id,
                      pointer_node_id,
                      all_selected_node_ids,
                      this._long_press_screen_position
                    )
                  }
                }
              }
            } else {
              if (this._tree_layout) {
                //
              } else {
                this._start_long_press_collapse(
                  pointer_id,
                  null,
                  all_selected_node_ids,
                  this._long_press_screen_position
                )
              }
            }
          }
        } else {
          for (const drag_node_id in this._pressed_node_id_pointer_id) {
            if (this._drag_node_id[drag_node_id]) {
              this._extend_drag_along_to_subgraph(drag_node_id)

              const subgraph_node_ids =
                this._get_node_subgraph_node_ids(drag_node_id)

              const pointer_id = this._drag_node_pointer_id[drag_node_id]

              const { x, y } = this._get_node_position(drag_node_id)

              for (const subgraph_node_id of subgraph_node_ids) {
                this.__on_node_drag_start(subgraph_node_id, pointer_id, x, y)
              }
            }
          }
        }

        this._refresh_compatible()
      } else if (prev_mode === 'multiselect' && this._mode !== 'multiselect') {
        this._restart_gesture = false

        for (const drag_node_id in this._pressed_node_id_pointer_id) {
          if (this._drag_node_id[drag_node_id]) {
            const pointer_id = getObjSingleKey(
              this._pressed_node_id_pointer_id[drag_node_id]
            )

            if (this._drag_along_node[drag_node_id]) {
              for (const drag_along_node_id of this._drag_along_node[
                drag_node_id
              ]) {
                if (!this._pressed_node_id_pointer_id[drag_along_node_id]) {
                  this.__on_node_drag_end(
                    drag_along_node_id,
                    Number.parseInt(pointer_id, 10)
                  )
                }
              }
            }

            this._de_extend_drag_along_to_subgraph(drag_node_id)
          }
        }

        this._refresh_compatible()
      }

      if (prev_mode !== 'none' && this._mode === 'none') {
        if (this.__is_freeze_mode(prev_mode)) {
          for (const pointer_id in this._pointer_id_pressed_node_id) {
            const pressed_node_id = this._pointer_id_pressed_node_id[pointer_id]
            const drag_along_node_ids = [
              ...(this._drag_along_node[pressed_node_id] ?? []),
            ]

            for (const drag_along_node_id of drag_along_node_ids) {
              this._remove_node_drag_along(pressed_node_id, drag_along_node_id)

              this.__on_node_drag_end(
                drag_along_node_id,
                Number.parseInt(pointer_id, 10)
              )

              this._refresh_node_fixed(drag_along_node_id)
            }

            for (const drag_node_id of [
              pressed_node_id,
              ...drag_along_node_ids,
            ]) {
              this._descend_node(drag_node_id)
            }
          }
        }
      } else if (prev_mode === 'none' && this._mode !== 'none') {
        //
      }

      if (
        !this._is_minimap_drag_and_drop_mode(prev_mode) &&
        this._is_minimap_drag_and_drop_mode(this._mode)
      ) {
        this._enable_minimap_drag_and_drop()
      } else if (
        this._is_minimap_drag_and_drop_mode(prev_mode) &&
        !this._is_minimap_drag_and_drop_mode(this._mode)
      ) {
        this._disable_minimap_drag_and_drop()
      }
    } else {
      if (this._search_unit_id) {
        const search_unit_id = this._search_unit_id

        if (prev_mode !== mode) {
          if (mode === 'none') {
            this._hide_search()
          } else if (mode === 'change') {
            this._turn_unit_blue(search_unit_id)
          } else if (mode === 'remove') {
            //
          } else if (mode === 'add') {
            //
          } else if (mode === 'data') {
            const spec_id = this._get_unit_spec_id(search_unit_id)
            const position = this._get_node_position(search_unit_id)

            this._state_remove_search_unit()
            this._add_data_search_unit(spec_id, position)
          } else if (mode === 'info') {
            if (this._search_unit_id) {
              this._show_node_info(this._search_unit_id)
            } else if (this._search_unit_datum_node_id) {
              this._show_node_info(this._search_unit_datum_node_id)
            }
          }
        }

        if (this._has_node(search_unit_id)) {
          this._refresh_node_color(search_unit_id)
          this._refresh_unit_description_color(search_unit_id)
        }
      }

      if (this._search_unit_datum_node_id) {
        const search_unit_datum_node_id = this._search_unit_datum_node_id

        if (prev_mode !== mode) {
          if (mode === 'change') {
            //
          } else if (mode === 'remove') {
            //
          } else if (mode === 'add') {
            const position = this._get_node_position(search_unit_datum_node_id)

            const layout_position = position

            const spec_id = this._search_unit_datum_spec_id

            const new_unit_id = this._new_unit_id(spec_id)

            this._remove_data_search_unit()

            const pin_position = emptyIO({}, {})

            this._add_search_unit(
              new_unit_id,
              spec_id,
              position,
              pin_position,
              layout_position
            )
          }
        }

        this._refresh_node_color(search_unit_datum_node_id)
      }
    }

    if (this._search) {
      const color = this._get_color()

      const theme_color = getThemeModeColor($theme, mode, color)

      let selected_color = theme_color

      if (this._mode === 'multiselect' || this._mode === 'info') {
        selected_color = getThemeModeColor($theme, 'add', color)
      }

      this._search.setProp('selectedColor', selected_color)
    }

    this.dispatchEvent('_graph_mode', { mode })
  }

  private _disable_crud = (): void => {
    if (this._modes && this._unlisten_crud) {
      // console.log('Graph', '_disable_crud')
      this._unlisten_crud()
      this._unlisten_crud = undefined
    }
  }

  private _refresh_tree_sub_component_index = (): void => {
    // console.log('Graph', '_refresh_tree_sub_component_index')

    const children = this._spec_get_component_children()

    let i = 0

    for (const sub_component_id of children) {
      i = this._set_tree_sub_component_index(sub_component_id, i)
    }

    if (this._is_fullwindow) {
      this._reorder_fullwindow_component_ids()
    }
  }

  private _reorder_fullwindow_component_ids = () => {
    this._fullwindow_component_ids = this._order_sub_component_ids(
      this._fullwindow_component_ids
    )
  }

  private _reorder_all_fullwindow = (): void => {
    this._decouple_all_fullwindow_component()
    this._reorder_fullwindow_component_ids()
    this._couple_all_fullwindow_component()
  }

  private _sub_component_index: Dict<number> = {}

  private _set_tree_sub_component_index = (
    sub_component_id: string,
    i: number
  ): number => {
    // console.log('Graph', '_set_tree_sub_component_index', sub_component_id, i)

    this._set_sub_component_index(sub_component_id, i)

    const children = this._spec_get_sub_component_children(sub_component_id)

    i++

    for (const child_id of children) {
      i = this._set_tree_sub_component_index(child_id, i)
    }

    return i
  }

  private _on_transcend_click = (): void => {
    if (this._core_component_unlocked_count > 0) {
      this._lock_all_component()

      this.focus()
    } else if (this._unlocked_datum.size > 0) {
      this._lock_all_datum()

      this.focus()
    } else {
      if (this._is_fullwindow) {
        this._leave_all_fullwindow(true)
      } else {
        this._enter_default_fullwindow()
      }
    }
  }

  private _order_sub_component_ids = (
    sub_component_ids: string[]
  ): string[] => {
    return sub_component_ids.sort((a, b) => {
      const a_index = this._sub_component_index[a]
      const b_index = this._sub_component_index[b]
      return a_index - b_index
    })
  }

  private _enter_default_fullwindow = (): void => {
    // console.log('Graph', '_enter_default_fullwindow')

    if (this._selected_component_count > 0 && !this._tree_layout) {
      this._enter_all_selected_fullwindow(true)
    } else {
      this._enter_all_fullwindow(true)
    }
  }

  private _enter_all_fullwindow = (
    animate: boolean,
    hide: boolean = true
  ): void => {
    // console.log('Graph', '_enter_all_fullwindow')

    const { component } = this.$props

    this._is_all_fullwindow = true

    const all_component_ids = keys(component.$subComponent)

    let visible_component_ids = all_component_ids

    if (this._tree_layout) {
      const current_layer_id = this._get_current_layout_layer_id()

      visible_component_ids = all_component_ids.filter((c_id) => {
        const parent_id = this._spec_get_sub_component_parent_id(c_id)

        if (parent_id === current_layer_id) {
          return true
        } else {
          return false
        }
      })
    }

    const visible_selected_component_ids = visible_component_ids.filter(
      this._is_node_selected
    )

    if (visible_selected_component_ids.length > 0) {
      visible_component_ids = visible_selected_component_ids
    }

    const ordered_all_component_ids = this._order_sub_component_ids(
      visible_component_ids
    )

    this._enter_fullwindow(animate, ordered_all_component_ids, hide)
  }

  private _enter_all_selected_fullwindow = (animate: boolean) => {
    // console.log('Graph', '_enter_all_selected_fullwindow')

    const selected_sub_component_ids = keys(this._selected_component)
    const ordered_selected_sub_component_ids = this._order_sub_component_ids(
      selected_sub_component_ids
    )
    this._enter_fullwindow(animate, ordered_selected_sub_component_ids)
  }

  private _get_sub_component_index = (sub_component_id: string): number => {
    const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)
    if (parent_id) {
      return this._spec_get_sub_component_parent_root_index(sub_component_id)
    } else {
      return this._get_sub_component_root_index(sub_component_id)
    }
  }

  private _get_sub_component_root_index = (unit_id: string): number => {
    const children = this._spec_get_component_children()

    const index = children.indexOf(unit_id)

    return index
  }

  private _spec_get_sub_component_parent_root_index = (
    sub_component_id: string
  ): number => {
    const parent_sub_component_id =
      this._spec_get_sub_component_parent_id(sub_component_id)
    const parent_sub_component_children = this._spec_get_sub_component_children(
      parent_sub_component_id
    )
    const sub_component_index =
      parent_sub_component_children.indexOf(sub_component_id)
    return sub_component_index
  }

  private _get_sub_component_tree_index = (
    sub_component_id: string
  ): number => {
    const parent_sub_component_id =
      this._spec_get_sub_component_parent_id(sub_component_id)
    if (parent_sub_component_id) {
      const parent_sub_component_children =
        this._spec_get_sub_component_children(parent_sub_component_id)
      const parent_sub_component_index = this._get_sub_component_tree_index(
        parent_sub_component_id
      )
      const sub_component_index =
        parent_sub_component_children.indexOf(sub_component_id)
      const index = parent_sub_component_index + sub_component_index
      return index
    } else {
      return this._get_sub_component_root_index(sub_component_id)
    }
  }

  private _get_sub_component_frame_context = (
    sub_component_id: string
  ): Context => {
    const core_context = this._core_component_frame_context[sub_component_id]
    return core_context
  }

  private _get_sub_component_frame = (sub_component_id: string): Frame => {
    const core_frame = this._core_component_frame[sub_component_id]
    return core_frame
  }

  private _get_component_sub_component_root_base = (
    sub_component_id: string
  ): LayoutBase => {
    const base = this._get_sub_component_root_base(sub_component_id)

    const _base = base.map(([path, comp]) => [
      [sub_component_id, ...path],
      comp,
    ]) as LayoutBase

    return _base
  }

  private _get_sub_component_base = (sub_component_id: string): LayoutBase => {
    const sub_component = this._get_sub_component(sub_component_id)
    const sub_component_base = sub_component.getBase()
    return sub_component_base
  }

  private _get_sub_component_root_base = (
    sub_component_id: string
  ): LayoutBase => {
    const sub_component = this._get_sub_component(sub_component_id)
    const sub_component_root_base = sub_component.getRootBase()
    return sub_component_root_base
  }

  private _get_fullwindow_foreground = (): Component<HTMLElement> => {
    if (this._frame_out) {
      const upper_foreground = findRef<HTMLElement>(this, 'foreground')

      if (upper_foreground) {
        return upper_foreground
      }
    }

    return this._foreground
  }

  private _leave_all_fullwindow = (animate: boolean) => {
    // console.log('Graph', '_leave_all_fullwindow')
    this._leave_fullwindow(animate)

    this._fullwindow_component_set = new Set()
    this._fullwindow_component_ids = []

    this._is_all_fullwindow = false

    this.focus()
  }

  private _abort_fullwindow_animation: Unlisten

  private _cancel_fullwindow_animation = () => {
    // console.log('Graph', '_cancel_fullwindow_animation')
    if (this._abort_fullwindow_animation) {
      this._abort_fullwindow_animation()
      this._abort_fullwindow_animation = undefined
    }
  }

  private _finish_component = () => {
    if (this._is_component_framed) {
      this._leave_component_frame()
    }
  }

  private _finish_sub_component = (sub_component_id: string) => {
    if (this._tree_layout) {
      const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)

      const current_layer_id = this._get_current_layout_layer_id()

      if (parent_id === current_layer_id) {
        if (this._tree_layout) {
          if (this._is_layout_component_layer_visible(current_layer_id)) {
            this._enter_sub_component_frame(sub_component_id)
          } else {
            this._enter_sub_component_frame(sub_component_id)
          }
        } else {
          this._enter_sub_component_frame(sub_component_id)
        }
      } else {
        this._append_sub_component_parent_root(parent_id, sub_component_id)
      }
    } else {
      this._enter_sub_component_frame(sub_component_id)
    }
  }

  private _leave_fullwindow = (_animate: boolean) => {
    // console.log('Graph', '_leave_fullwindow', this._id)

    const { leaveFullwindow } = this.$props

    const { animate } = this._config()

    leaveFullwindow()

    _animate = _animate ?? animate

    this._is_fullwindow = false

    if (!this._frame_out) {
      this._set_fullwindow_frame_off(_animate)
    }

    if (this._unlisten_fullwindow_escape) {
      this._unlisten_fullwindow_escape()

      this._unlisten_fullwindow_escape = undefined
    }

    this._cancel_fullwindow_animation()

    this._leave_all_fullwindow_sub_component(_animate)

    if (this._in_component_control) {
      const sub_component_ids = this._fullwindow_component_ids

      if (_animate) {
        //
      } else {
        for (const sub_component_id of sub_component_ids) {
          this._finish_sub_component(sub_component_id)
        }

        this._finish_component()
      }
    }

    if (this._is_component_framed) {
      this._leave_component_frame()
    }

    if (!this._frame_out) {
      if (!this._disabled) {
        if (this._core_component_unlocked_count === 0) {
          this._enable_input()

          this._show_control(animate)
        }
      }
    }

    if (this._transcend) {
      this._transcend.up()
    }

    if (!this._disabled) {
      this.focus()
    }

    this.dispatchEvent('leave_fullwindow', {}, false)
  }

  private _leave_all_fullwindow_sub_component = (_animate: boolean) => {
    if (this._in_component_control) {
      const sub_component_ids = this._fullwindow_component_ids

      if (_animate) {
        this._abort_fullwindow_animation = this._animate_leave_fullwindow(
          sub_component_ids,
          (sub_component_id) => {},
          () => {
            this._end_leave_fullwindow_animation(sub_component_ids)

            if (this._enabled()) {
              this.focus()
            }
          }
        )
      } else {
        for (const sub_component_id of sub_component_ids) {
          this._decouple_sub_component(sub_component_id)
        }
      }
    }
  }

  private _place_sub_component = (
    sub_component_id: string,
    at?: number
  ): void => {
    // console.log('Graph', '_place_sub_component', sub_component_id)

    if (this._is_all_fullwindow) {
      this._fullwindow_component_set.add(sub_component_id)

      push(this._fullwindow_component_ids, sub_component_id)

      this._couple_sub_component(sub_component_id, at)
    } else {
      this._enter_sub_component_frame(sub_component_id)
    }
  }

  private _displace_sub_component = (sub_component_id: string): void => {
    if (this._is_sub_component_fullwindow(sub_component_id)) {
      this._decouple_sub_component(sub_component_id)
    } else {
      this._leave_sub_component_frame(sub_component_id)
    }
  }

  private _couple_all_fullwindow_component = (): void => {
    for (const sub_component_id of this._fullwindow_component_ids) {
      this._couple_sub_component(sub_component_id)
    }
  }

  private _couple_sub_component = (
    sub_component_id: string,
    at?: number
  ): void => {
    // console.log('Graph', '_couple_sub_component', sub_component_id, at)

    if (at === undefined) {
      this.__move_sub_component(
        sub_component_id,
        (parent_id) => {
          this._append_sub_component_parent_root(parent_id, sub_component_id)
        },
        () => {
          this._append_sub_component_to_root(sub_component_id)
        }
      )
    } else {
      this._couple_sub_component_at(sub_component_id, at)
    }
  }

  private _couple_sub_component_at = (
    sub_component_id: string,
    at: number
  ): void => {
    this.__move_sub_component(
      sub_component_id,
      (parent_id) => {
        this._insert_sub_component_parent_root_at(
          parent_id,
          sub_component_id,
          at
        )
      },
      () => {
        this._insert_sub_component_root_at(sub_component_id, at)
      }
    )
  }

  private _get_sub_component_fullwindow_parent_id = (
    sub_component_id: string
  ): string => {
    let parent_id = this._spec_get_sub_component_parent_id(sub_component_id)
    while (parent_id && !this._is_sub_component_fullwindow(parent_id)) {
      parent_id = this._spec_get_sub_component_parent_id(parent_id)
    }
    return parent_id
  }

  private __move_sub_component = (
    sub_component_id: string,
    parent_root_callback: (parent_id: string) => void,
    root_callback: () => void
  ): void => {
    const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)
    if (parent_id) {
      parent_root_callback(parent_id)
    } else {
      root_callback()
    }
  }

  private _descend_sub_component = (sub_component_id: string): void => {
    this.__move_sub_component(
      sub_component_id,
      (parent_id) => {
        this._remove_sub_component_parent_root(parent_id, sub_component_id)
        this._enter_sub_component_frame(sub_component_id)
      },
      () => {
        this._remove_sub_component_from_root(sub_component_id)
        this._enter_sub_component_frame(sub_component_id)
      }
    )
  }

  public decouple_all_fullwindow_component = (): void => {
    for (const sub_component_id of this._fullwindow_component_ids) {
      this._decouple_sub_component(sub_component_id)
    }
  }

  private _decouple_all_fullwindow_component = (): void => {
    for (const sub_component_id of this._fullwindow_component_ids) {
      this._decouple_sub_component(sub_component_id)
    }
  }

  private _decouple_sub_component = (sub_component_id: string): void => {
    // console.log('Graph', '_decouple_sub_component', sub_component_id)

    this.__move_sub_component(
      sub_component_id,
      (parent_id) => {
        this._remove_sub_component_parent_root(parent_id, sub_component_id)
      },
      () => {
        this._remove_sub_component_from_root(sub_component_id)
      }
    )
  }

  private _unlisten_crud: Unlisten | undefined

  private _enable_crud = (): void => {
    if (this._modes) {
      if (!this._unlisten_crud) {
        this._unlisten_crud = this._modes.addEventListeners([
          makeCustomListener('entermode', this._on_enter_mode),
        ])

        if ((this._modes.getProp('mode') ?? 'none') !== this._mode) {
          this._modes.setProp('mode', this._mode)
        }

        this._mode = this._modes.getMode()
      }
    }
  }

  private _unlisten_cabinet: Unlisten | undefined

  private _enable_cabinet = (): void => {
    if (this._cabinet) {
      if (!this._unlisten_cabinet) {
        // console.log('Graph', '_enable_cabinet')
        this._unlisten_cabinet = this._cabinet.addEventListeners([
          makeCustomListener(
            'draweractive',
            ({ drawerId }: { drawerId: string }) => {
              this._on_cabinet_drawer_active(drawerId)
            }
          ),
          makeCustomListener(
            'drawerinactive',
            ({ drawerId }: { drawerId: string }) => {
              this._on_cabinet_drawer_inactive(drawerId)
            }
          ),
        ])
      }
    }
  }

  private _on_cabinet_drawer_active = (drawer_id: string): void => {
    // console.log('Graph', '_on_cabinet_drawer_active', drawer_id)
    if (drawer_id === 'minimap') {
      this._minimap_hidden = false
    }
  }

  private _on_cabinet_drawer_inactive = (drawer_id: string): void => {
    // console.log('Graph', '_on_cabinet_drawer_inactive', drawer_id)
    if (drawer_id === 'minimap') {
      this._minimap_hidden = true
    }
  }

  private _disable_cabinet = (): void => {
    if (this._cabinet) {
      if (this._unlisten_cabinet) {
        // console.log('Graph', '_disable_cabinet')
        this._unlisten_cabinet()
        this._unlisten_cabinet = undefined
      }
    }
  }

  private _keyboard_unlisten: Unlisten | undefined

  private _is_shift_pressed = (): boolean => {
    return this._is_key_pressed('Shift')
  }

  private _is_alt_pressed = (): boolean => {
    return this._is_key_pressed('Alt')
  }

  private _is_key_pressed = (key: string): boolean => {
    const {
      input: { keyboard },
    } = this.$system

    const keyCode = keyToKeyCode[key]

    const key_pressed = keyboard.pressed.indexOf(keyCode) > -1

    return key_pressed
  }

  private _unlisten_escape: Unlisten | undefined

  private _enable_escape = (): void => {
    if (!this._unlisten_escape) {
      this._unlisten_escape = this.addEventListener(
        makeShortcutListener([
          {
            combo: 'Escape',
            keydown: this._on_escape_keydown,
            strict: true,
          },
        ])
      )
    }
  }

  private _disable_escape = (): void => {
    if (this._unlisten_escape) {
      this._unlisten_escape()
      this._unlisten_escape = undefined
    }
  }

  private _unlisten_enter: Unlisten | undefined

  private _enable_enter = (): void => {
    if (!this._unlisten_enter) {
      this._unlisten_enter = this.addEventListener(
        makeShortcutListener([
          {
            combo: 'Enter',
            keydown: this._on_enter_keydown,
          },
        ])
      )
    }
  }

  private _disable_enter = (): void => {
    if (this._unlisten_enter) {
      this._unlisten_enter()
      this._unlisten_enter = undefined
    }
  }

  private _on_gamepad_buttondown = (button: number): void => {
    // console.log('Graph', '_on_gamepad_buttondown', button)

    const is_mode_red = button === 0
    const is_mode_green = button === 1
    const is_mode_blue = button === 2
    const is_mode_yellow = button === 3

    const is_zoom_button_in = button === 6
    const is_zoom_button_out = button === 7

    const is_search = button === 9

    const is_up = button === 12
    const is_down = button === 13

    const k = 0.01

    if (is_zoom_button_in) {
      this._gamepad_zoom_z = -k

      this._start_gamepad_zoom_frame()
    }

    if (is_zoom_button_out) {
      this._gamepad_zoom_z = k

      this._start_gamepad_zoom_frame()
    }

    if (is_mode_red) {
      this._set_crud_mode('remove')
    }

    if (is_mode_green) {
      this._set_crud_mode('add')
    }

    if (is_mode_blue) {
      this._set_crud_mode('change')
    }

    if (is_mode_yellow) {
      this._set_crud_mode('data')
    }

    if (is_search) {
      this._show_search()
    }

    if (is_up) {
      if (this._search_hidden) {
        // TODO
      } else {
        this._select_search_up()
      }
    }

    if (is_down) {
      if (this._search_hidden) {
        // TODO
      } else {
        this._select_search_down()
      }
    }
  }

  private _select_search_up = (): void => {
    if (this._search) {
      this._search.select_next(-1)
    }
  }

  private _select_search_down = (): void => {
    if (this._search) {
      this._search.select_next(1)
    }
  }

  private _on_gamepad_buttonup = (button: number): void => {
    // console.log('Graph', '_on_gamepad_buttonup', button)

    const is_mode_red = button === 0
    const is_mode_green = button === 1
    const is_mode_blue = button === 2
    const is_mode_yellow = button === 3

    const is_zoom_button_in = button === 6
    const is_zoom_button_out = button === 7

    const is_search = button === 9

    const k = 0

    if (is_zoom_button_in && !is_zoom_button_out) {
      this._gamepad_zoom_z = k

      this._start_gamepad_zoom_frame()
    }

    if (!is_zoom_button_in && is_zoom_button_out) {
      this._gamepad_zoom_z = k

      this._start_gamepad_zoom_frame()
    }

    if (this._search_hidden) {
      if (is_mode_red && this._mode === 'remove') {
        this._set_crud_mode('none')
      }

      if (is_mode_green && this._mode === 'add') {
        this._set_crud_mode('none')
      }

      if (is_mode_blue && this._mode === 'change') {
        this._set_crud_mode('none')
      }

      if (is_mode_yellow && this._mode === 'data') {
        this._set_crud_mode('none')
      }
    }

    if (is_search) {
      if (this._search_hidden) {
        //
      } else {
        // this._hide_search()
      }
    }
  }

  private _on_gamepad_axischange = (button: [number, number]): void => {
    // console.log('Graph', '_on_gamepad_axischange', button)

    const [side, d] = button

    const right_axis = side === 0 || side === 1
    const left_axis = side === 2 || side === 3

    const k = 6

    if (right_axis) {
      const x_axis = side === 0
      const y_axis = side === 1

      if (x_axis) {
        this._gamepad_zoom_x = -d / k

        if (Math.abs(d) < 0.1) {
          this._gamepad_zoom_x = 0
        }
      }

      if (y_axis) {
        this._gamepad_zoom_y = -d / k

        if (Math.abs(d) < 0.1) {
          this._gamepad_zoom_y = 0
        }
      }

      this._start_gamepad_zoom_frame()
    }
  }

  private _gamepad_zoom_x: number = 0
  private _gamepad_zoom_y: number = 0
  private _gamepad_zoom_z: number = 0

  private _gamepad_zoom_translate_frame: number | undefined

  private _start_gamepad_zoom_frame = (): void => {
    const {
      api: {
        animation: { requestAnimationFrame },
      },
    } = this.$system

    const { $width, $height } = this.$context

    this._gamepad_zoom_translate_frame = requestAnimationFrame(() => {
      const { x, y, z } = this._zoom

      if (
        this._gamepad_zoom_x === 0 &&
        this._gamepad_zoom_y === 0 &&
        this._gamepad_zoom_z === 0
      ) {
        this._stop_gamepad_zoom_frame()

        return
      }

      const next_zoom = {
        x: x + this._gamepad_zoom_x,
        y: y + this._gamepad_zoom_y,
        z,
      }

      this._set_zoom(next_zoom)

      if (this._gamepad_zoom_z !== 0) {
        this._zoom_in(this._gamepad_zoom_z, $width / 2, $height / 2)
      }

      this._start_gamepad_zoom_frame()
    })
  }

  private _stop_gamepad_zoom_frame = (): void => {
    const {
      api: {
        animation: { requestAnimationFrame, cancelAnimationFrame },
      },
    } = this.$system

    if (this._gamepad_zoom_translate_frame !== undefined) {
      cancelAnimationFrame(this._gamepad_zoom_translate_frame)

      this._gamepad_zoom_translate_frame = undefined
    }
  }

  private _enable_gamepad = () => {
    const {
      api: {
        input: {
          gamepad: { getGamepad, addEventListener },
        },
      },
    } = this.$system

    if (!this._gamepad_connection_unlisten) {
      // console.log('Graph', '_enable_gamepad')

      const onConnect = (event) => {
        // console.log('Graph', '_enable_gamepad', 'onConnect', event)

        const gamead = getGamepad(event.gamepad.index)

        this._gamepad = new Gamepad_(this.$system, gamead)

        this._gamepad_unlisten = callAll([
          this._gamepad.addListener('buttondown', this._on_gamepad_buttondown),
          this._gamepad.addListener('buttonup', this._on_gamepad_buttonup),
          this._gamepad.addListener('axischange', this._on_gamepad_axischange),
        ])
      }

      const onDisconnect = (event) => {
        // console.log('Graph', '_enable_gamepad', 'onDisconnect', event)

        this._gamepad.disconnect()

        this._stop_gamepad_zoom_frame()
      }

      this._gamepad_connection_unlisten = callAll([
        addEventListener('gamepadconnected', onConnect),
        addEventListener('gamepaddisconnected', onDisconnect),
      ])
    }
  }

  private _disable_gamepad = () => {
    // console.log('Graph', '_disable_gamepad')

    if (this._gamepad_unlisten) {
      this._gamepad_unlisten()
      this._gamepad_unlisten = undefined
    }

    if (this._gamepad_connection_unlisten) {
      this._gamepad_connection_unlisten()
      this._gamepad_connection_unlisten = undefined
    }
  }

  private _enable_keyboard = (): void => {
    if (!this._keyboard_unlisten) {
      // console.log('Graph', '_enable_keyboard')

      const combo_list: Shortcut[] = [
        {
          combo: ['Backspace', 'Delete'],
          keydown: this._on_backspace_keydown,
        },
        {
          // combo: 'Ctrl + p',
          // combo: 'p',
          // combo: 'space',
          combo: ['Ctrl + ;', ';'],
          // combo: ['Ctrl + /'],
          keydown: this._on_ctrl_semicolon_keydown,
          strict: false,
        },
        {
          // combo: 'p',
          combo: ';',
          // combo: '/',
          keydown: (key, { ctrlKey }) => {
            if (ctrlKey) {
              this._on_ctrl_semicolon_keydown()
            }
          },
        },
        {
          combo: ['Alt'],
          keydown: () => {
            this._on_alt_keydown()
          },
          keyup: () => {
            this._on_alt_keyup()
          },
        },
        {
          combo: ['`'],
          keydown: () => {
            //
          },
          keyup: () => {
            this._on_backtick_keyup()
          },
        },
        {
          combo: ['Ctrl + s'],
          keydown: () => {
            this._on_ctrl_s_keydown()
          },
          preventDefault: true,
        },
        {
          combo: ['Ctrl + Shift + s'],
          keydown: () => {
            this._on_ctrl_shift_s_keydown()
          },
          preventDefault: true,
        },
        {
          combo: ['Ctrl + o'],
          keydown: () => {
            this._on_ctrl_o_keydown()
          },
          preventDefault: true,
        },
        {
          combo: ['Ctrl + r'],
          keydown: () => {
            this._on_ctrl_r_keydown()
          },
          preventDefault: true,
        },
        {
          combo: ['Ctrl + l', 'l'],
          strict: true,
          keydown: this._on_ctrl_l_keydown,
        },
        {
          combo: ['Ctrl + m', 'm'],
          strict: true,
          keydown: this._on_ctrl_m_keydown,
        },
        {
          combo: 'Ctrl + a',
          keydown: this._on_ctrl_a_keydown,
        },
        {
          combo: 'Ctrl + c',
          keydown: this._on_ctrl_c_keydown,
        },
        {
          combo: 'Ctrl + Shift + c',
          keydown: this._on_ctrl_shift_c_keydown,
        },
        {
          combo: 'Ctrl + x',
          keydown: this._on_ctrl_x_keydown,
        },
        {
          combo: 'Ctrl + v',
          keydown: this._on_ctrl_v_keydown,
        },
        {
          combo: 'Ctrl + z',
          multiple: true,
          keydown: this._on_ctrl_z_keydown,
        },
        {
          combo: 'Ctrl + Shift + z',
          multiple: true,
          keydown: this._on_ctrl_shift_z_keydown,
        },
        {
          combo: ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'],
          multiple: true,
          strict: false,
          keydown: this._on_arrow_keydown,
        },
        {
          combo: ['Space'],
          keydown: this._on_space_keydown,
          preventDefault: true,
        },
        {
          combo: ['\\'],
          keydown: this._on_backslash_keydown,
          keyup: this._on_backslash_keyup,
        },
        {
          combo: ['/'],
          keydown: this._on_slash_keydown,
          keyup: this._on_slash_keyup,
        },
      ]
      const shortcutListener = makeShortcutListener(combo_list)
      this._keyboard_unlisten = this.addEventListener(shortcutListener)
    }

    this._enable_mode_keyboard()
  }

  private _unlisten_mode_keyboard: Unlisten | undefined = undefined

  private _enable_mode_keyboard = (): void => {
    // console.log('Graph', '_enable_mode_keyboard', this._id)

    if (this._modes && !this._unlisten_mode_keyboard) {
      this._unlisten_mode_keyboard = enableModeKeyboard(this, (mode: Mode) => {
        if (!this._search_hidden) {
          return false
        }

        if (this._edit_datum_node_id) {
          return false
        }

        this._mode_just_set_by_keyboard = true
        this._mode_set_by_keyboard = mode !== 'none'

        this._set_crud_mode(mode)

        this._mode_just_set_by_keyboard = false

        return true
      })
    }
  }

  private _disable_mode_keyboard = (): void => {
    // console.trace('Graph', '_disable_mode_keyboard', this._id)

    if (this._unlisten_mode_keyboard) {
      this._unlisten_mode_keyboard()
      this._unlisten_mode_keyboard = undefined
    }
  }

  private _unlisten_search: Unlisten | undefined

  private _control: GUI | null = null
  private _cabinet: Cabinet | null = null
  private _search: Search | null = null
  private _import: IconButton | null = null
  private _export: IconButton | null = null
  private _minimap: Minimap | null = null
  private _modes: Modes | null = null

  private _transcend: Transcend | null = null

  private _frame: Component<HTMLElement> | null = null

  private _lock_control = (): void => {
    const { animate } = this._config()

    if (!this._control_lock) {
      if (!this._disabled) {
        // console.log('Graph', '_lock_control', this._id)

        this._control_lock = true

        if (this._control) {
          this._control.dispatchEvent('lock', {}, false)
        }

        if (
          !this._subgraph_unit_id &&
          (!this._is_fullwindow || this._frame_out) &&
          (this._temp_control_lock || this._core_component_unlocked_count === 0)
        ) {
          this._enable_input()

          this._show_control(animate)
        }
      }
    }
  }

  private _enable_search = (): void => {
    if (this._search && !this._unlisten_search) {
      // console.log('Graph', '_enable_search', this._id)

      const pointerDownListener = makePointerDownListener(() => {
        this._search_to_be_focused = true
      })
      const selectedListener = makeCustomListener(
        'selected',
        this._on_search_item_selected
      )
      const shownListener = makeCustomListener(
        'shown',
        this._on_search_list_shown
      )
      const hiddenListener = makeCustomListener(
        'hidden',
        this._on_search_list_hidden
      )
      const pickListener = makeCustomListener('pick', this._on_search_item_pick)
      const emptyListener = makeCustomListener('empty', this._on_search_empty)
      const shapeListener = makeCustomListener('shape', this._on_search_shape)

      this._unlisten_search = this._search._search.addEventListeners([
        pointerDownListener,
        selectedListener,
        shownListener,
        hiddenListener,
        pickListener,
        emptyListener,
        shapeListener,
      ])

      const shape = this._tree_layout ? 'rect' : 'circle'

      this._search.setProp('selectedColor', COLOR_GREEN)
      this._search.setProp('registry', this._system)
      this._search.setProp('shape', shape)

      if (this._search_hidden) {
        this._hide_search()
      } else {
        this._show_search()
      }

      this._search._microphone.addEventListener(
        makeCustomListener('text', this._on_microphone_transcript)
      )
    }
  }

  private _on_microphone_transcript = (transcript: string) => {
    let value = transcript.toLowerCase()

    const writeToSearch = () => {
      value = value.substr(0, 30)

      this._search.setValue(value)
      this._search.focus()
    }

    const writeToEditDatum = () => {
      writeToDatum(this._edit_datum_node_id)
    }

    const writeToDatum = (datum_node_id: string) => {
      const datum = this._datum[datum_node_id] as Datum

      const leaf = datum._data_tree.getChildAtPath(this._edit_datum_path)

      const current = leaf._leaf._input.$element.value

      const { selectionStart, selectionEnd } = leaf._leaf._input.$element

      if (
        current === '' ||
        (selectionStart === 0 && selectionEnd === current.length)
      ) {
        let target_type

        const pin_node_id = this._datum_to_pin[datum_node_id]

        if (pin_node_id) {
          target_type = this._get_link_pin_type(pin_node_id)
        } else {
          target_type = ANY_TREE
        }

        const leaf_type =
          _getNodeAtPath(target_type, this._edit_datum_path) ?? ANY_TREE

        if (leaf_type.type === TreeNodeType.Number) {
          const parsed = parseNumberSentence(value)

          value = (parsed && `${parsed}`) || value
        } else if (leaf_type.type === TreeNodeType.Boolean) {
          //
        } else if (leaf_type.type === TreeNodeType.String) {
          value = `"${value}"`
        } else {
          const parsed = parseNumberSentence(value)

          value = (parsed && `${parsed}`) || `"${value}"`
        }
      }

      writeToTextField(this.$system, leaf._leaf._input.$element, value)
    }

    if (this._edit_datum_node_id) {
      writeToEditDatum()
    } else if (this._edit_node_name_id) {
      const name_comp = this._get_node_name_comp(this._edit_node_name_id)

      writeToTextField(this.$system, name_comp.$element, value)
    } else {
      writeToSearch()
    }
  }

  private _get_node_name_comp = (node_id: string): TextField | TextArea => {
    if (this._is_unit_node_id(node_id)) {
      return this._core_name[node_id]
    } else if (this._is_link_pin_node_id(node_id)) {
      return this._pin_name[node_id]
    } else if (this._is_plug_node_id(node_id)) {
      return this._ext_pin_name[node_id]
    } else {
      throw new InvalidStateError()
    }
  }

  private _unlisten_import: Unlisten

  private _enable_import = (): void => {
    if (this._import && !this._unlisten_import) {
      // console.log('Graph', '_enable_import')

      this._unlisten_import = this._import.addEventListener(
        makeClickListener({
          onClick: () => {
            this._on_ctrl_o_keydown()
          },
        })
      )
    }
  }

  private _disable_import = () => {
    if (this._unlisten_import) {
      // console.log('Graph', '_disable_import')

      this._unlisten_import()
      this._unlisten_import = undefined
    }
  }

  private _unlisten_export: Unlisten

  private _enable_export = (): void => {
    if (this._export && !this._unlisten_export) {
      // console.log('Graph', '_enable_export')

      this._unlisten_export = this._export.addEventListener(
        makeClickListener({
          onClick: () => {
            this._on_ctrl_s_keydown()
          },
        })
      )
    }
  }

  private _disable_export = () => {
    if (this._unlisten_export) {
      // console.log('Graph', '_disable_export')

      this._unlisten_export()
      this._unlisten_export = undefined
    }
  }

  private _disable_search = (): void => {
    if (this._unlisten_search) {
      // console.log('Graph', '_disable_search', this._id)

      this._unlisten_search()

      this._unlisten_search = undefined
    }
  }

  private _unlisten_transcend: Unlisten | undefined

  private _enable_transcend = (): void => {
    // console.log('Graph', '_enable_transcend', this._id)

    const { animate } = this._config()

    if (this._transcend) {
      if (this._unlisten_transcend) {
        this._unlisten_transcend()
      }

      this._unlisten_transcend = this._transcend.addEventListener(
        makeClickListener({
          onClick: this._on_transcend_click,
        })
      )

      if (this._is_fullwindow) {
        this._transcend.down(false)
      } else {
        this._transcend.up(false)
      }

      this._show_transcend(animate)
    }
  }

  private _disable_transcend = (): void => {
    // console.log('Graph', '_disable_transcend', this._id)

    if (this._transcend) {
      if (this._unlisten_transcend) {
        this._unlisten_transcend()
        this._unlisten_transcend = undefined
      }
    }
  }

  private _show_transcend = (animate: boolean) => {
    // console.log('Graph', '_show_transcend', animate, this._id)

    if (this._force_trasncend_animation_false) {
      this._force_trasncend_animation_false = false

      animate = false
    }

    if (this._transcend) {
      this._transcend.show(animate)
    }
  }

  private _hide_transcend = (animate: boolean) => {
    // console.log('Graph', '_hide_transcend', animate, this._id)

    if (this._transcend) {
      this._transcend.hide(animate)
    }
  }

  private _disable_keyboard = (): void => {
    if (this._keyboard_unlisten) {
      // console.log('Graph', '_disable_keyboard')
      this._keyboard_unlisten()
      this._keyboard_unlisten = undefined
    }

    this._disable_mode_keyboard()
  }

  private _pointer_up_all_pressed_pointer_id = () => {
    for (const pointer_id in this._pointer_id_pressed_node_id) {
      const pointerId = Number.parseInt(pointer_id)
      this.__on_pointer_up(pointerId)
    }
  }

  private _layout_core_animation_count: number = 0

  private _cancel_layout_core_animation = (sub_component_id: string) => {
    if (this._layout_core_abort_animation[sub_component_id]) {
      this._layout_core_abort_animation[sub_component_id]()

      delete this._layout_core_abort_animation[sub_component_id]

      this._layout_core_animating.delete(sub_component_id)
    }
  }

  private _cancel_parent_animation = (sub_component_id: string) => {
    if (this._abort_sub_component_parent_animation[sub_component_id]) {
      this._abort_sub_component_parent_animation[sub_component_id]()

      delete this._abort_sub_component_parent_animation[sub_component_id]
    }
  }

  private _animate_layout_core = (
    sub_component_id: string,
    n0: LayoutNode,
    n1: () => LayoutNode,
    callback: () => void
  ) => {
    // console.log('Graph', '_animate_layout_core', sub_component_id)

    this._cancel_layout_core_animation(sub_component_id)

    this._layout_core_animating.add(sub_component_id)

    this._layout_core_abort_animation[sub_component_id] =
      this._animate_simulate_trait(
        n0,
        n1,
        ({ x, y, sx, sy, width, height, opacity, fontSize }) => {
          this._set_layout_core_position_x(sub_component_id, x)
          this._set_layout_core_position_y(sub_component_id, y)

          this.__resize_layout_core(
            sub_component_id,
            Math.max(width, 0),
            Math.max(height, 0)
          )

          this._scale_layout_core_x(sub_component_id, sx)
          this._scale_layout_core_y(sub_component_id, sy)
        },
        () => {
          delete this._layout_core_abort_animation[sub_component_id]

          this._layout_core_animating.delete(sub_component_id)

          if (this._layout_core_animating.size === 0) {
            this._on_all_layout_core_animation_end()
          }

          callback()

          return true
        }
      )
  }

  private _animate_leaf_frame = (
    leaf_id: string,
    n0: LayoutNode,
    n1: () => LayoutNode,
    callback: () => void | boolean | Promise<boolean>
  ): Callback => {
    // console.log('Graph', '_animate_leaf_frame', leaf_id)

    return this._animate_simulate_trait(
      n0,
      n1,
      this._animate_tick_leaf_trait.bind(this, leaf_id),
      callback
    )
  }

  private _animate_simulate = <T extends Dict<AnimatableValue>>(
    n0: T,
    n1: () => T,
    ff: [string, number][],
    tf: (n: T) => void,
    callback: () => void | boolean | Promise<boolean>
  ): Callback => {
    return animateSimulate(this.$system, n0, n1, ff, tf, callback)
  }

  private _animate_simulate_trait = (
    n0: LayoutNode,
    n1: () => LayoutNode,
    tick: (n: LayoutNode) => void,
    callback: () => void | boolean | Promise<boolean>
  ): Callback => {
    // console.log('Graph', '_animate_simulate')

    return this._animate_simulate(
      n0,
      n1,
      [
        ['x', ANIMATION_DELTA_THRESHOLD],
        ['y', ANIMATION_DELTA_THRESHOLD],
        ['width', ANIMATION_DELTA_THRESHOLD],
        ['height', ANIMATION_DELTA_THRESHOLD],
        ['sx', ANIMATION_DELTA_THRESHOLD / 100],
        ['sy', ANIMATION_DELTA_THRESHOLD / 100],
        ['opacity', ANIMATION_DELTA_THRESHOLD / 100],
        ['fontSize', ANIMATION_DELTA_THRESHOLD / 10],
        ['color', ANIMATION_DELTA_THRESHOLD / 100],
      ],
      tick,
      callback
    )
  }

  private _on_all_layout_core_animation_end = (): void => {
    // console.log('Graph', '_on_all_layout_core_animation_end')

    if (this._tree_layout) {
      //
    } else {
      this._set_minimap_to_graph()
    }
  }

  private _animate_layout_core_target = (
    sub_component_id: string,
    target_id: string,
    n0: LayoutNode,
    callback: () => void
  ): void => {
    this._animate_layout_core(
      sub_component_id,
      n0,
      () => {
        if (target_id === sub_component_id) {
          const anchor_node = this._layout_target_node[target_id]
          return anchor_node
        } else {
          const anchor_node = this._layout_node[target_id]
          return anchor_node
        }
      },
      callback
    )
  }

  private _animate_layout_core_anchor = (
    sub_component_id: string,
    n0: LayoutNode,
    callback: () => void
  ): void => {
    const anchor_id = this._get_layout_node_anchor_id(sub_component_id)

    return this._animate_layout_core_target(
      sub_component_id,
      anchor_id,
      n0,
      callback
    )
  }

  private _animate_element_opacity = (
    element: HTMLElement,
    to: number,
    callback: Unlisten = NOOP
  ): Animation => {
    // console.log('Graph', '_animate_element_opacity', to)

    const animation = element.animate(
      [
        {
          opacity: `${to}`,
          composite: 'replace',
        },
      ],
      { duration: ANIMATION_T_MS, fill: 'forwards' }
    )

    animation.onfinish = () => {
      element.style.opacity = `${to}`

      flushAnimation(animation)

      callback()
    }

    return animation
  }

  private _animate_layout_root_element_opacity = (to: number) => {
    // console.log('Graph', '_animate_layout_root_element_opacity', to)

    if (this._layout_root_opacity_animation) {
      flushAnimation(this._layout_root_opacity_animation)
    }

    this._layout_root_opacity_animation = this._animate_element_opacity(
      this._layout_root.children.$element,
      to,
      () => {
        this._layout_root_opacity_animation = undefined
      }
    )
  }

  private _animate_layout_layer_element_opacity = (
    layer_id: string,
    to: number
  ) => {
    const layout_layer = this._get_layout_layer(layer_id)

    if (this._layout_layer_opacity_animation[layer_id]) {
      flushAnimation(this._layout_layer_opacity_animation[layer_id])
    }

    this._layout_layer_opacity_animation[layer_id] =
      this._animate_element_opacity(layout_layer.children.$element, to, () => {
        delete this._layout_layer_opacity_animation[layer_id]
      })
  }

  private _enter_tree_layout = (): void => {
    // console.log('Graph', '_enter_tree_layout')

    const { animate } = this._config()

    this._tree_layout = true

    this._pointer_up_all_pressed_pointer_id()

    this._cancel_all_layout_parent_children_animation()

    this._animate_layout_root_element_opacity(1)

    this._refresh_all_layout_layer_opacity()

    const current_layout_layer_id = this._get_current_layout_layer_id()

    const current_layout_layer = this._get_current_layout_layer()

    if (current_layout_layer_id) {
      this._animate_layout_layer_element_opacity(current_layout_layer_id, 1)
    }

    this._layout_comp.$element.style.pointerEvents = 'inherit'

    current_layout_layer.content.$element.style.overflowX = 'hidden'
    current_layout_layer.content.$element.style.overflowY = 'auto'
    current_layout_layer.layer.$element.style.pointerEvents = 'inherit'

    current_layout_layer.children.$element.style.pointerEvents = 'inherit'

    current_layout_layer.children.$element.style.overflowX = 'initial'
    current_layout_layer.children.$element.style.overflowY = 'initial'

    this._refresh_all_layout_node_target_position()
    this._layout_scroll_search_unit_into_view()

    this._force_all_layout_node_traits()

    for (const sub_component_id in this._component.$subComponent) {
      const { width, height } =
        this._get_unit_component_layout_size(sub_component_id)

      // PERF
      this._sim_layout_resize_sub_component(sub_component_id, width, height)
    }

    for (const sub_component_id in this._component.$subComponent) {
      const visible = this._is_layout_component_layer_visible(sub_component_id)
      const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)
      const children = this._spec_get_sub_component_children(sub_component_id)

      const parent_visible = !parent_id || this._layout_path.includes(parent_id)

      if (!visible && children.length > 0) {
        if (!this._animating_sub_component_base_id.has(sub_component_id)) {
          for (const child_id of children) {
            this._measure_sub_component_base(child_id)
          }
        }
      }

      if (parent_visible) {
        this._measure_sub_component_base(sub_component_id)
      }
    }

    if (animate) {
      this._animate_enter_tree_layout()
    } else {
      // TODO
    }

    this._animate_zoom_opacity(LAYER_OPACITY_MULTIPLIER)

    for (const sub_component_id in this._component.$subComponent) {
      const layout_core = this._layout_core[sub_component_id]

      this._listen_layout_core(sub_component_id, layout_core)
      this._move_core_content_graph_to_layout(sub_component_id)
      this._refresh_component_children_counter(sub_component_id)
    }

    this._set_minimap_to_layout()
  }

  private _refresh_all_layout_node_target_position = () => {
    this._refresh_layout_node_target_position(null)

    for (const layer of this._layout_path) {
      this._refresh_layout_node_target_position(layer)
    }
  }

  private _leaf_layer_offset_x: number = 0
  private _leaf_layer_offset_y: number = 0

  private _leaf_prop_unlisten: Dict<Unlisten> = {}

  private _plug_leaf_frame = (
    leaf_id: string,
    leaf_comp: Component<IOElement, any>,
    leaf_node: LayoutNode,
    leaf_layer: Component<HTMLElement>
  ): Frame => {
    // console.log('Graph', '_plug_leaf_frame', leaf_id, leaf_node)

    const {
      api: {
        text: { measureText },
      },
    } = this.$system

    const { x, y, width, height, sx, sy, fontSize, opacity, color } = leaf_node

    const frame_style = {
      display: 'block',
      position: 'absolute',
      left: `${
        x + this._leaf_layer_offset_x + ((Math.abs(sx) - 1) * width) / 2
      }px`,
      top: `${
        y + this._leaf_layer_offset_y + ((Math.abs(sy) - 1) * height) / 2
      }px`,
      width: `${width}px`,
      height: `${height}px`,
      // border: `1px solid ${randomColorString()}`,
      zIndex: '0',
      boxSizing: 'content-box',
      transform: `scale(${sx}, ${sy})`,
      opacity: `${opacity}`,
      fontSize: `${fontSize}px`,
      overflow: 'visible',
      pointerEvents: 'none',
      color: rgbaToHex(color),
    }

    const is_text = isTextLike(leaf_comp)
    const is_canvas = isCanvasLike(leaf_comp)
    const is_table = isTableLike(leaf_comp)
    const is_svg = isSVGLike(leaf_comp)

    const is_auto = is_svg || is_table

    const temp_style = {
      position: 'relative',
      boxSizing: 'border-box',
      margin: '0',
      top: '0',
      left: '0',
      right: '0',
      bottom: '0',
      width: is_auto ? undefined : '100%',
      height: is_auto ? undefined : '100%',
      opacity: '1',
      transform: '',
      color: 'currentcolor',
    }

    const prop_unlisten = leaf_comp.interceptProp('style', (style) => {
      const style_ = { ...style, ...temp_style }

      this._leaf_init_style[leaf_id] = style
      this._leaf_style[leaf_id] = style

      return style_
    })

    this._leaf_prop_unlisten[leaf_id] = prop_unlisten

    let leaf_frame: Frame = this._leaf_frame[leaf_id]

    if (leaf_frame) {
      applyStyle(leaf_frame.$element, frame_style)
    } else {
      leaf_frame = new Frame(
        {
          style: frame_style,
        },
        this.$system
      )

      this._leaf_frame[leaf_id] = leaf_frame
    }

    if (this._leaf_frame_active[leaf_id]) {
      const prev_layer = this._leaf_frame_layer[leaf_id]

      prev_layer.removeChild(leaf_frame)
    } else {
      leaf_frame.appendChild(leaf_comp)

      const style = rawExtractStyle(leaf_comp.$node, leaf_node, measureText)
      const leaf_style = extractStyle(leaf_comp, leaf_node, measureText)

      this._leaf_init_style[leaf_id] = style
      this._leaf_style[leaf_id] = leaf_style

      if (!is_text) {
        applyStyle(leaf_comp.$node as HTMLElement | SVGElement, {
          ...style,
          ...temp_style,
        })

        if (is_canvas) {
          const canvas_comp = leaf_comp as Canvas_

          const canvas_width = canvas_comp.getProp('width')
          const canvas_height = canvas_comp.getProp('height')

          if (canvas_width) {
            if (
              typeof canvas_width === 'string' &&
              isFrameRelativeValue(canvas_width)
            ) {
              this._leaf_attr[leaf_id] = {
                width: canvas_comp.getProp('width'),
              }

              canvas_comp.setProp('width', '100vw')
            }
          }

          if (
            typeof canvas_height === 'string' &&
            isFrameRelativeValue(canvas_height)
          ) {
            if (isFrameRelativeValue(canvas_height)) {
              this._leaf_attr[leaf_id] = {
                height: canvas_comp.getProp('height'),
              }

              canvas_comp.setProp('height', '100vh')
            }
          }
        }
      }
    }

    leaf_layer.appendChild(leaf_frame)

    // TODO add listener for style prop change

    this._leaf_frame_active[leaf_id] = true
    this._leaf_frame_layer[leaf_id] = leaf_layer

    return leaf_frame
  }

  private _unplug_leaf_frame = (
    leaf_id: string,
    leaf_comp: Component<any, any>
  ) => {
    // console.log('Graph', '_unplug_leaf_frame', leaf_id)

    if (this._leaf_frame_active[leaf_id]) {
      const leaf_layer = this._leaf_frame_layer[leaf_id]
      const leaf_frame = this._leaf_frame[leaf_id]

      leaf_frame.removeChild(leaf_comp)
      leaf_layer.removeChild(leaf_frame)

      const style = this._leaf_init_style[leaf_id]

      delete this._leaf_frame[leaf_id]
      delete this._leaf_frame_active[leaf_id]
      delete this._leaf_frame_layer[leaf_id]
      delete this._leaf_frame_node[leaf_id]
      delete this._leaf_style[leaf_id]
      delete this._leaf_init_style[leaf_id]

      const is_text = leaf_comp.$node instanceof Text
      const is_canvas = leaf_comp.$node instanceof HTMLCanvasElement

      const prop_unlisten = this._leaf_prop_unlisten[leaf_id]

      prop_unlisten()

      delete this._leaf_prop_unlisten[leaf_id]

      if (!is_text) {
        applyStyle(leaf_comp.$node, style)

        const leaf_attr = this._leaf_attr[leaf_id]

        for (const attr in leaf_attr) {
          leaf_comp.setProp(attr, leaf_attr[attr])
        }
      }
    }
  }

  private _get_sub_component_layout_layer = (
    sub_component_id: string
  ): LayoutLayer => {
    const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)

    return this._get_sub_component_parent_layer(parent_id)
  }

  private _get_sub_component_parent_layer = (
    parent_id: string | null
  ): LayoutLayer => {
    if (parent_id === null) {
      return this._layout_root
    }

    const is_parent_uncollapsed =
      !parent_id || this._layout_path.includes(parent_id)

    const parent_layer = this._get_layout_layer(parent_id)

    const parent_parent_id = this._get_sub_component_layout_parent(parent_id)

    const parent_parent_layer =
      this._get_sub_component_parent_layer(parent_parent_id)

    const leaf_layer = is_parent_uncollapsed
      ? parent_layer
      : parent_parent_layer

    return leaf_layer
  }

  private _measure_sub_component_base = (
    sub_component_id: string,
    base = this._get_sub_component_root_base(sub_component_id),
    offset = this._context_trait()
  ): void => {
    const {
      api: {
        text: { measureText },
      },
    } = this.$system

    for (const leaf of base) {
      let [leaf_path, leaf_comp] = leaf

      const leaf_id = joinPath([sub_component_id, ...leaf_path])

      const leaf_comp_offset = leaf_comp.getOffset() ?? leaf_comp

      if (leaf_comp.$wrap) {
        leaf_comp = leaf_comp_offset
      }

      const leaf_node = extractTrait(leaf_comp, measureText)

      leaf_node.x -= offset.x
      leaf_node.y -= offset.y

      leaf_node.x /= offset.sx
      leaf_node.y /= offset.sy

      leaf_node.sx /= offset.sx
      leaf_node.sy /= offset.sy

      this._leaf_frame_node[leaf_id] = leaf_node
    }
  }

  private _remove_sub_component_base = (sub_component_id: string): void => {
    // console.log('Graph', '_remove_sub_component_base', sub_component_id)

    const sub_component = this._get_sub_component(sub_component_id)
    const base = this._get_sub_component_base(sub_component_id)

    this.__remove_sub_component_leaf_base(sub_component, base)
  }

  private _remove_sub_component_root_base = (
    sub_component_id: string
  ): void => {
    // console.log('Graph', '_remove_sub_component_root_base', sub_component_id)

    const sub_component = this._get_sub_component(sub_component_id)
    const base = this._get_sub_component_root_base(sub_component_id)

    this.__remove_sub_component_leaf_base(sub_component, base)
  }

  private __remove_sub_component_leaf_base = (
    sub_component: Component,
    base: LayoutBase
  ) => {
    // console.log('Graph', '__remove_sub_component_leaf_base', sub_component, base)

    for (const leaf of base) {
      const [leaf_path, leaf_comp] = leaf

      const leaf_parent_last = leaf_path[leaf_path.length - 1]
      const leaf_parent_path = leaf_path.slice(0, -1)
      const leaf_parent = sub_component.pathGetSubComponent(leaf_parent_path)

      if (leaf_parent === leaf_comp) {
        //
      } else {
        const parent_id = leaf_parent.getSubComponentParentId(leaf_parent_last)

        if (parent_id) {
          const parent = leaf_parent.getSubComponent(parent_id)

          if (parent.$mountParentRoot.includes(leaf_comp)) {
            parent.removeParentRoot(leaf_comp)
          }
        } else {
          if (leaf_parent.$mountRoot.includes(leaf_comp)) {
            leaf_parent.removeRoot(leaf_comp)
          }
        }
      }
    }
  }

  private _plug_sub_component_base = (
    sub_component_id: string,
    leaf_base: LayoutBase,
    leaf_traits: LayoutNode[],
    leaf_layer: Component<HTMLElement>
  ): Unlisten => {
    // console.log(
    //   '_plug_sub_component_base',
    //   sub_component_id,
    //   leaf_base,
    //   leaf_traits,
    //   leaf_layer
    // )

    let i = 0

    const all_unlisten = []

    for (const leaf of leaf_base) {
      const [leaf_path, leaf_comp] = leaf

      const leaf_id = joinPath([sub_component_id, ...leaf_path])

      const leaf_node = leaf_traits[i] || this._leaf_frame_node[leaf_id]

      this._plug_leaf_frame(leaf_id, leaf_comp, leaf_node, leaf_layer)

      i++
    }

    return callAll(all_unlisten)
  }

  private _plug_animate_sub_component_base = (
    sub_component_id: string,
    leaf_base: LayoutBase,
    leaf_traits: LayoutNode[],
    leaf_layer: Component<HTMLElement>,
    n1: (
      leaf_id: string,
      leaf_path: string[],
      leaf_comp: Component
    ) => LayoutNode,
    callback: () => Promise<boolean>
  ): Unlisten => {
    return this._animate_sub_component_base(
      sub_component_id,
      leaf_base,
      leaf_traits,
      n1,
      callback
    )
  }

  private _animate_sub_component_base = (
    sub_component_id: string,
    leaf_base: LayoutBase,
    leaf_traits: LayoutNode[],
    n1: (
      leaf_id: string,
      leaf_path: string[],
      leaf_comp: Component
    ) => LayoutNode,
    callback: () => boolean | Promise<boolean>
  ): Unlisten => {
    // console.log('Graph', '_animate_sub_component_base', sub_component_id)

    const base_length = leaf_base.length

    let leaf_end_count = 0

    let i = 0

    const all_unlisten = []

    this._animating_sub_component_base_id.add(sub_component_id)

    for (const leaf of leaf_base) {
      const [leaf_path, leaf_comp] = leaf

      const leaf_id = joinPath([sub_component_id, ...leaf_path])

      const leaf_node = leaf_traits[i] || this._leaf_frame_node[leaf_id]

      const unlisten = this._animate_leaf_frame(
        leaf_id,
        leaf_node,
        () => {
          return n1(leaf_id, leaf_path, leaf_comp)
        },
        async () => {
          leaf_end_count++

          if (leaf_end_count === base_length) {
            this._animating_sub_component_base_id.delete(sub_component_id)

            callback()
          }

          return true
        }
      )

      all_unlisten.push(unlisten)

      i++
    }

    if (leaf_base.length === 0) {
      requestAnimationFrame(() => {
        this._animating_sub_component_base_id.delete(sub_component_id)

        callback()
      })
    }

    return callAll(all_unlisten)
  }

  private _cancel_enter_animation = (): void => {
    // console.log('Graph', '_cancel_enter_animation')

    for (const sub_component_id in this
      ._abort_sub_component_enter_base_animation) {
      this._cancel_enter_sub_component_animation(sub_component_id)
    }
  }

  private _cancel_all_layout_sub_component_animation = (): void => {
    for (const sub_component_id in {
      ...this._abort_tree_layout_sub_component_base_animation,
    }) {
      // console.log(
      //   '_cancel_all_layout_sub_component_animation',
      //   sub_component_id
      // )
      this._cancel_layout_sub_component_animation(sub_component_id)
    }
  }

  private _cancel_enter_sub_component_animation = (
    sub_component_id: string
  ): void => {
    const abort =
      this._abort_sub_component_enter_base_animation[sub_component_id]

    if (!abort) {
      return
    }

    // console.log(
    //   'Graph',
    //   '_cancel_enter_sub_component_animation',
    //   sub_component_id
    // )

    abort()

    delete this._abort_sub_component_enter_base_animation[sub_component_id]
  }

  private _cancel_all_enter_sub_component_animation = (): void => {
    for (const sub_component_id in {
      ...this._abort_sub_component_enter_base_animation,
    }) {
      this._cancel_enter_sub_component_animation(sub_component_id)
    }
  }

  private _end_all_enter_sub_component_animation = (): void => {
    for (const sub_component_id in {
      ...this._abort_sub_component_enter_base_animation,
    }) {
      this._end_sub_component_enter_base_animation(sub_component_id)
    }
  }

  private _cancel_leave_sub_component_animation = (
    sub_component_id: string
  ): boolean => {
    const abort =
      this._abort_sub_component_leave_base_animation[sub_component_id]

    if (!abort) {
      return false
    }

    // console.log(
    //   'Graph',
    //   '_cancel_leave_sub_component_animation',
    //   sub_component_id
    // )

    abort()

    delete this._abort_sub_component_leave_base_animation[sub_component_id]

    return true
  }

  private _cancel_all_leave_sub_component_animation = () => {
    for (const sub_component_id in {
      ...this._abort_sub_component_leave_base_animation,
    }) {
      this._cancel_leave_sub_component_animation(sub_component_id)
    }
  }

  private _cancel_layout_sub_component_animation = (
    sub_component_id: string
  ): void => {
    const abort =
      this._abort_tree_layout_sub_component_base_animation[sub_component_id]

    if (!abort) {
      return
    }

    // console.log(
    //   'Graph',
    //   '_cancel_layout_sub_component_animation',
    //   sub_component_id
    // )

    abort()

    delete this._abort_tree_layout_sub_component_base_animation[
      sub_component_id
    ]
  }

  private _get_sub_compononent_layout_layer_opacity = (
    sub_component_id: string
  ): number => {
    const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)

    const l = this._layout_path.length

    if (l === 0) {
      if (parent_id) {
        return 0
      } else {
        return 1
      }
    } else {
      if (parent_id) {
        const i = this._layout_path.indexOf(sub_component_id)
        if (i > -1) {
          return LAYER_OPACITY_MULTIPLIER / (l - i)
        } else {
          const pi = this._layout_path.indexOf(parent_id)

          if (pi > -1) {
            if (pi === this._layout_path.length - 1) {
              return 1
            } else {
              return LAYER_OPACITY_MULTIPLIER / (l - pi)
            }
          } else {
            return 0
          }
        }
      } else {
        return LAYER_OPACITY_MULTIPLIER / l
      }
    }

    return 1
  }

  private _reflect_sub_component_base_trait = (
    sub_component_id: string,
    base: LayoutBase,
    style: Style,
    trait: LayoutNode,
    expand: boolean
  ): Dict<LayoutNode> => {
    const sub_component = this._get_sub_component(sub_component_id)

    return this.__reflect_sub_component_base_trait(
      sub_component_id,
      sub_component,
      base,
      style,
      trait,
      expand
    )
  }

  private __reflect_sub_component_base_trait = (
    sub_component_id: string,
    component: Component,
    base: LayoutBase,
    style: Style,
    trait: LayoutNode,
    expand: boolean
  ): Dict<LayoutNode> => {
    const base_trait = this.___reflect_sub_component_base_trait(
      sub_component_id,
      component,
      base,
      style,
      trait,
      expand
    )

    const _base_trait = mapObjKeyKV(
      base_trait,
      (key) => `${sub_component_id}${key ? `/${key}` : ''}`
    )

    return _base_trait
  }

  private _extract_style = (
    trait: LayoutNode,
    leaf_id: string,
    leaf_comp: Component
  ) => {
    const {
      api: {
        text: { measureText },
      },
    } = this.$system

    if (isTextLike(leaf_comp)) {
      //
    } else if (this._leaf_style[leaf_id]) {
      let leaf_style = this._leaf_style[leaf_id]

      return leaf_style
    }

    return extractStyle(leaf_comp, trait, measureText)
  }

  private ___reflect_sub_component_base_trait = (
    sub_component_id: string,
    component: Component,
    base: LayoutBase,
    style: Style,
    trait: LayoutNode,
    expand: boolean
  ): Dict<LayoutNode> => {
    const base_trait = reflectComponentBaseTrait(
      this._component,
      sub_component_id,
      component,
      base,
      style,
      trait,
      (leaf_id, leaf_comp) => {
        return this._extract_style(trait, leaf_id, leaf_comp)
      },
      expand
    )

    return base_trait
  }

  private _animate_enter_tree_layout = (): void => {
    // console.log('Graph', '_animate_enter_tree_layout')

    const {
      api: {
        text: { measureText },
      },
    } = this.$system

    if (this._abort_fullwindow_animation) {
      //
    } else {
      this._leaf_layer_offset_x = 0
      this._leaf_layer_offset_y = 0
    }

    const animating_sub_component_set = new Set()

    for (const sub_component_id in this._component.$subComponent) {
      const animating_sub_component =
        this._animating_sub_component_base_id.has(sub_component_id) ||
        this._abort_sub_component_enter_base_animation[sub_component_id] ||
        this._abort_tree_layout_sub_component_base_animation[sub_component_id]

      if (animating_sub_component) {
        animating_sub_component_set.add(sub_component_id)
      }
    }

    this._cancel_fullwindow_animation()
    this._cancel_all_layout_sub_component_animation()
    this._cancel_enter_animation()

    const sub_component_ids = keys(this._component.$subComponent)

    let sub_component_count = 0
    let sub_component_finish_count = 0

    let sub_component_root: string[] = []
    let sub_component_parent_root: string[] = []
    let sub_component_parent_root_slot_children: Dict<Dict<string[]>> = {}

    let finished = false

    const finish = () => {
      if (sub_component_finish_count === sub_component_count) {
        if (finished) {
          return
        }

        finished = true

        for (const sub_component_id of sub_component_root) {
          for (const sub_component_id of sub_component_parent_root) {
            const all_slot_children =
              sub_component_parent_root_slot_children[sub_component_id]

            for (const slot_name in all_slot_children) {
              this._cancel_layout_parent_children_animation(
                sub_component_id,
                slot_name
              )
            }
          }

          delete this._abort_tree_layout_sub_component_base_animation[
            sub_component_id
          ]

          this._unplug_sub_component_root_base_frame(sub_component_id)

          if (sub_component_root.includes(sub_component_id)) {
            this._append_sub_component_root_base(sub_component_id)
          }

          this._enter_sub_component_frame(sub_component_id)
        }

        for (const sub_component_id of sub_component_parent_root) {
          const children =
            this._spec_get_sub_component_children(sub_component_id)

          const all_slot_children =
            sub_component_parent_root_slot_children[sub_component_id]

          for (const slot_name in all_slot_children) {
            const slot_children = all_slot_children[slot_name]

            this._cancel_layout_parent_children_animation(
              sub_component_id,
              slot_name
            )

            this._end_layout_sub_component_transfer_children_animation(
              sub_component_id,
              slot_name,
              slot_children
            )
          }

          delete this._abort_tree_layout_sub_component_base_animation[
            sub_component_id
          ]

          this._layout_sub_components_commit_base(children)

          for (const child_id of children) {
            this._append_sub_component_all_missing_root(child_id)

            delete this._abort_tree_layout_sub_component_base_animation[
              child_id
            ]

            this._insert_sub_component_child(sub_component_id, child_id)
          }
        }
      }
    }

    const ordered_sub_component_ids =
      this._order_sub_component_ids(sub_component_ids)

    for (const sub_component_id of ordered_sub_component_ids) {
      this._cancel_leave_sub_component_animation(sub_component_id)

      this._measure_sub_component_base(sub_component_id)

      const visible = this._is_layout_component_layer_visible(sub_component_id)

      const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)
      const parent_fullwindow = this._is_sub_component_fullwindow(parent_id)
      const parent_visible =
        !parent_fullwindow &&
        (!parent_id || this._layout_path.includes(parent_id))

      const children = this._spec_get_sub_component_children(sub_component_id)

      const layer = this._get_sub_component_layout_layer(sub_component_id)
      const parent_layer = this._get_sub_component_parent_layer(parent_id)

      const leaf_traits: LayoutNode[] = []
      const leaf_layer_opacity =
        this._get_sub_compononent_layout_layer_opacity(sub_component_id)

      if (!visible && children.length > 0) {
        sub_component_parent_root.push(sub_component_id)

        sub_component_count++

        const all_slot_children: Dict<string[]> = {}

        for (const child_id of children) {
          const slot_name = this._get_sub_component_slot_name(child_id)

          all_slot_children[slot_name] = all_slot_children[slot_name] || []
          all_slot_children[slot_name].push(child_id)
        }

        sub_component_parent_root_slot_children[sub_component_id] =
          all_slot_children

        for (const slot_name in all_slot_children) {
          const slot_children = all_slot_children[slot_name]

          for (const slot_child_id of slot_children) {
            this._measure_sub_component_base(slot_child_id)
          }
        }

        if (!animating_sub_component_set.has(sub_component_id)) {
          for (const child_id of children) {
            if (!animating_sub_component_set.has(child_id)) {
              this._leave_sub_component_frame(child_id)
              this._remove_sub_component_root_base(child_id)
            }
          }
        }

        for (const slot_name in all_slot_children) {
          const slot_children = all_slot_children[slot_name]

          this._animate_layout_append_children(
            sub_component_id,
            slot_children,
            slot_name,
            () => NULL_VECTOR,
            () => false,
            async () => {
              sub_component_finish_count++

              const grandparent_id =
                this._spec_get_sub_component_parent_id(sub_component_id)

              if (grandparent_id) {
                if (this._layout_layer_opacity_animation[grandparent_id]) {
                  await waitFinish(
                    this._layout_layer_opacity_animation[grandparent_id]
                  )
                }
              } else {
                if (this._layout_root_opacity_animation) {
                  await waitFinish(this._layout_root_opacity_animation)
                }
              }

              finish()
            }
          )
        }
      }

      if (
        parent_visible &&
        !this._is_sub_component_fullwindow(sub_component_id)
      ) {
        sub_component_root.push(sub_component_id)
        sub_component_count++

        const animating_sub_component =
          animating_sub_component_set.has(sub_component_id)

        this._abort_tree_layout_sub_component_base_animation[sub_component_id] =
          this._animate_parent_component(
            sub_component_id,
            animating_sub_component,
            animating_sub_component,
            leaf_traits,
            parent_layer.foreground,
            leaf_layer_opacity,
            true,
            () => {
              return { x: 0, y: -layer.content.$element.scrollTop }
            },
            async () => {
              sub_component_finish_count++

              if (this._layout_root_opacity_animation) {
                await waitFinish(this._layout_root_opacity_animation)

                this._layout_root_opacity_animation = undefined
              }

              if (this._tree_layout) {
                finish()
              }

              return true
            }
          )
      }
    }
  }

  private _animate_parent_component = (
    sub_component_id: string,
    dont_leave_frame: boolean,
    dont_plug_base: boolean,
    leaf_traits: LayoutNode[],
    leaf_layer: Component<HTMLElement>,
    leaf_layer_opacity: number,
    expand_children: boolean,
    offset: () => Point,
    callback: () => boolean | Promise<boolean>
  ): Unlisten => {
    const {
      api: {
        text: { measureText },
      },
    } = this.$system

    const frame = this._get_sub_component_frame(sub_component_id)
    const leaf_base = this._get_sub_component_root_base(sub_component_id)

    let trait: LayoutNode
    let all_leaf_trait: Dict<LayoutNode>

    if (!dont_leave_frame) {
      this._leave_sub_component_frame(sub_component_id)
    }

    this._remove_sub_component_root_base(sub_component_id)

    let i = 0

    if (!dont_plug_base) {
      this._plug_sub_component_base(
        sub_component_id,
        leaf_base,
        leaf_traits,
        leaf_layer
      )
    }

    const unlisten = this._plug_animate_sub_component_base(
      sub_component_id,
      leaf_base,
      leaf_traits,
      leaf_layer,
      (leaf_id: string) => {
        const { $width, $height } = this.$context

        const layout_node = this._layout_node[sub_component_id]

        const { x, y, width, height, color } = layout_node

        const { x: scrollX, y: scrollY } = getScrollPosition(
          leaf_layer.$element,
          this.$context.$element
        )

        if (i === 0) {
          trait = {
            x: 0,
            y: 0,
            width: layout_node.width,
            height: layout_node.height,
            fontSize: 14,
            sx: 1,
            sy: 1,
            opacity: 1,
            color,
          }

          const style = extractStyle(frame, trait, measureText)

          all_leaf_trait = this._reflect_sub_component_base_trait(
            sub_component_id,
            leaf_base,
            style,
            trait,
            expand_children
          )
        }

        const leaf_trait = all_leaf_trait[leaf_id]

        i = (i + 1) % leaf_base.length

        const { x: ox, y: oy } = offset()

        const leaf_trait_ = {
          x: x + $width / 2 - width / 2 + leaf_trait.x + ox,
          y: y + $height / 2 - height / 2 + leaf_trait.y + oy,
          width: leaf_trait.width / Math.abs(leaf_trait.sx),
          height: leaf_trait.height / Math.abs(leaf_trait.sy),
          sx: leaf_trait.sx,
          sy: leaf_trait.sy,
          opacity: leaf_trait.opacity * leaf_layer_opacity,
          fontSize: leaf_trait.fontSize,
          color: leaf_trait.color,
        }

        this._leaf_target_trait[leaf_id] = leaf_trait_

        return leaf_trait_
      },
      async () => {
        const result = await callback()

        if (result) {
          for (const [leaf_path] of leaf_base) {
            const leaf_id = `${sub_component_id}/${leaf_path.join('/')}`

            delete this._leaf_target_trait[leaf_id]
          }

          delete this._abort_sub_component_parent_animation[sub_component_id]
        }

        return result
      }
    )

    this._abort_sub_component_parent_animation[sub_component_id] = unlisten

    return unlisten
  }

  private _get_graph_sub_component_node_trait = (
    node_id: string
  ): LayoutNode => {
    const graph_node = this._node[node_id]

    const sub_component = this._get_sub_component(node_id)

    const color = sub_component.getColor()

    const { z } = this._zoom

    const trait = {
      x: 1,
      y: 1,
      width: graph_node.width - 2,
      height: graph_node.height - 2,
      sx: z,
      sy: z,
      opacity: 1,
      fontSize: 14,
      color,
    }

    return trait
  }

  private _animate_leave_tree_layout = (): void => {
    // console.log('Graph', '_animate_leave_tree_layout')

    const {
      api: {
        text: { measureText },
      },
    } = this.$system

    if (this._abort_fullwindow_animation) {
      //
    } else {
      this._leaf_layer_offset_x = 0
      this._leaf_layer_offset_y = 0
    }

    let animated_sub_component_total = 0
    let animated_sub_component_finished = 0

    const visible_parent_root = []

    const visible_parent_slot_children: Dict<Dict<string[]>> = {}
    const visible_parent_root_slot_total: Dict<number> = {}
    const visible_parent_root_slot_finished: Dict<number> = {}

    const visible_root = []

    let finished = false

    const finish = () => {
      if (animated_sub_component_finished === animated_sub_component_total) {
        if (finished) {
          return
        }

        finished = true

        for (const sub_component_id of visible_root) {
          delete this._abort_tree_layout_sub_component_base_animation[
            sub_component_id
          ]

          this._unplug_sub_component_root_base_frame(sub_component_id)
          this._append_sub_component_root_base(sub_component_id)
          this._enter_sub_component_frame(sub_component_id)
        }

        for (const sub_component_id of visible_parent_root) {
          const all_slot_children =
            visible_parent_slot_children[sub_component_id]

          for (const slot_name in all_slot_children) {
            const slot_children = all_slot_children[slot_name]

            this._end_layout_sub_component_transfer_children_animation(
              sub_component_id,
              slot_name,
              slot_children
            )
          }

          delete this._abort_tree_layout_sub_component_base_animation[
            sub_component_id
          ]

          const children =
            this._spec_get_sub_component_children(sub_component_id)

          for (const child_id of children) {
            delete this._abort_tree_layout_sub_component_base_animation[
              child_id
            ]

            this._enter_sub_component_frame(child_id)
            this._append_sub_component_root_base(child_id)
          }
        }
      }
    }

    for (const sub_component_id in this._component.$subComponent) {
      if (this._fullwindow_component_set.has(sub_component_id)) {
        continue
      }

      const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)
      const children = this._spec_get_sub_component_children(sub_component_id)

      const { foreground: leaf_layer } =
        this._get_sub_component_layout_layer(sub_component_id)

      const leaf_traits = []

      if (
        !this._layout_path.includes(sub_component_id) &&
        children.length > 0
      ) {
        visible_parent_root_slot_finished[sub_component_id] = 0

        const all_slot_children: Dict<string[]> = {}

        for (const child_id of children) {
          const slot_name = this._get_sub_component_slot_name(child_id)

          all_slot_children[slot_name] = all_slot_children[slot_name] || []
          all_slot_children[slot_name].push(child_id)
        }

        animated_sub_component_total++

        visible_parent_root.push(sub_component_id)
        visible_parent_slot_children[sub_component_id] = all_slot_children

        const slot_total = keyCount(all_slot_children)

        visible_parent_root_slot_total[sub_component_id] = slot_total

        for (const slot_name in all_slot_children) {
          const slot_children = all_slot_children[slot_name]

          this._animate_layout_sub_component_remove_children(
            sub_component_id,
            slot_name,
            slot_children,
            false,
            async () => {
              visible_parent_root_slot_finished[sub_component_id]++

              if (
                visible_parent_root_slot_finished[sub_component_id] ===
                visible_parent_root_slot_total[sub_component_id]
              ) {
                animated_sub_component_finished++

                if (this._zoom_opacity_animation) {
                  await waitFinish(this._zoom_opacity_animation)
                }

                if (!this._tree_layout) {
                  finish()
                }
              }

              return true
            }
          )
        }
      }

      if (!parent_id || this._layout_path.includes(parent_id)) {
        animated_sub_component_total++

        visible_root.push(sub_component_id)

        const sub_component = this._get_sub_component(sub_component_id)
        const leaf_base = this._get_sub_component_root_base(sub_component_id)
        const frame = this._get_sub_component_frame(sub_component_id)

        const graph_node = this._node[sub_component_id]

        let i = 0

        let all_leaf_trait

        this._plug_sub_component_base(
          sub_component_id,
          leaf_base,
          leaf_traits,
          leaf_layer
        )

        this._abort_tree_layout_sub_component_base_animation[sub_component_id] =
          this._plug_animate_sub_component_base(
            sub_component_id,
            leaf_base,
            leaf_traits,
            leaf_layer,
            (leaf_id: string) => {
              const { x, y } = this._get_node_screen_position(sub_component_id)

              if (i === 0) {
                const trait =
                  this._get_graph_sub_component_node_trait(sub_component_id)

                const frame_trait = extractTrait(frame, measureText)
                const frame_style = extractStyle(
                  frame,
                  frame_trait,
                  measureText
                )

                all_leaf_trait = this._reflect_sub_component_base_trait(
                  sub_component_id,
                  leaf_base,
                  frame_style,
                  trait,
                  false
                )
              }

              i = (i + 1) % leaf_base.length

              const leaf_trait = all_leaf_trait[leaf_id]

              const current_layout_layer = this._get_current_layout_layer()

              const parent_layout_layer =
                this._ensure_parent_layout_layer(sub_component_id)

              const { scrollTop = 0 } = parent_layout_layer.content.$element

              const parent_visible =
                this._is_layout_component_layer_visible(parent_id) || !parent_id

              const scroll_top = parent_visible ? scrollTop : 0

              return {
                x: x + leaf_trait.x,
                y: y + leaf_trait.y,
                width: leaf_trait.width,
                height: leaf_trait.height,
                sx: leaf_trait.sx,
                sy: leaf_trait.sy,
                opacity: leaf_trait.opacity,
                fontSize: leaf_trait.fontSize,
                color: leaf_trait.color,
              }
            },
            async () => {
              animated_sub_component_finished++

              if (this._zoom_opacity_animation) {
                await waitFinish(this._zoom_opacity_animation)

                this._zoom_opacity_animation = undefined
              }

              if (!this._tree_layout) {
                finish()
              }

              return true
            }
          )
      }
    }
  }

  private _listen_layout_core = (
    unit_id: string,
    component: Component
  ): void => {
    const unlisten = this._listen_node(unit_id, component)
    this._core_layout_core_unlisten[unit_id] = unlisten
  }

  private _unlisten_sub_component = (unit_id: string): void => {
    const unlisten = this._core_layout_core_unlisten[unit_id]

    unlisten()
  }

  private _listen_node = (node_id: string, component: Component): Unlisten => {
    return component.addEventListeners([
      makePointerDownListener((event: UnitPointerEvent) => {
        this._on_node_pointer_down(node_id, event)
      }),
      makePointerUpListener((event: UnitPointerEvent) => {
        this._on_node_pointer_up(node_id, event)
      }),
      makePointerEnterListener((event: UnitPointerEvent) => {
        this._on_node_pointer_enter(node_id, event)
      }),
      // makePointerInListener((event: UnitPointerEvent) => {
      //   this._on_node_pointer_in(node_id, event)
      // }),
      makePointerLeaveListener((event: UnitPointerEvent) => {
        this._on_node_pointer_leave(node_id, event)
      }),
      // makePointerOutListener((event: UnitPointerEvent) => {
      //   this._on_node_pointer_out(node_id, event)
      // }),
      makePointerCancelListener((event: UnitPointerEvent) => {
        this._on_node_pointer_cancel(node_id, event)
      }),
      makeClickListener({
        onClick: (event: UnitPointerEvent) => {
          this._on_node_click(node_id, event)
        },
        onDoubleClick: (event: UnitPointerEvent) => {
          this._on_node_double_click(node_id, event)
        },
        onLongClick: (event: UnitPointerEvent) => {
          this._on_node_long_click(node_id, event)
        },
        onLongPress: (event: UnitPointerEvent) => {
          this._on_node_long_press(node_id, event)
        },
        onClickHold: (event: UnitPointerEvent) => {
          this._on_node_click_hold(node_id, event)
        },
      }),
      makeDropListener((event: IODragEvent, _event: DragEvent) => {
        _event.preventDefault()

        const { dataTransfer } = event

        const { items } = dataTransfer

        for (let i = 0; i < items.length; i++) {
          const item = items[i]

          const { type, kind } = item

          if (kind === 'string') {
            if (type === 'text/plain' || type === 'text/uri-list') {
              _event.stopPropagation()

              _event.dataTransfer.items[i].getAsString((text) => {
                this._drop_text_on_node(node_id, text)
              })
            }
          }
        }
      }),
    ])
  }

  private _is_point_inside_node_rect = (
    node_id: string,
    x: number,
    y: number,
    padding: number
  ) => {
    // console.log('_is_point_inside_node_rect', node_id, x, y, padding)

    const node = this._node[node_id]

    const { width, height } = node

    return (
      x >= node.x - width / 2 - padding &&
      x <= node.x + width / 2 + padding &&
      y >= node.y - height / 2 - padding &&
      y <= node.y + height / 2 + padding
    )
  }

  private _is_point_inside_node_circle = (
    node_id: string,
    x: number,
    y: number,
    padding: number
  ) => {
    const node = this._node[node_id]

    return norm(node.x - x, node.y - y) < node.r + padding
  }

  private _is_point_inside_node = (
    node_id: string,
    x: number,
    y: number,
    padding: number
  ) => {
    const node = this._node[node_id]

    if (node.shape === 'circle') {
      return this._is_point_inside_node_circle(node_id, x, y, padding)
    } else {
      return this._is_point_inside_node_rect(node_id, x, y, padding)
    }
  }

  private _escape_external_text_if_needed = (text: string): TreeNode => {
    let tree = getTree(text)

    if (!_isValidTree(tree)) {
      ;[tree] = _filterEmptyNodes(tree, getTree__cached)

      tree = getTree(`"${escape(text)}"`)
    }

    return tree
  }

  private _drop_text_on_node = (node_id: string, text: string) => {
    if (this._is_pin_node_id(node_id)) {
      if (this._is_type_pin_match(node_id, STRING_TREE)) {
        const tree = this._escape_external_text_if_needed(text)

        const { value } = tree

        this._graph_debug_set_pin_value(node_id, value)

        this.set_pin_data(node_id, value)
      }
    } else if (this._is_unit_node_id(node_id)) {
      //
    }
  }

  private _listen_link = (link_id: string, link: Element): Unlisten => {
    return link.addEventListeners([
      makePointerDownListener((event: UnitPointerEvent) => {
        this._on_link_pointer_down(link_id, event)
      }),
      makePointerEnterListener((event: UnitPointerEvent) => {
        this._on_link_pointer_enter(link_id, event)
      }),
      makePointerLeaveListener((event: UnitPointerEvent) => {
        this._on_link_pointer_leave(link_id, event)
      }),
      makeClickListener({
        onClick: (event: UnitPointerEvent) => {
          this._on_link_click(link_id, event)
        },
        onDoubleClick: (event: UnitPointerEvent) => {
          this._on_link_click(link_id, event)
        },
        onLongClick: (event: UnitPointerEvent) => {
          this._on_link_long_click(link_id, event)
        },
        onLongPress: (event: UnitPointerEvent) => {
          this._on_link_long_press(link_id, event)
        },
      }),
    ])
  }

  private _get_layout_node_screen_position = (
    sub_component_id: string
  ): Position => {
    const { $width, $height } = this.$context

    const graph_node = this._node[sub_component_id]

    const { x: _x, y: _y, width: _width, height: _height } = graph_node

    const position = this._world_to_screen(_x, _y)

    const { x: __x, y: __y } = position

    const parent_layout_layer =
      this._ensure_parent_layout_layer(sub_component_id)

    const { scrollTop = 0 } = parent_layout_layer.content.$element

    const x = __x - $width / 2
    const y = __y - $height / 2

    return { x, y }
  }

  private _is_sub_component_animating = (sub_component_id: string): boolean => {
    const animating_sub_component = !!(
      this._animating_sub_component_base_id.has(sub_component_id) ||
      this._abort_sub_component_enter_base_animation[sub_component_id] ||
      this._abort_tree_layout_sub_component_base_animation[sub_component_id]
    )

    return animating_sub_component
  }

  private _zoom_opacity_animation: Animation

  private _animate_zoom_opacity = (to: number): void => {
    if (this._zoom_opacity_animation) {
      flushAnimation(this._zoom_opacity_animation)
    }

    this._zoom_opacity_animation = this._animate_element_opacity(
      this._zoom_comp._root.$element,
      to,
      () => {
        this._zoom_opacity_animation = undefined
      }
    )
  }

  private _leave_tree_layout = (): void => {
    // console.log('Graph', '_leave_tree_layout')

    const { animate } = this._config()

    this._pointer_up_all_pressed_pointer_id()

    const animating_sub_component_set = new Set()

    for (const sub_component_id in this._component.$subComponent) {
      const animating_sub_component =
        this._is_sub_component_animating(sub_component_id)

      if (animating_sub_component) {
        animating_sub_component_set.add(sub_component_id)
      }
    }

    this._cancel_fullwindow_animation()
    this._cancel_all_layout_sub_component_animation()
    this._cancel_all_layout_parent_children_animation()
    this._cancel_all_sub_component_parent_animation()

    this._tree_layout = false

    if (animate) {
      this._animate_zoom_opacity(1)
    } else {
      this._zoom_comp._root.$element.style.opacity = `${1}`
    }

    this._layout_comp.$element.style.pointerEvents = 'none'

    if (this._layout_root_opacity_animation) {
      flushAnimation(this._layout_root_opacity_animation)

      this._layout_root_opacity_animation = undefined
    }

    for (const sub_component_id in this._layout_layer_opacity_animation) {
      const animation = this._layout_layer_opacity_animation[sub_component_id]

      flushAnimation(animation)

      delete this._layout_layer_opacity_animation[sub_component_id]
    }

    this._layout_root.children.$element.style.opacity = '0'

    for (const layer_id of this._layout_path) {
      const layer_layer = this._layout_layer[layer_id]

      layer_layer.children.$element.style.opacity = '0'
    }

    for (const sub_component_id in this._component.$subComponent) {
      const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)
      const children = this._spec_get_sub_component_children(sub_component_id)

      if (animate) {
        if (!this._layout_path.includes(sub_component_id)) {
          if (!this._animating_sub_component_base_id.has(sub_component_id)) {
            for (const child_id of children) {
              this._measure_sub_component_base(child_id)
            }
          }
        }

        if (!parent_id || this._layout_path.includes(parent_id)) {
          this._measure_sub_component_base(sub_component_id)
        }

        if (!parent_id || this._layout_path.includes(parent_id)) {
          const animating_sub_component =
            animating_sub_component_set.has(sub_component_id)

          const fullwindow_sub_component =
            this._is_sub_component_fullwindow(sub_component_id)

          if (!animating_sub_component && !fullwindow_sub_component) {
            this._leave_sub_component_frame(sub_component_id)
            this._remove_sub_component_root_base(sub_component_id)
          }
        }
      }

      if (
        !this._layout_path.includes(sub_component_id) &&
        children.length > 0
      ) {
        for (const child_id of children) {
          if (!this._animating_sub_component_base_id.has(child_id)) {
            this._remove_sub_component_parent_root(sub_component_id, child_id)
            this._remove_sub_component_root_base(child_id)
          }
        }
      }

      this._refresh_component_children_counter(sub_component_id)
      this._unlisten_sub_component(sub_component_id)
      this._move_core_content_layout_to_graph(sub_component_id)

      const { width, height } =
        this._get_unit_component_graph_size(sub_component_id)

      this._resize_core_area(sub_component_id, width, height)
      this._resize_core_selection(sub_component_id, width, height)
    }

    if (animate) {
      this._animate_leave_tree_layout()
    }

    this._set_minimap_to_graph()
  }

  private _set_minimap_to_graph = (): void => {
    // console.log('Graph', '_set_minimap_to_graph', this._unit_node)
    if (this._minimap) {
      this._minimap.setProp('nodes', this._unit_node)
      this._minimap.setProp('links', this._unit_to_unit)
      this._minimap.tick()
    }
  }

  private _set_minimap_to_layout = (): void => {
    if (this._minimap) {
      // TODO
      // this._minimap.setProp('nodes', this._layout_node)
      // this._minimap.setProp('links', {})
      // this._minimap.tick()
    }
  }

  private _resize = (width: number, height: number): void => {
    // console.log('Graph', '_resize', width, height)

    const widthStr = `${width}px`
    const heightStr = `${height}px`

    mergeProps(this._zoom_comp, {
      width,
      height,
    })
    mergeProps(this._zoom_comp_alt, {
      width,
      height,
    })

    this._multiselect_area_svg.$element.style.width = widthStr
    this._multiselect_area_svg.$element.style.height = heightStr

    if (this._minimap_screen) {
      this._minimap_screen.setProp('width', width / this._zoom.z)
      this._minimap_screen.setProp('height', height / this._zoom.z)
    }

    if (this._tree_layout) {
      this._refresh_all_layout_node_target_position()
      this._layout_scroll_search_unit_into_view()
      this._refresh_search_list_height_offset()
    }
  }

  private _on_context_resize = ({
    width,
    height,
  }: IOFrameResizeEvent): void => {
    // console.log('Graph', '_on_context_resize', width, height)

    const area = this._width * this._height

    this._resize(width, height)

    const dw = width - this._width
    const dh = height - this._height

    this._width = width
    this._height = height

    const zoom = translate(this._zoom, dw / 2, dh / 2)

    this.set_zoom(zoom)

    for (const unit_id in this._subgraph_cache) {
      if (this._subgraph_unit_id !== unit_id) {
        const graph = this._subgraph_cache[unit_id]

        const graph_config = graph.getProp('config') ?? defaultProps.config

        const graph_zoom = graph.getZoom()

        const graph_translated_zoom = translate(graph_zoom, dw / 2, dh / 2)

        const graph_next_config = {
          ...graph_config,
          zoom: {
            ...graph_config.zoom,
            ...graph_translated_zoom,
          },
        }

        graph.setProp('config', graph_next_config)
      }
    }

    if (this._tree_layout) {
      this._refresh_all_layout_node_size()
      this._refresh_all_layout_node_target_position()
      this._refresh_search_list_height_offset()

      this._animate_all_layout_layer()
    }

    if (!area) {
      if (width && height) {
        this._center_graph(true)
      }
    }

    this._maybe_refresh_simulation_by_drag()
  }

  private _on_context_enabled = (): void => {
    // console.log('Graph', '_on_context_enabled')

    if (this._focused || this._is_fullwindow) {
      this._refresh_enabled()
    }
  }

  private _on_context_disabled = (): void => {
    // console.log('Graph', '_on_context_disabled')

    if (this._focused) {
      this._refresh_enabled()
    }
  }

  private _on_context_theme_changed = (): void => {
    // const { $theme } = this.$context

    this._refresh_color()

    // for (let component_id in this._core_component_frame) {
    //   const frame = this._core_component_frame[component_id]
    //   frame.setProp('theme', $theme)
    // }
  }

  private _on_context_color_changed = (): void => {
    // const { $color } = this.$context

    this._refresh_color()

    // const color = this._get_color()

    // for (let component_id in this._core_component_context) {
    //   const frame = this._core_component_frame[component_id]
    //   frame.setProp('color', color)
    // }
  }

  private _on_focus = () => {
    // console.log('Graph', '_on_focus', this._id, this._disabled)

    const { animate } = this._config()

    if (this._subgraph_graph) {
      this._subgraph_graph.focus()
    } else if (
      this._core_component_unlocked_count > 0 &&
      !this._temp_control_lock
    ) {
      const first = getObjSingleKey(this._core_component_unlocked)

      this._focus_sub_component(first)
    } else if (this._is_fullwindow) {
      if (this._fullwindow_component_ids.length > 0) {
        const first = this._fullwindow_component_ids[0]

        this._focus_sub_component(first)
      }

      this._hide_control(animate)

      this._focused = true

      this._lock_control()
    } else {
      this._focused = true

      this._enable()
      this._refresh_control()

      this._show_transcend(true)
    }
  }

  private _refresh_control = () => {
    const { animate } = this._config()

    if (this._control_lock) {
      this._enable_input()

      this._show_control(animate)
    } else {
      this._lock_control()
    }
  }

  private _on_blur = (event) => {
    // console.log('Graph', '_on_blur', this._id)

    const { container } = this.$props

    this._focused = false

    if (this._search_to_be_focused_by_click) {
      //
    } else if (this._datum_to_be_focused_by_click) {
      //
    } else if (this._search_to_be_focused) {
      this._search_to_be_focused = false
    } else if (this._datum_to_be_focused) {
      this._datum_to_be_focused = false
    } else if (this._name_to_be_focused) {
      //
    } else if (this._fullwindow_focusing) {
      //
    } else if (this._temp_control_unlock) {
      //
    } else {
      const { relatedTarget } = event

      if (relatedTarget) {
        if (
          (this._control &&
            this._control._control.$element.contains(relatedTarget)) ||
          this._graph.$element.contains(relatedTarget)
        ) {
          return
        }

        const hide = this._temp_control_unlock || this._control_lock

        if (container && container.$element.contains(relatedTarget)) {
          return
        }

        this._disable(hide)

        this._hide_transcend(true)
      }
    }
  }

  private _disable_input = (): void => {
    if (!this._input_disabled) {
      // console.log('Graph', '_disable_input', this._id)

      this._input_disabled = true

      this._disable_gamepad()
      this._disable_keyboard()
      this._disable_enter()
      this._disable_escape()

      this._disable_crud()
      this._disable_cabinet()
      this._disable_search()
      this._disable_minimap()
      this._disable_import()
      this._disable_export()
    }
  }

  private _enable_input = (): void => {
    if (this._input_disabled) {
      // console.log('Graph', '_enable_input', this._id)

      this._input_disabled = false

      this._enable_gamepad()
      this._enable_keyboard()
      this._enable_enter()
      this._enable_escape()

      this._enable_dock()
      this._enable_crud()
      this._enable_cabinet()
      this._enable_search()
      this._enable_minimap()
      this._enable_import()
      this._enable_export()
    }
  }

  private _search_dock_offset_x: number = 0
  private _search_dock_offset_y: number = 0

  private _enable_dock = () => {
    if (this._control) {
      this._control.addEventListeners([
        makeCustomListener('dock-move', ({ dy = 0, dx = 0 }) => {
          this._search_dock_offset_x = dx
          this._search_dock_offset_y = dy
        }),
        makeCustomListener('dock-leave', () => {
          this._search_dock_offset_x = 0
          this._search_dock_offset_y = 0
        }),
      ])
    }
  }

  private _on_node_pointer_in = (node_id: string, event: UnitPointerEvent) => {
    // console.log('Graph', '_on_node_pointer_in', node_id)
  }

  private _on_node_pointer_enter = (
    node_id: string,
    event: UnitPointerEvent
  ) => {
    // console.log('Graph', '_on_node_pointer_enter', node_id)

    const { pointerId } = event

    this.__on_node_pointer_enter(node_id, pointerId)
  }

  private __on_node_pointer_enter = (node_id: string, pointerId: number) => {
    // console.log('Graph', '__on_node_pointer_enter', node_id, pointerId)

    const { dispatchEvent } = this.$props

    const hover_node_id = this._pointer_id_hover_node_id[pointerId]

    if (!hover_node_id) {
      if (
        !this._pointer_id_pressed_node_id[pointerId] ||
        this._pointer_id_pressed_node_id[pointerId] === node_id
      ) {
        this._set_node_hovered(node_id, pointerId, true)
      }
    } else {
      if (hover_node_id === node_id) {
        //
      } else {
        //
      }
    }

    if (
      this._is_unit_node_id(node_id) &&
      this._is_unit_component(node_id) &&
      this._core_component_unlocked_count > 0
    ) {
      this._lock_all_component_but(node_id)
      this._disable_all_component_resize_but(node_id)

      this._unlock_sub_component(node_id, true)
      this._enable_core_resize(node_id)
    } else if (
      this._is_datum_node_id(node_id) &&
      !this._is_datum_class_literal(node_id) &&
      this._core_component_unlocked_count > 0
    ) {
      this._unlock_datum(node_id)
    }

    dispatchEvent('nodepointerenter', this._get_node_spec(node_id), false)
  }

  private _get_node_spec = (node_id: string) => {
    return this._node_type__template(node_id, {
      unit: function (unit_id: string) {
        return { type: 'unit', spec: node_id }
      },
      link: function (pin_node_id: string) {
        const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

        return { type: 'link', spec: { unitId, type, pinId } }
      },
      merge: function (merge_node_id: string) {
        const { mergeId } = segmentMergeNodeId(merge_node_id)

        return { type: 'merge', spec: mergeId }
      },
      plug: function (plug_node_id: string) {
        const { type, pinId, subPinId } = segmentPlugNodeId(plug_node_id)

        return { type: 'plug', spec: { type, pinId, subPinId } }
      },
      datum: (datum_node_id: string) => {
        const { datumId } = segmentDatumNodeId(datum_node_id)

        const { datum_pin_node_id, datum_plug_node_id } =
          this._get_datum_connected(datum_node_id)

        const datum_attached_node_id = datum_pin_node_id || datum_plug_node_id

        const attachedTo = datum_attached_node_id
          ? this._get_node_spec(datum_attached_node_id)
          : null

        const value = this._get_datum_value(datum_node_id) ?? null

        return { type: 'datum', spec: { datumId, value, attachedTo } }
      },
      err: function (err_node_id: string) {
        const { unitId } = segmentErrNodeId(err_node_id)

        return { type: 'err', spec: unitId }
      },
    })
  }

  private _spec_to_node_id = (node_spec: { type: string; spec: any }) => {
    const { type, spec } = node_spec

    return {
      unit: function (unitId: string) {
        return unitId
      },
      link: function ({
        unitId,
        type,
        pinId,
      }: {
        unitId: string
        type: IO
        pinId: string
      }) {
        return getPinNodeId(unitId, type, pinId)
      },
      merge: function (mergeId: string) {
        return getMergeNodeId(mergeId)
      },
      plug: function ({
        type,
        pinId,
        subPinId,
      }: {
        type: IO
        pinId: string
        subPinId: string
      }) {
        return getExtNodeId(type, pinId, subPinId)
      },
      datum: (datumId: string) => {
        return getDatumNodeId(datumId)
      },
      err: function (unitId: string) {
        return getErrNodeId(unitId)
      },
    }[type](spec)
  }

  private _on_node_pointer_out = (
    node_id: string,
    event: UnitPointerEvent
  ): void => {
    // console.log('Graph', '_on_node_pointer_out', node_id)
  }

  private _on_node_pointer_leave = (
    node_id: string,
    event: UnitPointerEvent
  ): void => {
    // console.log('Graph', '_on_node_pointer_leave', node_id)

    const { pointerId } = event

    this.__on_node_pointer_leave(node_id, pointerId)
  }

  private __on_node_pointer_leave = (
    node_id: string,
    pointer_id: number
  ): void => {
    // console.log('Graph', '__on_node_pointer_leave', node_id, pointer_id)

    const { dispatchEvent } = this.$props

    if (this._pointer_id_hover_node_id[pointer_id]) {
      this._set_node_hovered(node_id, pointer_id, false)
    } else {
      return
    }

    dispatchEvent('nodepointerleave', this._get_node_spec(node_id), false)
  }

  private _get_node_comp = (node_id: string): Div => {
    if (this._tree_layout) {
      return this._layout_core[node_id]
    } else {
      return this._node_comp[node_id]
    }
  }

  private _commit_shift_search = (): void => {
    this._commit_search()
    this._shift_search()
  }

  private _on_node_pointer_down = (
    node_id: string,
    event: UnitPointerEvent
  ) => {
    // console.log('Graph', '_on_node_pointer_down', node_id)

    const { pointerId, clientX, clientY } = event

    this.__on_node_pointer_down(node_id, pointerId, clientX, clientY)
  }

  private _drag_node_init_edge_overflow: Dict<{
    x0: boolean
    y0: boolean
    x1: boolean
    y1: boolean
  }> = {}

  private __on_node_pointer_down = (
    node_id: string,
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    // console.log('Graph', '__on_node_pointer_down', node_id, pointerId)

    if (this._pointer_down[pointerId]) {
      // throw new Error('pointer is already down')
    }

    if (this._resize_node_id_pointer_id[node_id] !== undefined) {
      return
    }

    // if (this._edit_node_name_id === node_id) {
    //   return
    // }

    if (this._main.hasPointerCapture(pointerId)) {
      this._main.releasePointerCapture(pointerId)
    }

    this._set_node_pointer_capture(node_id, pointerId)

    this.__set_node_pressed(node_id, pointerId, true)

    const edge_offset = this._get_node_edge_offset(node_id, 0)

    this._drag_node_init_edge_overflow[node_id] = {
      x0: edge_offset.x0 < 0,
      y0: edge_offset.y0 < 0,
      x1: edge_offset.x1 > 0,
      y1: edge_offset.y1 > 0,
    }

    if (this._search_unit_id) {
      if (this._is_link_pin_node_id(node_id)) {
        const { unitId } = segmentLinkPinNodeId(node_id)

        if (unitId === this._search_unit_id) {
          this._commit_shift_search()
        }
      } else if (this._search_unit_id === node_id) {
        this._commit_shift_search()
      } else {
        // this._hide_search()
      }
    } else if (this._search_unit_datum_node_id) {
      if (this._search_unit_datum_node_id === node_id) {
        this._commit_shift_search()
      }
    } else {
      this._hide_search()
    }
  }

  private _on_node_pointer_move = (
    node_id: string,
    event: UnitPointerEvent
  ): void => {
    // console.log('Graph', '_on_node_pointer_move', node_id)
  }

  private _on_node_pointer_up = (
    node_id: string,
    event: UnitPointerEvent
  ): void => {
    // console.log('Graph', '_on_node_pointer_up', node_id)

    const { pointerId } = event

    this.__on_node_pointer_up(node_id, pointerId)
  }

  private __on_node_pointer_up = (node_id: string, pointerId: number): void => {
    // console.log('Graph', '_on_node_pointer_up', node_id, pointerId)

    delete this._drag_node_init_edge_overflow[node_id]

    this._release_node_pointer_capture(node_id, pointerId)
  }

  private _on_node_pointer_cancel = (
    node_id: string,
    event: UnitPointerEvent
  ): void => {
    // console.log('Graph', '_on_node_pointer_cancel', node_id)

    this._on_node_pointer_up(node_id, event)
  }

  private _on_node_drag_start = (
    node_id: string,
    event: UnitPointerEvent
  ): void => {
    // console.log('Graph', '_on_node_drag_start', node_id)

    const { clientX, clientY, pointerId } = event

    const [x, y] = zoomInvert(this._zoom, clientX, clientY)

    this.__on_node_drag_start(node_id, pointerId, x, y)
  }

  private _node_drag_max_distance: Dict<number> = {}
  private _node_drag_init_position: Dict<Position> = {}

  private __on_node_drag_start = (
    node_id: string,
    pointer_id: number,
    x: number,
    y: number
  ) => {
    // console.log('Graph', '__on_node_drag_start', node_id, x, y)

    if (this._drag_node_id[node_id]) {
      // throw new Error('node is already being dragged')
      return
    }

    this._set_drag_node(node_id, pointer_id, true)

    const node_layer = this._get_node_default_layer(node_id)

    this._start_graph_simulation(node_layer)

    const node = this.get_node(node_id)

    node.hx = x - node.x
    node.hy = y - node.y

    node.fx = node.x
    node.fy = node.y

    this._node_drag_max_distance[node_id] = 0
    this._node_drag_init_position[node_id] = { x, y }

    this._start_drag_node_static(node_id)

    this._refresh_compatible()
  }

  private _start_static = (): void => {
    if (this._static) {
      return
    }

    // console.log('Graph', '_start_static')

    this._static = true

    for (const node_id in this._unit_node) {
      if (this._drag_node_id[node_id]) {
        continue
      }

      if (
        this._collapsing &&
        (this._is_node_selected(node_id) ||
          this._collapse_next_unit_id === node_id)
      ) {
        continue
      }

      this._start_node_static(node_id)
    }
  }

  private _start_node_static = (node_id: string): void => {
    // console.log('Graph', '_start_node_static', node_id)

    const node = this.get_node(node_id)

    const { x, y } = node

    this._static_position[node_id] = { x, y }
    this._static_count[node_id] = 0
  }

  private _stop_node_static = (node_id: string): void => {
    // console.log('Graph', '_stop_node_static', node_id)

    delete this._static_position[node_id]
    delete this._static_count[node_id]
  }

  private _stop_static = (): void => {
    if (!this._static) {
      return
    }

    // console.log('Graph', '_stop_static')

    this._static = false

    for (const node_id in this._unit_node) {
      if (this._drag_node_id[node_id]) {
        continue
      }

      // if (
      //   this._long_press_collapsing &&
      //   (this._is_node_selected(node_id) ||
      //     this._long_press_collapse_next_unit_id === node_id)
      // ) {
      //   continue
      // }

      this._stop_node_static(node_id)
    }
  }

  private _on_node_drag_move = (node_id: string, event: UnitPointerEvent) => {
    // console.log('Graph', '_on_node_drag_move', node_id)
    const { clientX, clientY } = event
    const [x, y] = zoomInvert(this._zoom, clientX, clientY)
    this._node_drag_move(node_id, x, y)
  }

  private _node_drag_move = (node_id: string, x: number, y: number) => {
    // console.log('Graph', '_node_drag_move', node_id, x, y)

    // if (this._node_draggable[node_id] === false) {
    //   return
    // }

    const node = this.get_node(node_id)

    const d = pointDistance({ x, y }, this._node_drag_init_position[node_id])

    this._node_drag_max_distance[node_id] = Math.max(
      this._node_drag_max_distance[node_id],
      d
    )

    if (this._drag_anchor_animation[node_id]) {
      return
    }

    node.fx = x - node.hx
    node.fy = y - node.hy

    node.x = node.fx
    node.y = node.fy
  }

  private _on_node_drag_end_and_drop = (
    node_id: string,
    pointerId: number,
    drop: boolean
  ) => {
    // console.log('Graph', '_on_node_drag_end_and_drop', node_id, pointerId, drop)

    const node_drag_max_distance = this._node_drag_max_distance[node_id]

    this.__on_node_drag_end(node_id, pointerId)

    if (drop) {
      if (this._is_droppable_mode()) {
        if (node_drag_max_distance > MIN_DRAG_DROP_MAX_D) {
          if (node_id === this._subgraph_unit_id) {
            //
          } else {
            this._drop_node(node_id)
          }
        }
      }
    }

    this._refresh_node_color(node_id)
    this._refresh_compatible()
  }

  private __on_node_drag_end = (node_id: string, pointerId: number) => {
    // console.log('Graph', '__on_node_drag_end', node_id)

    this._on_node_drag_end(node_id)
    this._set_drag_node(node_id, pointerId, false)
    this._stop_drag_node_static(node_id)

    if (this._is_ext_node_id(node_id)) {
      const int_node_id = getIntNodeIdFromExtNodeId(node_id)

      this._delete_all_node_to_node_charge(node_id)
      this._delete_all_node_to_node_charge(int_node_id)
    }

    this._refresh_node_fixed(node_id)
  }

  private _on_node_drag_end = (node_id: string) => {
    // console.log('Graph', '_on_node_drag_end', node_id)

    const node = this.get_node(node_id)

    node.hx = 0
    node.hy = 0

    if (!this._node_target[node_id]) {
      node.fx = undefined
      node.fy = undefined
    }

    delete this._node_drag_max_distance[node_id]
    delete this._node_drag_init_position[node_id]
  }

  private _start_drag_node_static = (node_id: string): void => {
    // console.log('Graph', '_start_drag_node_static', node_id)

    const subgraph_id = this._node_to_subgraph[node_id]

    this._static_subgraph_anchor[subgraph_id] =
      this._static_subgraph_anchor[subgraph_id] || {}
    this._static_subgraph_anchor_count[subgraph_id] =
      this._static_subgraph_anchor_count[subgraph_id] ?? 0

    if (!this._static_subgraph_anchor[subgraph_id][node_id]) {
      const subgraph = this._subgraph_to_node[subgraph_id]

      this._static_subgraph_anchor[subgraph_id][node_id] = true
      this._static_subgraph_anchor_count[subgraph_id]++

      for (const n_id of subgraph) {
        if (this._is_unit_node_id(n_id)) {
          this._static_count[n_id] = this._static_count[n_id] ?? 0
          this._static_count[n_id]++
        }
      }
    }
  }

  private _stop_drag_node_static = (node_id: string): void => {
    // console.log('Graph', '_stop_drag_node_static', node_id)

    const subgraph_id = this._node_to_subgraph[node_id]

    if (
      this._static_subgraph_anchor[subgraph_id] &&
      this._static_subgraph_anchor[subgraph_id][node_id]
    ) {
      const subgraph = this._subgraph_to_node[subgraph_id]

      for (const n_id of subgraph) {
        if (this._is_unit_node_id(n_id)) {
          this._static_count[n_id]--
          this._static_position[n_id] = this._get_node_position(n_id)

          if (this._static_count[n_id] === 0) {
            delete this._static_count[n_id]
            delete this._static_position[n_id]
          }
        }
      }

      delete this._static_subgraph_anchor[subgraph_id][node_id]

      this._static_subgraph_anchor_count[subgraph_id]--

      if (this._static_subgraph_anchor_count[subgraph_id] === 0) {
        delete this._static_subgraph_anchor_count[subgraph_id]
        delete this._static_subgraph_anchor[subgraph_id]
      }
    }
  }

  private _find_node = (
    filter: (node_id: string, node: GraphSimNode) => boolean
  ): string | null => {
    for (const node_id in this._node) {
      const node = this.get_node(node_id)
      if (filter(node_id, node)) {
        return node_id
      }
    }
    return null
  }

  private _node_node_surface_distance = (
    a_id: string,
    b_id: string
  ): { l: number; d: number; u: Point } => {
    const a_node = this._node[a_id]
    const b_node = this._node[b_id]

    return surfaceDistance(a_node, b_node)
  }

  private _node_node_center_distance = (a_id: string, b_id: string): number => {
    const a_node = this._node[a_id]
    const b_node = this._node[b_id]
    const d = pointDistance(a_node, b_node)
    return d
  }

  private _find_nearest_core_id = (
    node_id: string,
    maxDistance: number = NEAR,
    distance: (a: SimNode<any>, b: SimNode<any>) => number = (
      a: SimNode<any>,
      b: SimNode<any>
    ) => surfaceDistance(a, b).l,
    filter: (node_id: string) => boolean = () => true
  ): string | null => {
    const node = this.get_node(node_id)
    let nearest: string | null = null
    let nearest_l: number = Infinity

    for (const n_id in this._unit_node) {
      if (n_id !== node_id) {
        const n = this._node[n_id]
        if (filter(n_id)) {
          const d = distance(node, n)
          if (d < maxDistance / this._zoom.z && d < nearest_l) {
            nearest = n_id
            nearest_l = d
          }
        }
      }
    }
    return nearest
  }

  private _find_inside_node_id = (
    point: Point,
    nodes: GraphSimNodes,
    padding: number
  ): string | null => {
    let min_distance = Infinity
    let min_distance_node_id = null

    for (const n_id in nodes) {
      const n = nodes[n_id]

      const { l } = surfaceDistance(
        {
          shape: 'circle',
          x: point.x,
          y: point.y,
          width: 0,
          height: 0,
          r: 0,
        },
        n
      )

      if (l < min_distance) {
        min_distance = l
        min_distance_node_id = n_id
      }
    }

    if (min_distance < padding) {
      return min_distance_node_id
    }

    return null
  }

  private _find_inside_core_and_pin_id = (
    point: Point,
    padding: number
  ): string | null => {
    // const nodes = {
    //   ...this._unit_node,
    //   ...this._pin_node,
    // }
    const nodes = this._normal_node
    return this._find_inside_node_id(point, nodes, padding)
  }

  private _find_inside_core_id = (
    point: Point,
    padding: number
  ): string | null => {
    return this._find_inside_node_id(point, this._unit_node, padding)
  }

  private _find_nearest_node_id = (
    node_id: string,
    max_distance: number = NEAR,
    filter: (node_id: string, n_id: string) => boolean = () => true,
    nodes: GraphSimNodes = this._node
  ): string => {
    let nearest: string[] = []

    const nearest_l: Dict<number> = {}

    for (const n_id in nodes) {
      if (n_id !== node_id) {
        if (filter(node_id, n_id)) {
          const { l } = this._node_node_surface_distance(node_id, n_id)

          if (l < max_distance) {
            nearest.push(n_id)

            nearest_l[n_id] = l
          }
        }
      }
    }

    nearest = nearest.sort((a, b) => nearest_l[a] - nearest_l[b])

    return nearest[0]
  }

  private _find_nearest_node_id_to = (
    position: Position,
    filter: (node_id: string) => boolean = () => true,
    nodes: GraphSimNodes = this._node
  ): string => {
    let min_distance = Infinity
    let nearest_node_id: string

    for (const node_id in nodes) {
      if (filter(node_id)) {
        const node = nodes[node_id]

        const d = pointDistance(node, position)

        if (d < min_distance) {
          min_distance = d
          nearest_node_id = node_id
        }
      }
    }

    return nearest_node_id
  }

  private _find_nearest_unit_id_to_center = (): string => {
    const center = this._world_screen_center()

    return this._find_nearest_node_id_to(center, () => true, this._unit_node)
  }

  private _find_nearest_pin_node_id_from = (
    node_id: string,
    max_distance: number = NEAR,
    filter: (node_id: string) => boolean = () => true
  ): string => {
    return this._find_nearest_node_id(
      node_id,
      max_distance,
      filter,
      this._pin_node
    )
  }

  private _is_pin_unit_connected = (
    pin_node_id: string,
    unit_id: string
  ): boolean => {
    if (this._is_link_pin_node_id(pin_node_id)) {
      const { unitId } = segmentLinkPinNodeId(pin_node_id)

      return unitId === unit_id
    } else {
      const merge = this._get_merge_by_node_id(pin_node_id)

      return !!merge[unit_id]
    }
  }

  private _is_unit_pin_pre_match = (unit_id: string, pin_node_id: string) => {
    return (
      ((this._is_link_pin_node_id(pin_node_id) &&
        !this._spec_is_link_pin_ignored(pin_node_id)) ||
        this._is_merge_node_id(pin_node_id)) &&
      this._is_input_pin_node_id(pin_node_id) &&
      this._is_pin_node_ref(pin_node_id) &&
      !this._spec_get_pin_node_plug_spec('input', pin_node_id) &&
      !this._spec_get_pin_node_plug_spec('output', pin_node_id) &&
      !this._is_pin_unit_connected(pin_node_id, unit_id)
    )
  }

  private _is_unit_node_match = (unit_id: string, node_id: string): boolean => {
    // console.log('Graph', '_is_unit_node_match', unit_id, node_id)

    if (this._is_unit_pin_pre_match(unit_id, node_id)) {
      return this._is_unit_pin_post_match(unit_id, node_id)
    } else {
      return false
    }
  }

  private _is_unit_link_post_match = (
    unit_id: string,
    pin_node_id: string
  ): boolean => {
    const { unitId, type } = segmentLinkPinNodeId(pin_node_id)

    const merge_node_id = this._ref_unit_to_merge[unit_id]

    if (merge_node_id) {
      const merge = this._get_merge(merge_node_id)

      if (merge[unitId]) {
        return false
      } else {
        return this._is_ref_pin_unit_type_match(pin_node_id, unit_id)
      }
    } else {
      const ref = this._is_link_pin_ref(pin_node_id)

      if (ref) {
        const int_node_id = this._pin_to_int[type][pin_node_id]

        if (int_node_id) {
          return false
        }
      }

      return true
    }
  }

  private _is_unit_merge_post_match = (
    unit_id: string,
    merge_node_id: string
  ): boolean => {
    return true
  }

  private _drop_unit = (unit_id: string): void => {
    const nearest_ref_pin_node_id: string = this._find_nearest_node_id(
      unit_id,
      NEAR,
      this._is_unit_node_match
    )

    if (nearest_ref_pin_node_id) {
      this._merge_pin_unit(nearest_ref_pin_node_id, unit_id)
    }
  }

  private _is_pin_node_match = (
    pin_node_id: string,
    node_id: string
  ): boolean => {
    if (this._is_unit_node_id(node_id)) {
      return this._is_pin_unit_match(pin_node_id, node_id)
    } else if (this._is_link_pin_node_id(node_id)) {
      if (!this._spec_is_link_pin_ignored(node_id)) {
        if (this._is_pin_pin_match(pin_node_id, node_id)) {
          return true
        }
      }
    } else if (this._is_merge_node_id(node_id)) {
      if (this._is_pin_pin_match(pin_node_id, node_id)) {
        return true
      }
    } else if (this._is_int_node_id(node_id)) {
      if (this._is_plug_node_match(node_id, pin_node_id)) {
        return true
      }
    }
    return false
  }

  private _drop_pin = (pin_node_id: string): void => {
    // console.log('Graph', '_drop_pin', pin_node_id)

    const is_link_pin = this._is_link_pin_node_id(pin_node_id)
    const is_link_pin_ignored =
      is_link_pin && this._spec_is_link_pin_ignored(pin_node_id)

    if (is_link_pin_ignored) {
      return
    }

    const nearest_compatible_node_id: string = this._find_nearest_node_id(
      pin_node_id,
      NEAR,
      this._is_pin_node_match,
      { ...this._node, ...this._exposed_int_node }
    )

    if (nearest_compatible_node_id) {
      this.__drop_pin(pin_node_id, nearest_compatible_node_id)
    }
  }

  private _maybe_refresh_simulation_by_drag() {
    if (
      this._exposed_pin_unplugged_count > 0 ||
      this._empty_merge_node_count > 0
    ) {
      this._start_graph_simulation(LAYER_NONE)
    }
  }

  private _end_leave_fullwindow_animation(sub_component_ids: string[]) {
    // console.log('Graph', '_end_leave_fullwindow_animation', sub_component_ids)

    const ordered_sub_component_ids =
      this._order_sub_component_ids(sub_component_ids)

    for (const sub_component_id of ordered_sub_component_ids) {
      this._unplug_sub_component_root_base_frame(sub_component_id)
      this._append_sub_component_all_missing_root(sub_component_id)
      this._append_sub_component_root_base(sub_component_id)
    }

    for (const sub_component_id of ordered_sub_component_ids) {
      this._finish_sub_component(sub_component_id)

      this._animating_sub_component_fullwindow.delete(sub_component_id)
    }

    this._finish_component()
  }

  private _show_unit_ignored_pins(unit_id: string) {
    this._for_each_unit_pin(unit_id, (pin_node_id: string) => {
      if (this._spec_is_link_pin_ignored(pin_node_id)) {
        this._set_link_pin_opacity(pin_node_id, 0.5)
        this._set_link_pin_pointer_events(pin_node_id, 'inherit')
      }
    })
  }

  private _hide_unit_ignored_pins(unit_id: string) {
    this._for_each_unit_pin(unit_id, (pin_node_id: string) => {
      if (this._spec_is_link_pin_ignored(pin_node_id)) {
        this._set_link_pin_opacity(pin_node_id, 0)
        this._set_link_pin_pointer_events(pin_node_id, 'none')
      }
    })
  }

  private __drop_pin(pin_node_id: string, nearest_compatible_node_id: string) {
    if (this._is_pin_node_id(nearest_compatible_node_id)) {
      if (
        this._is_link_pin_node_id(pin_node_id) &&
        this._is_input_pin_ref(pin_node_id)
      ) {
        this._set_ref_link_pin_start_marker_to_node_r(
          pin_node_id,
          nearest_compatible_node_id
        )
      }

      this._set_node_target(pin_node_id, nearest_compatible_node_id)
    } else if (this._is_unit_node_id(nearest_compatible_node_id)) {
      if (
        this._is_link_pin_node_id(pin_node_id) &&
        this._is_input_pin_ref(pin_node_id)
      ) {
        this._set_ref_link_pin_start_marker_to_node_r(
          pin_node_id,
          nearest_compatible_node_id
        )
      }

      this._set_node_target(pin_node_id, nearest_compatible_node_id)
    } else if (this._is_int_node_id(nearest_compatible_node_id)) {
      this._set_node_target(pin_node_id, nearest_compatible_node_id)
    }
  }

  private _is_pin_active = (pin_node_id: string): boolean => {
    const datum_node_id = this._pin_datum_tree[pin_node_id]
    return !!datum_node_id
  }

  private _is_datum_node_match = (
    datum_node_id: string,
    node_id: string
  ): boolean => {
    if (
      ((this._is_link_pin_node_id(node_id) ||
        this._is_merge_node_id(node_id)) &&
        this._is_datum_pin_pre_match(datum_node_id, node_id)) ||
      (this._is_ext_node_id(node_id) &&
        this._is_datum_plug_match(datum_node_id, node_id)) ||
      (this._is_unit_node_id(node_id) &&
        this._is_datum_unit_pre_match(datum_node_id, node_id))
    ) {
      return true
    }
    return false
  }

  private _drop_datum = (datum_node_id: string): void => {
    const { classes } = this.$system
    const { specs } = this.$props

    if (this._search_unit_datum_node_id === datum_node_id) {
      this._mem_remove_search_datum()

      this._hide_search()
    }

    const nearest_compatible_node_id: string = this._find_nearest_node_id(
      datum_node_id,
      NEAR,
      this._is_datum_node_match
    )

    if (nearest_compatible_node_id) {
      if (this._is_pin_node_id(nearest_compatible_node_id)) {
        this._move_datum_to_pin(datum_node_id, nearest_compatible_node_id)
      } else if (this._is_ext_node_id(nearest_compatible_node_id)) {
        this._move_datum_to_exposed_pin(
          datum_node_id,
          nearest_compatible_node_id
        )
      } else if (this._is_unit_node_id(nearest_compatible_node_id)) {
        const unit_id = nearest_compatible_node_id

        this._set_node_target(datum_node_id, unit_id)

        const {
          x: prev_x,
          y: prev_y,
          width: prev_width,
          height: prev_height,
        } = this._node[unit_id]

        const { x, y } = this._get_node_position(unit_id)

        const datum_value = this._get_datum_value(datum_node_id)

        const bundle = evaluateBundleStr(
          datum_value,
          specs,
          classes,
          _evaluate__cached
        )

        const id = bundle.unit.id

        const r = getSpecRadius(specs, classes, id)

        const is_component = isComponentId(
          weakMerge(specs, bundle.specs ?? {}),
          id
        )

        let width: number
        let height: number

        if (is_component) {
          width = prev_width
          height = prev_height
        } else {
          width = 2 * r
          height = 2 * r
        }

        const target_trait = {
          x,
          y,
          width,
          height,
          opacity: 1,
        }

        this._animate_core_size_and_opacity(
          unit_id,
          {
            x: prev_x,
            y: prev_y,
            width: prev_width,
            height: prev_height,
            opacity: 1,
          },
          () => {
            return target_trait
          },
          ({ x, y, width, height }) => {
            this._set_node_x(unit_id, x)
            this._set_node_y(unit_id, y)

            this._resize_core_width(unit_id, width)
            this._resize_node_width(unit_id, width)

            this._resize_core_height(unit_id, height)
            this._resize_node_height(unit_id, height)
          },
          () => {
            //
          }
        )
      }
    }
  }

  private _animate_unit_opacity = (
    unit_id: string,
    from: number,
    to: number,
    callback: () => void
  ) => {
    const unlisten = this._animate_simulate(
      { opacity: from },
      () => {
        return { opacity: to }
      },
      [['opacity', 0.1]],
      ({ opacity }) => {
        this._set_unit_style_attr(unit_id, 'opacity', `${opacity}`)
      },
      callback
    )

    return unlisten
  }

  private _move_datum_to_empty_unit = (
    datum_node_id: string,
    unit_id: string
  ): void => {
    const { classes } = this.$system
    const { specs, injectSpecs } = this.$props

    const datum_value = this._get_datum_value(datum_node_id)

    const spec = this._get_unit_spec(unit_id)

    const class_bundle = evaluateBundleStr(
      datum_value,
      specs,
      classes,
      _evaluate__cached
    )

    injectSpecs(class_bundle.specs)

    const {
      unit: { id: class_spec_id, memory },
    } = class_bundle

    const class_spec = getSpec(specs, class_spec_id)

    const new_unit_id = this._new_unit_id(class_spec_id, undefined, specs)

    const {
      valid_pin_match,
      merged_pin_ids,
      merge_pin_index,
      exposed_pin_ids,
      exposed_pin_index,
    } = this._generate_identity_matches(unit_id)

    this._remove_datum(datum_node_id)

    this._state_swap_unit(
      unit_id,
      new_unit_id,
      class_spec_id,
      class_spec,
      valid_pin_match,
      merged_pin_ids,
      merge_pin_index,
      exposed_pin_ids,
      exposed_pin_index
    )

    if (memory) {
      this._set_unit_memory(new_unit_id, memory)
    }

    function makePinMap(pinIds: string[], newPinIds: string[]) {
      const pinMap = {}

      for (let i = 0; i < pinIds.length; i++) {
        const pinId = pinIds[i]
        const newPinId = newPinIds[i]

        pinMap[pinId] = newPinId
      }

      return pinMap
    }

    const new_unit_pin_map = emptyIO(
      makePinMap(keys(spec.inputs ?? {}), keys(class_spec.inputs ?? {})),
      makePinMap(keys(spec.outputs ?? {}), keys(class_spec.outputs ?? {}))
    )

    this._pod_add_unit_ghost(
      unit_id,
      new_unit_id,
      class_bundle,
      new_unit_pin_map
    )

    if (this._is_unit_component(new_unit_id)) {
      this._connect_sub_component(new_unit_id)
    }
  }

  private _move_datum_to_exposed_pin = (
    datum_node_id: string,
    ext_node_id: string
  ): void => {
    const value = this._get_datum_value(datum_node_id)

    const datum_pin_node_id = this._datum_to_pin[datum_node_id]
    const datum_plug_node_id = this._datum_to_plug[datum_node_id]

    if (datum_pin_node_id) {
      this._sim_remove_pin_datum_link(datum_node_id)
    }

    if (datum_plug_node_id) {
      if (datum_plug_node_id === ext_node_id) {
        //
      } else {
        this._sim_add_plug_datum_link(ext_node_id, datum_node_id)
      }
    } else {
      const { type, pinId } = segmentPlugNodeId(ext_node_id)

      this._remove_datum(datum_node_id)

      this._sim_set_pin_set_data(type, pinId, value)
    }

    this._pod_set_plug_data(ext_node_id, value)
  }

  private _is_plug_node_match = (
    exposed_pin_node_id: string,
    node_id: string
  ): boolean => {
    const { type, pinId } = segmentPlugNodeId(exposed_pin_node_id)
    if (
      this._is_pin_node_id(node_id) &&
      this._is_plug_pin_match(type, pinId, node_id)
    ) {
      return true
    } else if (
      this._is_unit_node_id(node_id) &&
      this._is_plug_unit_match(type, pinId, node_id)
    ) {
      return true
    } else if (
      this._is_int_node_id(exposed_pin_node_id) &&
      this._is_int_node_id(node_id) &&
      this._is_int_int_match(exposed_pin_node_id, node_id)
    ) {
      return true
    }

    return false
  }

  private _refresh_plug_layer = (
    ext_node_id: string,
    int_node_id: string
  ): void => {
    this._refresh_node_layer(ext_node_id)

    if (this._has_node(int_node_id)) {
      this._refresh_node_layer(int_node_id)
    }

    const type_node_id = getTypeNodeId(ext_node_id)

    if (this._has_node(type_node_id)) {
      const type_link_id = getLinkId(type_node_id, ext_node_id)

      this._refresh_node_layer(type_node_id)
      this._refresh_link_layer(type_link_id)
    }

    const datum_node_id = this._plug_to_datum[ext_node_id]

    if (datum_node_id) {
      const datum_link_id = getLinkId(datum_node_id, ext_node_id)

      this._refresh_node_layer(datum_node_id)
      this._refresh_link_layer(datum_link_id)
    }
  }

  private _drop_plug = (exposed_pin_node_id: string): void => {
    // console.log('Graph', '_drop_plug', exposed_pin_node_id)

    const { type, pinId, subPinId } = segmentPlugNodeId(exposed_pin_node_id)

    const ext_node_id = getExtNodeId(type, pinId, subPinId)
    const int_node_id = getIntNodeId(type, pinId, subPinId)

    if (!this._ext_to_node[ext_node_id]) {
      const nearest_compatible_node_id: string = this._find_nearest_node_id(
        int_node_id,
        NEAR,
        // 4 * LINK_DISTANCE + 2 * PIN_RADIUS,
        this._is_plug_node_match
      )

      if (nearest_compatible_node_id) {
        this._set_node_target(int_node_id, nearest_compatible_node_id)
      } else {
        this._refresh_plug_layer(ext_node_id, int_node_id)
      }
    } else {
      this._refresh_plug_layer(ext_node_id, int_node_id)
    }
  }

  private _node_target: Dict<string> = {}
  private _target_node: Dict<Set<string>> = {}
  private _node_target_count: number = 0

  private _turn_unit_into_data(unit_id: string) {
    const spec_id = this._get_unit_spec_id(unit_id)
    const position = this._get_node_position(unit_id)

    this._remove_unit(unit_id)

    const bundle = { unit: { id: spec_id } }

    this._add_data_unit(bundle, position)
  }

  private _set_node_target(node_id: string, target_id: string): void {
    if (this._node_target[node_id]) {
      return
    }

    // console.log('Graph', '_set_node_target', node_id, target_id)

    this._set_node_fixed(node_id, true)
    this._set_node_fixed(target_id, true)

    this._node_target[node_id] = target_id
    this._node_target_count++

    this._target_node[target_id] = this._target_node[target_id] ?? new Set()
    this._target_node[target_id].add(node_id)

    this._refresh_compatible()

    this._start_node_target_frame()
  }

  private _node_target_tick = (): void => {
    for (const node_id in this._node_target) {
      const target_node_id = this._node_target[node_id]

      const target_anchor_node_id =
        this._get_node_anchor_node_id(target_node_id)
      const node = this.get_node(node_id)

      const target_node = this._node[target_anchor_node_id]

      const u = pointUnitVector(node, target_node)

      const dx = target_node.x - node.x
      const dy = target_node.y - node.y

      const adx = Math.abs(dx)
      const ady = Math.abs(dy)

      const k = 1 / 2 / ANIMATION_C

      node.fx = node.fx ?? node.x
      node.fy = node.fy ?? node.y

      if (adx > 0) {
        const _dx = adx * u.x * k

        node.fx += _dx
      }

      if (ady > 0) {
        const _dy = ady * u.y * k

        node.fy += _dy
      }
    }
  }

  private _start_node_target_frame = () => {
    const {
      api: {
        animation: { requestAnimationFrame },
      },
    } = this.$system

    if (this._node_target_frame !== undefined) {
      return
    }

    const frame = () => {
      this._node_target_tick()

      if (this._node_target_count > 0) {
        this._node_target_frame = requestAnimationFrame(frame)
      } else {
        this._node_target_frame = undefined
      }
    }

    requestAnimationFrame(frame)
  }

  private _node_target_frame: number

  private _remove_node_target(node_id: string): void {
    if (!this._node_target[node_id]) {
      return
    }

    // console.log('Graph', '_remove_node_target', node_id)

    const target_id = this._node_target[node_id]

    this._target_node[target_id].delete(node_id)

    if (this._target_node[target_id].size === 0) {
      delete this._target_node[target_id]
    }

    delete this._node_target[node_id]

    this._node_target_count--

    this._refresh_compatible()

    if (this._has_node(node_id)) {
      this._refresh_node_fixed(node_id)
    }

    if (this._has_node(target_id)) {
      this._refresh_node_fixed(target_id)
    }
  }

  private _on_node_target_end(node_id: string, target_node_id: string): void {
    // console.log('Graph', '_on_node_target_end', node_id, target_node_id)
    if (this._is_pin_node_id(node_id)) {
      if (this._is_pin_node_id(target_node_id)) {
        this._on_pin_pin_target_end(node_id, target_node_id)
      } else if (this._is_unit_node_id(target_node_id)) {
        this._on_pin_unit_target_end(node_id, target_node_id)
      }
    } else if (this._is_plug_node_id(node_id)) {
      this._on_plug_target_end(node_id, target_node_id)
    } else if (this._is_datum_node_id(node_id)) {
      if (this._is_unit_node_id(target_node_id)) {
        this._move_datum_to_empty_unit(node_id, target_node_id)

        this._remove_node_target(node_id)
      }
    }
  }

  private _on_pin_pin_target_end = (
    pin_node_id: string,
    target_pin_node_id: string
  ) => {
    // console.log(
    //   'Graph',
    //   '_on_pin_pin_target_end',
    //   pin_node_id,
    //   target_pin_node_id
    // )

    const target_anchor_id = this._get_pin_anchor_node_id(target_pin_node_id)
    const target_position = this._get_node_position(target_anchor_id)

    const output_ref_merge_node_id = this._ref_output_to_merge[target_anchor_id]

    if (output_ref_merge_node_id) {
      this._merge_pin_pin(
        pin_node_id,
        output_ref_merge_node_id,
        target_position
      )
    } else {
      this._merge_pin_pin(pin_node_id, target_anchor_id, target_position)
    }

    this._remove_node_target(pin_node_id)
    this._remove_node_target(target_pin_node_id)
  }

  private _on_pin_unit_target_end = (
    pin_node_id: string,
    target_unit_id: string
  ) => {
    // console.log('Graph', '_on_pin_unit_target_end')

    this._remove_node_target(pin_node_id)

    this._merge_pin_unit(pin_node_id, target_unit_id)
  }

  private _on_plug_target_end(
    plug_node_id: string,
    target_node_id: string
  ): void {
    // console.log('Graph', '_on_plug_target_end', plug_node_id, target_node_id)

    const { type, pinId, subPinId } = segmentPlugNodeId(plug_node_id)

    this._set_node_fixed(plug_node_id, false)
    this._set_node_fixed(target_node_id, false)

    const ext_node_id = getExtNodeId(type, pinId, subPinId)
    const int_node_id = getIntNodeId(type, pinId, subPinId)

    this._remove_node_target(plug_node_id)

    this._refresh_plug_layer(ext_node_id, int_node_id)

    delete this._int_node_locked[int_node_id]

    if (this._is_pin_node_id(target_node_id)) {
      const { type: kind } = segmentLinkPinNodeId(target_node_id)

      this.__plug_exposed_pin_to(type, pinId, subPinId, target_node_id)
    } else if (this._is_unit_node_id(target_node_id)) {
      this.__plug_exposed_pin_to(type, pinId, subPinId, target_node_id)
    } else if (this._is_plug_node_id(target_node_id)) {
      const mergeId = this._new_merge_id()

      const merge_node_id = getMergeNodeId(mergeId)

      const int_position = this._get_node_position(target_node_id)
      const ext_position = this._get_node_position(plug_node_id)

      const position = centerOfMass([int_position, ext_position])

      this._add_merge(mergeId, {}, position, true)

      const {
        type: plugType,
        pinId: plugPinId,
        subPinId: plugSubPin,
      } = segmentPlugNodeId(plug_node_id)
      const {
        type: targetType,
        pinId: targetPinId,
        subPinId: targetSubPin,
      } = segmentPlugNodeId(target_node_id)

      this._plug_exposed_pin(plugType, plugPinId, plugSubPin, {
        mergeId,
      })
      this._plug_exposed_pin(targetType, targetPinId, targetSubPin, {
        mergeId,
      })

      this._set_merge_empty(merge_node_id)
    } else {
      throw new Error('invalid plug drop target')
    }
  }

  private _drop_node = (node_id: string): void => {
    // console.log('_drop_node', node_id)

    if (this._collapse_unit_id === node_id) {
      return
    }

    this._dropped_node_id.add(node_id)

    this._cancel_long_click = true

    setTimeout(() => {
      this._cancel_long_click = false
    }, 0)

    if (this._tree_layout) {
      //
    } else {
      if (this._is_unit_node_id(node_id)) {
        this._drop_unit(node_id)
      } else if (this._is_pin_node_id(node_id)) {
        this._drop_pin(node_id)
      } else if (this._is_datum_node_id(node_id)) {
        this._drop_datum(node_id)
      } else if (this._is_plug_node_id(node_id)) {
        this._drop_plug(node_id)
      }
    }

    this._dropped_node_id.delete(node_id)
  }

  public isFullwindow(): boolean {
    return this._is_fullwindow
  }

  public leaveFullwindow(animate: boolean): void {
    this._leave_all_fullwindow(animate)
  }

  public enterFullwindow(animate: boolean, hide: boolean = true): void {
    this._enter_all_fullwindow(animate, hide)
  }

  public getSubgraphPath(): string[] {
    if (this._subgraph_unit_id) {
      return [this._subgraph_unit_id, ...this._subgraph_graph.getPath()]
    }

    return []
  }

  public getSubgraphAtPath(path: string[]): Editor_ {
    if (path.length === 0) {
      return this
    } else {
      const [unit_id, ...sub_path] = path

      const cached_subgraph = this._subgraph_cache[unit_id]

      if (!cached_subgraph) {
        return null
      }

      return cached_subgraph.getSubgraphAtPath(sub_path)
    }
  }

  public focus(options: FocusOptions | undefined = { preventScroll: true }) {
    // console.log('Graph', 'focus', this._id)

    const { animate } = this._config()

    if (this._core_component_unlocked_count > 0) {
      const unlocked_component_id = getObjSingleKey(
        this._core_component_unlocked
      )
      const unlocked_sub_component = this._get_sub_component(
        unlocked_component_id
      )

      unlocked_sub_component.focus(options)
    } else {
      this._graph.focus(options)
    }
  }

  public blur(options: FocusOptions | undefined = { preventScroll: true }) {
    // console.log('Graph', 'blur', this._id)

    this._graph.blur()

    if (this._control_lock) {
      this._unlock_control()
    }
  }

  public temp_fixate_node = (node_id: string, t: number = 100): void => {
    const {
      api: {
        window: { setTimeout },
      },
    } = this.$system

    this._set_node_fixed(node_id, true)

    setTimeout(() => {
      this._set_node_fixed(node_id, false)
    }, t)
  }

  public _set_node_fixed = (node_id: string, fixed: boolean): void => {
    // console.log('Graph', 'set_node_fixed', node_id, fixed)

    this._node_fixed[node_id] = fixed

    const node = this.get_node(node_id)

    if (fixed) {
      node.fx = node.x
      node.fy = node.y
    } else {
      node.fx = undefined
      node.fy = undefined
    }
  }

  private _set_all_node_fixed = (fixed: boolean): void => {
    for (const node_id in this._node) {
      this._set_node_fixed(node_id, fixed)
    }
  }

  private _set_all_unit_node_fixed = (fixed: boolean): void => {
    for (const unit_id in this._unit_node) {
      this._set_node_fixed(unit_id, fixed)
    }

    for (const pin_node_id in this._pin_node) {
      this._set_node_fixed(pin_node_id, fixed)
    }
  }

  private _refresh_all_node_fixed = (): void => {
    for (const node_id in this._node) {
      this._refresh_node_fixed(node_id)
    }
  }

  private _set_node_draggable = (node_id: string, draggable: boolean): void => {
    this._node_draggable[node_id] = draggable
  }

  private _hide_core_overlay = (unit_id: string): void => {
    const core_overlay = this._core_component_overlay[unit_id]

    if (core_overlay) {
      core_overlay.$element.style.display = 'none'
    }
  }

  private _show_core_overlay = (unit_id: string): void => {
    const core_overlay = this._core_component_overlay[unit_id]

    if (core_overlay) {
      core_overlay.$element.style.display = 'block'
    }
  }

  private _hide_err_overlay = (err_node_id: string): void => {
    const err_overlay = this._err_overlay[err_node_id]

    if (err_overlay) {
      err_overlay.$element.style.display = 'none'
    }
  }

  private _show_err_overlay = (err_node_id: string): void => {
    const err_overlay = this._err_overlay[err_node_id]

    if (err_overlay) {
      err_overlay.$element.style.display = 'block'
    }
  }

  public unlock_sub_component = (unit_id: string, focus: boolean): void => {
    this._unlock_sub_component(unit_id, focus)
  }

  private _focusing_sub_component: boolean = false

  private _unlock_sub_component = (unit_id: string, focus: boolean): void => {
    // console.log('Graph', '_unlock_sub_component', unit_id, focus, this._id)

    const { animate } = this._config()

    const component = this._get_sub_component(unit_id)

    if (component) {
      if (!this._core_component_unlocked[unit_id]) {
        this._core_component_unlocked[unit_id] = true
        this._core_component_unlocked_count++

        if (this._core_component_unlocked_count === 1) {
          this._disable_input()

          if (this._control_lock) {
            this._hide_control(animate)
          }
        }

        this._refresh_selection_dasharray(unit_id)
        this._refresh_selection_dashoffset(unit_id)

        this._enable_core_frame(unit_id)
        this._hide_core_overlay(unit_id)

        if (focus) {
          this._focusing_sub_component = true

          this._focus_sub_component_frame(unit_id)
          this._focus_sub_component(unit_id)

          this._focusing_sub_component = false
        }

        const core_area = this._core_area[unit_id]
        const core_content = this._core_content[unit_id]

        core_area.$element.style.display = 'none'

        this._enable_core_text_selection(unit_id)

        this._listen_sub_component_escape(unit_id)
      }

      this._unlock_node(unit_id)
    }
  }

  private _on_control_lock = () => {
    // console.log('Graph', '_on_control_lock', this._id)

    if (!this._temp_control_lock) {
      if (!this._temp_control_unlock) {
        if (!this._focused) {
          this._unlock_control(false)
        }
      }
    }
  }

  private _unlock_control = (hide: boolean = true): void => {
    const { animate } = this._config()

    if (this._control_lock) {
      // console.log('Graph', '_unlock_control', this._id)

      this._control_lock = false

      this._disable_input()

      if (!this._focusing_sub_component && hide) {
        this._hide_control(animate)
      }
    }
  }

  private _control_lock_unlisten: Unlisten

  private _enable_control_lock = () => {
    if (this._control) {
      this._control_lock_unlisten = this._control.addEventListeners([
        makeCustomListener('lock', this._on_control_lock),
        makeCustomListener('temp_lock', this._on_control_temp_lock),
        makeCustomListener('temp_unlock', this._on_control_temp_unlock),
      ])
    }
  }

  private _disable_control_lock = (): void => {
    if (this._control_lock_unlisten) {
      this._control_lock_unlisten()
      this._control_lock_unlisten = undefined
    }
  }

  private _on_control_temp_lock = (): void => {
    if (!this._disabled && !this._is_fullwindow) {
      if (!this._temp_control_lock) {
        if (!this._temp_control_unlock) {
          // console.log('Graph', '_on_control_temp_lock', this._id)

          this._temp_control_unlock = true

          this._unlock_control(false)
        }
      }
    }
  }

  private _on_control_temp_unlock = (): void => {
    if (!this._is_fullwindow) {
      if (!this._temp_control_lock) {
        if (this._temp_control_unlock) {
          // console.log('Graph', '_on_control_temp_unlock', this._id)

          this._lock_control()

          this._temp_control_unlock = false

          this.focus()
        }
      }
    }
  }

  private _lock_sub_component = (
    unit_id: string,
    unlocking: boolean = false
  ) => {
    // console.log('Graph', '_lock_sub_component', unit_id, unlocking)

    const { animate } = this._config()

    delete this._core_component_unlocked[unit_id]

    this._core_component_unlocked_count--

    this._disable_core_frame(unit_id)

    if (this._core_component_unlocked_count === 0) {
      if (!unlocking) {
        this._enable_input()
        this._enable_transcend()

        this._show_control(animate)
        this._show_transcend(animate)
      }
    }

    this._unlisten_sub_component_escape()

    const core_area = this._core_area[unit_id]

    core_area.$element.style.display = 'block'

    this._show_core_overlay(unit_id)

    if (this._is_node_selected(unit_id)) {
      //
    } else {
      this._disable_core_resize(unit_id)
    }

    this._lock_node(unit_id)

    this._refresh_selection_color(unit_id)
    this._refresh_selection_dasharray(unit_id)
    this._refresh_selection_dashoffset(unit_id)

    this._disable_core_text_selection(unit_id)
  }

  private _lock_all_component = (): void => {
    for (const component_id in this._core_component_unlocked) {
      this._lock_sub_component(component_id)
    }
  }

  private _lock_all_component_but = (component_id: string): void => {
    for (const c_id in this._core_component_unlocked) {
      if (c_id !== component_id) {
        this._lock_sub_component(c_id)
      }
    }
  }

  private _disable_all_component_resize_but = (component_id: string): void => {
    for (const c_id in this._core_component_unlocked) {
      if (c_id !== component_id) {
        this._disable_core_resize(c_id)
      }
    }
  }

  private _set_node_selected = (node_id: string, selected: boolean) => {
    const was_selected = this._selected_node_id[node_id]
    if (was_selected && !selected) {
      this.deselect_node(node_id)
    } else if (!was_selected && selected) {
      this._select_node(node_id)
    }
  }

  private _is_node_id = (node_id: string): boolean => {
    return this._is_pin_node_id(node_id) || this._is_unit_node_id(node_id)
  }

  private _is_unit_node_id = (node_id: string): boolean => {
    return this._node_type[node_id] === 'u'
  }

  private _is_pin_node_id = (node_id: string): boolean => {
    return this._is_link_pin_node_id(node_id) || this._is_merge_node_id(node_id)
  }

  private _is_link_pin_node_id = (node_id: string): boolean => {
    return this._node_type[node_id] === 'p'
  }

  private _is_link_input_node_id = (node_id: string): boolean => {
    return this._is_link_pin_node_id(node_id) && isInputPinNodeId(node_id)
  }

  private _is_link_output_node_id = (node_id: string): boolean => {
    return this._is_link_pin_node_id(node_id) && isOutputPinId(node_id)
  }

  private _is_input_pin_node_id = (node_id: string): boolean => {
    return (
      this._is_link_input_node_id(node_id) ||
      (this._is_merge_node_id(node_id) && this._is_input_only_merge(node_id))
    )
  }

  private _is_output_pin_node_id = (node_id: string): boolean => {
    return (
      this._is_link_output_node_id(node_id) ||
      (this._is_merge_node_id(node_id) && this._is_output_only_merge(node_id))
    )
  }

  private _is_node_selected = (node_id: string): boolean => {
    return !!this._selected_node_id[node_id]
  }

  private _is_node_hovered = (node_id: string): boolean => {
    return !!this._hover_node_id[node_id]
  }

  private _is_node_dragged = (node_id: string): boolean => {
    return !!this._drag_node_id[node_id] || !!this._drag_along_source[node_id]
  }

  private _is_node_ascend = (node_id: string): boolean => {
    return !!this._ascend_node_dict[node_id]
  }

  private _is_merge_node_id = (node_id: string): boolean => {
    return this._node_type[node_id] === 'm'
  }

  private _is_datum_node_id = (node_id: string): boolean => {
    return this._node_type[node_id] === 'd'
  }

  private _is_type_node_id = (node_id: string): boolean => {
    return this._node_type[node_id] === 't'
  }

  private _is_err_node_id = (node_id: string): boolean => {
    return this._node_type[node_id] === 'x'
  }

  private _is_ext_node_id = (node_id: string): boolean => {
    return this._node_type[node_id] === 'e'
  }

  private _is_int_node_id = (node_id: string): boolean => {
    return this._node_type[node_id] === 'i' || isInternalNodeId(node_id)
  }

  private _is_plug_node_id = (node_id: string): boolean => {
    return this._is_ext_node_id(node_id) || this._is_int_node_id(node_id)
  }

  private _is_exposed_input_node_id = (node_id: string): boolean => {
    return (
      this._is_plug_node_id(node_id) &&
      segmentPlugNodeId(node_id).type === 'input'
    )
  }

  private _get_pin_datum_node_id = (
    pin_node_id: string
  ): string | undefined => {
    if (this._is_link_pin_node_id(pin_node_id)) {
      return this._pin_to_datum[pin_node_id]
    } else {
      return this._get_merge_datum_node_id(pin_node_id)
    }
  }

  private _get_merge_datum_node_id = (
    merge_node_id: string
  ): string | undefined => {
    const merge_datum_node_id = this._pin_to_datum[merge_node_id]
    if (merge_datum_node_id) {
      return merge_datum_node_id
    } else {
      return this._get_merge_first_datum_node_id(merge_node_id)
    }
  }

  private _get_merge_first_datum_node_id = (
    merge_node_id: string
  ): string | undefined => {
    return (
      this._get_merge_first_input_datum_node_id(merge_node_id) ||
      this._get_merge_first_output_datum_node_id(merge_node_id)
    )
  }

  private _get_merge_first_type_datum_node_id = (
    merge_node_id: string,
    type: IO
  ): string | undefined => {
    return type === 'input'
      ? this._get_merge_first_input_datum_node_id(merge_node_id)
      : this._get_merge_first_output_datum_node_id(merge_node_id)
  }

  private _get_merge_first_input_datum_node_id = (
    merge_node_id: string
  ): string | undefined => {
    // TODO `find key`
    const merge_to_input = this._merge_to_input[merge_node_id]
    for (const merge_pin_node_id in merge_to_input) {
      const merge_pin_datum_node_id = this._pin_to_datum[merge_pin_node_id]
      if (merge_pin_datum_node_id) {
        return merge_pin_datum_node_id
      }
    }
    return undefined
  }

  private _get_merge_first_output_datum_node_id = (
    merge_node_id: string
  ): string | undefined => {
    // TODO `find key`
    const merge_to_output = this._merge_to_output[merge_node_id]
    for (const merge_pin_node_id in merge_to_output) {
      const merge_pin_datum_node_id = this._pin_to_datum[merge_pin_node_id]
      if (merge_pin_datum_node_id) {
        return merge_pin_datum_node_id
      }
    }
    return undefined
  }

  public select_node = (node_id: string) => {
    // console.log('Graph', 'select_node', node_id)

    this._select_node(node_id)
  }

  private _select_node = (node_id: string): void => {
    // console.log('Graph', '_select_node', node_id)

    const { config } = this.$props

    if (this._selected_node_id[node_id]) {
      return
    }

    if (this._is_datum_node_id(node_id)) {
      if (!config?.dataSelect) {
        return
      }
    }

    this._selected_node_count++
    this._selected_node_id[node_id] = true

    if (this._is_unit_node_id(node_id)) {
      if (this._is_unit_component(node_id)) {
        this._selected_component_count++

        this._selected_component[node_id] = true

        if (this._mode === 'none') {
          this._enable_core_resize(node_id)
          this._disable_core_touch_area(node_id)
        }
      }
    } else if (this._is_link_pin_node_id(node_id)) {
      this._selected_pin_count++
    } else if (this._is_datum_node_id(node_id)) {
      if (this._mode === 'multiselect') {
        //
      } else if (this._mode === 'none') {
        if (this._selected_node_count === 1) {
          // const datum_anchor_node_id =
          //   this._get_datum_pin_anchor_node_id(node_id)
          // if (
          //   !datum_anchor_node_id ||
          //   !this._is_output_node_id(datum_anchor_node_id)
          // ) {
          //   this._disable_datum_overlay(node_id)
          // }
        }
      } else {
        //
      }
    } else if (this._is_merge_node_id(node_id)) {
      this._selected_pin_count++
    } else if (this._is_ext_node_id(node_id)) {
      // if (this._mode === 'info') {
      //   this._enable_plug_name(node_id)
      // }
    } else if (this._is_int_node_id(node_id)) {
      // if (this._mode === 'info') {
      //   const ext_node_id = getExtNodeIdFromIntNodeId(node_id)
      //   this._enable_plug_name(ext_node_id)
      // }
    } else if (this._is_err_node_id(node_id)) {
      this._hide_err_overlay(node_id)
    }

    if (this._has_node(node_id)) {
      this._refresh_node_selection(node_id)
      this._refresh_node_color(node_id)
      this._refresh_compatible()
    }

    if (this._mode === 'info') {
      if (this._hover_node_count === 0) {
        if (this._selected_node_count === 1) {
          this._set_all_nodes_links_opacity(0.2)
        }
        this._show_node_info(node_id)
      }
    }

    this._refresh_all_visible_datum()
    this._refresh_all_selected_pin_datum_visible()
  }

  private _refresh_all_selected_pin_datum_visible = () => {
    for (const selected_node_id in this._selected_node_id) {
      if (this._is_pin_node_id(selected_node_id)) {
        this._refresh_pin_datum_visible(selected_node_id)
        const datum_node_id = this._get_pin_datum_node_id(selected_node_id)

        if (datum_node_id) {
          this._refresh_datum_visible(datum_node_id)
        }
      }
    }
  }

  private _enable_core_frame = (unit_id: string) => {
    // console.log('Graph', '_enable_core_frame', unit_id)

    const frame = this._core_component_frame[unit_id]
    frame.setProp('disabled', false)
  }

  private _disable_core_frame = (unit_id: string) => {
    // console.log('Graph', '_disable_core_frame', unit_id)

    const frame = this._core_component_frame[unit_id]

    frame.setProp('disabled', true)
  }

  private _enable_core_resize = (unit_id: string): void => {
    // console.log('Graph', '_enable_core_resize', unit_id)

    const core_resize = this._core_component_resize[unit_id]
    if (core_resize) {
      core_resize.setProp('disabled', false)
    }
  }

  private _disable_core_resize = (unit_id: string): void => {
    // console.log('Graph', '_disable_core_resize')

    const core_resize = this._core_component_resize[unit_id]
    if (core_resize) {
      core_resize.setProp('disabled', true)
    }
  }

  private _enable_core_name = (unit_id: string): void => {
    // console.log('Graph', '_enable_core_name', unit_id)

    const core_name = this._core_name[unit_id]

    core_name.$element.style.pointerEvents = 'inherit'
    core_name.$element.style.userSelect = 'inherit'

    this._enable_core_text_selection(unit_id)
  }

  private _disable_core_name = (unit_id: string): void => {
    // console.log('Graph', '_disable_core_name', unit_id)

    const core_name = this._core_name[unit_id]

    core_name.$element.style.pointerEvents = 'none'
    core_name.$element.style.userSelect = 'none'

    this._disable_core_text_selection(unit_id)
  }

  private _set_plug_name_style_attr = (
    ext_node_id: string,
    attr: string,
    value: string
  ): void => {
    // console.log('Graph', '_set_plug_name_style_attr', ext_node_id, attr, value)

    const plug_name = this._ext_pin_name[ext_node_id]

    plug_name.$element.style[attr] = value
  }

  private _sim_set_plug_datum = (
    type: IO,
    pinId: string,
    subPinId: string,
    data: string,
    position?: Position
  ): void => {
    // console.log('Graph', '_sim_set_plug_datum', type, pinId, subPinId, data)

    const ext_node_id = getExtNodeId(type, pinId, subPinId)

    const current_datum_node_id = this._plug_to_datum[ext_node_id]

    if (current_datum_node_id) {
      const { datumId } = segmentDatumNodeId(current_datum_node_id)

      this._sim_set_datum_value(
        datumId,
        current_datum_node_id,
        ext_node_id,
        data
      )
    } else {
      this._sim_add_plug_datum(type, pinId, subPinId, data, position)
    }
  }

  private _sim_add_plug_datum = (
    type: IO,
    pinId: string,
    subPinId: string,
    data: string,
    position?: Position
  ): void => {
    // console.log('Graph', '_sim_add_plug_datum', type, pinId, subPinId, data)

    const datum_id = this._new_datum_id()

    const ext_node_id = getExtNodeId(type, pinId, subPinId)

    const u = this._plug_line_vector(ext_node_id)

    const ext_position = this._get_node_position(ext_node_id)

    position =
      position ?? addVector(ext_position, resizeVector(u, LINK_DISTANCE_DATA))

    const datum_node_id = getDatumNodeId(datum_id)

    this._sim_add_datum_node(datum_id, data, position)
    this._sim_add_plug_datum_link(ext_node_id, datum_node_id)

    const pin_node_id = this._ext_to_node[ext_node_id]

    if (pin_node_id) {
      this._refresh_pin_datum_visible(pin_node_id)
    }
  }

  private _sim_add_plug_datum_link = (
    ext_node_id: string,
    datum_node_id: string
  ): void => {
    // console.log('Graph', '_sim_add_plug_datum_link', ext_node_id, datum_node_id)

    this._datum_to_plug[datum_node_id] = ext_node_id
    this._plug_to_datum[ext_node_id] = datum_node_id

    this._sim_add_datum_node_link(datum_node_id, ext_node_id, false)
  }

  private __sim_add_plug_datum_link = (
    type: IO,
    pinId: string,
    subPinId: string,
    datum_node_id: string
  ): void => {
    const ext_node_id = getExtNodeId(type, pinId, subPinId)

    this._sim_add_plug_datum_link(ext_node_id, datum_node_id)
  }

  private _sim_remove_plug_datum = (
    type: IO,
    pin_id: string,
    sub_pin_id: string
  ): void => {
    // console.log('Graph', '_sim_remove_plug_datum', type, pin_id, sub_pin_id)

    const plug_node_id = getExtNodeId(type, pin_id, sub_pin_id)

    const datum_node_id = this._plug_to_datum[plug_node_id]

    this._sim_remove_plug_datum_link(type, pin_id, sub_pin_id)
    this._sim_remove_datum(datum_node_id)
  }

  private _sim_remove_plug_datum_link = (
    type: IO,
    pinId: string,
    subPinId: string
  ): void => {
    // console.log('Graph', '_sim_remove_datum_plug_link', type, pinId, subPinId)

    const ext_node_id = getExtNodeId(type, pinId, subPinId)

    const datum_node_id = this._plug_to_datum[ext_node_id]

    this._mem_remove_plug_datum_link(datum_node_id, ext_node_id)
    this._sim_remove_datum_link(datum_node_id, ext_node_id)
  }

  private _mem_remove_plug_datum_link = (
    datum_node_id: string,
    ext_node_id: string
  ): void => {
    // console.log('Graph', '_sim_remove_datum_plug_link', type, pinId, subPinId)

    delete this._datum_to_plug[datum_node_id]
    delete this._plug_to_datum[ext_node_id]
  }

  private _pod_remove_exposed_pin_datum = (type: IO, pinId: string) => {
    // console.log('Graph', '_pod_remove_exposed_pin_datum', type, pinId)

    this._pod_remove_exposed_pin_datum__template(type, pinId, {
      removePinData: this._pod.$removePinData.bind(this._pod),
    })
  }

  private _pod_remove_exposed_pin_datum__template = (
    type: IO,
    pinId: string,
    { removePinData }: { removePinData(data: UnitRemovePinDataData) }
  ) => {
    // console.log('Graph', '_pod_remove_exposed_pin_datum__template', type, pinId)

    removePinData({ type, pinId })
  }

  private _enable_plug_name = (ext_node_id: string): void => {
    // console.log('Graph', '_enable_plug_name', ext_node_id)

    this._set_plug_name_style_attr(ext_node_id, 'pointerEvents', 'inherit')
  }

  private _enable_pin_name = (pin_node_id: string): void => {
    // console.log('Graph', '_enable_pin_name', pin_node_id)

    this._set_pin_name_style_attr(pin_node_id, 'pointerEvents', 'inherit')
  }

  private _disable_pin_name = (pin_node_id: string): void => {
    // console.log('Graph', '_disable_pin_name', pin_node_id)

    this._set_pin_name_style_attr(pin_node_id, 'pointerEvents', 'none')
  }

  private _set_pin_name_style_attr = (
    pin_node_id: string,
    name: string,
    value: string
  ): void => {
    // console.log('Graph', '_set_pin_name_style_attr', pin_node_id, name, value)

    const text_comp = this._pin_name[pin_node_id]

    text_comp.$element.style[name] = value
  }

  private _disable_plug_name = (ext_node_id: string): void => {
    // console.log('Graph', '_disable_plug_name', ext_node_id)

    this._set_plug_name_style_attr(ext_node_id, 'pointerEvents', 'none')
  }

  private _enable_core_touch_area = (unit_id: string): void => {
    // console.log('Graph', '_enable_core_touch_area')

    const core_area = this._core_area[unit_id]

    core_area.$element.style.pointerEvents = 'inherit'
  }

  private _disable_core_touch_area = (unit_id: string): void => {
    // console.log('Graph', '_disable_core_touch_area')

    const core_area = this._core_area[unit_id]

    core_area.$element.style.pointerEvents = 'none'
  }

  private __deselect_node = (node_id: string): void => {
    // console.log('Graph', '__deselect_node', node_id)

    const pressed_node_id_pointer_id = this._pressed_node_id_pointer_id[node_id]

    for (const pointer_id in pressed_node_id_pointer_id) {
      for (let selected_node_id in this._selected_node_id) {
        if (selected_node_id !== node_id) {
          if ((this._node_pressed_count[selected_node_id] || 0) === 0) {
            if (!this._collapse_node_id.has(selected_node_id)) {
              if (
                this._drag_node_pointer_id[selected_node_id] ===
                Number.parseInt(pointer_id)
              ) {
                this._on_node_drag_end_and_drop(
                  selected_node_id,
                  Number.parseInt(pointer_id, 10),
                  true
                )
              }
            }
          }
        }
      }
    }

    this._selected_node_count--

    delete this._selected_node_id[node_id]

    if (this._is_pin_node_id(node_id)) {
      this._selected_pin_count--
    }

    if (this._is_unit_node_id(node_id)) {
      if (this._is_unit_component(node_id)) {
        this._selected_component_count--

        delete this._selected_component[node_id]

        this._disable_core_resize(node_id)
        this._enable_core_touch_area(node_id)
      }
    } else if (this._is_link_pin_node_id(node_id)) {
      //
    } else if (this._is_merge_node_id(node_id)) {
      const merge_datum_node_id = this._get_merge_datum_node_id(node_id)

      if (merge_datum_node_id) {
        this._refresh_datum_visible(merge_datum_node_id)
      }
    } else if (this._is_datum_node_id(node_id)) {
      this._refresh_datum_visible(node_id)
    } else if (this._is_err_node_id(node_id)) {
      this._show_err_overlay(node_id)
    }

    this._refresh_compatible()

    this._refresh_all_selected_pin_datum_visible()
  }

  public deselect_node = (node_id: string): void => {
    // console.log('Graph', 'deselect_node', node_id)

    this._deselect_node(node_id)
  }

  public _deselect_node = (node_id: string): void => {
    // console.log('Graph', '_deselect_node', node_id)

    if (!this._selected_node_id[node_id]) {
      return
    }

    this.__deselect_node(node_id)

    const has_node = this._has_node(node_id)

    if (has_node) {
      this._refresh_node_selection(node_id)
      this._refresh_node_color(node_id)
    }

    if (this._mode === 'info') {
      if (this._hover_node_count === 0) {
        if (has_node) {
          this._hide_node_info(node_id)
        }

        if (this._selected_node_count === 0) {
          this._set_all_nodes_links_opacity(1)
        }
      }
    }

    this._refresh_all_invisible_datum()
  }

  private _toggle_select = (node_id: string): void => {
    if (this._is_node_selected(node_id)) {
      this.deselect_node(node_id)
    } else {
      this._select_node(node_id)
    }
  }

  private _select_all = (): void => {
    // console.log('Graph', '_select_all')
    const nodes_ids = keys(this._node)

    this._select_many(nodes_ids)
  }

  private _select_many = (node_ids: string[]): void => {
    // console.log('Graph', '_select_many', node_ids)

    for (const node_id of node_ids) {
      this._select_node(node_id)
    }
  }

  private _toggle_select_all_visible = (): void => {
    // console.log('Graph', '_toggle_select_all_visible')

    let visible_node_ids = []

    for (const node_id in this._node) {
      if (this._is_node_visible(node_id)) {
        visible_node_ids.push(node_id)
      }
    }

    for (const node_id of visible_node_ids) {
      this._toggle_select(node_id)
    }
  }

  private _deselect_all = (): void => {
    forEachValueKey(this._selected_node_id, (_, node_id) => {
      this.deselect_node(node_id)
    })
  }

  private _deselect_all_but = (node_id: string) => {
    forEachValueKey(this._selected_node_id, (_, n_id) => {
      if (n_id !== node_id) {
        this.deselect_node(n_id)
      }
    })
  }

  private _enable_node_overlay = (node_id: string): void => {}

  private _enable_datum_overlay = (datum_node_id: string): void => {
    // console.log('Graph', '_enable_datum_overlay', datum_node_id)

    const datum_overlay = this._datum_overlay[datum_node_id]

    datum_overlay.$element.style.display = 'block'
  }

  private _disable_node_overlay = (node_id: string): void => {
    // TODO
  }

  private _disable_datum_overlay = (datum_node_id: string): void => {
    // console.log('Graph', '_disable_datum_overlay', datum_node_id)

    const datum_overlay = this._datum_overlay[datum_node_id]

    datum_overlay.$element.style.display = 'none'
  }

  private _disable_all_datum_overlay = (): void => {
    for (const datum_node_id in this._data_node) {
      this._disable_datum_overlay(datum_node_id)
    }
  }

  private _disable_all_selected_datum_overlay = (): void => {
    for (const datum_node_id in this._data_node) {
      if (this._is_node_selected(datum_node_id)) {
        this._disable_datum_overlay(datum_node_id)
      }
    }
  }

  private _enable_all_selected_datum_overlay = (): void => {
    for (const datum_node_id in this._data_node) {
      if (this._is_node_selected(datum_node_id)) {
        this._enable_datum_overlay(datum_node_id)
      }
    }
  }

  private _hide_control = (animate: boolean): void => {
    // console.log('Graph', '_hide_control', animate, this._id)

    if (this._force_control_animation_false) {
      this._force_control_animation_false = false

      animate = false
    }

    if (this._control) {
      this._control.hide(animate)
    }
  }

  private _show_control = (animate: boolean): void => {
    // console.log('Graph', '_show_control', animate, this._id)

    if (this._control) {
      if (this._force_control_animation_false) {
        this._force_control_animation_false = false

        animate = false
      }

      this._control.show(animate)
    }
  }

  private _force_control_animation_false: boolean = false
  private _force_trasncend_animation_false: boolean = false

  private _set_fullwindow_frame_off = (animate: boolean): void => {
    // console.log('Graph', '_set_fullwindow_frame_off')

    this._unclear_main(animate)
  }

  private _clear_component = (
    component: Component<any>,
    animate: boolean
  ): void => {
    // console.log('Graph', '_clear_component', component, animate)

    if (animate) {
      component.$element.style.transition = linearTransition('opacity')
    } else {
      component.$element.style.transition = ''
    }

    component.$element.style.opacity = `${LAYER_OPACITY_MULTIPLIER}`
  }

  private _clear_main = (animate: boolean): void => {
    // console.log('Graph', '_clear_main')

    this._clear_component(this._main, animate)
  }

  private _unclear_component = (
    component: Component<any>,
    animate: boolean
  ): void => {
    // console.log('Graph', '_unclear_component')

    if (animate) {
      component.$element.style.transition = linearTransition('opacity')
    } else {
      component.$element.style.transition = ''
    }
    component.$element.style.opacity = '1'
  }

  private _unclear_main = (animate: boolean): void => {
    // console.log('Graph', '_unclear_main')

    this._unclear_component(this._main, animate)
  }

  private _unclear_foreground = (animate: boolean): void => {
    // console.log('Graph', '_unclear_foreground')

    this._unclear_component(this._foreground, animate)
  }

  private _clear_foreground = (animate: boolean): void => {
    // console.log('Graph', '_clear_foreground')

    this._clear_component(this._foreground, animate)
  }

  private _set_fullwindow_frame_on = (animate: boolean): void => {
    // console.log('Graph', '_set_fullwindow_frame_on')

    this._clear_main(animate)
  }

  private _fullwindow_focusing: boolean = false

  private _unlisten_fullwindow_escape: Unlisten

  private _enter_fullwindow = (
    _animate: boolean,
    sub_component_ids: string[],
    hide: boolean = true
  ) => {
    // console.log('Graph', '_enter_fullwindow', _animate, sub_component_ids, this._id)

    const { container, enterFullwindow } = this.$props

    const { animate } = this._config()

    enterFullwindow()

    _animate = _animate ?? animate

    this._is_fullwindow = true

    if (!this._frame_out) {
      if (!this._disabled) {
        this._disable_input()

        if (hide) {
          this._hide_control(_animate)
        }
      }
    }

    const ordered_sub_component_ids =
      this._order_sub_component_ids(sub_component_ids)

    this._fullwindow_component_set = new Set(ordered_sub_component_ids)
    this._fullwindow_component_ids = ordered_sub_component_ids

    this._cancel_all_layout_parent_children_animation()
    this._cancel_all_layout_sub_component_animation()
    this._cancel_fullwindow_animation()

    if (!this._disabled) {
      if (this._transcend) {
        this._transcend.down(_animate)
      }
    }

    if (!this._frame_out) {
      container.focus()

      this._unlisten_fullwindow_escape = addListener(
        container,
        makeKeydownListener((event) => {
          const { key } = event

          if (key === 'Escape') {
            this._leave_all_fullwindow(_animate)
          }
        })
      )
    }

    const was_focused = this._focused

    if (this._in_component_control) {
      if (!this._is_component_framed) {
        this._enter_component_frame()
      }

      if (ordered_sub_component_ids.length > 0) {
        if (_animate) {
          const last_sub_component_id = last(ordered_sub_component_ids)

          const last_sub_component = this._get_sub_component(
            last_sub_component_id
          )

          last_sub_component.focus()

          this._abort_fullwindow_animation = this._animate_enter_fullwindow(
            this._fullwindow_component_ids,
            () => {
              for (const sub_component_id of this._fullwindow_component_ids) {
                this._unplug_sub_component_root_base_frame(sub_component_id)

                this._append_sub_component_all_missing_root(sub_component_id)
                this._append_sub_component_base(sub_component_id)
              }

              for (const sub_component_id of this._fullwindow_component_ids) {
                const parent_id =
                  this._spec_get_sub_component_parent_id(sub_component_id)

                if (!parent_id) {
                  this._couple_sub_component(sub_component_id)
                } else {
                  if (this._fullwindow_component_ids.includes(parent_id)) {
                    this._couple_sub_component(sub_component_id)
                  } else {
                    this._append_sub_component_to_root(sub_component_id)
                  }
                }

                if (last_sub_component_id === sub_component_id) {
                  const is_last_sub_component =
                    sub_component_id === last_sub_component_id

                  if (is_last_sub_component) {
                    if (this._enabled()) {
                      this._frame.focus()

                      last_sub_component.focus()
                    }
                  }
                }
              }
            }
          )
        } else {
          if (this._tree_layout) {
            for (const sub_component_id of sub_component_ids) {
              const parent_id =
                this._spec_get_sub_component_parent_id(sub_component_id)

              if (parent_id) {
                //
              } else {
                this._leave_sub_component_frame(sub_component_id)
              }
            }
          } else {
            for (const sub_component_id of sub_component_ids) {
              this._leave_sub_component_frame(sub_component_id)
            }
          }

          this._couple_all_fullwindow_component()
        }
      }

      const last_sub_component_id = last(sub_component_ids)

      if (was_focused) {
        this._fullwindow_focusing = true

        this._focus_sub_component(last_sub_component_id)

        this._fullwindow_focusing = true
      }
    }

    if (!this._frame_out) {
      this._set_fullwindow_frame_on(_animate)
    }

    this.dispatchEvent('enter_fullwindow', {}, false)
  }

  private _fullwindow_datum_id: string | null = null

  private _enter_datum_fullwindow = (datum_id: string): void => {
    this._fullwindow_datum_id = datum_id
    // TODO
  }

  private _leave_datum_fullwindow = (datum_id: string): void => {
    this._fullwindow_datum_id = null
    // TODO
  }

  private _get_node_selection_color = (node_id: string): string => {
    const selected = this._selected_node_id[node_id]
    const hovered = this._hover_node_pointer_count[node_id] > 0
    const pressed = this._node_pressed_count[node_id] > 0
    const compatible = this._compatible_node_id[node_id]
    const unlocked = this._unlocked_node.has(node_id)
    if (compatible) {
      return COLOR_GREEN
    } else if (selected) {
      return this._theme.selected
    } else if (unlocked) {
      return this._theme.selected
    } else if (hovered || pressed) {
      return this._theme.hovered
    }
    return COLOR_NONE
  }

  private _get_node_selection_target_dasharray = (
    node_id: string,
    paddingX: number,
    paddingY: number
  ): string => {
    const circle = (r: number): string => {
      const p = (paddingX + paddingY) / 2

      const l = 2 * Math.PI * (r + p / 2)

      return `${l / 8}`
    }

    const rect = (width: number, height: number): string => {
      const _width = width + paddingX
      const _height = height + paddingY

      return `${_width / 4} ${_width / 2} ${_width / 4 + 0.01} 0 ${
        _height / 4
      } ${_height / 2} ${_height / 4} 0`
    }

    if (this._tree_layout) {
      const layout_node = this.get_layout_node(node_id)

      const { width, height } = layout_node

      return rect(width, height)
    } else {
      const node = this.get_node(node_id)

      const { shape } = node

      if (shape === 'circle') {
        const { r } = node

        return circle(r)
      } else {
        const { width, height } = node

        return rect(width, height)
      }
    }
  }

  private _get_node_selection_dasharray = (
    node_id: string,
    paddingX: number,
    paddingY: number
  ): string => {
    if (this._is_node_unlocked(node_id)) {
      return this._get_node_selection_target_dasharray(
        node_id,
        paddingX,
        paddingY
      )
    }

    return '6'
  }

  private _pin_unit_ids = (pin_node_id: string): Dict<any> => {
    if (this._is_link_pin_node_id(pin_node_id)) {
      const { unitId } = segmentLinkPinNodeId(pin_node_id)
      return { [unitId]: true }
    } else if (this._is_merge_node_id(pin_node_id)) {
      const { mergeId } = segmentMergeNodeId(pin_node_id)
      return this._spec_get_merge(mergeId)
    } else {
      return {}
    }
  }

  private _should_show_hover_merge_data_on_this_mode() {
    // return this._mode === 'none' || this._mode === 'multiselect'
    return true
  }

  private _should_show_selected_merge_data_on_this_mode() {
    // return this._mode === 'none' || this._mode === 'multiselect'
    return true
  }

  private _should_edge_drag_on_this_mode() {
    return this._mode === 'none' || this._mode === 'multiselect'
  }

  private _should_hide_merge_datum = (
    datum_node_id: string,
    merge_node_id: string
  ): boolean | undefined => {
    const merge_first_datum_node_id =
      this._get_merge_datum_node_id(merge_node_id)

    if (merge_first_datum_node_id) {
      if (datum_node_id === merge_first_datum_node_id) {
        if (
          this._is_node_hovered(merge_node_id) &&
          this._should_show_hover_merge_data_on_this_mode()
        ) {
          return false
        } else if (
          this._is_node_selected(merge_node_id) &&
          this._should_show_selected_merge_data_on_this_mode()
        ) {
          if (!this._multiselect_area_ing) {
            if (this._selected_node_count === this._selected_pin_count) {
              return false
            } else if (
              this._selected_node_count === this._selected_pin_count + 1 &&
              this._selected_component_count === 1
            ) {
              return false
            }
          }
        } else if (this._is_node_hovered(merge_first_datum_node_id)) {
          return true
        }
      }
    }
  }

  private _should_hide_datum = (datum_node_id: string): boolean => {
    if (
      this._is_node_selected(datum_node_id) ||
      this._is_node_hovered(datum_node_id)
    ) {
      return false
    }

    if (this._edit_datum_node_id === datum_node_id) {
      return false
    }

    const pin_node_id = this._datum_to_pin[datum_node_id]

    if (pin_node_id) {
      const input_ext_node_id = this._pin_to_ext['input'][pin_node_id]
      const output_ext_node_id = this._pin_to_ext['output'][pin_node_id]

      if (input_ext_node_id) {
        return true
      }
      if (output_ext_node_id) {
        return true
      }

      if (this._is_link_pin_node_id(pin_node_id)) {
        if (this._spec_is_link_pin_ignored(pin_node_id)) {
          return true
        }

        const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

        if (this._animating_unit_explosion[unitId]) {
          return true
        }

        if (this._is_link_pin_ref(pin_node_id)) {
          if (type === 'output') {
            return true
          } else {
            const tree = this._get_datum_tree(datum_node_id)

            if (
              [
                TreeNodeType.Class,
                TreeNodeType.ClassLiteral,
                TreeNodeType.Unit,
                TreeNodeType.Generic,
              ].includes(tree.type)
            ) {
              //
            } else {
              return true
            }
          }
        }

        if (this._collapsing) {
          const mergeId = findPinMergeId(
            this._collapse_init_spec,
            unitId,
            type,
            pinId
          )

          if (mergeId) {
            const merge_node_id = getMergeNodeId(mergeId)

            if (this._collapse_init_node_id_set.has(merge_node_id)) {
              return true
            }
          }
        }

        const merge_node_id = this._pin_to_merge[pin_node_id]

        if (merge_node_id) {
          if (this._collapse_init_node_id_set.has(merge_node_id)) {
            return true
          }

          const { mergeId } = segmentMergeNodeId(merge_node_id)

          const merge_datum_node_id = this._pin_to_datum[merge_node_id]

          const ext_input_node_id = this._pin_to_ext['input']?.[merge_node_id]
          const ext_output_node_id = this._pin_to_ext['output']?.[merge_node_id]

          if (ext_input_node_id) {
            const ext_input_datum = this._plug_to_datum[ext_input_node_id]

            if (ext_input_datum) {
              return true
            }
          }
          if (ext_output_node_id) {
            const ext_output_datum = this._plug_to_datum[ext_output_node_id]

            if (ext_output_datum) {
              return true
            }
          }

          const input_only_merge = this._merge_output_count[mergeId] === 0

          if (input_only_merge) {
            if (merge_datum_node_id) {
              return true
            } else {
              return false
            }
          }

          const output_only_merge = this._merge_input_count[mergeId] === 0

          if (output_only_merge) {
            return false
          }

          const should_hide_merge_datum = this._should_hide_merge_datum(
            datum_node_id,
            merge_node_id
          )

          if (should_hide_merge_datum !== undefined) {
            return false
          } else if (this._is_node_hovered(pin_node_id)) {
            return false
          }

          return true
        }

        return false
      } else {
        const ext_input_node_id = this._pin_to_ext['input']?.[pin_node_id]
        const ext_output_node_id = this._pin_to_ext['output']?.[pin_node_id]

        if (ext_input_node_id) {
          //
        }

        if (ext_output_node_id) {
          const ext_output_datum_node_id =
            this._plug_to_datum[ext_output_node_id]

          if (ext_output_datum_node_id) {
            return true
          }
        }

        const should_hide_merge_datum = this._should_hide_merge_datum(
          datum_node_id,
          pin_node_id
        )

        if (should_hide_merge_datum !== undefined) {
          return should_hide_merge_datum
        }

        const { mergeId } = segmentMergeNodeId(pin_node_id)

        const input_merge = this._merge_output_count[mergeId] === 0
        const output_merge = this._merge_input_count[mergeId] === 0

        return !input_merge && !output_merge
      }
    } else {
      return false
    }
  }

  private _is_pin_pin_match(a: string, b: string): boolean {
    // console.log('Graph', '_is_pin_pin_match', a, b)

    const { config } = this.$props

    if (a === b) {
      return false
    }

    if (isExternalNodeId(a) || isExternalNodeId(b)) {
      return false
    }

    const firstUnitIds = this._pin_unit_ids(a)
    const secondUnitIds = this._pin_unit_ids(b)

    for (const unitId in firstUnitIds) {
      if (secondUnitIds[unitId]) {
        return false
      }
    }

    const a_link_pin = this._is_link_pin_node_id(a)
    const b_link_pin = this._is_link_pin_node_id(b)

    const a_ref = this._is_pin_node_ref(a)
    const b_ref = this._is_pin_node_ref(b)

    // if (a_ref !== b_ref) {
    //   return false
    // }

    if (a_link_pin && b_link_pin) {
      const { type: a_type } = segmentLinkPinNodeId(a)
      const { type: b_type } = segmentLinkPinNodeId(b)

      if (a_ref && !b_ref) {
        return (
          b_type === 'output' &&
          a_type === 'input' &&
          this._is_link_pin_ref_link_pin_type_match(a, a_type, b, b_type)
        )
      } else if (!a_ref && b_ref) {
        return (
          a_type === 'output' &&
          b_type === 'input' &&
          this._is_pin_pin_type_match(a, a_type, b, b_type)
        )
      } else if (a_ref && b_ref) {
        if (a_type === 'output' && b_type === 'output') {
          return false
        }
      }

      if (!config?.multiInputMerge) {
        if (a_type === 'input' && b_type === 'output') {
          if (this._node_to_ext[a]) {
            return false
          }
        } else if (a_type === 'output' && b_type === 'input') {
          if (this._node_to_ext[b]) {
            return false
          }
        } else if (a_type === 'output' && b_type === 'output') {
          return false
        }
      }

      return this._is_pin_pin_type_match(a, a_type, b, b_type)
    } else if (a_link_pin && !b_link_pin) {
      const { type: a_type } = segmentLinkPinNodeId(a)

      if (!config?.multiInputMerge) {
        const { mergeId } = segmentMergeNodeId(b)

        if (a_type === 'output' && this._merge_output_count[mergeId] > 0) {
          return false
        }
      }

      if (this._spec_is_empty_merge(b)) {
        return false
      }

      if (this._is_input_only_merge(b)) {
        return this._is_pin_pin_type_match(a, a_type, b, 'input')
      } else if (this._is_output_only_merge(b)) {
        return this._is_pin_pin_type_match(a, a_type, b, 'output')
      } else {
        return (
          a_ref === b_ref &&
          this._is_pin_pin_type_match(a, a_type, b, oppositePinType(a_type))
        )
      }
    } else if (!a_link_pin && b_link_pin) {
      const { type: b_type } = segmentLinkPinNodeId(b)

      if (!config?.multiInputMerge) {
        const { mergeId } = segmentMergeNodeId(a)

        if (b_type === 'output' && this._merge_output_count[mergeId] > 0) {
          return false
        }
      }

      if (this._spec_is_empty_merge(a)) {
        return false
      }

      if (this._is_input_only_merge(a)) {
        return this._is_pin_pin_type_match(a, 'input', b, b_type)
      } else if (this._is_output_only_merge(a)) {
        return this._is_pin_pin_type_match(a, 'output', b, b_type)
      } else {
        return (
          // a_ref === b_ref &&
          this._is_pin_pin_type_match(a, oppositePinType(b_type), b, b_type)
        )
      }
    } else {
      if (this._spec_is_empty_merge(a) || this._spec_is_empty_merge(b)) {
        return false
      }

      const a_input = this._is_input_only_merge(a)
      const b_input = this._is_input_only_merge(b)
      const a_output = this._is_output_only_merge(a)
      const b_output = this._is_output_only_merge(b)

      if (a_ref && b_ref) {
        if (a_input && b_input) {
          return true
        } else if (a_input) {
          return this._is_pin_pin_type_match(a, 'input', b, 'output')
        } else if (b_input) {
          return this._is_pin_pin_type_match(a, 'output', b, 'input')
        } else {
          return false
        }
      } else if (!a_ref && !b_ref) {
        if (a_input && b_input) {
          return this._is_pin_pin_type_match(a, 'input', b, 'input')
        } else if (a_input && b_output) {
          return this._is_pin_pin_type_match(a, 'input', b, 'output')
        } else if (a_output && b_input) {
          return this._is_pin_pin_type_match(a, 'output', b, 'input')
        } else if (a_output && b_output) {
          return this._is_pin_pin_type_match(a, 'output', b, 'output')
        } else if (a_input) {
          return this._is_pin_pin_type_match(a, 'input', b, 'output')
        } else if (b_input) {
          return this._is_pin_pin_type_match(a, 'output', b, 'input')
        } else if (a_output) {
          return this._is_pin_pin_type_match(a, 'output', b, 'input')
        } else if (b_output) {
          return this._is_pin_pin_type_match(a, 'input', b, 'output')
        } else {
          return (
            this._is_pin_pin_type_match(a, 'input', b, 'output') &&
            this._is_pin_pin_type_match(a, 'output', b, 'input')
          )
        }
      } else {
        return false
      }
    }
  }

  private _is_type_pin_match = (pin_node_id: string, type: TreeNode) => {
    const { specs } = this.$props

    const pin_type = this._get_pin_type(pin_node_id)

    return _isTypeMatch__cached(specs, type, pin_type)
  }

  private _is_plug_pin_match = (
    type: IO,
    pin_id: string,
    pin_node_id: string
  ): boolean => {
    const { specs, config } = this.$props

    const { pinId: pin_exposed_id } = this._spec_get_pin_node_plug_spec(
      type,
      pin_node_id
    ) ?? { kind: undefined }

    if (pin_exposed_id === pin_id) {
      return false
    }

    let plugged = false

    const plug_pin_spec = this._get_pin_spec(type, pin_id)

    const { plug = {} } = plug_pin_spec

    for (const sub_pin_id in plug) {
      const sub_pin = plug[sub_pin_id]

      const { unitId, mergeId } = sub_pin

      if (unitId || mergeId) {
        plugged = true

        continue
      }
    }

    if (this._is_link_pin_node_id(pin_node_id)) {
      if (this._spec_is_link_pin_ignored(pin_node_id)) {
        return false
      }

      const { type: _type } = segmentLinkPinNodeId(pin_node_id)

      if (config?.plugReverse || type === _type) {
        const exp_pin_type = this.__get_ext_pin_type(type, pin_id)
        const link_pin_type = this._get_link_pin_type(pin_node_id)

        if (_type === 'input') {
          if (this._is_link_pin_ref(pin_node_id)) {
            if (this._is_unit_datum_type(exp_pin_type)) {
              return true
            } else {
              return _isTypeMatch__cached(specs, exp_pin_type, link_pin_type)
            }
          } else {
            return _isTypeMatch__cached(specs, exp_pin_type, link_pin_type)
          }
        } else {
          return _isTypeMatch__cached(specs, link_pin_type, exp_pin_type)
        }
      }
    } else if (this._is_merge_node_id(pin_node_id)) {
      const merge = this._get_merge(pin_node_id)

      const merge_pin_count = getMergePinCount(merge)

      if (merge_pin_count === 0) {
        const merge_int_node_id = this._pin_to_int[type][pin_node_id]

        if (merge_int_node_id) {
          return false
        }
      }

      // if (
      //   (type === 'input' && !this._is_output_only_merge(pin_node_id)) ||
      //   (type === 'output' && !this._is_input_only_merge(pin_node_id))
      // ) {
      const exp_pin_type = this.__get_ext_pin_type(type, pin_id)
      const merge_pin_type = this._get_merge_pin_type(pin_node_id, type)

      if (type === 'input') {
        if (!config?.multiInputMerge) {
          const { mergeId } = segmentMergeNodeId(pin_node_id)

          if (this._merge_output_count[mergeId] > 0) {
            return false
          }
        }

        return _isTypeMatch__cached(specs, exp_pin_type, merge_pin_type)
      } else {
        return _isTypeMatch__cached(specs, merge_pin_type, exp_pin_type)
      }
      // }
    }

    return false
  }

  private _is_int_int_match = (
    a_int_node_id: string,
    b_int_node_id: string
  ) => {
    const { type: a_type } = segmentInternalNodeId(a_int_node_id)
    const { type: b_type } = segmentInternalNodeId(b_int_node_id)

    if (a_type === 'input' && b_type === 'output') {
      return true
    } else if (a_type === 'output' && b_type === 'input') {
      return true
    }

    return false
  }

  private _get_unit_type = (unit_id: string): TreeNode => {
    const unit_spec = this._get_unit_spec(unit_id)

    const { type: unit_type = '`U`' } = unit_spec

    const unit_type_tree = getTree(unit_type)

    return unit_type_tree
  }

  private _is_ref_pin_unit_match = (
    pin_node_id: string,
    unit_id: string
  ): boolean => {
    // console.log('Graph', '_is_ref_pin_unit_match', pin_node_id, unit_id)

    if (this._is_link_pin_node_id(pin_node_id)) {
      const { type } = segmentLinkPinNodeId(pin_node_id)

      if (type === 'output') {
        return false
      } else {
        if (this._is_pin_unit_connected(pin_node_id, unit_id)) {
          return false
        } else {
          const { type } = segmentLinkPinNodeId(pin_node_id)

          return (
            type === 'input' &&
            this._is_ref_pin_unit_type_match(pin_node_id, unit_id)
          )
        }
      }
    } else {
      if (this._is_pin_unit_connected(pin_node_id, unit_id)) {
        return false
      } else {
        if (this._is_input_only_merge(pin_node_id)) {
          return this._is_ref_pin_unit_type_match(pin_node_id, unit_id)
        }

        return false
      }
    }
  }

  private _is_ref_pin_unit_type_match = (
    pin_node_id: string,
    unit_id: string
  ): boolean => {
    const { specs } = this.$props

    const pin_type_tree = this._get_pin_type(pin_node_id)
    const unit_type_tree = this._get_unit_type(unit_id)

    const is_type_match = _isTypeMatch__cached(
      specs,
      unit_type_tree,
      pin_type_tree
    )

    return is_type_match
  }

  private _is_plug_unit_match = (
    type: IO,
    pin_id: string,
    unit_id: string
  ): boolean => {
    const { specs, config } = this.$props

    if (!config?.plugUnit) {
      return false
    }

    if (type === 'input') {
      const empty = this._is_unit_empty(unit_id)

      if (empty) {
        //
      } else {
        return false
      }
    }

    const exp_pin_type_tree = this.__get_ext_pin_type(type, pin_id)
    const unit_type_tree = this._get_unit_type(unit_id)

    if (unit_type_tree.value === '`U`' || unit_type_tree.value === '`G`') {
      return false
    }

    const is_type_match = _isTypeMatch__cached(
      specs,
      unit_type_tree,
      exp_pin_type_tree
    )

    return is_type_match
  }

  private _runtime_pin_type = (pin_node_id: string, kind: IO) => {
    const { specs } = this.$props

    const pin_datum_node_id = this._pin_to_datum[pin_node_id]

    if (
      pin_datum_node_id &&
      kind === 'output' &&
      !this._is_pin_node_ref(pin_node_id)
    ) {
      const { datumId } = segmentDatumNodeId(pin_datum_node_id)

      const pin_datum_tree = this._datum_tree[datumId]

      return _getValueType(specs, pin_datum_tree)
    } else {
      return this._pin_type_of_kind(pin_node_id, kind)
    }
  }

  private _is_unit_datum_type = (tree: TreeNode) => {
    if (
      [
        TreeNodeType.Class,
        TreeNodeType.ClassLiteral,
        TreeNodeType.Unit,
      ].includes(tree.type)
    ) {
      return true
    } else {
      return false
    }
  }

  private _is_link_pin_ref_link_pin_type_match = (
    a: string,
    a_type: IO,
    b: string,
    b_type: IO
  ): boolean => {
    const target_type = this._runtime_pin_type(b, b_type)

    // if (this._is_unit_datum_type(target_type)) {
    return this._is_pin_pin_type_match(a, a_type, b, b_type)
    // }

    return false
  }

  private _is_ref_link_pin_link_pin_type_match = (
    a: string,
    a_type: IO,
    b: string,
    b_type: IO
  ): boolean => {
    const source_type = this._runtime_pin_type(a, a_type)

    if (this._is_unit_datum_type(source_type)) {
      return this._is_pin_pin_type_match(a, a_type, b, b_type)
    }

    return false
  }

  private _is_pin_pin_type_match = (
    a: string,
    a_type: IO,
    b: string,
    b_type: IO
  ): boolean => {
    // console.log('Graph', '_is_pin_pin_type_match', a, a_type, b, b_type)

    const { specs } = this.$props

    const source_type = this._runtime_pin_type(a, a_type)
    const target_type = this._runtime_pin_type(b, b_type)

    return _pinTypeMatch(specs, source_type, a_type, target_type, b_type)
  }

  private _is_unit_pin_post_match = (
    unit_id: string,
    pin_node_id: string
  ): boolean => {
    const ref = this._is_pin_node_ref(pin_node_id)

    if (ref) {
      if (this._is_link_pin_node_id(pin_node_id)) {
        return this._is_unit_link_post_match(unit_id, pin_node_id)
      } else if (this._is_merge_node_id(pin_node_id)) {
        return this._is_unit_merge_post_match(unit_id, pin_node_id)
      }
    } else {
      return false
    }
  }

  private _is_datum_plug_match = (
    datum_node_id: string,
    ext_node_id: string
  ): boolean => {
    const { type } = segmentPlugNodeId(ext_node_id)

    return this._is_datum_plug_type_match(datum_node_id, ext_node_id)
  }

  private _is_datum_plug_type_match = (
    datum_node_id: string,
    ext_node_id: string
  ): boolean => {
    const { specs } = this.$props

    const datum_type = this._get_datum_type(datum_node_id)
    const plug_type = this._get_plug_type(ext_node_id)

    return _isTypeMatch__cached(specs, datum_type, plug_type)
  }

  private _is_datum_pin_pre_match = (
    datum_node_id: string,
    pin_node_id: string
  ): boolean => {
    const { config } = this.$props

    if (!config?.dataCompatible) {
      return false
    }

    const datum_pin_node_id = this._datum_to_pin[datum_node_id]
    if (datum_pin_node_id) {
      if (
        !this._drag_node_id[datum_node_id] &&
        !this._dropped_node_id.has(datum_node_id)
      ) {
        return false
      }
    }

    if (this._is_pin_node_ref(pin_node_id)) {
      if (!this._is_datum_class_literal(datum_node_id)) {
        return false
      }
    }

    if (isMergeNodeId(pin_node_id) && this._is_output_only_merge(pin_node_id)) {
      return false
    }

    // cannot add data to output
    if (isOutputPinId(pin_node_id)) {
      return false
    }

    if (
      this._is_link_pin_node_id(pin_node_id) &&
      this._spec_is_link_pin_ignored(pin_node_id)
    ) {
      return false
    }

    if (isExternalNodeId(pin_node_id)) {
      return false
    }

    if (!this._is_datum_tree_valid(datum_node_id)) {
      return false
    }

    return this._is_datum_pin_type_match(datum_node_id, pin_node_id)
  }

  private _is_datum_unit_pre_match = (
    datum_node_id: string,
    pin_node_id: string
  ): boolean => {
    if (!this._is_datum_class_literal(datum_node_id)) {
      return false
    }

    return this._is_datum_unit_type_match(datum_node_id, pin_node_id)
  }

  private _is_unit_empty = (unit_id: string) => {
    const unit_spec = this._get_unit_spec(unit_id) as GraphSpec

    const empty = isEmptySpec(unit_spec)

    return empty
  }

  private _is_datum_unit_type_match = (
    datum_node_id: string,
    unit_id: string
  ): boolean => {
    const { specs } = this.$props
    const { classes } = this.$system

    const unit_spec = this._get_unit_spec(unit_id) as GraphSpec

    const empty = this._is_unit_empty(unit_id)

    if (empty) {
      const input_count = keyCount(unit_spec.inputs)
      const output_count = keyCount(unit_spec.outputs)

      const datum_value = this._get_datum_value(datum_node_id)

      const class_spec_id = idFromUnitValue(
        datum_value,
        specs,
        classes,
        _evaluate__cached
      )
      const bundle = evaluateBundleStr(
        datum_value,
        specs,
        classes,
        _evaluate__cached
      )

      const class_spec = weakMerge(specs, bundle.specs ?? {})[class_spec_id]

      const class_input_count = keyCount(class_spec.inputs ?? {})
      const class_output_count = keyCount(class_spec.outputs ?? {})

      if (
        input_count === class_input_count &&
        output_count === class_output_count
      ) {
        return true
      } else {
        return false
      }
    }

    return false
  }

  private _get_datum_type = (datum_node_id: string): TreeNode => {
    const { specs } = this.$props

    const { datumId } = segmentDatumNodeId(datum_node_id)

    const data = this._datum_tree[datumId]

    const [data_] = _filterEmptyNodes(data, getTree__cached)

    const datum_type = getValueType__cached(specs, data_)

    return datum_type
  }

  private _is_datum_pin_type_match = (
    datum_node_id: string,
    pin_node_id: string
  ): boolean => {
    const { specs } = this.$props

    const pin_type = this._pin_type_of_kind(pin_node_id, 'input')
    const datum_type = this._get_datum_tree(datum_node_id)

    return _isTypeMatch__cached(specs, datum_type, pin_type)
  }

  private _get_display_node_id = (): string[] => {
    if (this._drag_count > 0) {
      return keys(this._drag_node_id)
    }

    if (this._unlocked_datum.size > 0) {
      return [...this._unlocked_datum]
    }

    if (this._selected_node_count > 0) {
      return keys(this._selected_node_id)
    }

    return []
  }

  private _is_ext_all_datum_match = (
    ext_node_id: string,
    all_datum_node_id: string[]
  ): boolean => {
    let compatible = true
    for (const datum_node_id of all_datum_node_id) {
      compatible =
        compatible && this._is_datum_plug_match(datum_node_id, ext_node_id)
      if (!compatible) {
        break
      }
    }
    return compatible
  }

  private _is_int_pin_match = (pin_node_id: string, int_node_id: string) => {
    const { type } = segmentPlugNodeId(int_node_id)

    if (this._is_link_pin_node_id(pin_node_id)) {
      return getTypeFromLinkPinNodeId(pin_node_id) === type
    } else if (this._is_merge_node_id(pin_node_id)) {
      if (this._has_input_merge(pin_node_id) && type === 'input') {
        return true
      } else if (this._has_output_merge(pin_node_id) && type === 'output') {
        return true
      }
    }

    return false
  }

  private _is_pin_all_pin_match = (
    pin_node_id: string,
    all_pin_node_id: string[]
  ): boolean => {
    let compatible = true

    for (const _pin_node_id of all_pin_node_id) {
      compatible =
        compatible && this._is_pin_pin_match(_pin_node_id, pin_node_id)
      if (!compatible) {
        break
      }
    }

    return compatible
  }

  private _is_all_pin_plug_match = (
    int_node_id: string,
    all_pin_node_id: string[]
  ): boolean => {
    let compatible = true

    for (const a_pin_node_id of all_pin_node_id) {
      compatible =
        compatible && this._is_int_pin_match(a_pin_node_id, int_node_id)
      if (!compatible) {
        break
      }
    }

    return compatible
  }

  private _is_pin_all_unit_match = (
    pin_node_id: string,
    all_unit_id: string[]
  ): boolean => {
    // console.log('Graph', '_is_pin_all_unit_match', pin_node_id, all_unit_id)

    if (all_unit_id.length > 1) {
      return false
    }

    const [unit_id] = all_unit_id

    return this._is_unit_pin_match(unit_id, pin_node_id)
  }

  private _is_pin_unit_match = (pin_node_id: string, unit_id: string) => {
    return this._is_unit_pin_match(unit_id, pin_node_id)
  }

  private _is_unit_pin_match = (unit_id: string, pin_node_id: string) => {
    if (this._is_unit_pin_pre_match(unit_id, pin_node_id)) {
      if (this._is_ref_pin_unit_type_match(pin_node_id, unit_id)) {
        return true
      }
    }

    return false
  }

  private _is_unit_all_pin_match = (
    unit_id: string,
    all_pin_node_id: string[]
  ): boolean => {
    let compatible = true

    for (const _pin_node_id of all_pin_node_id) {
      compatible = compatible && this._is_unit_pin_match(unit_id, _pin_node_id)

      if (!compatible) {
        break
      }
    }

    return compatible
  }

  private _is_datum_all_pin_pre_match = (
    datum_node_id: string,
    all_pin_node_id: string[]
  ): boolean => {
    let compatible = true
    for (const _pin_node_id of all_pin_node_id) {
      if (this._node_target[_pin_node_id]) {
        compatible = false
      }
      compatible =
        compatible && this._is_datum_pin_pre_match(datum_node_id, _pin_node_id)
      if (!compatible) {
        break
      }
    }
    return compatible
  }

  private _is_pin_all_datum_match = (
    pin_node_id: string,
    all_datum_node_id: string[]
  ): boolean => {
    let compatible = true
    for (const datum_node_id of all_datum_node_id) {
      compatible =
        compatible && this._is_datum_pin_pre_match(datum_node_id, pin_node_id)
      if (!compatible) {
        break
      }
    }
    return compatible
  }

  private _is_all_node = (
    node_ids: string[]
  ): {
    all_pin: boolean
    all_pin_ref: boolean
    all_plug_pin: boolean
    all_ext_pin: boolean
    all_int_pin: boolean
    all_data: boolean
    all_unit: boolean
    all_pin_ref_unit: Dict<boolean>
  } => {
    let all_pin = true
    let all_pin_link = true
    let all_pin_ref = true
    let all_data = true
    let all_pin_ref_unit = {}
    let all_unit = true
    let all_plug_pin = true
    let all_ext_pin = true
    let all_int_pin = true

    for (let node_id of node_ids) {
      all_pin = all_pin && this._is_pin_node_id(node_id)
      all_pin_link =
        all_pin && all_pin_link && this._is_link_pin_node_id(node_id)
      all_pin_ref = all_pin && all_pin_ref && this._is_pin_node_ref(node_id)

      if (all_pin_ref) {
        if (this._is_link_pin_node_id(node_id)) {
          const { unitId } = segmentLinkPinNodeId(node_id)

          all_pin_ref_unit[unitId] = true
        } else {
          const { mergeId } = segmentMergeNodeId(node_id)

          const merge = this._spec_get_merge(mergeId)

          const { keys: merge_units } = _keys({ obj: merge })

          for (const unit_id of merge_units) {
            all_pin_ref_unit[unit_id] = true
          }
        }
      }

      const is_ext_pin = this._is_ext_node_id(node_id)
      const is_int_pin = this._is_int_node_id(node_id)

      all_plug_pin = all_plug_pin && (is_ext_pin || is_int_pin)

      all_data = all_data && this._is_datum_node_id(node_id)
      all_unit = all_unit && this._is_unit_node_id(node_id)
    }

    return {
      all_pin,
      all_pin_ref,
      all_pin_ref_unit,
      all_plug_pin,
      all_ext_pin,
      all_int_pin,
      all_data,
      all_unit,
    }
  }

  private _all_pin: boolean = false
  private _all_pin_ref: boolean = false
  private _all_pin_ref_unit: Dict<boolean> = {}
  private _all_ext_pin: boolean = false
  private _all_data: boolean = false
  private _all_unit: boolean = false

  private _refresh_compatible =
    // debounce(
    (): void => {
      // console.log('Graph', 'refresh_compatible')

      const { config } = this.$props

      if (!config?.highlightCompatible) {
        return
      }

      const prev_compatible_node_id = this._compatible_node_id

      let display_node_id = this._get_display_node_id()

      display_node_id = display_node_id.map(
        (node_id) => this._pin_to_merge[node_id] ?? node_id
      )

      this._compatible_node_id = {}
      this._compatible_node_count = 0

      if (this._mode === 'change') {
        return
      }

      if (display_node_id.length > 0 && this._mode !== 'multiselect') {
        const {
          all_pin,
          all_pin_ref,
          all_pin_ref_unit,
          all_plug_pin,
          all_ext_pin,
          all_int_pin,
          all_data,
          all_unit,
        } = this._is_all_node(display_node_id)

        this._all_pin = all_pin
        this._all_pin_ref = all_pin_ref
        this._all_pin_ref_unit = all_pin_ref_unit
        this._all_ext_pin = all_plug_pin
        this._all_data = all_data
        this._all_unit = all_unit

        if (all_pin) {
          if (all_pin_ref) {
            for (const unit_id in this._unit_node) {
              if (!all_pin_ref_unit[unit_id]) {
                if (this._is_unit_all_pin_match(unit_id, display_node_id)) {
                  this._set_node_compatible(unit_id)
                }
              }
            }
          } else {
            for (const int_node_id in this._exposed_int_unplugged) {
              if (this._is_all_pin_plug_match(int_node_id, display_node_id)) {
                this._set_node_compatible(int_node_id)
              }
            }

            const all_pin_selected = !display_node_id.some(
              (pin_node_id) =>
                !this._is_node_selected(pin_node_id) ||
                this._is_node_dragged(pin_node_id)
            )

            if (all_pin_selected) {
              for (const datum_node_id in this._data_node) {
                if (
                  this._is_datum_all_pin_pre_match(
                    datum_node_id,
                    display_node_id
                  )
                ) {
                  this._set_node_compatible(datum_node_id)
                }
              }
            }
          }

          for (const pin_node_id in this._pin_node) {
            const merge_node_id =
              this._get_pin_merge_node_id(pin_node_id) ?? pin_node_id

            if (
              this._is_pin_all_pin_match(merge_node_id, display_node_id) &&
              this._is_pin_visible(pin_node_id)
            ) {
              this._set_node_compatible(pin_node_id)
            }
          }
        } else if (all_unit) {
          for (const pin_node_id in this._pin_node) {
            if (this._is_input_pin_ref(pin_node_id)) {
              if (this._is_link_pin_node_id(pin_node_id)) {
                const { unitId } = segmentLinkPinNodeId(pin_node_id)

                if (!display_node_id.includes(unitId)) {
                  if (
                    this._is_pin_all_unit_match(pin_node_id, display_node_id)
                  ) {
                    this._set_node_compatible(pin_node_id)
                  }
                }
              } else {
                let compatible = true

                const merge = this._get_merge_by_node_id(pin_node_id)

                for (const unit_id in merge) {
                  if (display_node_id.includes(unit_id)) {
                    compatible = false

                    break
                  }
                }

                if (compatible) {
                  this._set_node_compatible(pin_node_id)
                }
              }
            }
          }
        } else if (all_data) {
          if (config?.dataCompatible) {
            for (const pin_node_id in this._pin_node) {
              if (this._is_pin_all_datum_match(pin_node_id, display_node_id)) {
                this._set_node_compatible(pin_node_id)
              }
            }

            for (const ext_node_id in this._exposed_ext_node) {
              if (this._is_ext_all_datum_match(ext_node_id, display_node_id)) {
                this._set_node_compatible(ext_node_id)
              }
            }

            if (display_node_id.length === 1) {
              const datum_node_id = display_node_id[0]

              for (const unit_id in this._unit_node) {
                if (this._is_datum_unit_pre_match(datum_node_id, unit_id)) {
                  this._set_node_compatible(unit_id)
                }
              }
            }
          }
        } else if (all_plug_pin) {
          const ext_node_id = display_node_id[0]

          const { type, pinId } = segmentPlugNodeId(ext_node_id)
          for (const unit_id in this._unit_node) {
            if (this._is_plug_unit_match(type, pinId, unit_id)) {
              this._set_node_compatible(unit_id)
            }
          }
          for (const pin_node_id in this._pin_node) {
            if (this._is_plug_pin_match(type, pinId, pin_node_id)) {
              this._set_node_compatible(pin_node_id)
            }
          }

          if (all_int_pin) {
            if (display_node_id.length === 1) {
              const only_display_node_id = display_node_id[0]

              for (const int_node_id in this._exposed_int_unplugged) {
                if (this._is_int_int_match(int_node_id, only_display_node_id)) {
                  this._set_node_compatible(int_node_id)
                }
              }
            }
          }
        }
      }

      for (let node_id in prev_compatible_node_id) {
        this._refresh_node_fixed(node_id)
        this._refresh_node_selection(node_id)
      }

      for (let node_id in this._compatible_node_id) {
        this._refresh_node_fixed(node_id)
        this._refresh_node_selection(node_id)
      }
    }
  //   ,
  //   100,
  //   true
  // )

  private _refresh_all_compatible_unit = () => {
    for (let unit_id in this._unit_node) {
      this._refresh_node_fixed(unit_id)
      this._refresh_node_selection(unit_id)
    }
  }

  private _refresh_all_compatible_pin = () => {
    for (let pin_node_id in this._pin_node) {
      this._refresh_node_fixed(pin_node_id)
      this._refresh_node_selection(pin_node_id)
    }
  }

  private _refresh_all_compatible_data = () => {
    for (let datum_node_id in this._datum) {
      this._refresh_node_fixed(datum_node_id)
      this._refresh_node_selection(datum_node_id)
    }
  }

  private _refresh_node_fixed = (node_id: string): void => {
    // console.log('_refresh_node_fixed', node_id)
    let fixed = false
    if (
      this._drag_node_id[node_id] ||
      this._target_node[node_id] ||
      (!this._all_data &&
        this._compatible_node_id[node_id] &&
        (this._is_node_id(node_id) || this._is_int_node_id(node_id)))
    ) {
      fixed = true
    }
    this._set_node_fixed(node_id, fixed)
  }

  private _refresh_unit_fixed = (unit_id: string) => {
    this._refresh_node_fixed(unit_id)
    this._for_each_unit_pin(unit_id, (pin_node_id: string) => {
      const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)
      this._refresh_node_fixed(anchor_node_id)
    })
  }

  private _refresh_unit_layer = (unit_id: string): void => {
    // console.log('Graph', '_refresh_unit_layer', unit_id)

    this._refresh_node_layer(unit_id)

    this._for_each_unit_pin(unit_id, (pin_node_id: string) => {
      // if (
      //   !this._is_link_pin_merged(pin_node_id) ||
      //   (this._is_output_node_id(pin_node_id) &&
      //     this._is_link_pin_ref(pin_node_id))
      // ) {
      if (this._is_link_pin_visible(pin_node_id)) {
        this._refresh_node_layer(pin_node_id)
      }

      const link_id = getPinLinkIdFromPinNodeId(pin_node_id)

      this._refresh_link_layer(link_id)

      const datum_node_id = this._pin_to_datum[pin_node_id]

      if (datum_node_id) {
        this._refresh_node_layer(datum_node_id)
      }
    })
  }

  private _refresh_selection = (): void => {
    // console.log('Graph', '_refresh_selection')
    for (let node_id in this._node) {
      this._refresh_node_selection(node_id)
    }
  }

  private _refresh_node_selection = (node_id: string): void => {
    this._refresh_selection_color(node_id)
    this._refresh_selection_dasharray(node_id)
    this._refresh_selection_dashoffset(node_id)
  }

  private _get_node_default_layer = (node_id: string): number => {
    if (this._collapse_next_unit_id === node_id) {
      return LAYER_NONE
    }

    if (this._is_unit_node_id(node_id)) {
      return LAYER_NORMAL
    } else if (this._is_merge_node_id(node_id)) {
      return LAYER_NORMAL
    } else if (this._is_link_pin_node_id(node_id)) {
      if (this._spec_is_link_pin_ignored(node_id)) {
        return LAYER_IGNORED
      } else {
        return LAYER_NORMAL
      }
    } else if (this._is_plug_node_id(node_id)) {
      return LAYER_EXPOSED
    } else if (this._is_datum_node_id(node_id)) {
      if (this._linked_data_node[node_id]) {
        return LAYER_DATA_LINKED
      } else {
        return LAYER_DATA
      }
    } else if (this._is_err_node_id(node_id)) {
      return LAYER_ERR
    } else if (this._is_type_node_id(node_id)) {
      return LAYER_TYPE
    } else {
      return LAYER_NONE
    }
  }

  private _refresh_node_layer = (node_id: string): void => {
    // console.log('Graph', 'refresh_node_layer', node_id)

    const default_layer = this._get_node_default_layer(node_id)

    this._set_node_layer(node_id, default_layer)
  }

  private _get_link_default_layer = (link_id: string): number => {
    const { source, target } = segmentLinkId(link_id)

    return Math.max(
      this._get_node_default_layer(source),
      this._get_node_default_layer(target)
    )
  }

  private _refresh_link_layer = (link_id: string): void => {
    // console.log('Graph', '_refresh_link_layer', link_id)

    const default_layer = this._get_link_default_layer(link_id)

    this._set_link_layer(link_id, default_layer)
  }

  private _refresh_selection_color = (node_id: string): void => {
    // console.log('Graph', '_refresh_selection_color', node_id)

    const selection = this._node_selection[node_id]

    const stroke = this._get_node_selection_color(node_id)

    selection.setProp('stroke', stroke)
  }

  private _refresh_selection_dasharray = (node_id: string): void => {
    // console.log('Graph', '_refresh_selection_dasharray')

    const { paddingX, paddingY } = this._get_selection_opt(node_id)

    const selection_stroke_dasharray = this._get_node_selection_dasharray(
      node_id,
      paddingX,
      paddingY
    )

    this._set_selection_dasharray(node_id, selection_stroke_dasharray)
  }

  private _get_selection_opt = (node_id: string): SelectionOpt => {
    const selection_opt = this._selection_opt[node_id]

    return {
      paddingX: DEFAULT_SELECTION_PADDING,
      paddingY: DEFAULT_SELECTION_PADDING,
      strokeWidth: 1,
      ...selection_opt,
    }
  }

  private _refresh_selection_dashoffset = (node_id: string): void => {
    const { paddingX, paddingY } = this._get_selection_opt(node_id)

    const selection_stroke_dashoffset = this._get_node_selection_dashoffset(
      node_id,
      paddingX,
      paddingY
    )
    this._set_selection_dashoffset(node_id, selection_stroke_dashoffset)
  }

  private _set_selection_dashoffset = (node_id: string, dashoffset: number) => {
    // console.log('Graph', '_set_selection_dashoffset', node_id, dashoffset)
    const selection = this._node_selection[node_id]
    selection.setProp('strokeDashOffset', dashoffset)
  }

  private _set_selection_dasharray = (
    node_id: string,
    dasharray: string
  ): void => {
    // console.log('Graph', '_set_selection_dasharray', node_id, dasharray)
    const selection = this._node_selection[node_id]
    selection.setProp('strokeDasharray', dasharray)
  }

  public move_datum_to_many_pins = (
    datum_node_id: string,
    pin_node_ids: string[]
  ) => {
    const actions = []

    const { datumId } = segmentDatumNodeId(datum_node_id)

    const value = this._get_datum_value(datum_node_id)

    for (let i = 1; i < pin_node_ids.length; i++) {
      const clone_datum_node_id = this._sim_duplicate_datum(datum_node_id)

      this._move_datum_to_pin(clone_datum_node_id, pin_node_ids[i])

      actions.push(
        makeAddDatumLinkAction(
          datumId,
          value,
          this._get_node_spec(pin_node_ids[i])
        )
      )
    }

    actions.push(
      makeAddDatumLinkAction(
        datumId,
        value,
        this._get_node_spec(pin_node_ids[0])
      )
    )

    const bulk_action = makeBulkEditAction(actions)

    this._dispatch_action(bulk_action)

    this._move_datum_to_pin(datum_node_id, pin_node_ids[0])
  }

  public move_data_to_pin = (datum_node_ids: string[], pin_node_id: string) => {
    const actions = []

    for (let i = 0; i < datum_node_ids.length; i++) {
      const datum_node_id = datum_node_ids[i]

      const value = this._get_datum_value(datum_node_id)

      const { datumId } = segmentDatumNodeId(datum_node_id)

      actions.push(
        makeAddDatumLinkAction(datumId, value, this._get_node_spec(pin_node_id))
      )
    }

    const bulk_action = makeBulkEditAction(actions)

    this._dispatch_action(bulk_action)

    for (let i = 0; i < datum_node_ids.length; i++) {
      const datum_node_id = datum_node_ids[i]

      this._move_datum_to_pin(datum_node_id, pin_node_id)
    }
  }

  private _on_compatible_node_click = (
    node_id: string,
    event: UnitPointerEvent
  ): void => {
    const display_node_id = this._get_display_node_id()

    const display_node_count = display_node_id.length

    if (display_node_count > 0) {
      const {
        all_pin,
        all_pin_ref,
        all_pin_ref_unit,
        all_data,
        all_unit,
        all_plug_pin: all_ext_pin,
      } = this._is_all_node(display_node_id)

      if (all_pin) {
        if (this._is_pin_node_id(node_id)) {
          for (let i = 0; i < display_node_count; i++) {
            this._set_node_target(display_node_id[i], node_id)
          }
          this._cancel_click = true
        } else if (this._is_datum_node_id(node_id)) {
          this.move_datum_to_many_pins(node_id, display_node_id)
        } else if (this._is_unit_node_id(node_id)) {
          for (let i = 0; i < display_node_count; i++) {
            this._merge_pin_unit(display_node_id[i], node_id)
          }
          this._select_node(node_id)
        } else if (this._is_int_node_id(node_id)) {
          const { type, pinId, subPinId } = segmentInternalNodeId(node_id)
          const pin_node_id = display_node_id[0]
          this.__plug_exposed_pin_to(type, pinId, subPinId, pin_node_id)
        }
      } else if (all_data) {
        if (this._is_pin_node_id(node_id)) {
          this._cancel_click = true
          this.move_data_to_pin(display_node_id, node_id)
        } else if (this._is_plug_node_id(node_id)) {
          for (let i = 0; i < display_node_count; i++) {
            const _display_node_id = display_node_id[i]
            this._move_datum_to_plug(_display_node_id, node_id)
          }
        }
        return
      } else if (all_unit) {
        const unit_id = display_node_id[0]
        if (this._is_pin_node_id(node_id)) {
          this._merge_pin_unit(node_id, unit_id)
          this._select_node(unit_id)
          this._cancel_click = true
        }
      } else if (all_ext_pin) {
        if (this._is_pin_node_id(node_id)) {
          const internal_node_id = display_node_id[0]
          const { type, pinId, subPinId } =
            segmentInternalNodeId(internal_node_id)
          this.__plug_exposed_pin_to(type, pinId, subPinId, node_id)
        }
      }
    }
  }

  private _on_non_compatible_node_click = (
    node_id: string,
    event: UnitPointerEvent
  ): void => {
    if (this._core_component_unlocked_count > 0) {
      if (this._is_unit_node_id(node_id)) {
        if (this._is_unit_component(node_id)) {
          this._lock_all_component_but(node_id)
          this._unlock_sub_component(node_id, true)
        } else {
          this._select_node(node_id)
          this._deselect_all_but(node_id)
          this._lock_all_component_but(node_id)
        }
      } else if (this._is_datum_node_id(node_id)) {
        if (this._is_datum_unlocked(node_id)) {
          //
        } else {
          this._unlock_datum(node_id)
        }
      } else {
        this._select_node(node_id)
        this._deselect_all_but(node_id)
        this._lock_all_component_but(node_id)
      }
    } else {
      if (this._selected_node_count === 1) {
        this._select_node(node_id)
        this._deselect_all_but(node_id)
      } else {
        if (this._edit_datum_node_id === node_id) {
          //
        } else {
          this._select_node(node_id)
        }
      }
    }

    if (this._edit_datum_node_id !== node_id) {
      if (!this._disabled && this._control_lock) {
        this.focus()
      }
    }
  }

  private _on_node_none_click = (
    node_id: string,
    event: UnitPointerEvent
  ): void => {
    // console.log('Graph', '_on_none_mode_click')

    if (this._compatible_node_id[node_id]) {
      this._on_compatible_node_click(node_id, event)
    } else {
      this._on_non_compatible_node_click(node_id, event)
    }
  }

  private _on_node_multiselect_click = (
    node_id: string,
    event: UnitPointerEvent
  ): void => {
    // console.log('Graph', '_on_node_multiselect_click', node_id)
    if (this._is_node_selectable(node_id)) {
      if (this._selected_node_id[node_id]) {
        this.deselect_node(node_id)
      } else {
        this._select_node(node_id)
      }
    }
  }

  private _on_node_info_click = (
    node_id: string,
    event: UnitPointerEvent
  ): void => {
    // console.log('Graph', '_on_node_info_click', node_id)
    this._info_node(node_id)
    this._deselect_all()
    this._select_node(node_id)
  }

  private _on_node_green_click = (
    node_id: string,
    event: UnitPointerEvent
  ): void => {
    // console.log('Graph', '_on_node_green_click', node_id)
    if (this._is_node_duplicatable(node_id)) {
      this._green_click_node(node_id)
    }
  }

  private _on_node_blue_click = (
    node_id: string,
    event: UnitPointerEvent
  ): void => {
    // console.log('Graph', '_on_node_blue_click', node_id)
    if (this._is_node_changeable(node_id)) {
      if (this._is_unit_node_id(node_id)) {
        this._on_unit_blue_click(node_id)
      } else if (this._is_link_pin_node_id(node_id)) {
        this._on_link_pin_blue_click(node_id)
      } else if (this._is_datum_node_id(node_id)) {
        this._on_datum_blue_click(node_id)
      } else if (this._is_plug_node_id(node_id)) {
        this._on_exposed_blue_click(node_id)
      }
    }
  }

  private _on_link_pin_blue_click = (pin_node_id: string): void => {
    this._toggle_link_pin_constant(pin_node_id)
  }

  private _on_datum_blue_click = (datum_node_id: string): void => {
    this._change_datum(datum_node_id)
  }

  private _on_exposed_blue_click = (exp_node_id: string): void => {
    this._toggle_exposed_pin_functional(exp_node_id)
  }

  private _clicked_node_already_selected = false

  private _on_node_click = (node_id: string, event: UnitPointerEvent): void => {
    // console.log('Graph', '_on_node_click', node_id)

    const { dispatchEvent } = this.$props

    if (this._cancel_node_click.has(node_id)) {
      this._cancel_node_click.delete(node_id)

      return
    }

    if (this._resize_node_id_pointer_id[node_id]) {
      return
    }

    this._clicked_node_already_selected = this._is_node_selected(node_id)

    if (this._mode === 'none') {
      this._on_node_none_click(node_id, event)
    } else if (this._mode === 'multiselect') {
      this._on_node_multiselect_click(node_id, event)
    } else if (this._mode === 'info') {
      this._on_node_info_click(node_id, event)
    } else if (this._mode === 'add') {
      this._on_node_green_click(node_id, event)
    } else if (this._mode === 'remove') {
      this._on_node_red_click(node_id, event)
    } else if (this._mode === 'change') {
      this._on_node_blue_click(node_id, event)
    } else if (this._mode === 'data') {
      this._on_node_yellow_click(node_id)
    }

    dispatchEvent('nodeclick', this._get_node_spec(node_id), false)
  }

  private _on_node_red_click = (node_id: string, event: UnitPointerEvent) => {
    // console.log('Graph', '_on_node_red_click', node_id)

    const {
      api: {
        window: { setTimeout },
      },
    } = this.$system

    if (this._is_node_removable(node_id)) {
      this._cancel_click = true

      setTimeout(() => {
        const anchor_node_id = this._get_node_anchor_node_id(node_id)

        if (this._selected_node_id[anchor_node_id]) {
          this.cut_selected_nodes()
        } else {
          if (this._is_link_pin_node_id(node_id)) {
            this.set_link_pin_ignored(node_id, true)
          } else {
            this.cut_single_node(node_id)
          }
        }
      }, 0)
    }
  }

  private _is_node_removable = (node_id: string): boolean => {
    return true
  }

  private _animate_sub_component_graph_leave = (
    sub_component_id: string,
    base: LayoutBase,
    base_node: LayoutNode[],
    measure: () => { style: Style; trait: LayoutNode },
    callback: () => Promise<boolean>
  ): void => {
    // console.log('Graph', '_animate_sub_component_graph_leave', base, base_node)

    return this._animate_sub_component_graph_move__template(
      sub_component_id,
      base,
      base_node,
      true,
      measure,
      async () => {
        let result = callback()

        if (result) {
          if (
            this._main_opacity_animation &&
            this._main_opacity_animation.playState !== 'idle' &&
            this._main_opacity_animation.playState !== 'finished'
          ) {
            await waitFinish(this._main_opacity_animation)
          }

          this._unplug_sub_component_base_frame(sub_component_id)
          this._compose_sub_component(sub_component_id)
          this._append_sub_component_base(sub_component_id)
          this._enter_sub_component_frame(sub_component_id)
        }

        return result
      }
    )
  }

  private _animate_sub_component_graph_move__template = (
    sub_component_id: string,
    base: LayoutBase,
    base_node: LayoutNode[],
    expand: boolean,
    measure: () => { style: Style; trait: LayoutNode },
    callback: () => boolean | Promise<boolean>
  ): void => {
    // console.log('Graph', '_animate_sub_component_graph_move__template', base, base_node)

    const base_layer = this._foreground

    let i = 0

    for (const leaf of base) {
      const [leaf_path] = leaf

      const leaf_id = joinPath([sub_component_id, ...leaf_path])

      const leaf_node = base_node[i] || this._leaf_frame_node[leaf_id]

      this._leaf_frame_node[leaf_id] = leaf_node

      i++
    }

    this._leave_sub_component_frame(sub_component_id)

    if (this._animating_sub_component_base_id.has(sub_component_id)) {
      //
    } else {
      this._remove_sub_component_base(sub_component_id)
    }

    this._plug_sub_component_base(sub_component_id, base, base_node, base_layer)

    let base_trait: Dict<LayoutNode>

    i = 0

    const frame = this._get_sub_component_frame(sub_component_id)

    this._abort_sub_component_leave_base_animation[sub_component_id] =
      this._animate_sub_component_base(
        sub_component_id,
        base,
        base_node,
        (leaf_id: string) => {
          if (i === 0) {
            const { style, trait } = measure()

            base_trait = this._reflect_sub_component_base_trait(
              sub_component_id,
              base,
              style,
              trait,
              expand
            )
          }

          const leaf_trait = base_trait[leaf_id]

          i = (i + 1) % base.length

          return {
            x:
              -this.$context.$x -
              frame.$$context.$x * (this._zoom.z - 1) +
              leaf_trait.x * this._zoom.z,
            y:
              -this.$context.$y -
              frame.$$context.$y * (this._zoom.z - 1) +
              leaf_trait.y * this._zoom.z,
            width: leaf_trait.width,
            height: leaf_trait.height,
            sx: leaf_trait.sx,
            sy: leaf_trait.sy,
            opacity: leaf_trait.opacity,
            fontSize: leaf_trait.fontSize,
            color: leaf_trait.color,
          }
        },
        callback
      )
  }

  private _is_node_dataable = (node_id: string): boolean => {
    if (this._is_unit_node_id(node_id)) {
      return true
    } else if (this._is_pin_node_id(node_id)) {
      return this._is_pin_data_able(node_id)
    } else if (this._is_datum_node_id(node_id)) {
      return true
      // if (this._is_datum_class_literal(node_id)) {
      //   return true
      // }
    } else if (this._is_plug_node_id(node_id)) {
      return true
    }

    return false
  }

  private _is_node_infoable = (node_id: string): boolean => {
    return !this._is_type_node_id(node_id)
  }

  private _spec_remove_datum = (datum_node_id: string): void => {
    const { datumId } = segmentDatumNodeId(datum_node_id)

    deepDelete(this._spec, ['metadata', 'position', 'data', datumId])
  }

  private _spec_remove_node = (node_id: string): void => {
    // console.log('Graph', '_remove_node', node_id)

    if (this._is_unit_node_id(node_id)) {
      this._spec_remove_unit(node_id)
    } else if (this._is_link_pin_node_id(node_id)) {
      this._spec_set_link_pin_ignored(node_id, true)
    } else if (this._is_merge_node_id(node_id)) {
      this._spec_remove_merge(node_id)
    } else if (this._is_datum_node_id(node_id)) {
      this._spec_remove_datum(node_id)
    } else if (this._is_plug_node_id(node_id)) {
      this._spec_remove_exposed_sub_pin(node_id)
    }
  }

  private _get_datum_connected = (
    datum_node_id: string
  ): {
    datum_pin_node_id: string | null
    datum_plug_node_id: string | null
  } => {
    return {
      datum_pin_node_id: this._datum_to_pin[datum_node_id],
      datum_plug_node_id: this._datum_to_plug[datum_node_id],
    }
  }

  private _pod_remove_datum = (
    datum_node_id: string,
    datum_pin_node_id: string | null,
    datum_plug_node_id: string | null
  ) => {
    this._pod_remove_datum__template(
      datum_node_id,
      datum_pin_node_id,
      datum_plug_node_id,
      {
        takeInput: this._pod.$takeInput.bind(this._pod),
        removeMergeData: this._pod.$removeMergeData.bind(this._pod),
        removeUnitPinData: this._pod.$removeUnitPinData.bind(this._pod),
        removePinData: this._pod.$removePinData.bind(this._pod),
      }
    )
  }

  private _pod_remove_datum__template = (
    datum_node_id: string,
    datum_pin_node_id: string | null,
    datum_plug_node_id: string | null,
    {
      takeInput,
      removeMergeData,
      removeUnitPinData,
      removePinData,
    }: {
      takeInput: (data: UnitTakeInputData) => void
      removeMergeData(data: GraphRemoveMergeDataData): void
      removeUnitPinData(data: GraphRemoveUnitPinDataData): void
      removePinData(data: UnitRemovePinDataData): void
    }
  ) => {
    if (datum_pin_node_id) {
      this._pod_remove_pin_datum__template(datum_pin_node_id, {
        takeInput,
        removeMergeData,
        removeUnitPinData,
      })
    }

    if (datum_plug_node_id) {
      const { type, pinId } = segmentPlugNodeId(datum_plug_node_id)

      this._pod_remove_exposed_pin_datum__template(type, pinId, {
        removePinData,
      })
    }
  }

  private _pod_remove_node = (node_id: string): void => {
    if (this._is_unit_node_id(node_id)) {
      const is_component = this._is_unit_component(node_id)

      this._pod_remove_unit(node_id, is_component)
    } else if (this._is_link_pin_node_id(node_id)) {
      this._pod_set_unit_pin_ignored(node_id, true)
    } else if (this._is_merge_node_id(node_id)) {
      this._pod_remove_merge(node_id)
    } else if (this._is_datum_node_id(node_id)) {
      const { datum_pin_node_id, datum_plug_node_id } =
        this._get_datum_connected(node_id)

      this._pod_remove_datum(node_id, datum_pin_node_id, datum_plug_node_id)
    } else if (this._is_plug_node_id(node_id)) {
      this._pod_remove_exposed_sub_pin(node_id)
    }
  }

  private _action_buffer: Action[] = []
  private _action_buffer_cursor: number = -1

  private _dispatch_action = (action: Action): void => {
    // console.log('Graph', '_dispatch_action', action)

    this._flush_debugger()

    if (this._action_buffer_cursor < this._action_buffer.length - 1) {
      const start = this._action_buffer_cursor + 1
      const delete_count =
        this._action_buffer.length - this._action_buffer_cursor + 1
      this._action_buffer.splice(start, delete_count)
    }

    this._action_buffer.push(clone(action))
    this._action_buffer_cursor++

    this._refresh_type_cache_for_spec_id(this._spec.id)
  }

  public remove_exposed_sub_pin_or_set = (
    exposed_pin_node_id: string
  ): void => {
    const { pinId, type, subPinId } = segmentPlugNodeId(exposed_pin_node_id)

    const sub_pin_spec = this._get_exposed_sub_pin_spec(type, pinId, subPinId)

    this._dispatch_action(
      makeCoverPinAction(type, pinId, subPinId, sub_pin_spec)
    )

    this._remove_exposed_sub_pin_or_set(exposed_pin_node_id)
  }

  private _remove_exposed_sub_pin_or_set = (
    exposed_pin_node_id: string
  ): void => {
    // console.log('Graph', '_remove_exposed_sub_pin_or_set', exposed_pin_node_id)

    const { pinId, type, subPinId } = segmentPlugNodeId(exposed_pin_node_id)

    const pin_count = this._get_exposed_pin_set_count(exposed_pin_node_id)
    if (pin_count === 1 || pin_count === 0) {
      this._cover_pin_set(type, pinId)
    } else {
      this.__sim_remove_exposed_sub_pin(type, pinId, subPinId)
      this.__spec_remove_exposed_sub_pin(type, pinId, subPinId)
      this.__pod_remove_exposed_sub_pin(type, pinId, subPinId)
    }
  }

  private _get_exposed_pin_set_count = (
    exposed_pin_node_id: string
  ): number => {
    const { pinId, type } = segmentPlugNodeId(exposed_pin_node_id)

    const exposed_pin_spec = this._get_pin_spec(type, pinId)

    const { plug } = exposed_pin_spec

    const count = keyCount(plug || {})

    return count
  }

  private _spec_remove_exposed_sub_pin = (exposed_node_id: string): void => {
    const { pinId, type, subPinId } = segmentPlugNodeId(exposed_node_id)

    this.__spec_remove_exposed_sub_pin(type, pinId, subPinId)
  }

  private __spec_remove_exposed_sub_pin = (
    type: IO,
    pinId: string,
    subPinId: string
  ): void => {
    // console.log('Graph', '_spec_remove_exposed_sub_pin', type, pinId, subPinId)

    coverPin({ pinId, type, subPinId }, this._spec)
  }

  private _sim_remove_exposed_sub_pin = (exposed_pin_node_id: string) => {
    const { type, pinId, subPinId } = segmentPlugNodeId(exposed_pin_node_id)

    this.__sim_remove_exposed_sub_pin(type, pinId, subPinId)
  }

  private _state_remove_exposed_sub_pin = (
    exposed_pin_node_id: string
  ): void => {
    this._sim_remove_exposed_sub_pin(exposed_pin_node_id)
    this._spec_remove_exposed_sub_pin(exposed_pin_node_id)
  }

  private __state_remove_exposed_sub_pin = (
    type: IO,
    pin_id: string,
    sub_pin_id: string
  ): void => {
    this.__sim_remove_exposed_sub_pin(type, pin_id, sub_pin_id)
    this.__spec_remove_exposed_sub_pin(type, pin_id, sub_pin_id)
  }

  private __sim_remove_exposed_sub_pin = (
    type: IO,
    pin_id: string,
    sub_pin_id: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '__sim_remove_exposed_sub_pin',
    //   type,
    //   pin_id,
    //   sub_pin_id
    // )

    const input = type === 'input'

    const ext_node_id = getExtNodeId(type, pin_id, sub_pin_id)
    const int_node_id = getIntNodeId(type, pin_id, sub_pin_id)

    const source_id = input ? ext_node_id : int_node_id
    const target_id = input ? int_node_id : ext_node_id

    const datum_node_id = this._plug_to_datum[ext_node_id]

    if (datum_node_id) {
      this._sim_remove_plug_datum_link(type, pin_id, sub_pin_id)
      this._sim_remove_datum(datum_node_id)
    }

    const link_id = getLinkId(source_id, target_id)

    this._sim_remove_link(link_id)

    delete this._exposed_link[link_id]

    const pin_node_id = this._int_to_node[int_node_id]

    if (pin_node_id) {
      delete this._pin_to_int[type][pin_node_id]
      delete this._pin_to_ext[type][pin_node_id]

      delete this._int_to_node[int_node_id]

      const pin_datum_node_id = this._pin_to_datum[pin_node_id]

      if (pin_datum_node_id) {
        this._refresh_datum_visible(pin_datum_node_id)
      }
    }

    delete this._exposed_link_start_marker[ext_node_id]
    delete this._exposed_link_end_marker[ext_node_id]

    this._sim_remove_exposed_ext_node(ext_node_id)
    this._sim_remove_exposed_int_node(int_node_id)
  }

  private _sim_remove_exposed_ext_node = (ext_node_id: string) => {
    // console.log('Editor', '_sim_remove_exposed_ext_node', ext_node_id)

    delete this._exposed_node[ext_node_id]
    delete this._exposed_ext_node[ext_node_id]

    const ext_anchor_node_id = this._ext_to_node[ext_node_id]

    delete this._ext_to_node[ext_node_id]

    if (this._node_to_ext[ext_anchor_node_id]) {
      this._node_to_ext[ext_anchor_node_id].delete(ext_node_id)

      if (this._node_to_ext[ext_anchor_node_id].size === 0) {
        delete this._node_to_ext[ext_anchor_node_id]
      }
    }

    delete this._exposed_ext_unplugged[ext_node_id]
    delete this._ext_pin_name[ext_node_id]

    delete this._node_type[ext_node_id]

    this._sim_remove_node_type(ext_node_id)

    if (this._has_node(ext_node_id)) {
      this._sim_remove_node(ext_node_id)
    }
  }

  private _sim_remove_exposed_int_node = (int_node_id: string) => {
    // console.log('Editor', '_sim_remove_exposed_ext_node', int_node_id)

    delete this._exposed_node[int_node_id]
    delete this._exposed_int_node[int_node_id]
    delete this._exposed_int_unplugged[int_node_id]

    delete this._node_type[int_node_id]

    if (this._has_node(int_node_id)) {
      this._sim_remove_node(int_node_id)
    }
  }

  private _pod_remove_exposed_sub_pin = (exposed_node_id: string): void => {
    const { type, pinId, subPinId } = segmentPlugNodeId(exposed_node_id)

    this.__pod_remove_exposed_sub_pin(type, pinId, subPinId)
  }

  private __pod_remove_exposed_sub_pin = (
    type: IO,
    pinId: string,
    subPinId: string
  ): void => {
    const { fork, bubble } = this.$props

    const subPinSpec = this._get_exposed_sub_pin_spec(type, pinId, subPinId)

    this._pod.$coverPin({
      type,
      pinId,
      subPinId,
      subPinSpec,
      fork,
      bubble,
    })
  }

  private _set_link_pin_r = (pin_node_id: string, r: number): void => {
    const pin = this._pin[pin_node_id]

    const width = 2 * r
    const height = 2 * r

    pin.$element.style.width = `${width}px`
    pin.$element.style.height = `${height}px`

    this._resize_node(pin_node_id, width, height)
    this._resize_selection(pin_node_id, width, height)
  }

  private _set_link_pin_d = (pin_node_id: string, d: number): void => {
    const link_id = getPinLinkIdFromPinNodeId(pin_node_id)

    this._sim_set_link_d(link_id, d)
  }

  private _sim_set_link_d = (link_id: string, d: number): void => {
    // console.log('Graph', '_set_link_d', d)

    const link = this._link[link_id]

    link.l = d
  }

  private _set_link_pin_padding_source = (
    pin_node_id: string,
    padding: number
  ): void => {
    // console.log('Graph', '_set_link_pin_padding_source', pin_node_id, padding)

    const link_id = getPinLinkIdFromPinNodeId(pin_node_id)

    const link = this._link[link_id]

    link.padding.source = padding
  }

  private _set_link_pin_padding_target = (
    pin_node_id: string,
    padding: number
  ): void => {
    const link_id = getPinLinkIdFromPinNodeId(pin_node_id)
    const link = this._link[link_id]
    link.padding.target = padding
  }

  private _set_link_pin_start_marker_hidden = (
    pin_node_id: string,
    hidden: boolean
  ): void => {
    const start_marker = this._pin_link_start_marker[pin_node_id]

    start_marker.$element.style.display = hidden ? 'none' : 'block'
  }

  private _set_link_pin_end_marker_hidden = (
    pin_node_id: string,
    hidden: boolean
  ): void => {
    const end_marker = this._pin_link_end_marker[pin_node_id]

    end_marker.$element.style.display = hidden ? 'none' : 'block'
  }

  public set_link_pin_ignored = (
    pin_node_id: string,
    ignored: boolean
  ): void => {
    // console.log('Graph', 'set_link_pin_ignored')

    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    this._dispatch_action(
      makeSetUnitPinIgnoredAction(unitId, type, pinId, ignored)
    )

    this._set_link_pin_ignored(pin_node_id, ignored)
  }

  private _set_link_pin_ignored = (
    pin_node_id: string,
    ignored: boolean
  ): void => {
    // console.log('_set_link_pin_ignored', pin_node_id, ignored)

    this._state_set_link_pin_ignored(pin_node_id, ignored)
    this._pod_set_link_pin_ignored(pin_node_id, ignored)
  }

  private _pod_set_link_pin_ignored = (
    pin_node_id: string,
    ignored: boolean
  ): void => {
    // console.log('_set_link_pin_ignored', pin_node_id, ignored)
    const merge_node_id = this._pin_to_merge[pin_node_id]
    if (merge_node_id) {
      this._pod_remove_pin_or_merge(pin_node_id)
    }

    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    this.__pod_set_unit_pin_ignored(unitId, type, pinId, ignored)
  }

  private _state_set_link_pin_ignored = (
    pin_node_id: string,
    ignored: boolean
  ): void => {
    // console.log('_set_link_pin_ignored', pin_node_id, ignored)
    const merge_node_id = this._pin_to_merge[pin_node_id]
    if (merge_node_id) {
      this._state_remove_pin_or_merge(pin_node_id)
    }

    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    this._sim_set_unit_pin_ignored(pin_node_id, ignored)
    this.__spec_set_link_pin_ignored(unitId, type, pinId, ignored)
  }

  private _sim_set_unit_pin_ignored = (
    pin_node_id: string,
    ignored: boolean
  ) => {
    // console.log('Graph', '_sim_set_unit_pin_ignored', pin_node_id, ignored)

    const { unitId, type } = segmentLinkPinNodeId(pin_node_id)

    const internal_node_id = this._pin_to_int[type][pin_node_id]

    if (internal_node_id) {
      const { type, pinId, subPinId } = segmentInternalNodeId(internal_node_id)

      this._sim_unplug_exposed_pin(type, pinId, subPinId)
    }

    const datum_node_id = this._pin_to_datum[pin_node_id]

    const pin_datum_tree = this._pin_datum_tree[pin_node_id]

    const link_id = getPinLinkIdFromPinNodeId(pin_node_id)

    if (ignored) {
      this._set_node_layer(pin_node_id, LAYER_IGNORED)
      this._set_link_layer(link_id, LAYER_IGNORED)
      this._set_link_pin_d(pin_node_id, LINK_DISTANCE_IGNORED)
      this._set_link_pin_opacity(pin_node_id, 0)
      this._set_link_pin_pointer_events(pin_node_id, 'none')

      if (pin_datum_tree) {
        this._dec_unit_pin_active(unitId)
      }
    } else {
      this._set_node_layer(pin_node_id, LAYER_NORMAL)
      this._set_link_layer(link_id, LAYER_NORMAL)
      this._set_link_pin_d(pin_node_id, LINK_DISTANCE)
      this._set_link_pin_opacity(pin_node_id, 1)
      this._set_link_pin_pointer_events(pin_node_id, 'inherit')

      if (pin_datum_tree) {
        this._inc_unit_pin_active(unitId)
      }

      if (pin_node_id) {
        this._refresh_datum_visible(datum_node_id)
      }
    }

    this._refresh_node_color(pin_node_id)

    this._start_graph_simulation(LAYER_NONE)
  }

  private _sim_set_unit_pin_ref = (
    pin_node_id: string,
    ref: boolean,
    onRemoval: Callback<void> = NOOP,
    onAddMerge: (mergeId: string, merge_spec: GraphMergeSpec) => void,
    onAddLinkPinToMerge: (
      unitId: string,
      type: IO,
      pinId: string,
      mergeId: string
    ) => void,
    onRemovePinFromMerge: (
      unitId: string,
      type: IO,
      pinId: string,
      mergeId: string
    ) => void
  ) => {
    // console.log('Graph', '_sim_set_unit_pin_ref', pin_node_id, ref)

    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    const merge_node_id = this._pin_to_merge[pin_node_id]
    const merge_spec = merge_node_id && this._get_merge(merge_node_id)
    const merge_position =
      merge_spec && this._get_anchor_node_position(merge_node_id)
    const merge_ref = this._merge_ref[merge_node_id]
    const merge_output_ref = this._merge_to_ref_output[merge_node_id]

    const ext_node_id = this._pin_to_ext[type][pin_node_id]

    const position = this._get_anchor_node_position(pin_node_id)

    const data = this._pin_datum_tree[pin_node_id]

    this._sim_graph_remove_unit_pin(unitId, type, pinId)

    onRemoval()

    this._sim_graph_unit_expose_pin_set(
      unitId,
      type,
      pinId,
      position,
      undefined
    )

    if (ext_node_id) {
      const { type, pinId, subPinId } = segmentPlugNodeId(ext_node_id)

      this._sim_plug_exposed_pin(type, pinId, subPinId, {
        unitId,
        pinId,
        kind: type,
      })
    }

    if (data) {
      this._graph_debug_set_pin_data_tree(pin_node_id, data)
    }

    if (merge_node_id) {
      const { mergeId } = segmentMergeNodeId(merge_node_id)

      if (this._is_merge_ref(merge_node_id)) {
        //
      } else {
        if (this._has_node(merge_node_id)) {
          this._sim_remove_pin_from_merge(merge_node_id, pin_node_id)

          onRemovePinFromMerge(unitId, type, pinId, mergeId)

          this._sim_add_link_pin_to_merge(pin_node_id, merge_node_id)

          onAddLinkPinToMerge(unitId, type, pinId, mergeId)
        } else {
          onAddMerge(mergeId, merge_spec)

          this._sim_add_merge(mergeId, merge_spec, merge_position)
          this.__sim_collapse_merge(mergeId, merge_spec)
        }
      }
    }
  }

  private _pod_set_unit_pin_ignored = (
    pin_node_id: string,
    ignored: boolean
  ): void => {
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)
    this.__pod_set_unit_pin_ignored(unitId, type, pinId, ignored)
  }

  private __pod_set_unit_pin_ignored = (
    unitId: string,
    type: IO,
    pinId: string,
    ignored: boolean
  ): void => {
    const { fork, bubble } = this.$props

    this._pod.$setUnitPinIgnored({
      unitId,
      type,
      pinId,
      ignored,
      fork,
      bubble,
    })
  }

  private _spec_set_link_pin_ignored = (
    pin_node_id: string,
    ignored: boolean
  ): void => {
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)
    this.__spec_set_link_pin_ignored(unitId, type, pinId, ignored)
  }

  private __spec_set_link_pin_ignored = (
    unitId: string,
    type: IO,
    pinId: string,
    ignored: boolean
  ): void => {
    // console.log(
    //   'Graph',
    //   '__spec_set_link_pin_ignored',
    //   unitId,
    //   type,
    //   pinId,
    //   ignored
    // )

    setUnitPinIgnored({ unitId, type, pinId, ignored }, this._spec)
  }

  private _spec_set_unit_pin_constant = (
    unitId: string,
    type: IO,
    pinId: string,
    constant: boolean
  ): void => {
    // console.log(
    //   'Graph',
    //   '_spec_set_unit_pin_constant',
    //   unitId,
    //   type,
    //   pinId,
    //   constant
    // )

    setUnitPinConstant({ unitId, type, pinId, constant }, this._spec)

    const pin_node_id: string = getPinNodeId(unitId, type, pinId)

    const datum_node_id = this._pin_to_datum[pin_node_id]

    if (type === 'input') {
      if (datum_node_id) {
        if (constant) {
          const { datumId } = segmentDatumNodeId(datum_node_id)

          const tree = this._datum_tree[datumId]

          const { value } = tree

          this._spec_set_pin_data(pin_node_id, value)
        } else {
          this._spec_remove_pin_data(pin_node_id)
        }
      }
    }
  }

  private _spec_set_link_pin_ref = (
    unitId: string,
    type: IO,
    pinId: string,
    ref: boolean
  ): void => {
    deepSet(this._spec, ['units', unitId, type, pinId, 'ref'], ref)
  }

  private _is_node_duplicatable = (node_id: string): boolean => {
    if (this._is_link_pin_node_id(node_id)) {
      return true
    } else if (this._is_unit_node_id(node_id)) {
      return true
    } else if (this._is_datum_node_id(node_id)) {
      return true
    } else if (this._is_plug_node_id(node_id)) {
      return true
    } else if (this._is_merge_node_id(node_id)) {
      return true
    } else {
      return false
    }
  }

  private _green_click_node = (node_id: string): string | null => {
    if (this._is_node_selected(node_id)) {
      this.copy_selected_nodes(false)
    } else {
      if (this._is_link_pin_node_id(node_id)) {
        return this._duplicate_link_pin(node_id)
      }

      this.copy_single_node(node_id, false)

      return node_id
    }

    return null
  }

  private _set_unit_fixed = (unit_id: string, fixed: boolean) => {
    this._set_node_fixed(unit_id, fixed)
    this._for_each_unit_pin(unit_id, (pin_node_id) => {
      const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)
      this._set_node_fixed(anchor_node_id, fixed)
    })
  }

  private _green_click_unit = (unit_id: string): null => {
    if (this._is_node_selected(unit_id)) {
      this.copy_selected_nodes(false)
    } else {
      this.copy_single_node(unit_id, false)
    }
    return null
  }

  private _state_duplicate_unit = (
    unit_id: string,
    new_unit_id?: string
  ): string => {
    // console.log('Graph', '_state_duplicate_unit', unit_id)

    const unit = this._get_unit(unit_id)

    const { id } = unit

    new_unit_id = new_unit_id ?? this._new_unit_id(id)

    const new_unit = clone(unit)

    const unit_position = this._get_node_position(unit_id)
    const unit_pin_position = this._get_unit_pin_position(unit_id)
    const unit_layout_position = NULL_VECTOR

    this._spec_add_unit(new_unit_id, new_unit)

    let parent_id: string | null = null

    if (this._is_unit_component(new_unit_id)) {
      parent_id = this._spec_get_sub_component_parent_id(unit_id)

      this._spec_append_component(parent_id, new_unit_id)
    }

    this._sim_add_unit(
      new_unit_id,
      new_unit,
      unit_position,
      {},
      unit_pin_position,
      parent_id,
      unit_layout_position
    )

    if (this._is_unit_component(new_unit_id)) {
      const { width, height } = this._get_unit_component_graph_size(unit_id)

      this.resize_sub_component(new_unit_id, width + 2, height + 2)
    }

    return new_unit_id
  }

  private _duplicate_link_pin = (pin_node_id: string): string | null => {
    if (this._is_link_pin_node_id(pin_node_id)) {
      if (this._spec_is_link_pin_ignored(pin_node_id)) {
        this.set_link_pin_ignored(pin_node_id, false)

        this._refresh_pin_datum_visible(pin_node_id)
      }
    }
    return null
  }

  private _sim_duplicate_datum = (datum_node_id: string): string => {
    // console.log('Graph', '_sim_duplicated_datum', datum_node_id)

    const { datumId } = segmentDatumNodeId(datum_node_id)

    const datum_tree = this._datum_tree[datumId]

    const { x, y } = this._get_node_position(datum_node_id)

    const new_datum_id = this._new_datum_id()
    const new_datum_node_id = getDatumNodeId(new_datum_id)

    this.add_datum(new_datum_id, datum_tree.value, { x, y }, true)

    return new_datum_node_id
  }

  private _sim_duplicate_exposed_pin = (exposed_node_id: string): string => {
    // console.log('Graph', '_sim_duplicate_exposed_pin', exposed_node_id)

    const { type, pinId, subPinId } = segmentPlugNodeId(exposed_node_id)

    const pin_spec = this._get_pin_spec(type, pinId)

    const ext_node_id = getExtNodeId(type, pinId, subPinId)
    const int_node_id = getExtNodeId(type, pinId, subPinId)

    const new_sub_pin_id = this._new_sub_pin_id(type, pinId)

    const ext_position = this._get_node_position(ext_node_id)
    const int_position = this._get_node_position(int_node_id)

    const plug_position = {
      int: jigglePoint(int_position),
      ext: jigglePoint(ext_position),
    }

    const sub_pin_spec = {}

    this.add_exposed_pin(
      type,
      pinId,
      pin_spec,
      new_sub_pin_id,
      sub_pin_spec,
      plug_position
    )

    const new_exposed_ext_node_id = getExtNodeId(type, pinId, new_sub_pin_id)
    const new_exposed_int_node_id = getIntNodeId(type, pinId, new_sub_pin_id)

    this._transfer_node_position(ext_node_id, new_exposed_ext_node_id)
    this._transfer_node_position(int_node_id, new_exposed_int_node_id)

    const datum_node_id = this._plug_to_datum[ext_node_id]

    if (datum_node_id) {
      const value = this._get_datum_value(datum_node_id)

      this._sim_add_plug_datum(type, pinId, new_sub_pin_id, value)
    }

    return new_exposed_ext_node_id
  }

  private _transfer_node_position = (
    source_node_id: string,
    target_node_id: string
  ): void => {
    this._set_node_position(
      target_node_id,
      this._get_node_position(source_node_id)
    )
  }

  private _is_node_changeable = (node_id: string): boolean => {
    if (this._is_unit_node_id(node_id)) {
      return true
    } else if (this._is_link_pin_node_id(node_id)) {
      return true
    } else if (this._is_plug_node_id(node_id)) {
      return true
    } else if (this._is_datum_node_id(node_id)) {
      const datum_pin_node_id = this._datum_to_pin[node_id]
      if (datum_pin_node_id) {
        if (isOutputPinId(datum_pin_node_id)) {
          return false
        }
      }
      return true
    } else if (this._is_merge_node_id(node_id)) {
      return true
    } else {
      return false
    }
  }

  private _set_search_text = (text: string): void => {
    if (this._search) {
      this._search.setValue(text)
    }
  }

  private _set_search_filter = (filter: (id: string) => boolean) => {
    // console.log('Graph', '_set_search_filter')
    if (this._search) {
      this._search_filter = filter

      this._search.setProp('filter', filter)
    }
  }

  private _set_search_selected = (id: string) => {
    if (this._search) {
      this._search.setProp('selected', id)
    }
  }

  private _info_node = (node_id: string): void => {
    if (this._is_pin_node_id(node_id)) {
      this._info_pin(node_id)
    } else if (this._is_unit_node_id(node_id)) {
      this._info_unit(node_id)
    } else if (this._is_ext_node_id(node_id)) {
      this._info_ext_pin(node_id)
    }
  }

  private _temp_cancel_double_click = () => {
    const {
      api: {
        window: { setTimeout },
      },
    } = this.$system

    this._cancel_double_click = true

    setTimeout(() => {
      this._cancel_double_click = false
    }, CLICK_TIMEOUT)
  }

  private _on_node_yellow_click = (node_id: string): void => {
    if (this._is_pin_node_id(node_id)) {
      this._yellow_click_pin(node_id)
    } else if (this._is_unit_node_id(node_id)) {
      this._yellow_click_unit(node_id)
    } else if (this._is_datum_node_id(node_id)) {
      this._yellow_click_datum(node_id)
    } else if (this._is_plug_node_id(node_id)) {
      this._yellow_click_plug(node_id)
    }
  }

  private _yellow_click_datum = (datum_node_id) => {
    // TODO deep copy

    this._copy_nodes([datum_node_id], true, () => {
      // TODO
    })
  }

  private _yellow_long_press_datum = (
    datum_node_id,
    pointerId: number,
    clientX: number,
    clientY: number
  ) => {
    if (this._is_datum_class_literal(datum_node_id)) {
      this._yellow_long_press_class_literal(
        datum_node_id,
        pointerId,
        clientX,
        clientY
      )
    }
  }

  private _yellow_click_unit = (unit_id: string): void => {
    // console.log('Graph', '_yellow_click_unit', unit_id)

    this._copy_nodes([unit_id], true, () => {
      // TODO
    })
  }

  private _yellow_long_press_class_literal = (
    datum_node_id: string,
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    this._temp_cancel_double_click()

    const new_unit_id = this._turn_class_literal_into_unit(datum_node_id)

    this._force_pointer_drag_node(new_unit_id, pointerId, clientX, clientY)
  }

  private _yellow_click_plug = (plug_node_id: string): void => {
    const { specs } = this.$props

    const type = this._get_plug_type(plug_node_id, true)

    const data = randomTreeOfType(specs, type)

    if (data) {
      this._set_plug_data(plug_node_id, data.value)
    }
  }

  private _turn_class_literal_into_unit = (datum_node_id: string): string => {
    const { specs, injectSpecs } = this.$props

    const { classes } = this.$system

    const position = this._get_node_position(datum_node_id)

    const pin_position = emptyIO({}, {})

    const layout_position = NULL_VECTOR

    const { datumId } = segmentDatumNodeId(datum_node_id)

    const tree = this._datum_tree[datumId]

    const { value } = tree

    const spec_id = idFromUnitValue(value, specs, classes)

    const partial_bundle = evaluateBundleStr(value, specs, classes)

    const { unit } = partial_bundle

    injectSpecs(partial_bundle.specs)

    const bundle = unitBundleSpec(unit, specs)

    const { memory } = unit

    this._remove_datum(datum_node_id)

    const new_unit_id = this._new_unit_id(spec_id)

    this._add_unit(
      new_unit_id,
      bundle,
      position,
      pin_position,
      layout_position,
      null
    )

    this._set_unit_memory(new_unit_id, memory)

    if (this._mode === 'data') {
      this._for_each_visible_unit_output(new_unit_id, (pin_node_id) =>
        this._set_link_pin_opacity(pin_node_id, 0.5)
      )
      this._for_each_unit_ref_input(new_unit_id, (pin_node_id) =>
        this._set_link_pin_opacity(pin_node_id, 0.5)
      )
    }

    this.temp_fixate_node(new_unit_id)

    if (this._is_unit_component(new_unit_id)) {
      this._sim_add_sub_component(new_unit_id)
      this._connect_sub_component(new_unit_id)
    }

    this._refresh_compatible()

    return new_unit_id
  }

  private _info_unit = (unit_id: string): void => {
    //
  }

  private _show_core_description = (unit_id: string): void => {
    const core_description = this._core_description[unit_id]

    core_description.$element.style.display = 'table'
  }

  private _hide_core_description = (unit_id: string): void => {
    const core_description = this._core_description[unit_id]

    core_description.$element.style.display = 'none'
  }

  private _info_pin = (pin_node_id: string): void => {
    //
  }

  private _info_ext_pin = (ext_node_id: string) => {
    //
  }

  private _get_unit_input_data_valid_examples = (
    unitId: string,
    pinId: string,
    pinType: TreeNode
  ): string[] => {
    const { specs } = this.$props

    const examples = this._get_unit_input_data_examples(unitId, pinId)

    const valid_examples = examples.filter((example) => {
      const example_tree = getTree(example)

      return _isTypeMatch__cached(specs, example_tree, pinType)
    })

    return valid_examples
  }

  private _get_unit_input_data_examples = (
    unitId: string,
    pinId: string
  ): string[] => {
    const { specs } = this.$props

    const unit_spec_id = this._get_unit_spec_id(unitId)

    const examples = findInputDataExamples(specs, unit_spec_id, pinId)

    return examples
  }

  private _is_pin_data_able = (pin_node_id: string) => {
    return (
      this._is_link_input_node_id(pin_node_id) ||
      (this._is_merge_node_id(pin_node_id) &&
        !this._is_output_only_merge(pin_node_id))
    )
  }

  private _yellow_click_pin = (pin_node_id: string): void => {
    // console.log('Graph', '_yellow_click_pin', pin_node_id)

    const { specs } = this.$props

    if (this._is_pin_data_able(pin_node_id)) {
      let value: string

      const pin_datum_tree = this._pin_datum_tree[pin_node_id]

      const current_value = pin_datum_tree && pin_datum_tree.value

      const pin_type = this._get_pin_type(pin_node_id)

      if (this._is_link_pin_node_id(pin_node_id)) {
        const { unitId, pinId } = segmentLinkPinNodeId(pin_node_id)

        const examples = this._get_unit_input_data_valid_examples(
          unitId,
          pinId,
          pin_type
        )

        if (examples.length > 0) {
          if (examples.length === 1) {
            value = examples[0]
          } else {
            value = randomInArray(examples)

            if (examples.length > 1) {
              do {
                value = randomInArray(examples)
              } while (value === current_value)
            }
          }
        } else {
          let i = 0

          do {
            value = randomValueOfType(specs, pin_type)

            if (i++ > 3) {
              // console.warn('Could not find suitable random value.')

              break
            }
          } while (value === current_value)
        }
      } else {
        const { mergeId } = segmentMergeNodeId(pin_node_id)

        const all_examples_set = new Set<string>()
        const all_valid_examples_set = new Set<string>()
        const merge_type = this._get_merge_pin_type(pin_node_id, 'input')

        this._for_each_merge_pin(mergeId, (unitId, type, pinId) => {
          if (type === 'input') {
            const examples = this._get_unit_input_data_valid_examples(
              unitId,
              pinId,
              merge_type
            )

            examples.forEach((example) => all_examples_set.add(example))
          }
        })

        for (const example of all_examples_set) {
          if (isTypeMatch(specs, example, pin_type.value)) {
            all_valid_examples_set.add(example)
          }
        }

        if (all_valid_examples_set.size > 0) {
          value = all_valid_examples_set.values().next().value
        } else {
          let i = 0

          do {
            value = randomValueOfType(specs, pin_type)

            if (i++ > 3) {
              // console.warn('Could not find suitable random value.')

              break
            }
          } while (value === current_value)
        }
      }

      if (value) {
        if (this._is_merge_node_id(pin_node_id)) {
          this.set_merge_pin_data(pin_node_id, value)
        } else if (this._is_link_pin_node_id(pin_node_id)) {
          this.set_unit_pin_data(pin_node_id, value)
        } else {
          throw new CodePathNotImplementedError()
        }
      }
    }
  }

  public add_merge_pin_data = (merge_node_id: string, data: string) => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    this._state_add_merge_pin_data(merge_node_id, data)
    this._pod_set_merge_pin_data(mergeId, data)
  }

  public set_merge_pin_data = (merge_node_id: string, data: string) => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    this._state_set_merge_pin_data(merge_node_id, data)
    this._pod_set_merge_pin_data(mergeId, data)
  }

  private _state_add_merge_pin_data = (merge_node_id: string, data: string) => {
    const datum_id = this._new_datum_id()
    const datum_node_id = getDatumNodeId(datum_id)

    const merge_position = this._get_anchor_node_position(merge_node_id)

    this._sim_add_datum_node(datum_id, data, merge_position)
    this._sim_add_datum_node_link(datum_node_id, merge_node_id, false)
  }

  private _state_set_merge_pin_data = (merge_node_id: string, data: string) => {
    const merge_datum_node_id = this._pin_to_datum[merge_node_id]

    if (merge_datum_node_id) {
      const { datumId } = segmentDatumNodeId(merge_datum_node_id)

      this._sim_set_datum_value(
        datumId,
        merge_datum_node_id,
        merge_node_id,
        data
      )
    } else {
      this._state_add_merge_pin_data(merge_node_id, data)
    }
  }

  private _spec_type_interface_cache: Dict<any> = {}

  private _on_unit_blue_click = (unit_id: string): void => {
    // console.log('Graph', '_on_unit_blue_click', unit_id)

    if (this._search_unit_id === unit_id) {
      return
    }

    this._turn_unit_blue(unit_id)
  }

  private _turn_unit_blue = (unit_id: string) => {
    const { specs } = this.$props

    const spec_id = this._get_unit_spec_id(unit_id)

    if (this._search_start_unit_id) {
      const search_unit_id = this._search_unit_id

      this._abort_search_unit()

      this._refresh_node_color(search_unit_id)
    }

    this._plunk_pod()

    const position = this._get_node_position(unit_id)

    this._search_to_be_focused_by_click = true

    this._search_start_unit_id = unit_id
    this._search_start_spec_id = spec_id
    this._search_start_unit_position = position
    this._search_start_unit_merges = clone(this._get_unit_merges(unit_id))
    this._search_start_unit_plugs = clone(this._get_unit_plugs(unit_id))
    this._search_start_unit_data = clone(this._get_unit_data(unit_id))
    this._search_start_graph_unit_spec = clone(this._get_unit(unit_id))

    this._search_unit_id = unit_id
    this._search_unit_spec_id = spec_id
    this._search_unit_spec_id_changed = false

    if (this._is_unit_component(unit_id)) {
      this._search_start_component_index = this._sub_component_index[unit_id]
    }

    this._search_unit_merges = this._get_unit_merges(unit_id)

    this._search_unit_merged_pin_ids = {
      input: {
        ref: [],
        data: [],
      },
      output: {
        ref: [],
        data: [],
      },
    }
    this._search_unit_merged_pin_index = {
      input: {
        data: {},
        ref: {},
      },
      output: {
        data: {},
        ref: {},
      },
    }

    this._search_unit_exposed_pin_ids = {
      input: {
        data: {},
        ref: {},
      },
      output: {
        data: {},
        ref: {},
      },
    }
    this._search_unit_exposed_pin_count = {
      input: {
        data: 0,
        ref: 0,
      },
      output: {
        data: 0,
        ref: 0,
      },
    }
    this._search_unit_exposed_pin_index = {
      input: {
        data: {},
        ref: {},
      },
      output: {
        data: {},
        ref: {},
      },
    }

    const merged_pin_types: {
      input: {
        ref: TreeNode[]
        data: TreeNode[]
      }
      output: {
        ref: TreeNode[]
        data: TreeNode[]
      }
    } = {
      input: { ref: [], data: [] },
      output: { ref: [], data: [] },
    }

    const exposed_pin_types: {
      input: {
        ref: TreeNode[]
        data: TreeNode[]
      }
      output: {
        ref: TreeNode[]
        data: TreeNode[]
      }
    } = {
      input: { ref: [], data: [] },
      output: { ref: [], data: [] },
    }

    let pin_count: IOOf<{ ref: number; data: number }> = {
      input: {
        ref: 0,
        data: 0,
      },
      output: {
        ref: 0,
        data: 0,
      },
    }

    this._for_each_unit_pin(unit_id, (pin_node_id, type, pin_id) => {
      const opposite_type = opposite(type)

      const merge_node_id = this._pin_to_merge[pin_node_id]
      const plug_node_id = this._pin_to_ext[type][pin_node_id]
      const opposite_plug_node_id = this._pin_to_ext[opposite_type][pin_node_id]

      const int_node_id = this._pin_to_int[type][pin_node_id]
      const opposite_int_node_id = this._pin_to_int[opposite_type][pin_node_id]

      const input = type === 'input'

      const ref = this._is_link_pin_ref(pin_node_id)

      const tag = ref ? 'ref' : 'data'

      let pin_type: TreeNode

      if (merge_node_id) {
        this._search_unit_merged_pin_ids[type][tag].push(pin_id)

        const opposite_kind = oppositePinType(type)
        const merge = this._get_merge(merge_node_id)

        const _merge = _dissoc(merge, unit_id)

        const merge_type = this._get_merge_spec_type(_merge, opposite_kind)

        pin_type = merge_type

        this._search_unit_merged_pin_index[type][tag][pin_id] =
          pin_count[type][tag]
      }

      if (plug_node_id) {
        const plug_type = this._get_plug_type(plug_node_id)

        pin_type = pin_type ? _mostSpecific(plug_type, pin_type) : plug_type

        this._search_unit_exposed_pin_index[type][tag][pin_id] =
          pin_count[type][tag]
      }

      if (opposite_plug_node_id) {
        const plug_type = this._get_plug_type(opposite_plug_node_id)

        pin_type = pin_type ? _mostSpecific(plug_type, pin_type) : plug_type

        this._search_unit_exposed_pin_index[type][tag][pin_id] =
          pin_count[opposite_type][tag]
      }

      if (pin_type) {
        merged_pin_types[type][tag].push(pin_type)

        pin_count[type][tag]++
      }

      if (int_node_id) {
        const { pinId, subPinId } = segmentPlugNodeId(int_node_id)

        this._search_unit_exposed_pin_ids[type][tag][pin_id] = [
          pinId,
          subPinId,
          type,
        ]
        this._search_unit_exposed_pin_count[type][tag]++
      }

      if (opposite_int_node_id) {
        const {
          pinId,
          subPinId,
          type: type_,
        } = segmentPlugNodeId(opposite_int_node_id)

        this._search_unit_exposed_pin_ids[type][tag][pin_id] = [
          pinId,
          subPinId,
          opposite_type,
        ]
        this._search_unit_exposed_pin_count[type][tag]++
      }
    })

    const search_unit_merge_input_data =
      this._search_unit_merged_pin_ids.input.data
    const search_unit_merge_input_ref =
      this._search_unit_merged_pin_ids.input.ref

    const merge_input_data_count = search_unit_merge_input_data.length
    const merge_input_ref_count = search_unit_merge_input_ref.length

    const search_unit_merge_output_data =
      this._search_unit_merged_pin_ids.output.data
    const search_unit_merge_output_ref =
      this._search_unit_merged_pin_ids.output.ref

    const merge_output_data_count = search_unit_merge_output_data.length
    const merge_output_ref_count = search_unit_merge_output_ref.length

    const search_unit_merge_input_count =
      merge_input_data_count + merge_input_ref_count
    const search_unit_merge_output_count =
      merge_output_data_count + merge_output_ref_count

    const search_unit_exposed_input_count =
      this._search_unit_exposed_pin_count['input']
    const search_unit_exposed_output_count =
      this._search_unit_exposed_pin_count['output']

    const exposed_input_data_count = search_unit_exposed_input_count.data
    const exposed_input_ref_count = search_unit_exposed_input_count.ref
    const exposed_output_data_count = search_unit_exposed_output_count.data
    const exposed_output_ref_count = search_unit_exposed_output_count.ref

    this._search_option_valid_pin_matches = {}

    const filter = this._make_compatible_search_filter(
      merge_input_data_count,
      merge_input_ref_count,
      merge_output_data_count,
      merge_output_ref_count,
      exposed_input_data_count,
      exposed_input_ref_count,
      exposed_output_data_count,
      exposed_output_ref_count,
      merged_pin_types,
      (id, match) => {
        this._search_option_valid_pin_matches[id] = match
      }
    )

    this._set_search_text('')
    this._set_search_filter(filter)
    this._set_search_selected(spec_id)
    this._show_search()
  }

  private _make_compatible_search_filter = (
    merge_input_data_count: number,
    merge_input_ref_count: number,
    merge_output_data_count: number,
    merge_output_ref_count: number,
    exposed_input_data_count: number,
    exposed_input_ref_count: number,
    exposed_output_data_count: number,
    exposed_output_ref_count: number,
    merged_pin_types: {
      input: {
        ref: TreeNode[]
        data: TreeNode[]
      }
      output: {
        ref: TreeNode[]
        data: TreeNode[]
      }
    },
    on_found_valid_match = (
      id: string,
      match: {
        input: {
          data: [number, number][][]
          ref: [number, number][][]
        }
        output: {
          data: [number, number][][]
          ref: [number, number][][]
        }
      }
    ) => {}
  ) => {
    return (id: string) => {
      const { specs } = this.$props

      const inputs = getSpecInputs(specs, id)
      const outputs = getSpecOutputs(specs, id)

      const pins = {
        input: inputs,
        output: outputs,
      }

      const input_ids = keys(inputs)
      const output_ids = keys(outputs)

      const pin_ids = {
        input: input_ids,
        output: output_ids,
      }

      const filter_pin_ids = (type: IO, _ref: boolean): string[] => {
        return pin_ids[type].filter((input_id) => {
          const i = pins[type][input_id]
          const { ref } = i
          return !!ref === _ref
        })
      }

      const input_data_ids = filter_pin_ids('input', false)
      const input_ref_ids = filter_pin_ids('input', true)
      const output_data_ids = filter_pin_ids('output', false)
      const output_ref_ids = filter_pin_ids('output', true)

      const input_data_count = input_data_ids.length
      const input_ref_count = input_ref_ids.length
      const output_data_count = output_data_ids.length
      const output_ref_count = output_ref_ids.length

      const input_count = input_ids.length
      const output_count = output_ids.length

      const { input: input_type, output: output_type } =
        _getSpecTypeInterfaceById(
          id,
          specs,
          this._spec_type_interface_cache,
          {}
        )

      const data_input_types = input_data_ids.map(
        (input_id) => input_type[input_id]
      )
      const ref_input_types = input_ref_ids.map(
        (input_id) => input_type[input_id]
      )
      const data_output_types = output_data_ids.map(
        (output_id) => output_type[output_id]
      )
      const ref_output_types = output_ref_ids.map(
        (output_id) => output_type[output_id]
      )

      if (
        input_data_count >= merge_input_data_count + exposed_input_data_count &&
        input_ref_count >= merge_input_ref_count + exposed_input_ref_count &&
        output_data_count >=
          merge_output_data_count + exposed_output_data_count &&
        output_ref_count >= merge_output_ref_count + exposed_output_ref_count
      ) {
        if (this._search_option_valid_pin_matches[id]) {
          on_found_valid_match(id, this._search_option_valid_pin_matches[id])

          return true
        } else {
          const data_input_matches = _matchAllExcTypes(
            specs,
            merged_pin_types.input.data,
            data_input_types
          )
          const ref_input_matches = _matchAllExcTypes(
            specs,
            merged_pin_types.input.ref,
            ref_input_types
          )

          const valid_data_input_matches = data_input_matches.filter(
            (input_match) => {
              return (
                input_match.length ===
                merge_input_data_count + exposed_input_data_count
              )
            }
          )

          const valid_ref_input_matches = ref_input_matches.filter(
            (input_match) => {
              return (
                input_match.length ===
                merge_input_ref_count + exposed_input_ref_count
              )
            }
          )

          if (
            (merge_input_data_count + exposed_input_data_count > 0 &&
              valid_data_input_matches.length === 0) ||
            (merge_input_ref_count + exposed_input_ref_count > 0 &&
              valid_ref_input_matches.length === 0)
          ) {
            return false
          }

          const data_output_matches = _matchAllExcTypes(
            specs,
            merged_pin_types.output.data,
            data_output_types
          )
          const ref_output_matches = _matchAllExcTypes(
            specs,
            merged_pin_types.output.ref,
            ref_output_types
          )

          const valid_data_output_matches = data_output_matches.filter(
            (output_match) => {
              return (
                output_match.length ===
                merge_output_data_count + exposed_output_data_count
              )
            }
          )

          const valid_ref_output_matches = ref_output_matches.filter(
            (output_match) => {
              return (
                output_match.length ===
                merge_output_ref_count + exposed_output_ref_count
              )
            }
          )

          if (
            (merge_output_data_count + exposed_output_data_count > 0 &&
              valid_data_output_matches.length === 0) ||
            (merge_output_ref_count + exposed_output_ref_count > 0 &&
              valid_ref_output_matches.length === 0)
          ) {
            return false
          }

          const match = {
            input: {
              ref: valid_ref_input_matches,
              data: valid_data_input_matches,
            },
            output: {
              data: valid_data_output_matches,
              ref: valid_ref_output_matches,
            },
          }

          on_found_valid_match(id, match)
        }

        return true
      } else {
        return false
      }
    }
  }

  private _change_datum = (datum_node_id: string): void => {
    // console.log('Graph', '_change_datum', datum_node_id)

    const { classes } = this.$system
    const { specs } = this.$props

    const { datumId } = segmentDatumNodeId(datum_node_id)
    const tree = this._datum_tree[datumId]
    const value = tree.value

    const type = _getValueType(specs, tree)

    const pin_node_id = this._datum_to_pin[datum_node_id]

    if (pin_node_id) {
      this._yellow_click_pin(pin_node_id)
    } else {
      let next_value: string

      do {
        next_value = randomValueOfType(specs, type)
      } while (value === next_value && value !== 'null')

      const next_tree = _getValueTree__cached(next_value)

      let datum = this._datum[datum_node_id]

      if (next_tree.type === TreeNodeType.Unit) {
        datum = datum as ClassDatum

        const { value } = next_tree

        const id = idFromUnitValue(value, specs, classes)

        datum.setProp('id', id)
        datum.dispatchEvent('datumchange', { data: getTree(id) })

        this._datum_tree[datumId] = next_tree

        this._refresh_class_literal_datum_node_selection(datum_node_id)
      } else {
        datum = datum as Datum

        datum.setProp('data', next_tree)
        datum.dispatchEvent('datumchange', { data: next_tree })
      }
    }

    this._refresh_node_color(datum_node_id)
  }

  private _toggle_link_pin_constant = (pin_node_id: string): void => {
    // console.log('_toggle_link_pin_constant', pin_node_id)

    const constant = this._is_link_pin_constant(pin_node_id)

    this.set_link_pin_constant(pin_node_id, !constant)
  }

  private _toggle_link_pin_ref = (pin_node_id: string): void => {
    return

    const ref = this._is_link_pin_ref(pin_node_id)

    this._set_link_pin_ref(pin_node_id, !ref)
  }

  private _is_exposed_pin_functional = (exposed_node_id: string): boolean => {
    const { type, pinId } = segmentPlugNodeId(exposed_node_id)

    return this.__is_exposed_pin_functional(type, pinId)
  }

  private __is_exposed_pin_functional = (type: IO, id: string): boolean => {
    const pin_spec = this._get_pin_spec(type, id)

    const { functional } = pin_spec

    return !!functional
  }

  private _toggle_exposed_pin_functional = (exposed_node_id: string): void => {
    const { type } = segmentPlugNodeId(exposed_node_id)

    if (type === 'output') {
      return
    }

    const functional = this._is_exposed_pin_functional(exposed_node_id)

    this._set_exposed_pin_functional(exposed_node_id, !functional)
  }

  public set_exposed_pin_functional = (
    exposed_node_id: string,
    functional: boolean
  ) => {
    const { type, pinId } = segmentPlugNodeId(exposed_node_id)

    this._dispatch_action(
      makeSetPinSetFunctionalAction(type, pinId, functional)
    )

    this._set_exposed_pin_functional(exposed_node_id, functional)
  }

  private _set_exposed_pin_functional = (
    exposed_node_id: string,
    functional: boolean,
    emit: boolean = true
  ): void => {
    this._spec_set_exposed_pin_functional(exposed_node_id, functional)
    this._sim_set_exposed_pin_functional(exposed_node_id, functional)
    emit && this._pod_set_exposed_pin_functional(exposed_node_id, functional)
  }

  private _spec_set_exposed_pin_functional = (
    exposed_node_id: string,
    functional: boolean
  ): void => {
    const { type, pinId } = segmentPlugNodeId(exposed_node_id)

    setPinSetFunctional({ type, pinId, functional }, this._spec)
  }

  private _sim_set_exposed_pin_functional = (
    exposed_node_id: string,
    functional: boolean
  ): void => {
    const { type, pinId } = segmentPlugNodeId(exposed_node_id)
    const pin_spec = this._get_pin_spec(type, pinId)
    const { plug = {} } = pin_spec
    for (let subPinId in plug) {
      const ext_node_id = getExtNodeId(type, pinId, subPinId)
      const end_marker = this._exposed_link_end_marker[ext_node_id]
      if (type === 'input') {
        end_marker.setProp(
          'd',
          `${functional ? ARROW_MEMORY : ''}${ARROW_SEMICIRCLE}`
        )
      } else {
        end_marker.setProp('d', `${functional ? ARROW_MEMORY : ''}`)
      }
    }
  }

  private _pod_set_exposed_pin_functional = (
    exposed_node_id: string,
    functional: boolean
  ): void => {
    // console.log('_pod_set_exposed_pin_functional', exposed_node_id, functional)

    const { fork, bubble } = this.$props

    const { type, pinId } = segmentPlugNodeId(exposed_node_id)

    this._pod.$setPinSetFunctional({
      type,
      pinId,
      functional,
      fork,
      bubble,
    })
  }

  public _spec_set_exposed_pin_ref = (
    type: IO,
    pinId: string,
    ref: boolean
  ): void => {
    setPinSetRef({ type, pinId, ref }, this._spec)
  }

  private set_link_pin_constant = (
    pin_node_id: string,
    constant: boolean
  ): void => {
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    this._dispatch_action(
      makeSetUnitPinConstantAction(unitId, type, pinId, constant)
    )

    this._set_link_pin_constant(pin_node_id, constant)
  }

  private _set_link_pin_constant = (
    pin_node_id: string,
    constant: boolean,
    emit: boolean = true
  ): void => {
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    this._state_set_unit_pin_constant(pin_node_id, constant)
    emit && this._pod_set_link_pin_constant(unitId, type, pinId, constant)
  }

  private _set_unit_memory(unit_id: string, memory: Memory) {
    const add_pin_datum = (type: IO, pin_id: string) => {
      const pin_node_id = getPinNodeId(unit_id, type, pin_id)

      const { _register } = memory[type][pin_id]

      if (_register !== undefined) {
        const new_datum_id = this._new_datum_id()

        const tree = getTree__cached(_register)

        const position = this._predict_pin_datum_initial_position(pin_node_id)
        this._sim_add_pin_datum_tree(
          unit_id,
          type,
          pin_id,
          new_datum_id,
          tree,
          position,
          false
        )
      }
    }

    if (memory) {
      const { input, output } = memory

      for (const input_id in input) {
        add_pin_datum('input', input_id)
      }

      for (const output_id in output) {
        add_pin_datum('output', output_id)
      }
    }
  }

  private _state_set_unit_pin_constant(pin_node_id: string, constant: boolean) {
    // console.log('_state_set_link_pin_constant', pin_node_id, constant)

    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    this._spec_set_unit_pin_constant(unitId, type, pinId, constant)
    this._sim_set_unit_pin_constant(pin_node_id, constant)
  }

  private _sim_set_unit_pin_constant = (
    pin_node_id: string,
    constant: boolean
  ): void => {
    // console.log('_sim_set_unit_pin_constant', pin_node_id, constant)

    const link_id = getPinLinkIdFromPinNodeId(pin_node_id)
    const link_base = this._link_base[link_id]
    if (constant) {
      this._link_pin_constant_count++

      link_base.$element.style.strokeDasharray = '3'
    } else {
      this._link_pin_constant_count--

      link_base.$element.style.strokeDasharray = ''
    }
  }

  private _pod_set_link_pin_constant = (
    unitId: string,
    type: IO,
    pinId: string,
    constant: boolean
  ) => {
    const { fork, bubble } = this.$props

    this._pod.$setUnitPinConstant({
      unitId,
      type,
      pinId,
      constant,
      fork,
      bubble,
    })
  }

  private _set_link_pin_ref = (pin_node_id: string, ref: boolean): void => {
    // console.log('Graph', '_set_link_pin_ref', pin_node_id, ref)

    const { $theme } = this.$context

    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    const link_id = getPinLinkIdFromPinNodeId(pin_node_id)

    const link_base = this._link_base[link_id]
    const link_arrow = this._pin_link_end_marker[pin_node_id]
    const link = this._link[link_id]

    if (ref) {
      this._link_pin_memory_count++

      link_base.$element.style.strokeWidth = '1px'
    } else {
      this._link_pin_memory_count--

      link_base.$element.style.strokeWidth = '3px'
    }

    let pin_link_current_color = this._theme.link

    if (
      this._hover_node_id[pin_node_id] &&
      ['add', 'remove', 'change'].indexOf(this._mode) > -1
    ) {
      pin_link_current_color = getThemeLinkModeColor($theme, this._mode)
    }

    const pin_link_end_marker_d = ref ? ARROW_MEMORY : ARROW_NORMAL
    const pin_link_end_marker_fill = ref ? 'none' : pin_link_current_color
    const pin_link_end_marker_stroke = ref ? pin_link_current_color : 'none'
    const pin_link_end_marker_stroke_width = ref ? '1px' : '0'

    link_arrow.setProp('d', pin_link_end_marker_d)

    link_arrow.$element.style.fill = pin_link_end_marker_fill
    link_arrow.$element.style.stroke = pin_link_end_marker_stroke
    link_arrow.$element.style.strokeWidth = pin_link_end_marker_stroke_width

    link.padding = link.padding || { source: 0, target: 0 }

    if (ref) {
      link.padding.target = -1
    } else {
      link.padding.target = -5.75
    }
    this._tick_link(link_id)

    this._spec_set_link_pin_ref(unitId, type, pinId, ref)
  }

  private _on_node_double_click = (
    node_id: string,
    event: UnitPointerEvent
  ) => {
    // console.log('Graph', '_on_node_double_click', node_id)
    const { pointerId } = event

    if (this._resize_node_id_pointer_id[node_id]) {
      return
    }

    if (this._is_unit_node_id(node_id)) {
      this._on_unit_double_click(node_id, event)
    } else if (this._is_pin_node_id(node_id)) {
      this._on_pin_double_click(node_id, event)
    } else if (this._is_datum_node_id(node_id)) {
      this._on_datum_double_click(node_id, event)
    } else if (this._is_plug_node_id(node_id)) {
      this._on_plug_double_click(node_id, event)
    }
  }

  private _on_pin_double_click = (
    pin_node_id: string,
    event: UnitPointerEvent
  ): void => {
    const { config } = this.$props

    if (this._mode === 'none') {
      if (
        this._is_link_input_node_id(pin_node_id) ||
        (this._is_merge_node_id(pin_node_id) &&
          !this._is_output_only_merge(pin_node_id))
      ) {
        if (
          this._is_link_pin_node_id(pin_node_id) &&
          this._is_link_pin_ref(pin_node_id)
        ) {
          return
        }

        if (this._is_node_selected(pin_node_id)) {
          this.deselect_node(pin_node_id)
        }

        const pin_datum_node_id = this._get_pin_datum_node_id(pin_node_id)

        if (pin_datum_node_id) {
          if (!config?.dataEdit) {
            return
          }

          const { datumId } = segmentDatumNodeId(pin_datum_node_id)

          this._show_datum(pin_datum_node_id)
          this._unlock_datum(pin_datum_node_id)
          this._focus_datum(datumId, [])
        } else {
          if (!config?.dataCreate) {
            return
          }

          const datum_id = this._new_datum_id()
          const position = this._pin_line_position(pin_node_id, LINK_DISTANCE)

          const datum_node_id = getDatumNodeId(datum_id)

          this._add_empty_datum(datum_id, position)

          this._sim_add_pin_datum_link(datum_node_id, pin_node_id, false)

          this._unlock_datum(datum_node_id)
          this._focus_datum(datum_id, [])
        }
      }
    } else {
      this._on_node_click(pin_node_id, event)
    }
  }

  private _is_datum_editable = (datum_node_id: string): boolean => {
    // const datum_pin_node_id = this._datum_to_pin[datum_node_id]

    // if (datum_pin_node_id) {
    //   if (this._is_output_node_id(datum_pin_node_id)) {
    //     return false
    //   }
    // }

    return true
  }

  private _on_datum_double_click = (
    datum_node_id: string,
    event: UnitPointerEvent
  ) => {
    // console.log('Graph', '_on_datum_double_click', datum_node_id)

    if (this._mode === 'none') {
      this._on_datum_none_double_click(datum_node_id, event)
    } else if (this._mode === 'multiselect') {
      this._on_datum_multiselect_double_click(datum_node_id, event)
    } else if (this._mode === 'data') {
      this._on_data_background_double_click(event)
    } else {
      this._on_node_click(datum_node_id, event)
    }
  }

  private _on_plug_double_click = (
    plug_node_id: string,
    event: UnitPointerEvent
  ) => {
    // console.log('Graph', '_on_plug_double_click', plug_node_id)

    const { type, pinId, subPinId } = segmentPlugNodeId(plug_node_id)

    const ext_node_id = getExtNodeId(type, pinId, subPinId)

    if (this._mode === 'none') {
      const plug_datum_node_id = this._plug_to_datum[ext_node_id]

      if (plug_datum_node_id) {
        //
      } else {
        const datum_id = this._new_datum_id()

        const datum_node_id = getDatumNodeId(datum_id)

        const tree = getTree('')

        const position = this._predict_plug_data_initial_position(
          ext_node_id,
          tree
        )

        this._add_empty_datum(datum_id, position)

        this._sim_add_plug_datum_link(ext_node_id, datum_node_id)
      }
    } else if (this._mode === 'multiselect') {
      //
    } else if (this._mode === 'data') {
      //
    } else {
      //
    }
  }

  private _on_unit_double_click = (
    unit_id: string,
    event: UnitPointerEvent
  ): void => {
    // this.dispatchEvent('unit-double-click', { id: unit_id }

    if (this._mode === 'none') {
      if (!this._resize_node_id_pointer_id[unit_id]) {
        if (this._is_unit_component(unit_id)) {
          if (!this._clicked_node_already_selected) {
            this._deselect_node(unit_id)
            this._enable_core_resize(unit_id)
          }

          this._unlock_drag_initiated = false

          this._unlock_sub_component(unit_id, true)
          this._focus_sub_component(unit_id)
        }
      }
    } else {
      this._on_node_click(unit_id, event)
    }
  }

  private _focus_sub_component = (unit_id: string): void => {
    // console.log('Graph', '_focus_sub_component', unit_id)
    const sub_component = this._get_sub_component(unit_id)

    sub_component.focus()
  }

  private _focus_sub_component_frame = (unit_id: string): void => {
    // console.log('Graph', '_focus_sub_component_frame', unit_id)
    const sub_component_frame = this._get_sub_component_frame(unit_id)

    sub_component_frame.focus()
  }

  private _blur_sub_component = (unit_id: string): void => {
    // console.log('Graph', '_blur_sub_component', unit_id)
    const sub_component = this._get_sub_component(unit_id)
    sub_component.blur()
  }

  private _is_sub_component_fullwindow = (
    sub_component_id: string
  ): boolean => {
    const is_ascended = this._fullwindow_component_set.has(sub_component_id)
    return is_ascended
  }

  private _subgraph_return_fullwindow = false
  private _subgraph_return_fullwindow_component_ids: string[] = []

  public enter_subgraph = (unit_id: string, animate: boolean): void => {
    this._enter_subgraph(unit_id, animate)
  }

  private _unplug_sub_component_root_base_frame = (
    sub_component_id: string
  ) => {
    const base = this._get_sub_component_root_base(sub_component_id)

    return this._unplug_base_frame(sub_component_id, base)
  }

  private _unplug_sub_component_base_frame = (sub_component_id: string) => {
    // console.log('Graph', '_unplug_sub_component_base_frame', sub_component_id)

    const base = this._get_sub_component_base(sub_component_id)

    return this._unplug_base_frame(sub_component_id, base)
  }

  private _unplug_base_frame = (sub_component_id: string, base: LayoutBase) => {
    // console.log(
    //   'Graph',
    //   '_unplug_base_frame',
    //   sub_component_id,
    //   base,
    //   base.length
    // )

    for (const leaf of base) {
      const [leaf_path, leaf_comp] = leaf

      const leaf_id = joinPath([sub_component_id, ...leaf_path])

      if (this._leaf_frame_active[leaf_id]) {
        this._unplug_leaf_frame(leaf_id, leaf_comp as any)
      }
    }
  }

  public mem_enter_subgraph = (unit_id: string, graph: Editor_) => {
    this._mem_enter_subgraph(unit_id, graph)
  }

  private _mem_enter_subgraph = (unit_id: string, graph: Editor_) => {
    this._subgraph_unlisten = graph.addEventListeners([
      makeCustomListener('leave', this._on_subgraph_leave),
      makeCustomListener('enterunit', this._on_subgraph_enter_unit),
      makeCustomListener('leaveunit', this._on_subgraph_leave_unit),
    ])

    this._subgraph_fork = this._mode !== 'info'
    this._subgraph_graph = graph
    this._subgraph_unit_id = unit_id
    this._subgraph_depth = 1 + graph.get_subraph_depth()
  }

  public dom_enter_subgraph = (
    unit_id: string,
    graph: Editor_,
    animate: boolean
  ) => {
    this._dom_enter_subgraph(animate)
  }

  private _main_opacity_animation: Animation

  private _animate_main_opacity = (to: number) => {
    if (this._main_opacity_animation) {
      flushAnimation(this._main_opacity_animation)
    }

    this._main_opacity_animation = this._animate_element_opacity(
      this._main.$element,
      to
    )
  }

  private _dom_enter_subgraph = (animate: boolean) => {
    mergePropStyle(this._subgraph_graph, {
      opacity: '1',
      pointerEvents: 'inherit',
      transition: ifLinearTransition(animate, 'opacity'),
    })

    this._subgraph.$element.style.pointerEvents = 'inherit'

    this._main.$element.style.pointerEvents = 'none'

    if (animate) {
      this._animate_main_opacity(LAYER_OPACITY_MULTIPLIER)
    } else {
      this._main.$element.style.opacity = `${LAYER_OPACITY_MULTIPLIER}`
    }
  }

  private _dom_leave_subgraph = (animate: boolean) => {
    mergePropStyle(this._subgraph_graph, {
      opacity: '0',
      pointerEvents: 'none',
      transition: ifLinearTransition(animate, 'opacity'),
    })

    this._subgraph.$element.style.pointerEvents = 'none'

    this._main.$element.style.pointerEvents = 'inherit'

    if (animate) {
      this._animate_main_opacity(1)
    } else {
      this._main.$element.style.opacity = '1'
    }
  }

  private _ensure_graph_and__template = (
    unit_id: string,
    { color, fullwindow }: { color?: string; fullwindow?: boolean } = {},
    callback: Callback
  ) => {
    return (...args) => {
      this._ensure_subgraph(unit_id, { color, fullwindow })

      callback(...args)
    }
  }

  private _ensure_subgraph = (
    unit_id: string,
    { color, fullwindow }: { color?: string; fullwindow?: boolean } = {}
  ): Editor_ => {
    const {
      fork,
      specs,
      typeCache,
      frame,
      frameOut,
      container,
      config,
      hasSpec,
      emptySpec,
      getSpec,
      setSpec,
      newSpec,
      deleteSpec,
      forkSpec,
      shouldFork,
      injectSpecs,
      registerUnit,
      unregisterUnit,
      lockSpec,
      unlockSpec,
      newSpecId,
      dispatchEvent,
      enterFullwindow,
      leaveFullwindow,
    } = this.$props

    const { animate } = this._config()

    let graph = this._subgraph_cache[unit_id]

    if (graph) {
      //
    } else {
      let sub_component = this._get_sub_component(unit_id)

      if (!sub_component) {
        sub_component = parentComponent({}, this.$system)
      }

      const pod = this._get_subgraph_pod(unit_id)

      graph = new Editor_(
        {
          graph: pod,
          style: {
            color,
            opacity: '0',
            pointerEvents: 'none',
            transition: ifLinearTransition(animate, 'opacity'),
          },
          disabled: true,
          parent: this,
          frame,
          config,
          container,
          frameOut,
          fullwindow,
          fork: this._subgraph_fork,
          bubble: fork,
          component: sub_component,
          system: this._system,
          typeCache,
          specs,
          hasSpec,
          emptySpec,
          getSpec,
          setSpec,
          newSpec,
          deleteSpec,
          forkSpec,
          injectSpecs,
          registerUnit,
          shouldFork,
          lockSpec,
          unlockSpec,
          unregisterUnit,
          newSpecId,
          dispatchEvent,
          enterFullwindow,
          leaveFullwindow,
        },
        this.$system
      )

      this.cache_subgraph(unit_id, graph)
    }

    return graph
  }

  private _enter_subgraph = (
    unit_id: string,
    _animate?: boolean,
    opt?: Dict<{ base: LayoutBase; base_node: LayoutNode[] }>
  ): void => {
    const { specs } = this.$props

    const {
      api: {
        text: { measureText },
      },
    } = this.$system

    const { dispatchEvent } = this.$props

    let { animate } = this._config()

    if (_animate !== undefined) {
      animate = _animate
    }

    this._force_control_animation_false = true

    const unit: GraphUnitSpec = this._get_unit(unit_id)

    const { id } = unit

    if (isBaseSpecId(specs, id)) {
      return
    }

    const color = this._get_color()

    for (const component_id in this._selected_component) {
      this._disable_core_resize(component_id)
    }

    const is_component = this._is_unit_component(unit_id)

    let fullwindow = false

    let sub_component = this._get_sub_component(unit_id)

    const was_animating_leave =
      !!this._abort_sub_component_leave_base_animation[unit_id]

    if (is_component) {
      this._set_sub_component_controlled(unit_id, true)

      this._cancel_enter_sub_component_animation(unit_id)
      this._cancel_leave_sub_component_animation(unit_id)

      if (this._animating_sub_component_fullwindow.has(unit_id)) {
        this._cancel_fullwindow_animation()
        this._end_leave_fullwindow_animation([unit_id])

        this._animating_sub_component_base_id.delete(unit_id)
      }

      if (this._is_sub_component_fullwindow(unit_id)) {
        fullwindow = true
      }

      if (!opt) {
        opt = {}

        for (const sub_sub_component_id in sub_component.$subComponent) {
          const sub_sub_component =
            sub_component.$subComponent[sub_sub_component_id]

          const base = sub_sub_component.getRootBase()

          const base_node = []

          for (const sub_sub_component_leaf of base) {
            const [leaf_path, leaf_comp] = sub_sub_component_leaf

            const leaf_offset = leaf_comp.getOffset()

            const leaf_trait = extractTrait(leaf_offset, measureText)

            leaf_trait.x -= this.$context.$x
            leaf_trait.y -= this.$context.$y

            base_node.push(leaf_trait)
          }

          opt[sub_sub_component_id] = { base, base_node }
        }
      }
    }

    if (this._is_fullwindow) {
      this._subgraph_return_fullwindow = true
      this._subgraph_return_fullwindow_component_ids =
        this._fullwindow_component_ids

      this._leave_all_fullwindow(true)
    }

    const animating_sub_component = this._is_sub_component_animating(unit_id)

    if (is_component) {
      if (animating_sub_component) {
        const sub_component = this._get_sub_component(unit_id)

        this._unplug_sub_component_root_base_frame(unit_id)
        this._cancel_layout_sub_component_animation(unit_id)
        this._uncollapse_sub_component(unit_id)
        this._cancel_enter_sub_component_animation(unit_id)
        this._unplug_leaf_frame(unit_id, sub_component)

        const base = this._get_sub_component_base(unit_id)

        this._unplug_base_frame(unit_id, base)
      } else {
        this._decompose_sub_component(unit_id)
        this._leave_sub_component_frame(unit_id)
      }
    }

    const graph = this._ensure_subgraph(unit_id, { color, fullwindow })

    this._mem_enter_subgraph(unit_id, graph)

    this._disable_input()
    this._disable_transcend()

    const can_uncollapse = !was_animating_leave

    this._dom_enter_subgraph(animate)

    graph.setProp('fork', this._subgraph_fork)

    graph.focus()

    graph.enter(
      animate,
      opt,
      !animating_sub_component,
      can_uncollapse,
      this._main_opacity_animation?.finished
    )

    dispatchEvent('enterunit', {}, false)
  }

  private _on_datum_multiselect_double_click(
    datum_node_id: string,
    event: UnitPointerEvent
  ) {
    this._on_node_click(datum_node_id, event)
  }

  private _on_datum_none_double_click(
    datum_node_id: string,
    event: UnitPointerEvent
  ) {
    const {
      api: {
        document: { elementFromPoint },
      },
    } = this.$system

    const { config } = this.$props

    if (config?.dataEdit) {
      if (this._is_datum_editable(datum_node_id)) {
        if (!this._clicked_node_already_selected) {
          this._deselect_node(datum_node_id)
        }

        this._unlock_datum(datum_node_id)

        const { screenX, screenY } = event

        const leaf = elementFromPoint(screenX, screenY)

        // AD HOC
        if (leaf.className === 'data-tree-leaf') {
          // @ts-ignore
          leaf.focus && leaf.focus()
        } else {
          const { datumId } = segmentDatumNodeId(datum_node_id)

          this._focus_datum(datumId, [])
        }
      }
    } else {
      this._on_node_click(datum_node_id, event)
    }
  }

  public cache_subgraph(unit_id: string, graph: Editor_) {
    // console.log('Graph', 'cache_subgraph', unit_id)

    this._subgraph_cache[unit_id] = graph

    this._subgraph.appendChild(graph)
  }

  private _in_component_control: boolean = false

  public _take_component_control = (): void => {
    // console.log('Graph', '_take_component_control')

    if (this._in_component_control) {
      return
    }

    this._in_component_control = true

    if (this._is_fullwindow) {
      this._enter_component_frame()
      this._couple_all_fullwindow_component()
    } else {
      for (const sub_component_id in this._spec?.component?.subComponents) {
        if (!this._is_sub_component_animating(sub_component_id)) {
          this._enter_sub_component_frame(sub_component_id)
        }
      }
    }
  }

  public _lose_component_control = (): void => {
    // console.log('Graph', '_lose_component_control')

    if (!this._in_component_control) {
      return
    }

    this._in_component_control = false

    if (this._is_fullwindow) {
      this._decouple_all_fullwindow_component()
      this._leave_component_frame()
    } else {
      for (const sub_component_id in this._component.$subComponent) {
        if (!this._is_sub_component_animating(sub_component_id)) {
          this._leave_sub_component_frame(sub_component_id)
        }
      }
    }
  }

  private _end_sub_component_enter_base_animation = (
    sub_component_id: string
  ) => {
    // console.log(
    //   'Graph',
    //   '_end_sub_component_enter_base_animation',
    //   sub_component_id
    // )

    this._unplug_sub_component_root_base_frame(sub_component_id)
    // this._append_sub_component_all_root(sub_component_id)
    this._append_sub_component_root_base(sub_component_id)

    if (this._in_component_control) {
      this._enter_sub_component_frame(sub_component_id)
    }

    delete this._abort_sub_component_enter_base_animation[sub_component_id]
  }

  private _animate_enter = (
    animate_config: Dict<{ base: LayoutBase; base_node: LayoutNode[] }> = {},
    component_collapsed: boolean,
    should_uncollapse: boolean = true,
    wait_for: Promise<void> = Promise.resolve()
  ) => {
    // console.log('Graph', '_animate_enter', animate_config)

    const {
      api: {
        text: { measureText },
      },
    } = this.$system

    const leaf_layer = this._foreground

    this._leaf_layer_offset_x = 0
    this._leaf_layer_offset_y = 0

    const sub_component_ids = keys(this._component.$subComponent)

    const ordered_sub_component_ids = [
      ...this._order_sub_component_ids(sub_component_ids),
    ]

    for (const sub_component_id of ordered_sub_component_ids) {
      const frame = this._get_sub_component_frame(sub_component_id)

      if (!animate_config[sub_component_id]) {
        continue
      }

      const { base, base_node } = animate_config[sub_component_id]

      let i = 0

      for (const leaf of base) {
        const [leaf_path] = leaf

        const leaf_id = joinPath([sub_component_id, ...leaf_path])

        const leaf_node = base_node[i]

        this._leaf_frame_node[leaf_id] = leaf_node

        i++
      }

      if (component_collapsed) {
        if (!this._animating_sub_component_base_id.has(sub_component_id)) {
          this._remove_sub_component_root_base(sub_component_id)
        }
      } else {
        if (should_uncollapse) {
          const sub_component = this._get_sub_component(sub_component_id)

          if (sub_component.$primitive) {
            this._uncollapse_sub_component(sub_component_id)
          }
        }
      }

      const trait = extractTrait(frame, measureText)
      const style = extractStyle(frame, trait, measureText)

      if (!this._animating_sub_component_base_id.has(sub_component_id)) {
        this._plug_sub_component_base(
          sub_component_id,
          base,
          base_node,
          leaf_layer
        )
      }

      let base_trait = this._reflect_sub_component_base_trait(
        sub_component_id,
        base,
        style,
        trait,
        false
      )

      const base_length = base.length

      i = 0

      this._abort_sub_component_enter_base_animation[sub_component_id] =
        this._plug_animate_sub_component_base(
          sub_component_id,
          base,
          base_node,
          leaf_layer,
          (leaf_id) => {
            if (i === 0) {
              const trait = extractTrait(frame, measureText)
              const frame_style = extractStyle(frame, trait, measureText)

              base_trait = this._reflect_sub_component_base_trait(
                sub_component_id,
                base,
                frame_style,
                trait,
                false
              )
            }

            const trait = base_trait[leaf_id]

            i = (i + 1) % base_length

            return {
              x: -this.$context.$x + trait.x,
              y: -this.$context.$y + trait.y,
              width: trait.width,
              height: trait.height,
              sx: trait.sx,
              sy: trait.sy,
              opacity: trait.opacity,
              fontSize: trait.fontSize,
              color: trait.color,
            }
          },
          async () => {
            await wait_for

            this._end_sub_component_enter_base_animation(sub_component_id)

            return true
          }
        )
    }
  }

  public enter = (
    animate: boolean,
    animate_config: Dict<{ base: LayoutBase; base_node: LayoutNode[] }> = {},
    component_collapsed: boolean = true,
    should_uncollapse: boolean = true,
    wait_for: Promise<any> = Promise.resolve()
  ): void => {
    // console.log('Graph', 'enter', animate, animate_config)

    const {
      api: {
        window: { setTimeout },
      },
    } = this.$system

    this._force_control_animation_false = true
    this._force_trasncend_animation_false = true

    if (animate && !this._fetching_bundle) {
      this._animate_enter(
        animate_config,
        component_collapsed,
        should_uncollapse,
        wait_for
      )
    } else {
      //
    }

    if (this._in_component_control) {
      return
    }

    this._in_component_control = true

    if (this._is_fullwindow) {
      this._enter_component_frame()
      this._couple_all_fullwindow_component()
    } else {
      for (const sub_component_id in this._spec?.component?.subComponents) {
        if (!this._is_sub_component_animating(sub_component_id)) {
          this._enter_sub_component_frame(sub_component_id)
        }
      }
    }

    this._flush_debugger()

    setTimeout(() => {
      this._force_control_animation_false = false
      this._force_trasncend_animation_false = false
    }, 0)
  }

  public _get_base_trait = (sub_base: LayoutBase) => {
    const {
      api: {
        text: { measureText },
      },
    } = this.$system

    const sub_base_node = []

    for (const leaf of sub_base) {
      const [leaf_path, leaf_comp] = leaf

      const leaf_offset = leaf_comp.getOffset()

      const leaf_trait = extractTrait(leaf_comp, measureText)

      leaf_trait.x -= this.$context.$x
      leaf_trait.y -= this.$context.$y

      sub_base_node.push(leaf_trait)
    }

    const all_sub_component_trait = {
      sub_base,
      sub_base_node,
    }

    return all_sub_component_trait
  }

  public _get_all_sub_component_base_trait = () => {
    const base = this._component.getBase()

    return this._get_base_trait(base)
  }

  public leave = (all_sub_component_base_trait?): void => {
    // console.log('Graph', 'leave', all_sub_component_base_trait)

    const { animate } = this._config()

    const sub_component_animating_set = new Set()

    for (const sub_component_id in this._component.$subComponent) {
      if (this._is_sub_component_animating(sub_component_id)) {
        sub_component_animating_set.add(sub_component_id)
      }
    }

    this._cancel_all_enter_sub_component_animation()
    // this._cancel_all_leave_sub_component_animation()

    if (this._subgraph_unit_id) {
      this._subgraph_graph.leave(all_sub_component_base_trait)
    } else {
      const { parent } = this.$props

      this._force_control_animation_false = true
      this._force_trasncend_animation_false = true

      if (parent) {
        const { units, links, merges, data, inputs, outputs } =
          this._segregate_node_id(this._pressed_node_id_pointer_id)

        all_sub_component_base_trait =
          all_sub_component_base_trait ||
          this._get_all_sub_component_base_trait()

        for (const sub_component_id in this._component.$subComponent) {
          if (this._animating_sub_component_base_id.has(sub_component_id)) {
            this._unplug_sub_component_root_base_frame(sub_component_id)
          }

          if (
            this._abort_sub_component_enter_base_animation[sub_component_id]
          ) {
            this._cancel_enter_sub_component_animation(sub_component_id)
            this._unplug_sub_component_base_frame(sub_component_id)
          }

          this._cancel_layout_sub_component_animation(sub_component_id)
        }

        const scale = this._zoom.z

        if (!this._in_component_control) {
          return
        }

        this._in_component_control = false

        if (this._is_fullwindow) {
          this._decouple_all_fullwindow_component()
          this._leave_component_frame()
        } else {
          for (const sub_component_id in this._component.$subComponent) {
            if (!sub_component_animating_set.has(sub_component_id)) {
              this._leave_sub_component_frame(sub_component_id)
            }
          }
        }

        this._disable_transcend()

        this.dispatchEvent(
          'leave',
          {
            clipboard: { units, links, merges, data, inputs, outputs },
            component: all_sub_component_base_trait,
            scale,
          },
          false
        )
      } else {
        if (this._tree_layout) {
          return
        }
      }
    }
  }

  private _can_leave = (): boolean => {
    const { parent } = this.$props

    if (this._tree_layout) {
      return false
    }

    // only accept "leaving" if there is a parent or there is "at least one edit"
    return (
      !!parent ||
      this._unit_count > 1 ||
      this._exposed_pin_set_count > 0 ||
      this._link_pin_constant_count > 0 ||
      this._link_pin_memory_count > 0
    )
  }

  private _get_sub_component_base_trait(sub_component_id: string): {
    base: LayoutBase
    base_node: LayoutNode[]
  } {
    const {
      api: {
        text: { measureText },
      },
    } = this.$system

    const base_node = []

    const base = this._get_sub_component_root_base(sub_component_id)

    for (const sub_component_base_leaf of base) {
      const [_, leaf_comp] = sub_component_base_leaf

      const leaf_node = extractTrait(leaf_comp, measureText)

      base_node.push(leaf_node)
    }

    const _base = base.map(([path, comp]) => [
      [sub_component_id, ...path],
      comp,
    ]) as LayoutBase

    return { base: _base, base_node }
  }

  private _on_subgraph_leave = ({
    clipboard: { units, data },
    component: { sub_base, sub_base_node },
  }: {
    clipboard: {
      units: string[]
      data: string[]
    }
    component: {
      sub_base: LayoutBase
      sub_base_node: LayoutNode[]
    }
    scale: number
  }) => {
    this._leave_subgraph(sub_base, sub_base_node)
  }

  private _on_subgraph_enter_unit = (): void => {
    this._subgraph_depth++
    // console.log('Graph', '_on_subgraph_enter_unit', this._subgraph_depth)
    this._refresh_main_opacity()
  }

  private _on_subgraph_leave_unit = (): void => {
    this._subgraph_depth--
    // console.log('Graph', '_on_subgraph_leave_unit', this._subgraph_depth)
    this._refresh_main_opacity()
  }

  private _refresh_main_opacity = () => {
    let opacity: number = 0

    if (this._subgraph_depth < 4) {
      opacity = Math.pow(LAYER_OPACITY_MULTIPLIER, this._subgraph_depth)
    }

    this._animate_main_opacity(opacity)
  }

  public leave_subgraph = (): void => {
    this._leave_subgraph()
  }

  private _leave_subgraph = (
    sub_base: LayoutBase = [],
    sub_base_node: LayoutNode[] = []
  ): void => {
    const {
      api: {
        text: { measureText },
      },
    } = this.$system

    const { dispatchEvent } = this.$props

    const { animate } = this._config()

    // console.log('Graph', '_leave_subgraph', sub_base, sub_base_node)

    if (this._subgraph_graph && this._subgraph_unit_id) {
      this._force_control_animation_false = true

      const unit_id = this._subgraph_unit_id

      this._subgraph_unlisten()

      this._subgraph_depth = 0

      this._dom_leave_subgraph(animate)

      this._refresh_main_opacity()

      this._subgraph_graph = null
      this._subgraph_unit_id = null

      for (const component_id in this._selected_component) {
        this._enable_core_resize(component_id)
      }

      if (this._is_unit_component(unit_id)) {
        this._set_sub_component_controlled(unit_id, false)

        this._enter_sub_component_frame(unit_id)

        const frame = this._get_sub_component_frame(unit_id)

        if (animate) {
          this._animate_sub_component_graph_leave(
            unit_id,
            sub_base,
            sub_base_node,
            () => {
              const trait = extractTrait(frame, measureText)

              trait.x -= 1
              trait.y -= 1

              const style = extractStyle(frame, trait, measureText)

              return {
                style,
                trait,
              }
            },
            async () => {
              return true
            }
          )
        } else {
          this._enter_sub_component_frame(unit_id)
          this._compose_sub_component(unit_id)
        }
      }

      if (this._subgraph_return_fullwindow) {
        this._enter_fullwindow(
          false,
          this._subgraph_return_fullwindow_component_ids
        )
        this._subgraph_return_fullwindow = false
        this._subgraph_return_fullwindow_component_ids = []
      }

      if (this._enabled()) {
        this._enable_transcend()

        this._show_transcend(animate)
      }

      this.focus()

      dispatchEvent('leaveunit', {}, false)
    }
  }

  private _is_component_framed: boolean = false

  private _enter_component_frame = (): void => {
    // console.log('Graph', '_enter_component_frame')

    this._frame.appendChild(this._component)

    this._is_component_framed = true
  }

  private _leave_component_frame = (): void => {
    // console.log('Graph', '_leave_component_frame')

    this._frame.removeChild(this._component)

    this._is_component_framed = false
  }

  private _enter_sub_component_frame = (unit_id: string): void => {
    // console.log('Graph', '_enter_sub_component_frame', unit_id)

    const sub_component = this._get_sub_component(unit_id)

    const core_component_frame = this._core_component_frame[unit_id]

    core_component_frame.appendChild(sub_component)
  }

  private _leave_sub_component_frame = (unit_id: string): void => {
    // console.log('Graph', '_leave_sub_component_frame', unit_id)

    const sub_component = this._get_sub_component(unit_id)

    this.__leave_sub_component_frame(unit_id, sub_component)
  }

  private __leave_sub_component_frame = (
    unit_id: string,
    sub_component: Component
  ): void => {
    // console.log('Graph', '__leave_sub_component_frame', unit_id)

    const core_component_frame = this._core_component_frame[unit_id]

    core_component_frame.removeChild(sub_component)
  }

  private _layout_layer_opacity_animation: Dict<Animation> = {}
  private _layout_root_opacity_animation: Animation

  private _refresh_all_layout_layer_opacity = () => {
    // console.log('Graph', '_refresh_all_layout_layer_opacity')

    const l = this._layout_path.length

    if (l > 0) {
      for (let i = 0; i < l - 1; i++) {
        const layout_layer_id = this._layout_path[i]

        this._animate_layout_layer_element_opacity(
          layout_layer_id,
          LAYER_OPACITY_MULTIPLIER / (l - 1 - i)
        )
      }

      this._animate_layout_root_element_opacity(LAYER_OPACITY_MULTIPLIER / l)
    }
  }

  private _append_sub_component_base = (sub_component_id: string): void => {
    // console.log('Graph', '_append_sub_component_base', sub_component_id)

    return this.__commit_sub_component_base(
      sub_component_id,
      (parent, leaf_comp) => {
        const slot_name = this._get_sub_component_slot_name(sub_component_id)

        const i = parent.$parentRoot.indexOf(leaf_comp)

        parent.insertParentRootAt(leaf_comp, i, slot_name)
      },
      (leaf_parent, leaf_comp) => {
        const i = leaf_parent.$root.indexOf(leaf_comp)

        leaf_parent.insertRootAt(leaf_comp, i)
      }
    )
  }

  private _append_sub_component_root_base = (
    sub_component_id: string
  ): void => {
    // console.log('Graph', '_append_sub_component_root_base', sub_component_id)

    return this.__commit_sub_component_root_base(
      sub_component_id,
      (parent, leaf_comp) => {
        const slot_name = this._get_sub_component_slot_name(sub_component_id)
        const i = parent.$parentRoot.indexOf(leaf_comp)

        parent.insertParentRootAt(leaf_comp, i, slot_name)
      },
      (parent, leaf_comp) => {
        const i = parent.$root.indexOf(leaf_comp)

        parent.insertRootAt(leaf_comp, i)
      }
    )
  }

  private __commit_sub_component_base = (
    sub_component_id: string,
    callback: (parent: Component, leaf_comp: Component) => void,
    _callback: (leaf_parent: Component, leaf_comp: Component) => void
  ): void => {
    // console.log('Graph', '__commit_sub_component_base', sub_component_id)

    const base = this._get_sub_component_base(sub_component_id)

    return this._commit_sub_component_base__template(
      sub_component_id,
      base,
      callback,
      _callback
    )
  }

  private __commit_sub_component_root_base = (
    sub_component_id: string,
    callback: (parent: Component, leaf_comp: Component) => void,
    _callback: (leaf_parent: Component, leaf_comp: Component) => void
  ): void => {
    // console.log('Graph', '__commit_sub_component_root_base', sub_component_id)

    const base = this._get_sub_component_root_base(sub_component_id)

    return this._commit_sub_component_base__template(
      sub_component_id,
      base,
      callback,
      _callback
    )
  }

  private _append_sub_component_all_root = (sub_component_id: string): void => {
    // console.log('Graph', '_append_sub_component_root', sub_component_id)

    const sub_component = this._get_sub_component(sub_component_id)

    sub_component.appendAllRoot()
  }

  private _append_sub_component_all_missing_root = (
    sub_component_id: string
  ): void => {
    // console.log('Graph', '_append_sub_component_all_missing_root', sub_component_id)

    const sub_component = this._get_sub_component(sub_component_id)

    sub_component.appendAllMissingRoot()
  }

  private _remove_sub_component_all_root = (sub_component_id: string): void => {
    // console.log('Graph', '_remove_sub_component_all_root', sub_component_id)

    const sub_component = this._get_sub_component(sub_component_id)

    sub_component.removeAllRoot()
  }

  private _commit_sub_component_base__template = (
    sub_component_id: string,
    base: LayoutBase,
    callback: (parent: Component, leaf_comp: Component) => void,
    _callback: (leaf_parent: Component, leaf_comp: Component) => void
  ): void => {
    // console.log('Graph', '_commit_sub_component_base__template', sub_component_id)

    const sub_component = this._get_sub_component(sub_component_id)

    for (const leaf of base) {
      const [leaf_path, leaf_comp] = leaf

      const leaf_parent_last = leaf_path[leaf_path.length - 1]
      const leaf_parent_path = leaf_path.slice(0, -1)

      const leaf_parent = sub_component.pathGetSubComponent(leaf_parent_path)

      if (leaf_parent === leaf_comp) {
        //
      } else {
        const parent_id = leaf_parent.getSubComponentParentId(leaf_parent_last)
        if (parent_id) {
          const parent = leaf_parent.getSubComponent(parent_id)

          if (!parent.$mountParentRoot.includes(leaf_comp)) {
            callback(parent, leaf_comp)
          }
        } else {
          if (!leaf_parent.$mountRoot.includes(leaf_comp)) {
            _callback(leaf_parent, leaf_comp)
          }
        }
      }
    }
  }

  private _layout_sub_components_commit_base = (
    sub_component_ids: string[]
  ): void => {
    for (const sub_component_id of sub_component_ids) {
      this._append_sub_component_root_base(sub_component_id)
    }
  }

  private _layout_enter_sub_component = (sub_component_id: string): void => {
    // console.log('Graph', '_layout_enter_sub_component', sub_component_id)

    const { animate } = this._config()

    const prev_layout_layer = this._ensure_parent_layout_layer(sub_component_id)

    this._layout_path.push(sub_component_id)

    const layout_layer = this._ensure_layout_layer(sub_component_id)

    const children = this._spec_get_sub_component_children(sub_component_id)

    this._refresh_layout_node_target_position(sub_component_id)

    if (animate) {
      this._animate_layout_enter_sub_component(sub_component_id, children)
    } else {
      // TODO
    }

    prev_layout_layer.content.$element.style.overflow = 'auto'
    prev_layout_layer.content.$element.style.overflowY = 'visible'

    this._refresh_all_layout_layer_opacity()

    prev_layout_layer.children.$element.style.pointerEvents = 'none'
    prev_layout_layer.layers.$element.style.pointerEvents = 'inherit'

    layout_layer.content.$element.style.overflowX = 'hidden'
    layout_layer.content.$element.style.overflowY = 'auto'
    layout_layer.layer.$element.style.pointerEvents = 'inherit'

    layout_layer.layer.$element.style.overscrollBehaviorY = 'none'

    layout_layer.children.$element.style.pointerEvents = 'inherit'

    layout_layer.children.$element.style.overflowX = 'initial'
    layout_layer.children.$element.style.overflowY = 'initial'

    this._animate_layout_layer_element_opacity(sub_component_id, 1)
  }

  private _offset_sub_component_base_node = (
    sub_component_id: string,
    offset_x: number,
    offset_y: number
  ) => {
    const leaf_base = this._get_sub_component_root_base(sub_component_id)

    for (const [leaf_path] of leaf_base) {
      const leaf_id = `${sub_component_id}/${leaf_path.join('/')}`
      const leaf_node = this._leaf_frame_node[leaf_id]

      leaf_node.x += offset_x
      leaf_node.y += offset_y
    }
  }

  private _layout_leave_sub_component = () => {
    // console.log('Graph', '_layout_leave_sub_component')

    const { animate } = this._config()

    const sub_component_id = this._get_current_layout_layer_id()

    this._measure_sub_component_base(sub_component_id)

    const children = this._spec_get_sub_component_children(sub_component_id)

    this._layout_path.pop()

    const next_unit_id = this._get_current_layout_layer_id()

    const next_layout_layer = next_unit_id
      ? this._layout_layer[next_unit_id]
      : this._layout_root

    const layout_layer = this._layout_layer[sub_component_id]

    layout_layer.content.$element.style.overflowX = 'hidden'
    layout_layer.content.$element.style.overflowY = 'hidden'

    layout_layer.children.$element.style.opacity = '0'

    layout_layer.children.$element.style.overflowY = 'initial'
    layout_layer.children.$element.style.overflowX = 'initial'

    if (next_unit_id) {
      this._animate_layout_layer_element_opacity(next_unit_id, 1)
    } else {
      this._animate_layout_root_element_opacity(1)
    }

    next_layout_layer.content.$element.style.overflowY = 'auto'
    next_layout_layer.content.$element.style.overflowX = 'auto'

    next_layout_layer.children.$element.style.overflowX = 'initial'
    next_layout_layer.children.$element.style.overflowY = 'initial'

    this._refresh_all_layout_layer_opacity()

    next_layout_layer.children.$element.style.pointerEvents = 'inherit'

    next_layout_layer.layers.$element.style.pointerEvents = 'none'

    if (animate) {
      const all_slot_children: Dict<string[]> = {}

      for (const child_id of children) {
        const slot_name = this._get_sub_component_slot_name(child_id)

        all_slot_children[slot_name] = all_slot_children[slot_name] || []
        all_slot_children[slot_name].push(child_id)

        this._measure_sub_component_base(child_id)
      }

      const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)

      const parent_layer = this._get_layout_layer(parent_id)

      const finish = async () => {
        for (const slot_name in all_slot_children) {
          const slot_children = all_slot_children[slot_name]

          if (next_unit_id) {
            if (this._layout_layer_opacity_animation[next_unit_id]) {
              await waitFinish(
                this._layout_layer_opacity_animation[next_unit_id]
              )
            }
          } else {
            if (this._layout_root_opacity_animation) {
              await waitFinish(this._layout_root_opacity_animation)
            }
          }

          this._end_layout_sub_component_transfer_children_animation(
            sub_component_id,
            slot_name,
            slot_children
          )

          this._layout_sub_components_commit_base(children)

          for (const child_id of children) {
            this._insert_sub_component_child(sub_component_id, child_id)
          }
        }

        this._unplug_sub_component_root_base_frame(sub_component_id)
        this._append_sub_component_root_base(sub_component_id)
        this._enter_sub_component_frame(sub_component_id)
      }

      const slot_count = keyCount(all_slot_children)

      let parent_animation_finished = false
      let children_animation_finished = slot_count === 0

      let slot_animation_finished_count = 0

      this._animate_parent_component(
        sub_component_id,
        false,
        false,
        [],
        parent_layer.foreground,
        1,
        true,
        () => {
          return { x: 0, y: -parent_layer.content.$element.scrollTop }
        },
        () => {
          parent_animation_finished = true

          if (children_animation_finished) {
            finish()

            return true
          }

          return false
        }
      )

      for (const child_id of children) {
        if (!this._animating_sub_component_base_id.has(child_id)) {
          this._leave_sub_component_frame(child_id)
          this._remove_sub_component_root_base(child_id)
        }
      }

      for (const slot_name in all_slot_children) {
        const slot_children = all_slot_children[slot_name]

        this._animate_layout_append_children(
          sub_component_id,
          slot_children,
          slot_name,
          () => NULL_VECTOR,
          () => true,
          () => {
            slot_animation_finished_count += 1

            if (slot_animation_finished_count === slot_count) {
              children_animation_finished = true

              if (parent_animation_finished) {
                finish()

                return true
              }
            }

            return false
          }
        )
      }
    } else {
      // TODO
    }
  }

  private _ensure_layout_layer = (parent_id: string | null): LayoutLayer => {
    // console.log('Graph', '_ensure_layout_layer', parent_id)

    if (parent_id === null) {
      return this._layout_root
    }

    let layout_layer = this._layout_layer[parent_id]

    if (!layout_layer) {
      layout_layer = this._create_layout_layer({
        className: 'graph-layout-layer',
        style: {},
      })

      const parent_parent_id = this._spec_get_sub_component_parent_id(parent_id)

      const parent_layer = this._ensure_parent_layout_layer(parent_id)

      parent_layer.layers.appendChild(layout_layer.layer)

      this._layout_layer[parent_id] = layout_layer
    }

    return layout_layer
  }

  private _is_component_parent = (unit_id: string): boolean => {
    const children_count = this._get_component_children_count(unit_id)
    const is_parent = children_count > 0
    return is_parent
  }

  private _get_layout_layer_selected_count = (): number => {
    let layout_layer_selected_count = 0

    const current_layout_layer = this._get_current_layout_layer_id()

    if (current_layout_layer) {
      for (const sub_component_id in this._selected_component) {
        const sub_component_parent =
          this._spec_get_sub_component_parent_id(sub_component_id)
        if (sub_component_parent === current_layout_layer) {
          layout_layer_selected_count++
        }
      }
    } else {
      for (const sub_component_id in this._selected_component) {
        const sub_component_parent =
          this._spec_get_sub_component_parent_id(sub_component_id)
        if (!sub_component_parent) {
          layout_layer_selected_count++
        }
      }
    }

    return layout_layer_selected_count
  }

  private _just_node_long_clicked: boolean

  private _on_node_long_click = (node_id: string, event: UnitPointerEvent) => {
    // console.log('Graph', '_on_node_long_click')

    const { pointerId } = event

    this._just_node_long_clicked = true

    setTimeout(() => {
      this._just_node_long_clicked = false
    }, 0)

    if (this._collapse_pointer_to_unit[pointerId]) {
      return
    }

    if (this._cancel_node_long_click) {
      this._cancel_node_long_click = false

      return
    }

    if (this._tree_layout) {
      if (this._mode === 'none') {
        this._layout_enter_sub_component(node_id)
      }
    } else {
      if (this._is_unit_node_id(node_id)) {
        this._on_unit_long_click(node_id)
      } else if (this._is_link_pin_node_id(node_id)) {
        this._on_link_pin_long_click(node_id)
      } else if (this._is_datum_node_id(node_id)) {
        this._on_datum_long_click(node_id)
      } else {
        //
      }
    }
  }

  private _on_unit_long_click = (unit_id: string) => {
    const { config } = this.$props

    if (
      !this._resize_node_id_pointer_id[unit_id] &&
      !this._animating_unit_explosion[unit_id]
    ) {
      if (this._mode === 'none') {
        if (config?.enterGraph) {
          if (!this._is_unit_base(unit_id)) {
            this._enter_subgraph(unit_id)
          } else {
            //
          }
        }
      } else if (this._mode === 'multiselect') {
        //
      } else if (this._mode === 'info') {
        if (this._tree_layout) {
          //
        } else {
          if (config?.enterGraph) {
            if (!this._is_unit_base(unit_id)) {
              this._enter_subgraph(unit_id)
            }
          }
        }
      } else {
        //
      }
    }
  }

  private _on_link_pin_long_click = (pin_node_id: string) => {
    if (this._mode === 'change') {
      // this._toggle_link_pin_memory(node_id)
    }
  }

  private _on_datum_long_click = (datum_node_id: string) => {
    if (this._mode === 'none') {
      if (this._is_datum_class_literal(datum_node_id)) {
        this._enter_datum_class_literal(datum_node_id)
      }
    }
  }

  private _enter_datum_class_literal = (datum_node_id: string) => {
    const {
      fork,
      specs,
      typeCache,
      container,
      config,
      hasSpec,
      emptySpec,
      getSpec,
      setSpec,
      newSpec,
      deleteSpec,
      forkSpec,
      shouldFork,
      injectSpecs,
      registerUnit,
      unregisterUnit,
      newSpecId,
      enterFullwindow,
      leaveFullwindow,
      dispatchEvent,
    } = this.$props

    const { animate } = this._config()

    const { datumId } = segmentDatumNodeId(datum_node_id)

    const datum_tree = this._get_datum_tree(datum_node_id)

    const is_class_literal = datum_tree.type === TreeNodeType.Unit

    const pin_node_id = this._datum_to_pin[datum_node_id]

    if (is_class_literal) {
      let unitBundle = evaluateBundleStr(
        datum_tree.value,
        specs,
        this.$system.classes
      )

      const specs_ = weakMerge(specs, unitBundle.specs)

      unitBundle = unitBundleSpec(unitBundle.unit, specs_)

      const spec = getSpec(unitBundle.unit.id) as GraphSpec

      if (isBaseSpec(spec)) {
        return
      }

      const bundle = bundleSpec(spec, specs_)

      const graph = start(this._system, bundle, true)

      const pod = proxyWrap(AsyncGraph(graph), UCGEE)
      const component = componentFromUnitBundle(this._system, unitBundle)

      for (const subComponentId in component.$subComponent) {
        const sub_component = component.$subComponent[subComponentId]

        sub_component.uncollapse(false)
      }

      component.removeAllRoot()

      const editor = new Editor_(
        {
          graph: pod,
          style: {
            transition: ifLinearTransition(animate, 'opacity'),
          },
          disabled: true,
          parent: this,
          frame: this._frame,
          frameOut: false,
          container,
          fullwindow: false,
          component,
          system: this._system,
          typeCache,
          specs,
          config,
          fork: true,
          bubble: true,
          ...([
            'hasSpec',
            'emptySpec',
            'getSpec',
            'setSpec',
            'newSpec',
            'deleteSpec',
            'forkSpec',
            'injectSpecs',
            'registerUnit',
            'shouldFork',
            'unregisterUnit',
            'newSpecId',
          ].reduce((acc, name) => {
            return {
              ...acc,
              [name]: this.$system[name].bind(this.$system),
            }
          }, {}) as R),
          dispatchEvent,
          enterFullwindow,
          leaveFullwindow,
        },
        this.$system
      )

      editor._graph.addEventListener(
        makeCustomListener('leave', () => {
          const {
            api: {
              window: { setTimeout },
            },
          } = this.$system

          const modified_bundle = editor.getUnitBundle()

          const spec_id_map = this.$props.injectSpecs(modified_bundle.specs)

          remapUnitBundle(modified_bundle, spec_id_map)

          const modified_value = `$${stringify(modified_bundle)}`

          const specs = weakMerge(
            this.$system.specs,
            modified_bundle.specs ?? {}
          )

          const id = modified_bundle.unit.id

          const spec = specs[id]

          const node_positions = editor.get_node_relative_positions()

          this._set_spec_node_positions(spec, editor, node_positions)

          setSpec(spec.id, spec)

          const class_datum_comp = this._datum[datum_node_id] as ClassDatum

          class_datum_comp.setProp('specs', specs)

          if (pin_node_id) {
            this._set_unit_pin_data(pin_node_id, modified_value)
          } else {
            const modified_tree = getTree(modified_value)

            this._set_datum(datumId, modified_tree)
          }

          delete this._datum_sub_graph[datum_node_id]
          delete this._datum_graph[datum_node_id]

          editor.destroy()

          this._show_transcend(animate)
          this._enable_transcend()
          this._enable_input()

          this._main.$element.style.pointerEvents = 'inherit'
          this._foreground.$element.style.pointerEvents = 'none'

          this._unclear_main(animate)

          if (animate) {
            setTimeout(() => {
              this._foreground.removeChild(editor)
            }, ANIMATION_T_MS)
          } else {
            this._foreground.removeChild(editor)
          }

          this.focus()
        })
      )

      this._datum_sub_graph[datum_node_id] = editor
      this._datum_graph[datum_node_id] = graph

      this._foreground.appendChild(editor)

      this._clear_main(animate)

      this._main.$element.style.pointerEvents = 'none'
      this._foreground.$element.style.pointerEvents = 'inherit'

      this._disable_input()
      this._disable_transcend()

      editor.setProp('disabled', false)
      editor.focus()
      editor.enter(animate, {}, false, false)
    }
  }

  private _datum_sub_graph: Dict<Editor_> = {}
  private _datum_graph: Dict<Graph> = {}

  private _on_link_pin_long_press = (pin_node_id: string): void => {
    if (this._mode === 'none') {
      //
    } else if (this._mode === 'multiselect') {
      //
    } else if (this._mode === 'data') {
      //
    } else if (this._mode === 'add') {
      //
    } else if (this._mode === 'remove') {
      //
    } else if (this._mode === 'change') {
      this._toggle_link_pin_ref(pin_node_id)
    }
  }

  private _long_press_append_sub_component_children = (
    parent_id: string,
    children: string[],
    slot_name: string = 'default'
  ): void => {
    // console.log(
    //   'Graph',
    //   '_long_press_append_sub_component_children',
    //   parent_id,
    //   children,
    //   slot_name
    // )

    this.move_sub_component_root(parent_id, children, slot_name)
  }

  private _get_sub_components_slot_map = (sub_component_ids): Dict<string> => {
    const slot_map = {}

    for (const sub_component_id of sub_component_ids) {
      const slot_name = this._get_sub_component_slot_name(sub_component_id)

      slot_map[slot_name] = sub_component_id
    }

    return slot_map
  }

  private _get_sub_components_parent_map = (
    sub_component_ids
  ): Dict<string> => {
    const parent_map = {}

    for (const sub_component_id of sub_component_ids) {
      const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)

      parent_map[parent_id] = sub_component_id
    }

    return parent_map
  }

  private move_sub_component_root = (
    parent_id: string | null,
    children: string[],
    slot_name: string = 'default'
  ) => {
    const prev_slot_map = this._get_sub_components_slot_map(children)
    const prev_parent_map = this._get_sub_components_parent_map(children)

    const slot_map = makeTagObj(children, slot_name)

    this._dispatch_action(
      makeMoveSubComponentRootAction(
        parent_id,
        prev_parent_map,
        children,
        slot_map,
        prev_slot_map
      )
    )

    this._move_sub_component_root(parent_id, children, slot_name)
  }

  private _move_sub_component_root = (
    parent_id: string,
    children: string[],
    slot_name: string = 'default',
    emit: boolean = true,
    animate?: boolean
  ): void => {
    // console.log(
    //   'Graph',
    //   '_move_sub_component_root',
    //   parent_id,
    //   children,
    //   slot_name
    // )

    const config = this._config()

    animate = animate ?? config.animate

    // this._cancel_tree_layout_animation()

    this._ensure_layout_layer(parent_id)

    const current_layer_id = this._get_current_layout_layer_id()

    animate = animate && !this._is_layout_component_layer_visible(parent_id)

    if (animate) {
      const spec_children = this._spec_get_sub_component_children(parent_id)

      const parent_component = this._get_sub_component(parent_id)

      const slot_children = spec_children.filter((sub_component_id) => {
        const child_sub_component = this._get_sub_component(sub_component_id)

        if (parent_component.$mountParentRoot.includes(child_sub_component)) {
          return true
        } else {
          return false
        }
      })

      const all_children = [...slot_children, ...children]

      this._measure_sub_component_base(parent_id)

      for (const child_id of all_children) {
        this._measure_sub_component_base(child_id)
      }

      for (const child_id of children) {
        const child_component = this._get_sub_component(child_id)

        this._cancel_layout_sub_component_animation(child_id)

        const prev_parent_id = this._spec_get_sub_component_parent_id(child_id)
        if (prev_parent_id) {
          const prev_parent_component = this._get_sub_component(prev_parent_id)

          prev_parent_component.pullParentRoot(child_component)
        } else {
          this._component.pullRoot(child_component)
        }

        this._pre_append_sub_component_child(parent_id, child_id, slot_name)
      }

      for (const child_id of all_children) {
        if (!this._animating_sub_component_base_id.has(child_id)) {
          this._remove_sub_component_root_base(child_id)
        }
      }

      for (const child_id of slot_children) {
        if (!this._animating_sub_component_base_id.has(child_id)) {
          this._remove_sub_component_parent_root(parent_id, child_id)
        }
      }

      for (const child_id of children) {
        if (!this._animating_sub_component_base_id.has(child_id)) {
          this._leave_sub_component_frame(child_id)
        }
      }

      const parent_animating = this._is_sub_component_animating(parent_id)

      const parent_leaf_traits = []

      const parent_layer = this._get_sub_component_layout_layer(parent_id)

      let parent_finished = false
      let children_finished = false

      const maybe_finish = () => {
        if (parent_finished && children_finished) {
          stop_parent_animation()
          stop_children_animation()

          finish()

          return true
        }

        return false
      }

      const stop_parent_animation = this._animate_parent_component(
        parent_id,
        parent_animating,
        parent_animating,
        parent_leaf_traits,
        parent_layer.foreground,
        1,
        true,
        () => ({
          x: -layer.content.$element.scrollLeft,
          y: -layer.content.$element.scrollTop,
        }),
        () => {
          parent_finished = true

          return maybe_finish()
        }
      )

      const layer = this._get_sub_component_parent_layer(parent_id)

      const stop_children_animation = this._animate_layout_append_children(
        parent_id,
        all_children,
        slot_name,
        () => NULL_VECTOR,
        () => true,
        () => {
          children_finished = true

          return maybe_finish()
        }
      )

      const finish = () => {
        this._unplug_sub_component_root_base_frame(parent_id)
        this._append_sub_component_root_base(parent_id)
        this._enter_sub_component_frame(parent_id)

        this._end_layout_sub_component_transfer_children_animation(
          parent_id,
          slot_name,
          all_children
        )

        for (const child_id of slot_children) {
          this._insert_sub_component_child(parent_id, child_id)
        }
        for (const child_id of children) {
          this._insert_sub_component_child(parent_id, child_id)
        }

        this._layout_sub_components_commit_base(all_children)
        this._animate_all_current_layout_layer_node()
      }

      for (const child_id of children) {
        this._animate_layout_core_anchor(
          child_id,
          this._layout_node[child_id],
          () => {
            this._layout_layer_move_sub_component_child(
              current_layer_id,
              parent_id,
              child_id
            )
          }
        )
      }
    }

    if (animate) {
      //
    } else {
      const parent_current_children =
        this._spec_get_sub_component_children(parent_id)

      let i = parent_current_children.length

      for (const child_id of children) {
        const child_parent_id = this._spec_get_sub_component_parent_id(child_id)

        this._layout_layer_move_sub_component_child(
          child_parent_id,
          parent_id,
          child_id
        )

        if (!this._is_layout_component_layer_visible(parent_id)) {
          this._displace_sub_component(child_id)

          this.__insert_sub_component_child(parent_id, child_id, 'default', i)
        }

        i++
      }

      for (const child_id of children) {
        const child_component = this._get_sub_component(child_id)

        const prev_parent_id = this._spec_get_sub_component_parent_id(child_id)

        this._refresh_layout_node_target_position(prev_parent_id)
        this._force_layout_node_traits(prev_parent_id)
      }

      this._refresh_layout_node_target_position(parent_id)
      this._force_layout_node_traits(parent_id)
    }
  }

  private _mem_append_sub_component_child = (
    parent_id: string,
    child_id: string,
    slot_name: string
  ): void => {}

  private _pre_append_sub_component_child = (
    parent_id: string,
    child_id: string,
    slot_name: string
  ): void => {
    // console.log('Graph', '_pre_append_sub_component_child', parent_id, child_id)

    this._state_pre_append_sub_component_child(parent_id, child_id, slot_name)
    this._pod_move_sub_component_root(parent_id, [child_id], {
      [child_id]: slot_name,
    })
  }

  private _state_pre_append_sub_component_child = (
    parent_id: string,
    child_id: string,
    slot_name: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_state_pre_append_sub_component_child',
    //   parent_id,
    //   child_id
    // )

    const is_child_fullwindow = this._is_sub_component_fullwindow(child_id)

    if (is_child_fullwindow) {
      this._decouple_sub_component(child_id)
    }

    this._mem_push_sub_component_child(parent_id, child_id, slot_name)
    this._spec_remove_sub_component_from_parent(child_id)
    this._spec_append_sub_component_child(parent_id, child_id, slot_name)

    if (is_child_fullwindow) {
      this._couple_sub_component(child_id)
    }
  }

  private _context_trait(): LayoutNode {
    const { $x, $y, $sx, $sy, $width, $height, $color } = this.$context

    return {
      x: $x,
      y: $y,
      sx: $sx,
      sy: $sy,
      width: $width,
      height: $height,
      opacity: 1,
      color: hexToRgba($color),
      fontSize: DEFAULT_FONT_SIZE,
    }
  }

  private _animate_enter_fullwindow = (
    sub_component_ids: string[],
    callback: () => void | boolean
  ): Unlisten => {
    // console.log('Graph', '_animate_enter_fullwindow', sub_component_ids)

    const {
      api: {
        text: { measureText },
      },
    } = this.$system

    this._animating_enter_fullwindow = true

    let all_base = []

    const layer = this._get_fullwindow_foreground()

    let layer_trait = extractTrait(layer, measureText)

    for (const sub_component_id of sub_component_ids) {
      const { base } = this._get_sub_component_base_trait(sub_component_id)

      if (!this._animating_sub_component_fullwindow.has(sub_component_id)) {
        const base = this._get_sub_component_root_base(sub_component_id)

        this._measure_sub_component_base(sub_component_id, base, layer_trait)
      }

      all_base = [...all_base, ...base]
    }

    const fontSize = this._component.getFontSize()
    const k = 1
    const opacity = 1

    const frame_slot = this._frame.$slot['default']

    let all_trait: Dict<LayoutNode>

    const leaf_total = all_base.length

    const sub_component_total = sub_component_ids.length

    let sub_component_end_count = 0

    let i = 0

    const all_abort: Unlisten[] = []

    this._leaf_layer_offset_x = 0
    this._leaf_layer_offset_y = 0

    for (const sub_component_id of sub_component_ids) {
      const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)

      if (
        !this._animating_sub_component_base_id.has(sub_component_id) &&
        !this._animating_sub_component_fullwindow.has(sub_component_id)
      ) {
        if (this._tree_layout) {
          if (parent_id) {
            const current_layer_id = this._get_current_layout_layer_id()

            if (parent_id === current_layer_id) {
              this._leave_sub_component_frame(sub_component_id)
            } else {
              this._remove_sub_component_parent_root(
                parent_id,
                sub_component_id
              )
            }
          } else {
            this._leave_sub_component_frame(sub_component_id)
          }
        } else {
          this._leave_sub_component_frame(sub_component_id)
        }
      }
    }

    for (const sub_component_id of sub_component_ids) {
      const sub_component = this._get_sub_component(sub_component_id)
      const base = this._get_sub_component_root_base(sub_component_id)

      if (!this._animating_sub_component_fullwindow.has(sub_component_id)) {
        this._remove_sub_component_root_base(sub_component_id)

        this._plug_sub_component_base(sub_component_id, base, [], layer)
      }

      this._animating_sub_component_fullwindow.add(sub_component_id)

      const abort = this._plug_animate_sub_component_base(
        sub_component_id,
        base,
        [],
        layer,
        (leaf_id: string) => {
          if (i === 0) {
            const color = sub_component.getColor()

            let target_slot = frame_slot

            const frame_position = getRelativePosition(
              this._frame.$element,
              this._frame.$context.$element
            )

            const frame_size = getSize(target_slot.$element)

            let width =
              frame_slot.isParent() || frame_slot.$wrap
                ? this._frame.$context.$width
                : frame_size.width
            let height =
              frame_slot.isParent() || frame_slot.$wrap
                ? this._frame.$context.$height
                : frame_size.height

            const trait: LayoutNode = {
              x: frame_position.x,
              y: frame_position.y,
              width: width / this._frame.$context.$sx,
              height: height / this._frame.$context.$sy,
              sx: k,
              sy: k,
              opacity,
              fontSize,
              color,
            }

            const style = extractStyle(frame_slot, trait, measureText)

            all_trait = this.___reflect_sub_component_base_trait(
              '',
              this._component,
              all_base,
              style,
              trait,
              true
            )
          }

          const layer_trait = extractTrait(layer, measureText)
          const frame_trait = extractTrait(frame_slot, measureText)

          const offset_x = this._frame_out ? frame_trait.x : this.$context.$x
          const offset_y = this._frame_out ? frame_trait.y : this.$context.$y

          const _trait = all_trait[leaf_id]

          const trait = {
            x: _trait.x - layer_trait.x + offset_x,
            y: _trait.y - layer_trait.y + offset_y,
            width: _trait.width,
            height: _trait.height,
            sx: _trait.sx,
            sy: _trait.sy,
            opacity: _trait.opacity,
            fontSize: _trait.fontSize,
            color: _trait.color,
          }

          i = (i + 1) % leaf_total

          return trait
        },
        async () => {
          sub_component_end_count++

          if (sub_component_end_count === sub_component_total) {
            for (const sub_component_id of sub_component_ids) {
              this._animating_sub_component_fullwindow.delete(sub_component_id)
            }

            this._animating_enter_fullwindow = false

            callback()
          }

          return true
        }
      )

      all_abort.push(abort)
    }

    return callAll(all_abort)
  }

  private _animate_leave_fullwindow = (
    sub_component_ids: string[],
    callback: Callback<string>,
    end: Callback
  ): Unlisten => {
    // console.log('Graph', '_animate_leave_fullwindow', sub_component_ids)

    const {
      api: {
        text: { measureText },
        layout: { reflectChildrenTrait },
      },
    } = this.$system

    const all_abort = []

    const sub_component_total = sub_component_ids.length

    let sub_component_end_leaf_count = 0

    const all_parent_id: Dict<string> = {}
    const all_parent_children: Dict<string[]> = {}

    const all_parent_base: Dict<Dict<LayoutBase>> = {}
    const all_root_base: Dict<LayoutBase> = {}

    const parent_frame_style = {}
    const parent_frame_trait = {}

    const layer = this._get_fullwindow_foreground()

    const layer_trait = extractTrait(layer, measureText)

    for (const sub_component_id of sub_component_ids) {
      const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)
      const base = this._get_sub_component_root_base(sub_component_id)
      const frame = this._get_sub_component_frame(sub_component_id)

      if (!this._animating_sub_component_fullwindow.has(sub_component_id)) {
        this._measure_sub_component_base(sub_component_id, base, layer_trait)
      }

      const frame_trait = extractTrait(frame, measureText)
      const frame_style = extractStyle(frame, frame_trait, measureText)

      parent_frame_style[sub_component_id] = frame_style
      parent_frame_trait[sub_component_id] = frame_trait

      if (this._tree_layout) {
        const parent_visible =
          this._is_layout_component_layer_visible(parent_id)

        if (parent_id && !parent_visible) {
          if (parent_visible) {
            all_root_base[sub_component_id] =
              all_root_base[sub_component_id] || []
            all_root_base[sub_component_id] = [
              ...all_root_base[sub_component_id],
              ...base,
            ]
          } else {
            const slot_name =
              this._get_sub_component_slot_name(sub_component_id)

            all_parent_base[parent_id] = all_parent_base[parent_id] || {}
            all_parent_base[parent_id][slot_name] =
              all_parent_base[parent_id][slot_name] || []
            all_parent_base[parent_id][slot_name] = [
              ...all_parent_base[parent_id][slot_name],
              ...base,
            ]
            all_parent_id[sub_component_id] = parent_id

            all_parent_children[parent_id] =
              all_parent_children[parent_id] || []
            all_parent_children[parent_id].push(sub_component_id)
          }
        } else {
          all_root_base[sub_component_id] =
            all_root_base[sub_component_id] || []
          all_root_base[sub_component_id] = [
            ...all_root_base[sub_component_id],
            ...base,
          ]
        }
      } else {
        all_root_base[sub_component_id] = all_root_base[sub_component_id] || []
        all_root_base[sub_component_id] = [
          ...all_root_base[sub_component_id],
          ...base,
        ]
      }
    }

    const all_trait: Dict<LayoutNode> = {}

    const reset_all_trait = () => {
      for (const sub_component_id in all_root_base) {
        const base = all_root_base[sub_component_id]

        const frame = this._get_sub_component_frame(sub_component_id)

        const trait = extractTrait(frame, measureText)
        const style = extractStyle(frame, trait, measureText)

        const parent_base_trait = this._reflect_sub_component_base_trait(
          sub_component_id,
          base,
          style,
          trait,
          true
        )

        const layer_trait = extractTrait(layer, measureText)

        for (const leaf_id in parent_base_trait) {
          const leaf_trait = parent_base_trait[leaf_id]

          all_trait[leaf_id] = {
            x: (leaf_trait.x - layer_trait.x) / layer_trait.sx,
            y: (leaf_trait.y - layer_trait.y) / layer_trait.sy,
            width: leaf_trait.width / layer_trait.sx,
            height: leaf_trait.height / layer_trait.sy,
            sx: leaf_trait.sx,
            sy: leaf_trait.sy,
            opacity: leaf_trait.opacity,
            fontSize: leaf_trait.fontSize,
            color: leaf_trait.color,
          }
        }
      }
    }

    if (!this._animating_enter_fullwindow) {
      this._component.decompose()
    }

    for (const sub_component_id of sub_component_ids) {
      if (
        !this._animating_sub_component_base_id.has(sub_component_id) &&
        !this._animating_sub_component_fullwindow.has(sub_component_id)
      ) {
        this._remove_sub_component_root_base(sub_component_id)
        this._remove_sub_component_all_root(sub_component_id)
      }
    }

    for (const sub_component_id of sub_component_ids) {
      if (this._tree_layout) {
        this._collapse_sub_component(sub_component_id)
      }

      const base = this._get_sub_component_root_base(sub_component_id)
      const layer = this._get_fullwindow_foreground()

      this._animating_sub_component_fullwindow.add(sub_component_id)

      let i = 0

      const leaf_total = base.length

      this._plug_sub_component_base(sub_component_id, base, [], layer)

      const abort = this._plug_animate_sub_component_base(
        sub_component_id,
        base,
        [],
        layer,
        (leaf_id: string) => {
          if (i === 0) {
            reset_all_trait()
          }

          const _trait = all_trait[leaf_id]

          i = (i + 1) % leaf_total

          return _trait
        },
        async () => {
          callback(sub_component_id)

          sub_component_end_leaf_count++

          if (sub_component_end_leaf_count === sub_component_total) {
            for (const sub_component_id of sub_component_ids) {
              this._animating_sub_component_fullwindow.delete(sub_component_id)
            }

            end()
          }

          return true
        }
      )

      all_abort.push(abort)
    }

    return callAll(all_abort)
  }

  private _setup_layout_sub_component_append_children_animation = (
    parent_id: string,
    children: string[],
    slot_name: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_setup_layout_sub_component_append_children_animation',
    //   parent_id,
    //   children,
    //   slot_name
    // )

    const {
      api: {
        text: { measureText },
      },
    } = this.$system

    this._cancel_layout_parent_children_animation(parent_id, slot_name)

    this._reset_layout_transfer_parent(parent_id, slot_name)
    this._reset_layout_transfer_parent_children(parent_id, slot_name, children)

    this._layout_transfer_parent_animating[parent_id] = true

    const _leaf_style = []

    type Leaf = [string[], Component]

    const extractLeafComp = (slot_children_base: Leaf[]): Component[] => {
      return slot_children_base.map(([_, comp]) => comp)
    }

    const all_children_base_comp = []

    for (const child_id of children) {
      this._animating_sub_component_base_id.add(child_id)

      const base = this._get_sub_component_root_base(child_id)

      for (const leaf of base) {
        this._layout_transfer_parent_leaf[parent_id][slot_name].push(leaf)
        this._layout_transfer_parent_leaf_sub_component_id[parent_id][
          slot_name
        ].push(child_id)

        const [leaf_path, leaf_comp] = leaf

        this._layout_transfer_parent_leaf_path[parent_id][slot_name].push(
          leaf_path
        )
        this._layout_transfer_parent_leaf_comp[parent_id][slot_name].push(
          leaf_comp
        )
      }

      const sub_component_leaves = extractLeafComp(base)

      all_children_base_comp.splice(
        all_children_base_comp.length,
        0,
        ...sub_component_leaves
      )
    }

    const parent_frame = this._get_sub_component_frame(parent_id)

    const parent_trait = extractTrait(parent_frame, measureText)

    for (const leaf_comp of all_children_base_comp) {
      const leaf_style = extractStyle(leaf_comp, parent_trait, measureText)

      _leaf_style.push(leaf_style)
    }

    let leaf_i = 0

    this._layout_transfer_parent_remaining_child[parent_id][slot_name] =
      new Set(children)

    const { child_foreground: leaf_layer } =
      this._get_sub_component_parent_layer(parent_id)

    for (const child_id of children) {
      const base = this._get_sub_component_root_base(child_id)

      for (const leaf of base) {
        const [leaf_path, leaf_comp] = leaf

        const leaf_id = joinPath([child_id, ...leaf_path])

        const leaf_node = this._leaf_frame_node[leaf_id]

        this._plug_leaf_frame(leaf_id, leaf_comp, leaf_node, leaf_layer)

        leaf_i++
      }
    }

    this._layout_transfer_parent_leaf_count[parent_id][slot_name] = leaf_i
  }

  private _setup_layout_sub_component_remove_parent_children_animation = (
    parent_id: string,
    slot_name: string,
    children: string[]
  ): void => {
    // console.log(
    //   'Graph',
    //   '_setup_layout_sub_component_remove_parent_children_animation',
    //   parent_id,
    //   children
    // )
    const {
      api: {
        text: { measureText },
      },
    } = this.$system

    this._cancel_layout_parent_children_animation(parent_id, slot_name)

    this._reset_layout_transfer_parent(parent_id, slot_name)
    this._reset_layout_transfer_parent_children(parent_id, slot_name, children)

    const parent_child_leaf_style = []

    const sub_component = this._get_sub_component(parent_id)

    const frame = this._get_sub_component_frame(parent_id)

    const slot = sub_component.$slot[slot_name]

    for (const child_id of children) {
      this._animating_sub_component_base_id.add(child_id)

      const child_base = this._get_sub_component_root_base(child_id)

      const child_base_style = []

      for (const leaf of child_base) {
        const [leaf_path, leaf_comp] = leaf

        this._layout_transfer_parent_leaf[parent_id][slot_name].push(leaf)
        this._layout_transfer_parent_leaf_path[parent_id][slot_name].push(
          leaf_path
        )
        this._layout_transfer_parent_leaf_comp[parent_id][slot_name].push(
          leaf_comp
        )
        this._layout_transfer_parent_leaf_sub_component_id[parent_id][
          slot_name
        ].push(child_id)

        const frame_trait = extractTrait(frame, measureText)

        const leaf_style = extractStyle(leaf_comp, frame_trait, measureText)

        child_base_style.push(leaf_style)
        parent_child_leaf_style.push(leaf_style)
      }
    }

    let leaf_i = 0

    for (const leaf of this._layout_transfer_parent_leaf[parent_id][
      slot_name
    ]) {
      const sub_component_id =
        this._layout_transfer_parent_leaf_sub_component_id[parent_id][
          slot_name
        ][leaf_i]

      const [leaf_path, leaf_comp] = leaf

      const leaf_id = joinPath([sub_component_id, ...leaf_path])

      const leaf_node = this._leaf_frame_node[leaf_id]

      const { child_foreground: leaf_layer } =
        this._get_sub_component_layout_layer(sub_component_id)

      this._plug_leaf_frame(leaf_id, leaf_comp as any, leaf_node, leaf_layer)

      leaf_i++
    }

    this._layout_transfer_parent_leaf_count[parent_id][slot_name] = leaf_i
  }

  private _cancel_all_layout_parent_children_animation = () => {
    for (const sub_component_id in {
      ...this._layout_parent_children_animation_frame,
    }) {
      // console.log('_cancel_all_layout_parent_children_animation', slot_name)
      this._cancel_layout_parent_children_animation(sub_component_id)
    }
  }

  private _cancel_all_sub_component_parent_animation = () => {
    for (const sub_component_id in {
      ...this._abort_sub_component_parent_animation,
    }) {
      this._cancel_parent_animation(sub_component_id)
    }
  }

  private _cancel_all_layout_parent_children_slot_animation = (
    slot_name: string
  ) => {
    for (const sub_component_id in {
      ...this._layout_parent_children_animation_frame,
    }) {
      // console.log('_cancel_all_layout_parent_children_animation', slot_name)
      this._cancel_layout_parent_children_animation(sub_component_id, slot_name)
    }
  }

  private _cancel_layout_parent_children_animation = (
    parent_id: string,
    slot_name: string = 'default' // TODO
  ): void => {
    if (this._layout_parent_children_animation_frame[parent_id] !== undefined) {
      // console.log(
      //   'Graph',
      //   '_cancel_layout_parent_children_animation',
      //   parent_id
      // )

      cancelAnimationFrame(
        this._layout_parent_children_animation_frame[parent_id]
      )

      delete this._layout_parent_children_animation_frame[parent_id]
    }
  }

  private _start_layout_children_animation = (
    parent_id: string,
    slot_name: string,
    frame: () => void
  ): void => {
    // console.log('Graph', '_start_layout_children_animation', parent_id)

    this._layout_parent_children_animation_frame[parent_id] =
      requestAnimationFrame(frame)
  }

  private _animate_layout_append_children = (
    sub_component_id: string,
    children: string[],
    slot_name: string,
    offset: () => Point,
    include_scroll: () => boolean,
    callback: Callback
  ): Unlisten => {
    // console.log(
    //   'Graph',
    //   '_animate_layout_append_children',
    //   sub_component_id,
    //   children,
    //   include_scroll,
    //   slot_name
    // )

    // this._cancel_layout_current_children_transfer_animation()
    this._cancel_layout_parent_children_animation(sub_component_id, slot_name)

    this._setup_layout_sub_component_append_children_animation(
      sub_component_id,
      children,
      slot_name
    )

    this._layout_transfer_parent_callback[sub_component_id] = callback

    const pack: [string, string, string, string][] = []
    const target: Dict<Component> = {}

    for (const child_id of children) {
      pack.push([child_id, sub_component_id, sub_component_id, slot_name])
    }

    const parent_component = this._get_sub_component(sub_component_id)

    target[sub_component_id] = parent_component

    return this._play_layout_sub_component_transfer_children_animation(
      sub_component_id,
      slot_name,
      children,
      pack,
      target,
      true,
      offset,
      include_scroll,
      callback
    )
  }

  private _play_layout_sub_component_transfer_children_animation = (
    parent_id: string,
    slot_name: string,
    children: string[],
    pack: [string, string, string, string][],
    target: Dict<Component>,
    should_expand_slot: boolean,
    offset: () => Point,
    include_scroll: () => boolean,
    callback: Callback
  ) => {
    const frame = () => {
      this._tick_animate_layout_transfer_children(
        parent_id,
        slot_name,
        pack,
        target,
        should_expand_slot,
        offset,
        include_scroll
      )

      if (
        this._layout_transfer_parent_leaf_end_count[parent_id][slot_name] <
        this._layout_transfer_parent_leaf_count[parent_id][slot_name]
      ) {
        this._start_layout_children_animation(parent_id, slot_name, frame)
      } else {
        for (const child_id of children) {
          if (this._layout_core_animating.has(child_id)) {
            this._start_layout_children_animation(parent_id, slot_name, frame)

            return
          }
        }

        callback()
      }
    }

    frame()

    return () => {
      this._cancel_layout_parent_children_animation(parent_id)
    }
  }

  private _end_layout_sub_component_transfer_children_animation = (
    parent_id: string,
    slot_name: string,
    children: string[]
  ) => {
    delete this._layout_transfer_parent_animating[parent_id]
    delete this._layout_transfer_parent_callback[parent_id]

    for (const child_id of children) {
      this._animating_sub_component_base_id.delete(child_id)
    }

    if (this._layout_transfer_parent_leaf[parent_id]?.[slot_name]) {
      for (
        let i = 0;
        i < this._layout_transfer_parent_leaf[parent_id]?.[slot_name]?.length;
        i++
      ) {
        const child_id =
          this._layout_transfer_parent_leaf_sub_component_id[parent_id][
            slot_name
          ][i]
        const leaf_path =
          this._layout_transfer_parent_leaf_path[parent_id][slot_name][i]
        const leaf_comp =
          this._layout_transfer_parent_leaf_comp[parent_id][slot_name][i]

        const leaf_id = joinPath([child_id, ...leaf_path])

        this._unplug_leaf_frame(leaf_id, leaf_comp as any)
      }
    }
  }

  private _play_layout_sub_component_remove_children_animation = (
    parent_id: string,
    slot_name: string,
    children: string[],
    expand: boolean,
    callback: Callback
  ): Callback => {
    // console.log(
    //   'Graph',
    //   '_play_layout_sub_component_remove_children_animation',
    //   parent_id
    // )

    const pack: [string, string, string, string][] = []
    const target: Dict<Component> = {}

    for (const child_id of children) {
      pack.push([child_id, parent_id, child_id, slot_name])

      const frame = this._get_sub_component_frame(child_id)

      target[child_id] = frame
    }

    const parent_component = this._get_sub_component(parent_id)

    target[parent_id] = parent_component

    return this._play_layout_sub_component_transfer_children_animation(
      parent_id,
      slot_name,
      children,
      pack,
      target,
      expand,
      () => ({ x: 0, y: 0 }),
      () => true,
      callback
    )
  }

  private _animate_layout_sub_component_remove_children = (
    parent_id: string,
    slot_name: string,
    children: string[],
    expand: boolean,
    callback: Callback
  ): Unlisten => {
    // console.log(
    //   'Graph',
    //   '_animate_layout_sub_component_remove_children',
    //   parent_id,
    //   expand,
    //   children
    // )

    this._cancel_layout_parent_children_animation(parent_id, slot_name)

    this._setup_layout_sub_component_remove_parent_children_animation(
      parent_id,
      slot_name,
      children
    )

    return this._play_layout_sub_component_remove_children_animation(
      parent_id,
      slot_name,
      children,
      expand,
      callback
    )
  }

  private _animate_tick_leaf_trait = (
    leaf_id: string,
    trait: LayoutNode,
    include_scroll: () => boolean = () => true
  ) => {
    const leaf_node = this._leaf_frame_node[leaf_id]

    return animateSimulateTick(
      leaf_node,
      trait,
      [
        ['x', ANIMATION_DELTA_THRESHOLD],
        ['y', ANIMATION_DELTA_THRESHOLD],
        ['width', ANIMATION_DELTA_THRESHOLD],
        ['height', ANIMATION_DELTA_THRESHOLD],
        ['fontSize', ANIMATION_DELTA_THRESHOLD / 10],
        ['opacity', ANIMATION_DELTA_THRESHOLD / 100],
        ['sx', ANIMATION_DELTA_THRESHOLD / 10],
        ['sy', ANIMATION_DELTA_THRESHOLD / 10],
        ['color', ANIMATION_DELTA_THRESHOLD / 100],
      ],
      (n) => {
        this._animate_leaf_frame_tick(leaf_id, n, include_scroll)
      }
    )
  }

  private _animate_leaf_frame_tick = (
    leaf_id: string,
    { x, y, sx, sy, width, height, opacity, fontSize, color },
    include_scroll: () => boolean
  ) => {
    const leaf_node = this._leaf_frame_node[leaf_id]
    const leaf_frame = this._leaf_frame[leaf_id]
    const leaf_layer = this._leaf_frame_layer[leaf_id]

    const { x: scrollX, y: scrollY } = getScrollPosition(
      leaf_layer.$element,
      this.$context.$element
    )

    leaf_node.x = x
    leaf_node.y = y
    leaf_node.width = width
    leaf_node.height = height
    leaf_node.fontSize = fontSize
    leaf_node.opacity = opacity
    leaf_node.sx = sx
    leaf_node.sy = sy
    leaf_node.color = color

    const color_: RGBA = [
      Math.floor(color[0]),
      Math.floor(color[1]),
      Math.floor(color[2]),
      Math.floor(color[3]),
    ]

    const scroll = include_scroll()

    const scrollX_ = scroll ? scrollX : 0
    const scrollY_ = scroll ? scrollY : 0

    leaf_frame.$element.style.left = `${
      x +
      this._leaf_layer_offset_x +
      ((Math.abs(sx) - 1) * width) / 2 +
      scrollX_
    }px`
    leaf_frame.$element.style.top = `${
      y +
      this._leaf_layer_offset_y +
      ((Math.abs(sy) - 1) * height) / 2 +
      scrollY_
    }px`
    leaf_frame.$element.style.width = `${width}px`
    leaf_frame.$element.style.height = `${height}px`
    leaf_frame.$element.style.transform = `scale(${sx}, ${sy})`
    leaf_frame.$element.style.opacity = `${opacity}`
    leaf_frame.$element.style.fontSize = `${fontSize}px`
    leaf_frame.$element.style.color = `${rgbaToHex(color_)}`
  }

  private _tick_animate_layout_move_children = (
    children: [string, string, string, string][],
    target: Dict<Component>,
    setup: (leaf_id: string, parent_id: string, slot_name: string) => void,
    callback: (leaf_id: string, ended: boolean) => void,
    should_expand_slot: boolean = true,
    offset: () => Point,
    include_scroll: () => boolean
  ) => {
    const {
      api: {
        text: { measureText },
        layout: { reflectChildrenTrait },
      },
    } = this.$system

    const root_base: Dict<Dict<string[]>> = {}
    const root_style: Dict<Dict<Tag[]>> = {}

    const parent_slot_base: Dict<string[]> = {}
    const parent_slot_style: Dict<Tag[]> = {}

    const all_leaf_trait: Dict<LayoutNode> = {}
    const all_leaf_style: Dict<Tag> = {}

    const tick_leaf = (
      leaf_id: string,
      leaf_trait_target: LayoutNode
    ): void => {
      const { x, y } = offset()

      leaf_trait_target.x += x
      leaf_trait_target.y += y

      const ended = this._animate_tick_leaf_trait(
        leaf_id,
        leaf_trait_target,
        include_scroll
      )

      callback(leaf_id, ended)
    }

    for (const [child_id, parent_id, target_id, slot_name] of children) {
      const child_component = this._get_sub_component(child_id)
      const target_component = this._get_sub_component(target_id)
      const target_frame = this._get_sub_component_frame(target_id)

      const target_frame_trait = extractTrait(target_frame, measureText)

      const base = this._get_sub_component_root_base(child_id)

      let child_base_slot: Component

      const child_slot_name =
        target_component.getParentRootSlotId(child_component) || 'default'
      const child_base_slot_path = [
        target_id,
        ...target_component.getSlotPath(child_slot_name),
      ]

      let child_slot_base_path = []
      let child_base_slot_lookup =
        this._component.pathGetSubComponent(child_base_slot_path)

      for (let i = child_base_slot_path.length - 1; i >= 0; i--) {
        if (!child_base_slot_lookup) {
          continue
        }

        if (child_base_slot_lookup.isBase()) {
          child_slot_base_path = child_slot_base_path.slice(0, i)

          break
        }

        child_base_slot_lookup = child_base_slot_lookup.$slotParent
      }

      const is_root = child_base_slot_path.length === 0

      const slot_leaf_id = joinPath(child_base_slot_path)

      let is_frame_target = child_id === target_id

      if (is_frame_target) {
        child_base_slot = target_frame
      } else {
        if (child_base_slot_lookup && !child_base_slot_lookup.$wrap) {
          child_base_slot = child_base_slot_lookup
        } else {
          child_base_slot = target_frame
        }
      }

      let slot_leaf_trait: LayoutNode = this._leaf_target_trait[slot_leaf_id]

      if (!slot_leaf_trait) {
        slot_leaf_trait = extractTrait(child_base_slot, measureText)

        slot_leaf_trait.sx /= this.$context.$sx
        slot_leaf_trait.sy /= this.$context.$sy

        slot_leaf_trait.x -= this.$context.$x
        slot_leaf_trait.y -= this.$context.$y

        slot_leaf_trait.x /= this.$context.$sx
        slot_leaf_trait.y /= this.$context.$sy
      }

      const slot_leaf_style = extractStyle(
        child_base_slot,
        target_frame_trait,
        measureText
      )

      all_leaf_trait[slot_leaf_id] = slot_leaf_trait
      all_leaf_style[slot_leaf_id] = {
        name: child_base_slot.$element.nodeName,
        style: slot_leaf_style,
      }

      for (const leaf of base) {
        const [leaf_path, leaf_comp] = leaf

        const _leaf_path = [child_id, ...leaf_path]

        const leaf_id = joinPath(_leaf_path)

        const leaf_style =
          this._leaf_style[leaf_id] ||
          extractStyle(leaf_comp, slot_leaf_trait, measureText)

        if (is_root) {
          root_base[target_id] = root_base[target_id] || {}
          root_style[target_id] = root_style[target_id] || {}

          root_base[target_id][slot_name] =
            root_base[target_id][slot_name] || []
          root_style[target_id][slot_name] =
            root_style[target_id][slot_name] || []

          root_base[target_id][slot_name].push(leaf_id)
          root_style[target_id][slot_name].push({
            name: leaf_comp.$element.nodeName,
            style: leaf_style,
          })
        } else {
          parent_slot_base[slot_leaf_id] = parent_slot_base[slot_leaf_id] || []
          parent_slot_base[slot_leaf_id].push(leaf_id)

          parent_slot_style[slot_leaf_id] =
            parent_slot_style[slot_leaf_id] || []
          parent_slot_style[slot_leaf_id].push({
            name: leaf_comp.$element.nodeName,
            style: leaf_style,
          })
        }

        setup(leaf_id, parent_id, slot_name)
      }
    }

    for (const target_id in root_base) {
      const base = root_base[target_id]
      const base_style = root_style[target_id]

      const parent_component = target[target_id]

      const target_frame = this._get_sub_component_frame(target_id)

      const target_frame_trait = extractTrait(target_frame, measureText)

      for (const slot_name in base) {
        const slot_base = base[slot_name]
        const slot_base_style = base_style[slot_name]

        const slot = parent_component.$slot[slot_name]

        const slot_offset = slot.getOffset()

        const slot_style =
          this._leaf_style[target_id] ??
          extractStyle(slot_offset, target_frame_trait, measureText)
        const slot_trait = extractTrait(slot_offset, measureText)

        const slot_base_trait = reflectChildrenTrait(
          slot_trait,
          slot_style,
          slot_base_style,
          (path): Tag[] => {
            return []
          }
        )

        let leaf_i = 0

        for (const leaf_id of slot_base) {
          const leaf_trait = slot_base_trait[leaf_i]
          const leaf_style = slot_base_style[leaf_i]

          all_leaf_trait[leaf_id] = leaf_trait
          all_leaf_style[leaf_id] = leaf_style

          leaf_i++
        }
      }
    }

    for (const slot_id in parent_slot_base) {
      const slot_base = parent_slot_base[slot_id]
      const slot_base_style = parent_slot_style[slot_id]

      const slot_trait: LayoutNode = all_leaf_trait[slot_id]
      const slot_style: Tag = all_leaf_style[slot_id]

      const slot_base_trait = reflectChildrenTrait(
        slot_trait,
        slot_style.style,
        slot_base_style,
        (path) => {
          if (!should_expand_slot) {
            return []
          }

          const children_style = expandSlot(
            this._component,
            slot_trait,
            slot_id,
            slot_id === slot_base[0] ? path.slice(1) : path,
            false,
            (leaf_id, leaf_comp) => {
              return this._extract_style(slot_trait, leaf_id, leaf_comp)
            }
          )

          return children_style
        }
      )

      let leaf_i = 0

      for (const leaf_id of slot_base) {
        const leaf_trait = slot_base_trait[leaf_i]

        all_leaf_trait[leaf_id] = leaf_trait

        tick_leaf(leaf_id, leaf_trait)

        leaf_i++
      }
    }
  }

  private _tick_animate_layout_transfer_children = (
    parent_id: string,
    slot_name: string,
    pack: [string, string, string, string][],
    target: Dict<Component>,
    should_expand_slot: boolean,
    offset: () => Point,
    include_scroll: () => boolean
  ) => {
    return this._tick_animate_layout_move_children(
      pack,
      target,
      (leaf_id, parent_id, slot_name) => {
        if (
          this._layout_transfer_parent_leaf_end_set[parent_id]?.[
            slot_name
          ]?.has(leaf_id)
        ) {
          this._layout_transfer_parent_leaf_end_count[parent_id][slot_name]--
          this._layout_transfer_parent_leaf_end_set[parent_id][
            slot_name
          ].delete(leaf_id)
        }
      },
      (leaf_id, ended) => {
        if (ended) {
          this._layout_transfer_parent_leaf_end_count[parent_id][slot_name]++
          this._layout_transfer_parent_leaf_end_set[parent_id][slot_name].add(
            leaf_id
          )
        }
      },
      should_expand_slot,
      offset,
      include_scroll
    )
  }

  private _set_all_current_layout_layer_core_position = (): void => {
    const current_layer = this._get_current_layout_layer_id()

    this._set_all_layout_layer_core_position(current_layer)
  }

  private _set_all_layout_layer_core_position = (
    layer: string | null
  ): void => {
    // console.log('Graph', '_set_all_layout_layer_core_position', layer)

    const children = this._spec_get_layout_layer_children(layer)

    for (const child_id of children) {
      const { x, y } = this._layout_target_node[child_id]

      this._set_layout_core_position(child_id, x, y)
    }
  }

  private _mem_pull_sub_component_child = (
    parent_id: string | null,
    child_id: string
  ): void => {
    // console.log('Graph', '_mem_pull_sub_component_child', parent_id, child_id)

    const { component } = this.$props

    const child_component = this._get_sub_component(child_id)

    if (parent_id) {
      const parent_component = this._get_sub_component(parent_id)

      parent_component.pullParentRoot(child_component)
    } else {
      component.pullRoot(child_component)
    }
  }

  private _mem_push_sub_component_child = (
    parent_id: string,
    child_id: string,
    slot_name: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_mem_push_parent_root',
    //   parent_id,
    //   child_id,
    //   slot_name
    // )

    const parent_component = this._get_sub_component(parent_id)
    const child_component = this._get_sub_component(child_id)
    const slot = this._get_sub_component_slot_name(child_id)

    parent_component.pushParentRoot(child_component, slot)

    this._layout_sub_component_parent[child_id] = parent_id

    this._mem_layout_push_parent_root(parent_id, child_id, slot_name)
  }

  private _mem_layout_push_parent_root = (
    parent_id: string,
    child_id: string,
    slot_name: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_mem_layout_push_parent_root',
    //   parent_id,
    //   child_id,
    //   slot_name
    // )

    this._refresh_component_children_counter_up(
      parent_id,
      1 + (this._layout_component_count[child_id] || 0)
    )
  }

  private _mem_push_sub_component = (
    parent_id: string | null,
    child_id: string,
    slot_name: string
  ) => {
    // console.log('Graph', '_mem_push_sub_component', parent_id, child_id, slot_name)

    if (parent_id === null) {
      this._mem_push_root(child_id)
    } else {
      this._mem_push_sub_component_child(parent_id, child_id, slot_name)
    }
  }

  private _mem_push_root = (child_id: string) => {
    // console.log('Graph', '_mem_push_root', child_id)

    const child_component = this._get_sub_component(child_id)

    this._component.pushRoot(child_component)
  }

  private _layout_layer_move_sub_component_child = (
    parent_id: string,
    next_parent_id: string | null,
    child_id: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_layout_layer_move_sub_component_child',
    //   parent_id,
    //   next_parent_id,
    //   child_id
    // )

    const layout_core = this._layout_core[child_id]

    const parent_layout_layer = this._ensure_layout_layer(parent_id)
    const next_parent_layout_layer = this._ensure_layout_layer(next_parent_id)

    if (parent_layout_layer.children.$children.includes(layout_core)) {
      parent_layout_layer.children.removeChild(layout_core)
    }
    if (!next_parent_layout_layer.children.$children.includes(layout_core)) {
      next_parent_layout_layer.children.appendChild(layout_core)
    }

    const layout_layer = this._get_layout_layer(child_id)

    if (layout_layer) {
      parent_layout_layer.layers.removeChild(layout_layer.layer)
      next_parent_layout_layer.layers.appendChild(layout_layer.layer)
    }
  }

  private _ensure_parent_layout_layer = (
    sub_component_id: string
  ): LayoutLayer => {
    const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)
    if (parent_id) {
      return this._ensure_layout_layer(parent_id)
    } else {
      return this._layout_root
    }
  }

  private _collapse_sub_component = (sub_component_id: string): void => {
    const sub_component = this._get_sub_component(sub_component_id)
    sub_component.collapse()
  }

  private _uncollapse_sub_component = (sub_component_id: string): void => {
    const sub_component = this._get_sub_component(sub_component_id)
    sub_component.uncollapse()
  }

  private _append_sub_component_to_root = (sub_component_id: string): void => {
    // console.log('Graph', '_append_sub_component_to_root', sub_component_id)

    const sub_component = this._get_sub_component(sub_component_id)
    this._component.appendRoot(sub_component)
  }

  private _insert_sub_component_root_at = (
    unit_id: string,
    at: number
  ): void => {
    // console.log('Graph', '_insert_sub_component_root_at', unit_id)
    const sub_component = this._get_sub_component(unit_id)
    this._component.insertRootAt(sub_component, at)
  }

  private _append_sub_component_parent_root = (
    parent_id: string,
    child_id: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_append_sub_component_parent_root',
    //   parent_id,
    //   child_id
    // )

    const parent_component = this._get_sub_component(parent_id)
    const child_component = this._get_sub_component(child_id)

    const slot = this._get_sub_component_slot_name(child_id)

    parent_component.appendParentRoot(child_component, slot)
  }

  private _insert_sub_component_parent_root_at = (
    parent_id: string,
    child_id: string,
    at: number
  ): void => {
    // console.log('Graph', '_insert_sub_component_parent_root_at', unit_id)
    const parent_component = this._get_sub_component(parent_id)
    const child_component = this._get_sub_component(child_id)
    const slot = this._get_sub_component_slot_name(child_id)
    parent_component.insertParentRootAt(child_component, at, slot)
  }

  private _remove_sub_component_parent_root = (
    sub_component_id: string,
    child_id: string
  ): void => {
    const sub_component = this._get_sub_component(sub_component_id)
    const sub_component_child = this._get_sub_component(child_id)

    sub_component.removeParentRoot(sub_component_child)
  }

  private _remove_sub_component_from_root = (
    sub_component_id: string
  ): void => {
    // console.log('Graph', '_remove_sub_component_from_root', sub_component_id)

    const sub_component = this._get_sub_component(sub_component_id)

    this._component.removeRoot(sub_component)
  }

  private _layout_collapse_sub_component = (
    sub_component_id: string,
    parent: string | null
  ): void => {
    // console.log('Graph', '_layout_collapse_sub_component')

    this._refresh_component_children_counter(sub_component_id)

    const sub_component = this._get_sub_component(sub_component_id)

    if (!this._layout_path.includes(sub_component_id)) {
      const sub_component_children =
        this._spec_get_sub_component_children(sub_component_id)

      for (const child_id of sub_component_children) {
        if (!this._is_fullwindow) {
          this._leave_sub_component_frame(child_id)
        }

        this._layout_collapse_sub_component(child_id, sub_component_id)
      }

      if (!this._is_fullwindow) {
        sub_component.collapse()
      }
    }

    const layout_core = this._layout_core[sub_component_id]

    this._listen_layout_core(sub_component_id, layout_core)

    const { width, height } =
      this._get_unit_component_layout_size(sub_component_id)

    this._resize_layout_core(sub_component_id, width, height)
  }

  private _layout_uncollapse_sub_component = (
    sub_component_id: string
  ): void => {
    // console.log('Graph', '_layout_uncollapse_sub_component', sub_component_id)

    const sub_component = this._get_sub_component(sub_component_id)

    const is_visible = this._layout_path.includes(sub_component_id)

    const sub_component_children =
      this._spec_get_sub_component_children(sub_component_id)

    if (!this._is_fullwindow) {
      for (const sub_child_id of sub_component_children) {
        if (!is_visible) {
          const sub_child_component = this._get_sub_component(sub_child_id)

          if (sub_component.$mountParentRoot.includes(sub_child_component)) {
            sub_component.removeParentRoot(sub_child_component)

            // this._enter_sub_component_frame(sub_child_id)
          }
        }

        this._layout_uncollapse_sub_component(sub_child_id)
      }
    }
  }

  private _move_core_content_layout_to_graph = (
    sub_component_id: string
  ): void => {
    // console.log('Graph', '_move_core_content_layout_to_graph', sub_component_id)

    this._remove_core_content_from_layout(sub_component_id)
    this._append_core_content_to_graph(sub_component_id)
  }

  private _remove_core_content_from_layout = (
    sub_component_id: string
  ): void => {
    // console.log('Graph', '_remove_core_content_from_layout', sub_component_id)

    const layout_core = this._layout_core[sub_component_id]
    const core_content = this._core_content[sub_component_id]

    layout_core.removeChild(core_content)
  }

  private _append_core_content_to_graph = (sub_component_id: string): void => {
    // console.log('Graph', '_append_core_content_to_graph', sub_component_id)

    const core = this._core[sub_component_id]
    const core_content = this._core_content[sub_component_id]

    core.appendChild(core_content)
  }

  public move_all_core_content_graph_to_layout = (): void => {
    for (const sub_component_id in this._component.$subComponent) {
      this._move_core_content_graph_to_layout(sub_component_id)
    }
  }

  private _move_core_content_graph_to_layout = (
    sub_component_id: string
  ): void => {
    // console.log('Graph', '_move_core_content_graph_to_layout', sub_component_id)

    this._remove_core_content_from_graph(sub_component_id)
    this._append_core_content_to_layout(sub_component_id)
  }

  private _append_core_content_to_layout = (sub_component_id: string): void => {
    // console.log('Graph', '_append_core_content_to_layout', sub_component_id)

    const layout_core = this._layout_core[sub_component_id]
    const core_content = this._core_content[sub_component_id]

    layout_core.appendChild(core_content)
  }

  private _remove_core_content_from_graph = (
    sub_component_id: string
  ): void => {
    // console.log('Graph', '_remove_core_content_from_graph', sub_component_id)

    const core = this._core[sub_component_id]
    const core_content = this._core_content[sub_component_id]

    core.removeChild(core_content)
  }

  private _get_component_children_count = (unit_id: string): number => {
    const children_count = this._layout_component_count[unit_id] || 0

    return children_count
  }

  private _refresh_component_children_counter = (unit_id: string): void => {
    // console.log('Graph', '_refresh_component_children_counter', unit_id)

    const children_counter = this._layout_core_children_counter[unit_id]

    const children_count = this._get_component_children_count(unit_id)

    children_counter.setProp('innerText', `${children_count}`)

    if (this._tree_layout) {
      if (children_count > 0) {
        children_counter.$element.style.opacity = '1'
      } else {
        children_counter.$element.style.opacity = '0'
      }
    } else {
      children_counter.$element.style.opacity = '0'
    }
  }

  private _refresh_component_children_counter_up = (
    unit_id: string,
    offset: number
  ): void => {
    // console.log(
    //   'Graph',
    //   '_refresh_component_children_counter_up',
    //   unit_id,
    //   offset
    // )

    let p = unit_id
    while (p) {
      this._layout_component_count[p] =
        (this._layout_component_count[p] ?? 0) + offset

      this._refresh_component_children_counter(p)

      p = this._layout_sub_component_parent[p]
    }
  }

  private _spec_remove_sub_component_from_parent = (child_id: string) => {
    removeSubComponentFromParent(
      { subComponentId: child_id },
      this._spec.component
    )
  }

  private _spec_append_sub_component_child = (
    parent_id: string,
    child_id: string,
    slot_name: string
  ): void => {
    // console.log('Graph', '_spec_append_component_child', parent_id, child_id, slot_name)

    this.__spec_append_sub_component_child(parent_id, child_id, slot_name)

    this._refresh_component_children_counter(parent_id)
    this._refresh_tree_sub_component_index()
  }

  private __spec_append_sub_component_child = (
    parent_id: string,
    child_id: string,
    slot_name: string
  ): void => {
    // console.log('Graph', '__spec_append_sub_component_child', parent_id, child_id, slot_name)

    if (parent_id) {
      appendSubComponentChild(
        { parentId: parent_id, childId: child_id },
        this._spec.component
      )

      this._layout_sub_component_parent[child_id] = parent_id
    } else {
      appendRoot({ childId: child_id }, this._spec.component)

      delete this._layout_sub_component_parent[child_id]
    }
  }

  private _pod_move_sub_component_root = (
    parentId: string | null,
    children: string[],
    slotMap: Dict<string>
  ): void => {
    // console.log(
    //   'Graph',
    //   '_pod_move_sub_component_root',
    //   parentId,
    //   children,
    //   slotMap
    // )

    const { fork, bubble } = this.$props

    this._pod.$moveSubComponentRoot({
      parentId,
      children,
      slotMap,
      fork,
      bubble,
    })
  }

  private _spec_get_component_children = (): string[] => {
    const { component: { children = [] } = {} } = this._spec

    return children
  }

  private _get_sub_component_spec_layer = (unit_id: string): string[] => {
    const parent_id = this._spec_get_sub_component_parent_id(unit_id)
    if (parent_id) {
      return this._spec_get_sub_component_children(parent_id)
    } else {
      return this._spec_get_component_children()
    }
  }

  private _spec_get_sub_component_parent_id = (
    unit_id: string
  ): string | null => {
    // TODO cache parent
    const component_spec = this._get_component_spec()

    const { subComponents } = component_spec

    for (const sub_component_id in subComponents) {
      const sub_component = subComponents[sub_component_id]

      const { children = [] } = sub_component

      for (const child_id of children) {
        if (child_id === unit_id) {
          return sub_component_id
        }
      }
    }

    return null
  }

  private _get_sub_component_layout_parent = (
    sub_component_id: string
  ): string | null => {
    const parent_id =
      this._layout_sub_component_parent[sub_component_id] || null

    return parent_id
  }

  private _reset_layout_transfer_parent_children = (
    parent_id: string,
    slot_name: string,
    children: string[]
  ): void => {
    this._layout_transfer_parent_remaining_child[parent_id] =
      this._layout_transfer_parent_remaining_child[parent_id] || {}
    this._layout_transfer_parent_remaining_child[parent_id][slot_name] =
      new Set(children)
  }

  private _reset_layout_transfer_parent = (
    parent_id: string,
    slot_name: string
  ): void => {
    this._layout_transfer_parent_leaf[parent_id] =
      this._layout_transfer_parent_leaf[parent_id] || {}
    this._layout_transfer_parent_leaf_path[parent_id] =
      this._layout_transfer_parent_leaf_path[parent_id] || {}
    this._layout_transfer_parent_leaf_comp[parent_id] =
      this._layout_transfer_parent_leaf_comp[parent_id] || {}
    this._layout_transfer_parent_leaf_sub_component_id[parent_id] =
      this._layout_transfer_parent_leaf_sub_component_id[parent_id] || {}
    this._layout_transfer_parent_leaf_end_count[parent_id] =
      this._layout_transfer_parent_leaf_end_count[parent_id] || {}
    this._layout_transfer_parent_leaf_end_set[parent_id] =
      this._layout_transfer_parent_leaf_end_set[parent_id] || {}
    this._layout_transfer_parent_leaf_count[parent_id] =
      this._layout_transfer_parent_leaf_count[parent_id] || {}

    this._layout_transfer_parent_leaf[parent_id][slot_name] = []
    this._layout_transfer_parent_leaf_path[parent_id][slot_name] = []
    this._layout_transfer_parent_leaf_comp[parent_id][slot_name] = []
    this._layout_transfer_parent_leaf_sub_component_id[parent_id][slot_name] =
      []
    this._layout_transfer_parent_leaf_end_count[parent_id][slot_name] = 0
    this._layout_transfer_parent_leaf_end_set[parent_id][slot_name] = new Set()
    this._layout_transfer_parent_leaf_count[parent_id][slot_name] = 0
  }

  public remove_sub_component_all_children = (
    parent_id: string,
    slot_name: string,
    next_parent_id: string | null,
    next_slot_name: string
  ): void => {
    const children = this._spec_get_sub_component_children(parent_id)

    const slot_map = this._get_sub_components_slot_map(children)
    const parent_map = this._get_sub_components_parent_map(children)

    this._dispatch_action(
      makeMoveSubComponentRootAction(null, parent_map, children, {}, slot_map)
    )

    this._remove_sub_component_all_children(
      parent_id,
      slot_name,
      next_parent_id,
      next_slot_name
    )
  }

  private _remove_sub_component_all_children = (
    parent_id: string,
    slot_name: string,
    next_parent_id: string | null,
    next_slot_name: string
  ): void => {
    const children = clone(this._spec_get_sub_component_children(parent_id))

    this._remove_sub_component_children(
      parent_id,
      slot_name,
      next_parent_id,
      next_slot_name,
      children
    )
  }

  private _remove_sub_component_children = (
    parent_id: string,
    slot_name: string,
    next_parent_id: string | null,
    next_slot_name: string,
    children: string[]
  ): void => {
    let { animate } = this._config()

    const parent_visible = this._is_layout_component_layer_visible(parent_id)

    animate = animate && !parent_visible

    const layout_parent_node = this._layout_node[parent_id]

    const { x, y, width, height } = layout_parent_node

    this._measure_sub_component_base(parent_id)

    for (const child_id of children) {
      this._cancel_layout_sub_component_animation(child_id)

      this._layout_layer_move_sub_component_child(
        parent_id,
        next_parent_id,
        child_id
      )

      if (animate) {
        this._set_layout_core_position(child_id, x, y)
        this._set_layout_core_size(child_id, width, height)

        this._measure_sub_component_base(child_id)
      }
    }

    if (this._tree_layout) {
      for (const child_id of children) {
        if (!this._animating_sub_component_base_id.has(child_id)) {
          if (!this._is_layout_component_layer_visible(parent_id)) {
            this._remove_sub_component_parent_root(parent_id, child_id)
          } else {
            //
          }

          if (animate) {
            this._remove_sub_component_root_base(child_id)
          }
        }
      }
    }

    this._cancel_layout_parent_children_animation(parent_id, slot_name)

    if (this._tree_layout) {
      if (animate) {
        this._setup_layout_sub_component_remove_parent_children_animation(
          parent_id,
          slot_name,
          children
        )
      }
    }

    for (const child_id of children) {
      this._pre_remove_sub_component_child(parent_id, child_id, next_parent_id)
    }

    this._refresh_current_layout_node_target_position()
    this._refresh_layout_node_target_position(next_parent_id)

    if (this._tree_layout) {
      if (animate) {
        const parent_animating = this._is_sub_component_animating(parent_id)

        const parent_leaf_traits = []

        const parent_layer = this._get_sub_component_layout_layer(parent_id)

        this._animate_parent_component(
          parent_id,
          parent_animating,
          parent_animating,
          parent_leaf_traits,
          parent_layer.foreground,
          1,
          false,
          () => ({ x: 0, y: -parent_layer.content.$element.scrollTop }),
          () => {
            this._unplug_sub_component_root_base_frame(parent_id)
            this._append_sub_component_root_base(parent_id)
            this._enter_sub_component_frame(parent_id)

            return true
          }
        )

        this._animate_all_layout_layer_node(next_parent_id)

        this._play_layout_sub_component_remove_children_animation(
          parent_id,
          slot_name,
          children,
          true,
          () => {
            this._end_layout_sub_component_transfer_children_animation(
              parent_id,
              slot_name,
              children
            )

            for (const child_id of children) {
              this._enter_sub_component_frame(child_id)
              this._append_sub_component_base(child_id)
            }
          }
        )
      } else {
        if (!parent_visible) {
          for (const child_id of children) {
            this._enter_sub_component_frame(child_id)
            this._append_sub_component_base(child_id)
          }
        }

        this._force_layout_node_traits(next_parent_id)
      }
    }
  }

  private _pre_remove_sub_component_child = (
    parent_id: string,
    child_id: string,
    next_parent_id: string | null
  ): void => {
    const is_child_fullwindow = this._is_sub_component_fullwindow(child_id)

    if (is_child_fullwindow) {
      this._decouple_sub_component(child_id)
    }

    this._mem_move_out_sub_component_child(parent_id, child_id, next_parent_id)
    this._layout_move_sub_component_child(parent_id, child_id, next_parent_id)
    this._spec_move_sub_component_child(
      parent_id,
      child_id,
      next_parent_id,
      'default'
    )
    this._pod_move_sub_component_root(next_parent_id, [child_id], {})

    if (is_child_fullwindow) {
      this._couple_sub_component(child_id)
    }
  }

  private _sim_move_out_sub_component_children = (
    parent_id: string,
    next_parent_id: string | null
  ): void => {
    const children = this._spec_get_sub_component_children(parent_id)

    const parent_component = this._get_sub_component(parent_id)

    for (const child_id of children) {
      const child_component = this._get_sub_component(child_id)

      if (this._tree_layout) {
        parent_component.removeParentRoot(child_component)

        this._enter_sub_component_frame(child_id)
      }

      parent_component.pullParentRoot(child_component)

      if (next_parent_id) {
        const next_parent_component = this._get_sub_component(next_parent_id)

        next_parent_component.pushParentRoot(child_component, 'default')
      } else {
        this._component.pushRoot(child_component)
      }
    }
  }

  private _sim_move_out_sub_component_layout_children = (
    parent_id: string,
    next_parent_id: string | null
  ): void => {
    const children = this._spec_get_sub_component_children(parent_id)

    for (const child_id of children) {
      this._layout_move_sub_component_child(parent_id, child_id, next_parent_id)
      this._layout_layer_move_sub_component_child(
        parent_id,
        next_parent_id,
        child_id
      )
    }
  }

  private _remove_sub_component_child = (
    parent_id: string,
    child_id: string
  ) => {
    const parent_component = this._get_sub_component(parent_id)
    const child_component = this._get_sub_component(child_id)

    parent_component.removeParentRoot(child_component)
  }

  private _mem_move_out_sub_component_child = (
    parent_id: string,
    child_id: string,
    next_parent_id: string | null
  ) => {
    // if (this._tree_layout) {
    this._mem_pull_sub_component_child(parent_id, child_id)

    if (next_parent_id) {
      this._mem_push_sub_component_child(next_parent_id, child_id, 'default')
    } else {
      this._mem_push_root(child_id)
    }
    // }
  }

  private _layout_move_sub_component_child = (
    parent_id: string,
    child_id: string,
    next_parent_id: string | null
  ): void => {
    // console.log(
    //   'Graph',
    //   '_layout_move_sub_component_child',
    //   parent_id,
    //   child_id,
    //   next_parent_id
    // )

    this._refresh_component_children_counter_up(
      parent_id,
      -(1 + (this._layout_component_count[child_id] || 0))
    )

    if (next_parent_id) {
      this._layout_sub_component_parent[child_id] = next_parent_id
    } else {
      delete this._layout_sub_component_parent[child_id]
    }
  }

  private _show_layout_core = (unit_id: string): void => {
    // console.log('Graph', '_show_layout_core', unit_id)

    const layout_core = this._layout_core[unit_id]

    layout_core.$element.style.pointerEvents = 'inherit'
    layout_core.$element.style.opacity = '1'

    if (this._tree_layout) {
      if (this._is_node_selected(unit_id)) {
        this._enable_core_resize(unit_id)
      }
    }
  }

  private _hide_layout_core = (unit_id: string): void => {
    // console.log('Graph', '_hide_layout_core', unit_id)

    const layout_core = this._layout_core[unit_id]

    layout_core.$element.style.pointerEvents = 'none'
    layout_core.$element.style.opacity = '0'

    if (this._tree_layout) {
      if (this._is_node_selected(unit_id)) {
        this._disable_core_resize(unit_id)
      }
    }
  }

  private _spec_remove_component_children = (
    parent_id: string,
    next_parent_id: string | null
  ): void => {
    const children = this._spec_get_sub_component_children(parent_id)

    for (const child_id of children) {
      this._spec_move_sub_component_child(
        parent_id,
        child_id,
        next_parent_id,
        'default'
      )
    }

    this._refresh_component_children_counter(parent_id)
  }

  private _spec_move_sub_component_child = (
    parent_id: string | null,
    child_id: string,
    next_parent_id: string,
    next_slot_id: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_spec_move_sub_component_child',
    //   parent_id,
    //   child_id,
    //   next_parent_id,
    //   next_slot_id
    // )

    this._spec.component = this._spec.component || {}

    if (parent_id) {
      removeSubComponentChild(
        { subComponentId: parent_id, childId: child_id },
        this._spec.component
      )
    } else {
      removeRoot({ childId: child_id }, this._spec.component)
    }

    if (next_parent_id) {
      appendSubComponentChild(
        { parentId: next_parent_id, childId: child_id },
        this._spec.component
      )

      this._layout_sub_component_parent[child_id] = next_parent_id
    } else {
      appendRoot({ childId: child_id }, this._spec.component)

      delete this._layout_sub_component_parent[child_id]
    }
  }

  private _is_unit_long_press_able = (unit_id: string): boolean => {
    if (this._mode === 'none') {
      if (!this._is_unit_base(unit_id)) {
        return true
      }
    } else {
      return true
    }

    return false
  }

  private _is_datum_long_press_able = (unit_id: string): boolean => {
    return false
  }

  private _is_node_mode_long_press_able = (node_id: string): boolean => {
    if (this._is_unit_node_id(node_id)) {
      return this._is_unit_long_press_able(node_id)
    } else if (this._is_datum_node_id(node_id)) {
      return this._is_datum_long_press_able(node_id)
    } else {
      return false
    }
  }

  private _is_node_none_long_press_able = (node_id: string): boolean => {
    if (this._is_unit_node_id(node_id)) {
      if (!this._is_unit_base(node_id)) {
        return true
      }
    }

    return false
  }

  private _is_node_blue_long_press_able = (node_id: string): boolean => {
    if (this._is_link_pin_node_id(node_id)) {
      if (this._is_input_pin_node_id(node_id)) {
        return true
      }
    }

    return false
  }

  private _on_node_long_press = (
    node_id: string,
    event: UnitPointerEvent
  ): void => {
    // console.log('Graph', '_on_node_long_press', node_id)

    const { pointerId, clientX, clientY, screenX, screenY } = event

    this._set_long_press_pointer(pointerId, clientX, clientY)

    if (this._resize_node_id_pointer_id[node_id]) {
      return
    }

    if (this._is_node_mode_long_press_able(node_id)) {
      this._animate_pulse(screenX, screenY, 'out')
    }

    if (this._tree_layout) {
      this.__on_layout_node_long_press(node_id, pointerId, clientX, clientY)
    } else {
      this._on_graph_node_long_press(
        node_id,
        pointerId,
        clientX,
        clientY,
        screenX,
        screenY
      )
    }
  }

  private __on_layout_node_long_press = (
    node_id: string,
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    if (this._is_unit_node_id(node_id)) {
      if (this._mode === 'none') {
        //
      } else if (this._mode === 'multiselect') {
        if (!this._layout_drag_node[node_id]) {
          this.__on_layout_component_drag_start(node_id, clientX, clientY)
        }

        if (this._is_node_selected(node_id)) {
          if (this._layout_drag_node[node_id]) {
            this._on_layout_component_drag_end(node_id)
          }

          this._cancel_node_long_click = true

          const next_parent_id = this._get_current_layout_layer_id()

          this._remove_sub_component_all_children(
            node_id,
            'default',
            next_parent_id,
            'default'
          )

          this.deselect_node(node_id)
        } else {
          const layout_layer_selected_count =
            this._get_layout_layer_selected_count()

          if (layout_layer_selected_count > 0) {
            this._cancel_node_long_click = true

            if (this._selected_component_count > 0) {
              const children_id: string[] = []

              for (const selected_node_id in this._selected_component) {
                const current_parent = this._get_current_layout_layer_id()

                if (
                  (this._layout_sub_component_parent[selected_node_id] ||
                    null) === current_parent
                ) {
                  children_id.push(selected_node_id)
                }
              }

              this._long_press_append_sub_component_children(
                node_id,
                children_id
              )
            }
          }
        }
      }
    }
  }

  private _on_graph_node_long_press = (
    node_id: string,
    pointerId: number,
    clientX: number,
    clientY: number,
    screenX: number,
    screenY: number
  ): void => {
    if (this._is_unit_node_id(node_id)) {
      this._on_unit_long_press(
        node_id,
        pointerId,
        clientX,
        clientY,
        screenX,
        screenY
      )
    } else if (this._is_link_pin_node_id(node_id)) {
      this._on_link_pin_long_press(node_id)
    } else if (this._is_datum_node_id(node_id)) {
      this._on_graph_datum_long_press(node_id, pointerId, clientX, clientY)
    } else if (this._is_ext_node_id(node_id)) {
      this._on_plug_long_press(node_id)
    }
  }

  private _on_plug_long_press = (plug_node_id: string) => {
    const { type, pinId } = segmentPlugNodeId(plug_node_id)

    const default_ignored = this._is_pin_default_ignored(type, pinId)

    if (this._mode === 'remove') {
      if (!default_ignored) {
        this._set_pin_set_default_ignored(type, pinId, true)
      }
    } else if (this._mode === 'add') {
      if (default_ignored) {
        this._set_pin_set_default_ignored(type, pinId, false)
      }
    }
  }

  private _is_pin_default_ignored = (type: IO, pinId: string): boolean => {
    const default_ignored = deepGetOrDefault(
      this._spec,
      [`${type}s`, pinId, 'defaultIgnored'],
      false
    )

    return default_ignored
  }

  private _set_pin_set_default_ignored = (
    type: IO,
    pinId: string,
    defaultIgnored: boolean
  ): void => {
    this._spec_set_pin_set_default_ignored(type, pinId, defaultIgnored)
    this._sim_set_pin_set_default_ignored(type, pinId, defaultIgnored)
    this._pod_set_pin_set_default_ignored(type, pinId, defaultIgnored)
  }

  private _sim_set_pin_set_default_ignored = (
    type: IO,
    pinId: string,
    ignored: boolean
  ): void => {
    const opacity = ignored ? DEFAULT_IGNORED_PIN_SET_OPACITY : 1

    this._set_pin_set_opacity(type, pinId, opacity)
  }

  private _spec_set_pin_set_default_ignored = (
    type: IO,
    pinId: string,
    ignored: boolean
  ): void => {
    setPinSetDefaultIgnored(
      { type, pinId, defaultIgnored: ignored },
      this._spec
    )
  }

  private _pod_set_pin_set_default_ignored = (
    type: IO,
    pinId: string,
    ignored: boolean
  ): void => {
    const { fork, bubble } = this.$props

    this._pod.$setPinSetDefaultIgnored({
      type,
      pinId,
      defaultIgnored: ignored,
      fork,
      bubble,
    })
  }

  private _on_unit_long_press = (
    unit_id: string,
    pointerId: number,
    clientX: number,
    clientY: number,
    screenX: number,
    screenY: number
  ): void => {
    if (this._mode === 'multiselect') {
      this._on_graph_group_unit_long_press(
        unit_id,
        pointerId,
        clientX,
        clientY,
        screenX,
        screenY
      )
    } else if (this._mode === 'add') {
      this._on_graph_green_unit_long_press(unit_id, pointerId, clientX, clientY)
    } else if (this._mode === 'change') {
      this._on_graph_blue_unit_long_press(unit_id, pointerId, clientX, clientY)
    } else if (this._mode === 'remove') {
      this._on_graph_red_unit_long_press(unit_id, pointerId, clientX, clientY)
    } else if (this._mode === 'data') {
      this._on_graph_yellow_unit_long_press(
        unit_id,
        pointerId,
        clientX,
        clientY
      )
    } else if (this._mode === 'none') {
      this._on_graph_none_unit_long_press(unit_id, pointerId, clientX, clientY)
    }
  }

  private _on_graph_datum_long_press = (
    datum_node_id: string,
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    if (this._mode === 'data') {
      this._yellow_long_press_datum(datum_node_id, pointerId, clientX, clientY)
    }
  }

  private _on_graph_group_node_long_press = (
    node_id: string,
    pointerId: number,
    clientX: number,
    clientY: number,
    screenX: number,
    screenY: number
  ): void => {
    if (this._is_unit_node_id(node_id)) {
      this._on_graph_group_unit_long_press(
        node_id,
        pointerId,
        clientX,
        clientY,
        screenX,
        screenY
      )
    } else if (this._is_datum_node_id(node_id)) {
      this._on_graph_group_datum_node_long_press(
        node_id,
        pointerId,
        clientX,
        clientY
      )
    }
  }

  private _on_graph_none_unit_long_press = (
    unit_id: string,
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    //
  }

  private _get_all_selected_node_ids = () => {
    return keys(this._selected_node_id)
  }

  private _add_empty_unit = (
    partial_spec: Partial<GraphSpec>,
    position: Position
  ) => {
    const { specs } = this.$props

    const new_spec_id = newSpecId(specs)

    this._add_empty_spec(new_spec_id, partial_spec)

    const new_unit_id = this._new_unit_id(new_spec_id)

    const unit: GraphUnitSpec = {
      id: new_spec_id,
    }

    const bundle = unitBundleSpec(unit, specs)

    const pin_position = { input: {}, output: {} }

    const layout_position = { x: 0, y: 0 }

    this.add_unit(
      new_unit_id,
      bundle,
      position,
      pin_position,
      layout_position,
      null
    )

    const { render } = partial_spec

    if (render) {
      this._mem_add_unit_component(new_unit_id, {})
      this._mem_add_unit_component_parent(new_unit_id)

      this._enter_sub_component_frame(new_unit_id)
    }

    return new_unit_id
  }

  private _compose_contained_nodes = (
    contained_node_ids: string[],
    partial_spec: Partial<GraphSpec>,
    position: Position,
    animate: boolean,
    partial_collapse_map?: Partial<GraphMoveSubGraphData>
  ): string => {
    const new_unit_id = this._add_empty_unit(partial_spec, position)

    this._move_contained_nodes(
      new_unit_id,
      contained_node_ids,
      animate,
      partial_collapse_map
    )

    return new_unit_id
  }

  private _on_graph_group_unit_long_press = (
    unit_id: string,
    pointerId: number,
    clientX: number,
    clientY: number,
    screenX: number,
    screenY: number
  ): void => {
    // console.log('Graph', '_on_graph_group_unit_long_press', unit_id)

    const {
      api: {
        window: { setTimeout },
      },
    } = this.$system

    if (this._is_node_selected(unit_id)) {
      if (this._collapse_next_unit_id === unit_id) {
        //
      } else {
        if (this._is_unit_base(unit_id)) {
          //
        } else {
          this._animate_pulse(screenX, screenY, 'out')

          this._cancel_long_click = true
          this._cancel_long_press = true

          if (this._multiselect_area_ing) {
            this._on_multiselect_area_end()
          }

          this._swap_next_click_hold_long_press = true
          this._cancel_click = true

          setTimeout(() => {
            this._swap_next_click_hold_long_press = false
            this._cancel_click = false
          }, 3 * CLICK_TIMEOUT)

          this.explode_unit(unit_id)
        }
      }
    } else {
      const is_component = this._is_unit_component(unit_id)

      const all_selected_node_ids = this._get_all_selected_node_ids()

      let collapse_node_ids = all_selected_node_ids

      let target_unit_id = unit_id

      if (this._is_unit_base(unit_id)) {
        const position = this._get_node_position(unit_id)
        const render = this._get_unit_spec_render(unit_id)

        let partial_spec: Partial<GraphSpec> = {
          render,
        }

        if (is_component) {
          const { width, height } = this._get_node_size(unit_id)

          partial_spec = {
            ...partial_spec,
            component: {
              slots: [],
              defaultWidth: width,
              defaultHeight: height,
            },
          }
        }

        const new_unit_id = this._add_empty_unit(partial_spec, position)

        if (is_component) {
          this._connect_sub_component(new_unit_id)
        }

        this._force_pointer_drag_swap(
          unit_id,
          new_unit_id,
          pointerId,
          clientX,
          clientY
        )

        target_unit_id = new_unit_id

        collapse_node_ids = [...collapse_node_ids, unit_id]
      }

      if (is_component) {
        for (const selected_node_id of all_selected_node_ids) {
          if (
            this._is_unit_node_id(selected_node_id) &&
            this._is_unit_component(selected_node_id)
          ) {
            const parent_id =
              this._spec_get_sub_component_parent_id(selected_node_id)

            if (parent_id !== unit_id) {
              this._state_pre_append_sub_component_child(
                unit_id,
                selected_node_id,
                'default'
              )
            }
          }
        }
      }

      const screen_position = this._get_node_screen_position(target_unit_id)

      const long_press_collapse_started = this._start_long_press_collapse(
        pointerId,
        target_unit_id,
        collapse_node_ids,
        screen_position
      )

      if (long_press_collapse_started) {
        if (!this._drag_node_id[target_unit_id]) {
          this.__drag_start(target_unit_id, pointerId, clientX, clientY)
        }
      }

      this._cancel_long_click = true
      this._cancel_long_press = true
    }
  }

  private _on_graph_green_unit_long_press = (
    unit_id: string,
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    // console.log('Graph', '_on_graph_green_unit_long_press')

    const bundle = this._get_unit_bundle(unit_id)

    this._swap_long_press_unit_bundle(
      unit_id,
      bundle,
      pointerId,
      clientX,
      clientY
    )
  }

  private _swap_long_press_unit_bundle = (
    unit_id: string,
    bundle: UnitBundleSpec,
    pointerId: number,
    clientX: number,
    clientY: number
  ) => {
    // console.log('Graph', '_swap_long_press_unit_bundle', unit_id, bundle, pointerId, clientX, clientY)

    const position = this._screen_to_world(clientX, clientY)

    const { datum_node_id } = this._add_data_unit(bundle, position)

    this._force_pointer_drag_swap(
      unit_id,
      datum_node_id,
      pointerId,
      clientX,
      clientY
    )

    if (this._is_draggable_mode()) {
      this._ascend_node(datum_node_id)
    }
  }

  private _on_graph_yellow_unit_long_press = (
    unit_id: string,
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    // console.log('Graph', '_on_graph_yellow_unit_long_press')

    this._pod_get_unit_deep_bundle(unit_id, (bundle) => {
      this._swap_long_press_unit_bundle(
        unit_id,
        bundle,
        pointerId,
        clientX,
        clientY
      )
    })
  }

  private _on_graph_blue_unit_long_press = (
    unit_id: string,
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    const new_spec = this._make_unit_body_spec(unit_id)
    const new_unit_id = newUnitIdFromName(this._spec, new_spec.name)

    this._pod_remove_unit_ghost(
      unit_id,
      new_unit_id,
      new_spec,
      ({ specId, bundle }) => {
        this._swap_long_press_unit_bundle(
          unit_id,
          bundle,
          pointerId,
          clientX,
          clientY
        )
        this._state_remove_unit_ghost(unit_id, specId, new_spec)
      }
    )
  }

  private _make_unit_body_spec = (unit_id: string): GraphSpec => {
    const spec = this._get_unit_spec(unit_id)

    const new_name = spec.name
    const new_type = spec.type

    const new_render = this._is_unit_component(unit_id)

    const new_inputs = mapObjKV(spec.inputs || {}, (input_id) => {
      const pin_node_id = getInputNodeId(unit_id, input_id)

      const defaultIgnored = this._is_link_pin_default_ignored(pin_node_id)
      const ref = this._is_link_pin_ref(pin_node_id)

      return {
        plug: { 0: {} },
        ref,
        defaultIgnored,
      }
    })

    const new_outputs = mapObjKV(spec.outputs || {}, (output_id) => {
      const pin_node_id = getOutputNodeId(unit_id, output_id)

      const defaultIgnored = this._is_link_pin_default_ignored(pin_node_id)
      const ref = this._is_link_pin_ref(pin_node_id)

      return {
        plug: { 0: {} },
        ref,
        defaultIgnored,
      }
    })

    const { width: defaultWidth, height: defaultHeight } =
      this._get_unit_component_default_size(unit_id)

    const new_component = {
      defaultWidth,
      defaultHeight,
    }

    const new_spec = emptySpec({
      name: new_name,
      inputs: new_inputs,
      outputs: new_outputs,
      render: new_render,
      component: new_component,
      type: new_type,
    })

    return new_spec
  }

  private _on_graph_red_unit_long_press = (
    unit_id: string,
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    const new_spec = this._make_unit_body_spec(unit_id)

    const next_unit_id = newUnitIdFromName(this._spec, new_spec.name)

    this._pod_remove_unit_ghost(
      unit_id,
      next_unit_id,
      new_spec,
      ({ specId, bundle }) => {
        this._swap_long_press_unit_bundle(
          unit_id,
          bundle,
          pointerId,
          clientX,
          clientY
        )
        this._state_remove_unit_ghost(unit_id, specId, new_spec)
      }
    )

    if (this._is_unit_component(next_unit_id)) {
      this._connect_sub_component(next_unit_id)
    }
  }

  private _is_link_pin_default_ignored = (pin_node_id: string): boolean => {
    const pin_spec = this._get_unit_pin_spec(pin_node_id)

    const { defaultIgnored = false } = pin_spec

    return defaultIgnored
  }

  private _abort_graph_node_transition: Dict<Unlisten> = {}

  private _animate_nodes_style = (
    node_ids: string[],
    n0f: (node_id: string) => Dict<number>,
    n1: () => Dict<number>,
    ff: [string, number][],
    f: (node_id: string, n: Dict<number>) => void,
    callback: (node_id: string) => void
  ) => {
    for (const node_id of node_ids) {
      const n0 = n0f(node_id)

      this._animate_node_style(
        node_id,
        n0,
        n1,
        ff,
        (n) => f(node_id, n),
        () => callback(node_id)
      )
    }
  }

  private _animate_node_style = (
    node_id: string,
    n0: Dict<number>,
    n1: () => Dict<number>,
    ff: [string, number][],
    f: (n: Dict<number>) => void,
    callback: Callback
  ) => {
    this._abort_graph_node_transition[node_id] = this._animate_simulate(
      n0,
      n1,
      ff,
      f,
      callback
    )
  }

  private _animate_core_size_and_opacity = (
    unit_id: string,
    n0: Rect & { opacity: number },
    n1: () => Rect & { opacity: number },
    f: (n: Rect & { opacity: number }) => void,
    callback: Callback
  ): Unlisten => {
    const unlisten = this.__animate_core_style(
      unit_id,
      n0,
      n1,
      [
        ['width', 1],
        ['height', 1],
        ['opacity', 0.1],
      ],
      f,
      callback
    )

    return unlisten
  }

  private _animate_core_size = (
    unit_id: string,
    n0: Size,
    n1: () => Size,
    f: (n: Size) => void,
    callback: Callback
  ): Unlisten => {
    const unlisten = this.__animate_core_style(
      unit_id,
      n0,
      n1,
      [
        ['width', 1],
        ['height', 1],
      ],
      f,
      callback
    )

    return unlisten
  }

  private __animate_core_style = (
    unit_id: string,
    n0: Dict<any>,
    n1: () => Dict<any>,
    ff: [string, number][],
    f: (n: Dict<any>) => void,
    callback: Callback
  ): Unlisten => {
    const unlisten = this._animate_simulate(n0, n1, ff, f, callback)

    this._abort_graph_node_transition[unit_id] = unlisten

    return unlisten
  }

  private _get_unit_exposed_pins = (
    unit_id: string
  ): IOOf<
    Dict<{ type: IO; pinId: string; subPinId: string; position: Position }>
  > => {
    const exposed_pin_ids: IOOf<
      Dict<{ type: IO; pinId: string; subPinId: string; position: Position }>
    > = {
      input: {},
      output: {},
    }

    this._for_each_unit_pin(unit_id, (pin_node_id, type, pin_id) => {
      const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)

      const int_node_id = this._pin_to_int[type][anchor_node_id]

      if (int_node_id) {
        const { type, pinId, subPinId } = segmentPlugNodeId(int_node_id)

        const position = this._get_node_position(anchor_node_id)

        exposed_pin_ids[type][pin_id] = { type, pinId, subPinId, position }
      }
    })

    return exposed_pin_ids
  }

  private _get_unit_input_names = (unit_id: string): string[] => {
    const spec = this._get_unit_spec(unit_id)

    const { inputs = {} } = spec

    return keys(inputs)
  }

  private _get_unit_input_node_ids = (unit_id: string): string[] => {
    const names = this._get_unit_input_names(unit_id)

    return names.map(getPinNodeId__(unit_id, 'input'))
  }

  private _get_unit_output_names = (unit_id: string): string[] => {
    const spec = this._get_unit_spec(unit_id)

    const { outputs = {} } = spec

    return keys(outputs)
  }

  private _get_unit_output_node_ids = (unit_id: string): string[] => {
    const names = this._get_unit_output_names(unit_id)

    return names.map(getPinNodeId__(unit_id, 'output'))
  }

  private _get_unit_tag_exposed_pins = (unit_id: string) => {
    const exposed_pin_ids = {
      input: {
        data: {},
        ref: {},
      },
      output: {
        data: {},
        ref: {},
      },
    }

    this._for_each_unit_pin(unit_id, (pin_node_id, type, pin_id) => {
      const opposite_type = opposite(type)

      const ref = this._is_link_pin_ref(pin_node_id)

      const tag = ref ? 'ref' : 'data'

      const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)

      const int_node_id = this._pin_to_int[type][anchor_node_id]
      const opposite_int_node_id =
        this._pin_to_int[opposite_type][anchor_node_id]

      if (int_node_id) {
        const { pinId, subPinId } = segmentPlugNodeId(int_node_id)

        exposed_pin_ids[type][tag][pin_id] = [pinId, subPinId, type]
      }

      if (opposite_int_node_id) {
        const { pinId, subPinId } = segmentPlugNodeId(opposite_int_node_id)

        exposed_pin_ids[type][tag][pin_id] = [pinId, subPinId, opposite_type]
      }
    })

    return exposed_pin_ids
  }

  private _get_unit_tag_merges = (unit_id: string): IOOf<TagData<string[]>> => {
    const merged_pin_ids: IOOf<TagData<string[]>> = {
      input: {
        data: [],
        ref: [],
      },
      output: {
        data: [],
        ref: [],
      },
    }

    this._for_each_unit_pin(unit_id, (pin_node_id, type, pin_id) => {
      const merge_node_id = this._pin_to_merge[pin_node_id]

      const ref = this._is_link_pin_ref(pin_node_id)

      const tag = ref ? 'ref' : 'data'

      if (merge_node_id) {
        merged_pin_ids[type][tag].push(pin_id)
      }
    })

    return merged_pin_ids
  }

  private _generate_identity_matches = (unit_id: string) => {
    const unit_spec = this._get_unit_spec(unit_id)

    const input_names = keys(unit_spec.inputs ?? {})
    const output_names = keys(unit_spec.outputs ?? {})

    const data_input_names = input_names.filter(
      (pin_id) => !this.__is_link_pin_ref(unit_id, 'input', pin_id)
    )
    const data_output_names = output_names.filter(
      (pin_id) => !this.__is_link_pin_ref(unit_id, 'output', pin_id)
    )
    const ref_input_names = input_names.filter((pin_id) =>
      this.__is_link_pin_ref(unit_id, 'input', pin_id)
    )
    const ref_output_names = output_names.filter((pin_id) =>
      this.__is_link_pin_ref(unit_id, 'output', pin_id)
    )

    const valid_pin_match: IOKindOf<[number, number][]> = {
      input: {
        data: data_input_names.map((_, i: number) => [i, i]),
        ref: ref_input_names.map((_, i: number) => [i, i]),
      },
      output: {
        data: data_output_names.map((_, i: number) => [i, i]),
        ref: ref_output_names.map((_, i: number) => [i, i]),
      },
    }

    const merge_pin_index: IOKindOf<Dict<number>> = {
      input: {
        data: data_input_names.reduce((acc, pin_id, index) => {
          acc[pin_id] = index

          return acc
        }, {}),
        ref: ref_input_names.reduce((acc, pin_id, index) => {
          acc[pin_id] = index

          return acc
        }, {}),
      },
      output: {
        data: data_output_names.reduce((acc, pin_id, index) => {
          acc[pin_id] = index

          return acc
        }, {}),
        ref: ref_output_names.reduce((acc, pin_id, index) => {
          acc[pin_id] = index

          return acc
        }, {}),
      },
    }

    const exposed_pin_index: IOKindOf<Dict<number>> = {
      input: {
        data: data_input_names.reduce((acc, pin_id, index) => {
          acc[pin_id] = index

          return acc
        }, {}),
        ref: ref_input_names.reduce((acc, pin_id, index) => {
          acc[pin_id] = index

          return acc
        }, {}),
      },
      output: {
        data: data_output_names.reduce((acc, pin_id, index) => {
          acc[pin_id] = index

          return acc
        }, {}),
        ref: ref_output_names.reduce((acc, pin_id, index) => {
          acc[pin_id] = index

          return acc
        }, {}),
      },
    }

    const merged_pin_ids = this._get_unit_tag_merges(unit_id)
    const exposed_pin_ids = this._get_unit_tag_exposed_pins(unit_id)

    return {
      valid_pin_match,
      merge_pin_index,
      exposed_pin_index,
      merged_pin_ids,
      exposed_pin_ids,
    }
  }

  private _state_remove_unit_ghost = (
    unit_id: string,
    new_spec_id: string,
    new_spec: GraphSpec
  ): void => {
    // console.log('Graph', '_state_remove_unit_ghost', unit_id)

    const { setSpec } = this.$props

    setSpec(new_spec_id, new_spec)

    const unit_node = this._node[unit_id]

    const {
      x: prev_x,
      y: prev_y,
      width: prev_width,
      height: prev_height,
    } = unit_node

    const new_unit_id = this._new_unit_id(new_spec_id)

    const {
      valid_pin_match,
      merge_pin_index,
      exposed_pin_index,
      merged_pin_ids,
      exposed_pin_ids,
    } = this._generate_identity_matches(unit_id)

    this._state_swap_unit(
      unit_id,
      new_unit_id,
      new_spec_id,
      new_spec,
      valid_pin_match,
      merged_pin_ids,
      merge_pin_index,
      exposed_pin_ids,
      exposed_pin_index
    )

    const { x, y, width, height } = this._node[new_unit_id]

    const target_trait = {
      x,
      y,
      width,
      height,
      opacity: 1,
    }

    this._animate_core_size_and_opacity(
      new_unit_id,
      {
        x: prev_x,
        y: prev_y,
        width: prev_width,
        height: prev_height,
        opacity: 1,
      },
      () => {
        return target_trait
      },
      ({ x, y, width, height }) => {
        this._set_node_x(new_unit_id, x)
        this._set_node_y(new_unit_id, y)

        this._resize_core_width(new_unit_id, width)
        this._resize_node_width(new_unit_id, width)

        this._resize_core_height(new_unit_id, height)
        this._resize_node_height(new_unit_id, height)
      },
      () => {
        //
      }
    )

    this._refresh_compatible()
  }

  private _on_graph_group_datum_node_long_press = (
    datum_node_id: string,
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    const { datumId } = segmentDatumNodeId(datum_node_id)

    const array_tree = this._datum_tree[datumId]

    const { type: array_type } = array_tree

    const is_array = array_type === TreeNodeType.ArrayLiteral

    if (is_array) {
      const screen_position = this._get_node_screen_position(datum_node_id)

      const datum_node = this._node[datum_node_id]

      screen_position.x += datum_node.width * this._zoom.z
      screen_position.y += (datum_node.height * this._zoom.z) / 2

      const all_selected_node_ids = keys(this._selected_node_id)

      this._start_long_press_collapse(
        pointerId,
        datum_node_id,
        all_selected_node_ids,
        screen_position
      )
      this._set_node_layer(datum_node_id, LAYER_COLLAPSE)

      if (!this._drag_node_id[datum_node_id]) {
        this.__drag_start(datum_node_id, pointerId, clientX, clientY)
      }

      this._cancel_long_click = true
      this._cancel_long_press = true
    }
  }

  private _explode_unit = (
    unit_id: string,
    map_unit_id: Dict<string>,
    map_merge_id: Dict<string>,
    map_plug_id: IOOf<Dict<Dict<string>>>,
    selected_node_ids: string[]
  ): void => {
    // console.log('Graph', '_explode_unit', unit_id)

    const { getSpec } = this.$props

    const unit_spec = this._get_unit_spec(unit_id) as GraphSpec

    const {
      units: _units = {},
      merges: _merges = {},
      inputs = {},
      outputs = {},
    } = unit_spec

    const actions = this._make_explode_unit_actions(
      unit_id,
      map_unit_id,
      map_merge_id,
      map_plug_id
    )

    this._state_explode_unit(
      unit_id,
      map_unit_id,
      map_merge_id,
      map_plug_id,
      selected_node_ids
    )

    this._pod_explode_unit(unit_id, map_unit_id, map_merge_id, actions)
  }

  private _make_full_spec_collapse_map = (
    unit_id: string,
    spec: GraphSpec,
    map_unit_id: Dict<string>,
    map_merge_id: Dict<string>,
    map_plug_id: IOOf<Dict<Dict<string>>>
  ): GraphMoveSubGraphData => {
    return makeFullSpecCollapseMap(
      unit_id,
      spec,
      map_unit_id,
      map_merge_id,
      map_plug_id,
      {
        getMerge: (mergeId) => this._spec_get_merge(mergeId),
        getUnitMerges: (unitId) => this._get_unit_merges(unitId),
        getUnitPlugs: (unitId) => this._get_unit_plugs(unitId),
        getPinMergeId: (unitId, type, pinId) => {
          const pin_node_id = getPinNodeId(unitId, type, pinId)

          return this._get_pin_merge_id(pin_node_id)
        },
        getPlugSpec: this._get_exposed_sub_pin_spec,
        getUnitPinSpec: this.__get_unit_pin_spec,
      }
    )
  }

  private _make_explode_unit_actions = (
    unit_id: string,
    map_unit_id: Dict<string>,
    map_merge_id: Dict<string>,
    map_plug_id: IOOf<Dict<Dict<string>>>
  ) => {
    const { shouldFork, newSpecId } = this.$props

    const spec = this._get_unit_spec(unit_id) as GraphSpec
    const unit = this._get_unit(unit_id)

    const { id } = spec

    const new_unit = clone(unit)

    const collapse_map: GraphMoveSubGraphData =
      this._make_full_spec_collapse_map(
        unit_id,
        spec,
        map_unit_id,
        map_merge_id,
        map_plug_id
      )

    const render = this._get_unit_spec_render(unit_id)

    const is_component = this._is_unit_component(unit_id)

    if (is_component) {
      const { width, height } = this._get_unit_component_graph_size(unit_id)

      deepSet(new_unit, ['metadata', 'component', 'width'], width)
      deepSet(new_unit, ['metadata', 'component', 'height'], height)
    }

    const empty_bundle: UnitBundleSpec = {
      unit: new_unit,
      specs: {
        [new_unit.id]: {
          name: spec.name,
          units: {},
          inputs: {},
          outputs: {},
          render,
          id,
        },
      },
    }

    const graph_unit_bundle_spec = this._get_graph_unit_bundle_spec(unit_id)
    const graph_spec = this._get_unit_spec(unit_id) as GraphSpec

    return [
      wrapMoveSubgraphOutOfData({
        graphId: unit_id,
        graphBundle: graph_unit_bundle_spec,
        graphSpec: graph_spec,
        ...collapse_map,
      }),
      this._make_remove_unit_action(unit_id, empty_bundle, false, false),
    ]
  }

  private _make_explode_unit_action = (
    unit_id: string,
    map_unit_id: Dict<string>,
    map_merge_id: Dict<string>,
    map_plug_id: IOOf<Dict<Dict<string>>>
  ) => {
    const actions = this._make_explode_unit_actions(
      unit_id,
      map_unit_id,
      map_merge_id,
      map_plug_id
    )

    return makeBulkEditAction(actions)
  }

  public explode_unit = (unit_id: string): void => {
    // console.log('Graph', 'explode_unit', unit_id)

    const { getSpec } = this.$props

    const unit_spec = this._get_unit_spec(unit_id) as GraphSpec

    const { map_unit_id, map_merge_id, map_plug_id, selected_node_ids } =
      buildGraphRemap(
        unit_spec,
        getSpec,
        this._new_unit_id,
        this._new_merge_id,
        this._new_sub_pin_id,
        this._new_datum_id
      )

    const action = this._make_explode_unit_action(
      unit_id,
      map_unit_id,
      map_merge_id,
      map_plug_id
    )

    this._dispatch_action(action)

    this._explode_unit(
      unit_id,
      map_unit_id,
      map_merge_id,
      map_plug_id,
      selected_node_ids
    )
  }

  private _state_explode_unit = (
    unit_id: string,
    map_unit_id: Dict<string>,
    map_merge_id: Dict<string>,
    map_plug_id: IOOf<Dict<Dict<string>>>,
    selected_node_ids: string[]
  ): void => {
    // console.log('Graph', '_state_explode_unit', unit_id)

    const {
      api: {
        window: { setTimeout },
      },
    } = this.$system

    this._simulation_prevent_restart = true

    const _spec = this._get_unit_spec(unit_id) as GraphSpec

    const {
      units: _units = {},
      merges: _merges = {},
      inputs = {},
      outputs = {},
    } = _spec

    const unit_merges = clone(this._get_unit_merges(unit_id))
    const unit_plugs = clone(this._get_unit_plugs(unit_id))
    const unit_merge_position = mapObjKV(unit_merges, (mergeId) => {
      return this.__get_merge_node_position(mergeId)
    })
    const unit_data = this._get_unit_data(unit_id)
    const unit_merge_selected = mapObjKV(unit_merges, (mergeId) => {
      const merge_node_id = getMergeNodeId(mergeId)

      return this._is_node_selected(merge_node_id)
    })

    forEachGraphSpecPin(_spec, (type, pinId, pinSpec) => {
      const { plug } = pinSpec

      const pin_node_id = getPinNodeId(unit_id, type, pinId)

      const merge_node_id = this._pin_to_merge[pin_node_id]

      const merged = !!merge_node_id

      if (merge_node_id) {
        const { mergeId } = segmentMergeNodeId(merge_node_id)

        const merge_spec = clone(this._get_merge(merge_node_id))

        delete merge_spec[unit_id]

        const merge_pin_count = getMergePinCount(merge_spec)

        let should_selected_merge = false

        for (const sub_pin_id in plug) {
          const sub_pin = plug[sub_pin_id]

          if (sub_pin.mergeId) {
            should_selected_merge = true
          }
        }

        if (merge_pin_count === 1) {
          const opposite_unit_id = getObjSingleKey(merge_spec)

          if (should_selected_merge) {
            selected_node_ids.push(merge_node_id)
          } else {
            const opposite_type = getObjSingleKey(
              merge_spec[opposite_unit_id]
            ) as IO
            const opposite_pin_id = getObjSingleKey(
              merge_spec[opposite_unit_id][opposite_type]
            )

            const opposite_pin_node_id = getPinNodeId(
              opposite_unit_id,
              opposite_type,
              opposite_pin_id
            )

            if (this._has_node(opposite_pin_node_id)) {
              selected_node_ids.push(opposite_pin_node_id)
            }
          }
        } else if (merge_pin_count > 1) {
          const merge_input_count = getMergePinTypeCount(merge_spec, 'input')
          const merge_output_count = getMergePinTypeCount(merge_spec, 'output')

          if (merge_input_count === 0 || merge_output_count === 0) {
            const merge_pin_ids: Dict<string[]> = {
              input: [],
              output: [],
            }

            forEachPinOnMerge(merge_spec, (unit_id, type, pin_id) => {
              merge_pin_ids[type].push(pin_id)
            })

            const get_first = (type: IO) => {
              return merge_pin_ids[type].sort((a, b) => a.localeCompare(b))[0]
            }

            const merge_anchor_pin_id = {
              input: get_first('input'),
              output: get_first('output'),
            }

            const opposite_type = opposite(type)

            if (merge_anchor_pin_id[opposite_type] === pinId) {
              selected_node_ids.push(merge_node_id)
            }
          }
        } else {
          //
        }
      }

      for (const sub_pin_id in plug) {
        const sub_pin_spec = plug[sub_pin_id]

        const next_sub_pin_id = deepGetOrDefault(
          map_plug_id,
          [type, pinId, sub_pin_id],
          sub_pin_id
        )

        const outer_plug = this._spec_get_unit_pin_plug(unit_id, type, pinId)

        if (
          shouldExposePin(
            type,
            pinId,
            pinSpec,
            sub_pin_id,
            sub_pin_spec,
            merged,
            outer_plug
          )
        ) {
          const ext_node_id = getExtNodeId(
            type,
            outer_plug?.pinId ?? pinId,
            next_sub_pin_id
          )

          selected_node_ids.push(ext_node_id)
        } else if (outer_plug) {
          const int_node_id = getIntNodeId(
            type,
            outer_plug?.pinId ?? pinId,
            sub_pin_id
          )

          selected_node_ids.push(int_node_id)
        }
      }
    })

    const core_node = this._node[unit_id]

    const { x, y, width, height } = core_node

    const k = 1.25

    const target_node = {
      x,
      y,
      width: k * width,
      height: k * height,
      opacity: 0,
    }

    const init_node = { x, y, width, height, opacity: 1 }

    this._state_remove_unit_merges(unit_id)
    this._state_remove_unit_plugs(unit_id)

    this._negate_unit_layer(unit_id)

    this._disable_unit_pointer_events(unit_id)

    this._animating_unit_explosion[unit_id] = new Promise<void>((resolve) => {
      this._animate_core_size_and_opacity(
        unit_id,
        init_node,
        () => {
          return target_node
        },
        ({ x, y, width, height, opacity }) => {
          set_opacity(unit_id, opacity)

          this._set_node_x(unit_id, x)
          this._set_node_y(unit_id, y)

          this._resize_core_width(unit_id, width)
          this._resize_node_width(unit_id, width)

          this._resize_core_height(unit_id, height)
          this._resize_node_height(unit_id, height)
        },
        () => {
          const { parent } = this.$props

          delete this._animating_unit_explosion[unit_id]

          const unregister = !parent

          this._state_remove_unit(unit_id, unregister, false)

          resolve()
        }
      )
    })

    this._state_gut_unit(
      unit_id,
      map_unit_id,
      map_merge_id,
      map_plug_id,
      unit_merges,
      unit_plugs,
      unit_data,
      unit_merge_position,
      unit_merge_selected
    )

    const visible_selected_node_ids = selected_node_ids.filter((n_id) =>
      this._is_node_visible(n_id)
    )

    const visible_anchor_node_ids = [
      ...new Set(visible_selected_node_ids.map(this._get_node_anchor_node_id)),
    ]

    this._select_many(visible_anchor_node_ids)

    const set_opacity = (node_id, opacity) => {
      if (this._has_node(node_id)) {
        this._set_node_opacity(node_id, opacity)
      }

      if (this._is_unit_node_id(node_id)) {
        this._for_each_unit_pin(node_id, (pin_node_id) => {
          if (
            this._has_node(pin_node_id) &&
            !this._spec_is_link_pin_ignored(pin_node_id)
          ) {
            set_opacity(pin_node_id, opacity)
          }
        })

        const err_node_id = getErrNodeId(node_id)

        if (this._has_node(err_node_id)) {
          this._set_err_opacity(err_node_id, opacity)
        }
      }

      if (this._is_link_pin_node_id(node_id)) {
        this._set_link_pin_opacity(node_id, opacity)

        const datum_node_id = this._pin_to_datum[node_id]

        if (datum_node_id) {
          this._set_datum_opacity(datum_node_id, opacity)
        }
      } else if (this._is_merge_node_id(node_id)) {
        const { mergeId } = segmentMergeNodeId(node_id)

        this._for_each_merge_pin(mergeId, (unit_id, type, pin_id) => {
          if (pin_id !== SELF) {
            const pin_node_id = getPinNodeId(unit_id, type, pin_id)

            this._set_link_pin_opacity(pin_node_id, opacity)
          }
        })
      }
    }

    this._animate_nodes_style(
      visible_anchor_node_ids,
      () => ({ opacity: 0 }),
      () => ({ opacity: 1 }),
      [['opacity', ANIMATION_DELTA_THRESHOLD]],
      (node_id, { opacity }) => {
        set_opacity(node_id, opacity)
      },
      (node_id) => {
        set_opacity(node_id, 1)
      }
    )

    this._simulation.alpha(1)
    this._simulation.alphaDecay(0)

    setTimeout(() => {
      this._simulation.alphaDecay(SIMULATION_DEFAULT_ALPHA_DECAY)
    }, 3000)

    this._simulation_prevent_restart = false

    this._start_graph_simulation(LAYER_NONE)
  }

  private _state_gut_unit = (
    graph_id: string,
    map_unit_id: Dict<string>,
    map_merge_id: Dict<string>,
    map_plug_id: IOOf<Dict<Dict<string>>>,
    unit_merges: Dict<GraphMergeSpec>,
    unit_plugs: IOOf<Dict<GraphPlugOuterSpec>>,
    unit_data: IOOf<Dict<TreeNode>>,
    unit_merge_position: Dict<Position>,
    unit_merge_selected: Dict<boolean>
  ): void => {
    // console.log(
    //   'Graph',
    //   '_state_gut_unit',
    //   unit_id,
    //   map_unit_id,
    //   map_merge_id,
    //   unit_merges
    // )

    const spec = this._get_unit_spec(graph_id) as GraphSpec

    const pin_to_merge = {}

    forEachPinOnMerges(unit_merges, (mergeId, unitId, type, pinId) => {
      if (unitId === graph_id) {
        deepSet(pin_to_merge, [type, pinId], mergeId)
      }
    })

    const {
      units = {},
      merges = {},
      inputs = {},
      outputs = {},
      render,
      component = { subComponents: {}, children: [] },
      metadata = {},
    } = spec

    const position = this._get_node_position(graph_id)

    const transfilter_pins = (type: IO, pins: GraphPinsSpec) => {
      return filterObj(
        mapObjKV(pins, (pin_id, pin_spec) => {
          const next_pin_spec = clone(pin_spec)

          next_pin_spec.plug = {}

          const { plug = {} } = pin_spec

          const merged = !!deepGetOrDefault(
            pin_to_merge,
            [type, pin_id],
            undefined
          )

          const outer_plug = unit_plugs[type][pin_id]

          const plugged = !!outer_plug

          for (const sub_pin_id in plug) {
            const sub_pin = plug[sub_pin_id]

            if (
              shouldExposePin(
                type,
                pin_id,
                pin_spec,
                sub_pin_id,
                sub_pin,
                merged,
                outer_plug && {
                  type,
                  ...outer_plug,
                }
              )
            ) {
              next_pin_spec.plug[sub_pin_id] = sub_pin
            }
          }

          return next_pin_spec
        }),
        (pin_spec) => {
          const { plug = {} } = pin_spec

          const plug_count = keyCount(plug)

          return plug_count > 0
        }
      )
    }

    const next_inputs = transfilter_pins('input', inputs)
    const next_outputs = transfilter_pins('output', outputs)

    const graph = {
      units,
      merges,
      component,
      metadata,
      render,
      inputs: next_inputs,
      outputs: next_outputs,
    }

    this._state_paste_spec(
      graph,
      position,
      map_unit_id,
      map_merge_id,
      map_plug_id,
      {},
      false,
      false
    )

    const merge_plug_count: Dict<number> = {}

    forEachGraphSpecPin(spec, (type, pinId, pinSpec) => {
      const { plug = {} } = pinSpec

      const new_merge_blacklist = new Set(keys(unit_merges))

      let next_merge_id = this._new_merge_id(new_merge_blacklist)

      const pin_merge_id = deepGetOrDefault(
        pin_to_merge,
        [type, pinId],
        undefined
      )

      const merged = !!pin_merge_id

      const next_merge = {}

      delete next_merge[graph_id]

      const pin_positions = []

      for (const subPinId in plug) {
        const subPinSpec = plug[subPinId]

        if (
          !shouldExposePin(type, pinId, pinSpec, subPinId, subPinSpec, merged)
        ) {
          const { unitId, pinId: pinId_, mergeId } = subPinSpec

          if (unitId && pinId_) {
            const next_unit_id = map_unit_id[unitId] ?? unitId

            const pin_node_id = getPinNodeId(next_unit_id, type, pinId_)

            let anchor_node_id

            if (type === 'output' && pinId_ === SELF) {
              anchor_node_id = unitId
            } else {
              anchor_node_id = pin_node_id
            }

            const pin_position = this._get_node_position(anchor_node_id)

            pin_positions.push(pin_position)

            deepSet(next_merge, [next_unit_id, type, pinId_], true)
          } else if (mergeId) {
            merge_plug_count[mergeId] = (merge_plug_count[mergeId] ?? 0) + 1

            next_merge_id = map_merge_id[mergeId] ?? mergeId
          } else {
            //
          }
        }
      }

      const position =
        pin_positions.length > 0
          ? centerOfMass(pin_positions)
          : this._jiggle_world_screen_center()

      if (!this.__spec_has_merge(next_merge_id)) {
        if (getMergePinCount(next_merge) === 1) {
          return
        }

        const merge_pin_count = getMergePinCount(next_merge)

        if (merge_pin_count === 0) {
          const plug_count = merge_plug_count[next_merge_id] ?? 0

          if (plug_count !== 2) {
            return
          }
        }

        if (merge_pin_count > 0) {
          this._state_add_merge(next_merge_id, next_merge, position)
          this._sim_collapse_merge(next_merge_id)
        }
      }
    })

    for (const merge_id in unit_merges) {
      const merge = unit_merges[merge_id]
      const merge_position = unit_merge_position[merge_id]

      const merge_node_id = getMergeNodeId(merge_id)

      let next_merge_id
      let next_merge_node_id

      const next_merge = {}

      let is_self: boolean = false

      for (const merge_unit_id in merge) {
        const _merge_unit = merge[merge_unit_id]

        if (merge_unit_id === graph_id) {
          const { input: _input = {}, output: _output = {} } = _merge_unit

          if (_output?.[SELF]) {
            is_self = true

            break
          }
        }
      }

      if (is_self) {
        continue
      }

      for (const merge_unit_id in merge) {
        const _merge_unit = merge[merge_unit_id]

        if (merge_unit_id === graph_id) {
          const { input: _input = {}, output: _output = {} } = _merge_unit

          const replacePin = (_type: IO, _pin_id: string) => {
            const _pin = spec[`${_type}s`][_pin_id]

            const { plug } = _pin

            for (const sub_pin_id in plug) {
              const sub_pin = plug[sub_pin_id]

              const { unitId, pinId, mergeId } = sub_pin

              if (mergeId) {
                const sub_next_merge_id = map_merge_id[mergeId] ?? mergeId

                const sub_next_merge_node_id = getMergeNodeId(sub_next_merge_id)

                const sub_merge_spec = this._get_merge(sub_next_merge_node_id)

                next_merge_id = sub_next_merge_id
                next_merge_node_id = sub_next_merge_node_id

                if (sub_merge_spec && !isEmptyObject(sub_merge_spec)) {
                  forEachPinOnMerge(
                    sub_merge_spec,
                    (__unitId, __type, __pinId) => {
                      const ___unitId = __unitId

                      deepSet(next_merge, [___unitId, __type, __pinId], true)
                    }
                  )
                } else {
                  forEachPinOnMerge(merge, (unitId, type, pinId) => {
                    if (unitId !== graph_id) {
                      if (
                        deepGetOrDefault(
                          next_merge,
                          [unitId, type, pinId],
                          undefined
                        )
                      ) {
                        return
                      }

                      deepSet(next_merge, [unitId, type, pinId], true)
                    }
                  })
                }
              } else if (unitId && pinId) {
                const sub_next_unit_id = map_unit_id[unitId] ?? unitId

                deepSet(next_merge, [sub_next_unit_id, _type, pinId], true)

                next_merge_id = merge_id
                next_merge_node_id = merge_node_id
              }
            }
          }

          for (const _input_id in _input) {
            replacePin('input', _input_id)
          }
          for (const _output_id in _output) {
            replacePin('output', _output_id)
          }
        }
      }

      for (const _unit_id in merge) {
        const _merge_unit = merge[_unit_id]

        if (_unit_id !== graph_id) {
          next_merge[_unit_id] = _merge_unit
        }
      }

      if (!next_merge_id) {
        next_merge_id = merge_id
        next_merge_node_id = merge_node_id
      }

      forEachPinOnMerge(next_merge, (unitId, type, pinId) => {
        const pin_node_id = getPinNodeId(unitId, type, pinId)

        const merge_node_id = this._pin_to_merge[pin_node_id]

        if (merge_node_id) {
          this._state_remove_pin_or_merge(pin_node_id)
        }
      })

      const next_merge_pin_count = getMergePinCount(next_merge)

      if (next_merge_pin_count === 0 || next_merge_pin_count > 1) {
        this._state_add_merge(next_merge_id, next_merge, merge_position)
        this._sim_collapse_merge(next_merge_id)

        const next_merge_anchor_node_id =
          this._get_merge_anchor_node_id(next_merge_node_id)

        if (unit_merge_selected[merge_id]) {
          this._select_node(next_merge_anchor_node_id)
        }
      } else {
        if (this._spec_has_merge(next_merge_node_id)) {
          forEachPinOnMerge(next_merge, (unit_id, type, pin_id) => {
            const pin_node_id = getPinNodeId(unit_id, type, pin_id)

            this._state_merge_link_pin_merge_pin(
              pin_node_id,
              next_merge_node_id
            )
          })
        } else {
          forEachPinOnMerge(next_merge, (unit_id, type, pin_id) => {
            const pin_node_id = getPinNodeId(unit_id, type, pin_id)

            const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)

            this._select_node(anchor_node_id)
          })
        }
      }
    }

    forIOObjKV(
      unit_plugs,
      (type, unitPinId, { pinId, subPinId, type: type_ }) => {
        if (unitPinId === SELF) {
          //
        } else {
          const specPin = getPinSpec(spec, type, unitPinId)

          const { plug } = specPin

          for (const sub_pin_id in plug) {
            const sub_pin = plug[sub_pin_id]

            if (sub_pin.unitId && sub_pin.pinId) {
              const sub_pin_next_unit_id =
                map_unit_id[sub_pin.unitId] ?? sub_pin.unitId

              this._state_plug_exposed_pin(type_, pinId, subPinId, {
                unitId: sub_pin_next_unit_id,
                pinId: sub_pin.pinId,
                kind: sub_pin.kind ?? type,
              })
            } else if (sub_pin.mergeId) {
              const sub_pin_next_merge_id =
                map_merge_id[sub_pin.mergeId] ?? sub_pin.mergeId

              this._state_plug_exposed_pin(type_, pinId, subPinId, {
                mergeId: sub_pin_next_merge_id,
              })
            }
          }
        }
      }
    )

    forIOObjKV(unit_data, (type, pinId, data) => {
      if (data) {
        if (this._spec_has_pin_named(type, pinId)) {
          this._sim_set_pin_set_data(type, pinId, data.value, data)
        }
      }
    })
  }

  private _pod_explode_unit = (
    unit_id: string,
    map_unit_id: Dict<string>,
    map_merge_id: Dict<string>,
    actions
  ): void => {
    // console.log(
    //   'Graph',
    //   '_pod_explode_unit',
    //   unit_id,
    //   map_unit_id,
    //   map_merge_id
    // )

    const { fork, bubble } = this.$props

    if (this._is_unit_component(unit_id)) {
      this._disconnect_sub_component(unit_id)
    }

    const unit_pod = this._pod.$refUnit({
      unitId: unit_id,
      _: UCGEE,
    }) as $Graph

    unit_pod.$getGraphData({}, ({ err, pinData, children, mergeData }) => {
      const _pinData = mapObjKey(pinData, (value, key) => {
        return map_unit_id[key]
      })
      this._process_graph_active_pin_data(_pinData)

      const _err = mapObjKey(err, (value, key) => {
        return map_unit_id[key]
      })
      this._process_graph_active_err(_err)

      const _children = mapObjKey(children, (value, key) => {
        return map_unit_id[key]
      })
      this._process_graph_active_children(_children)

      const _mergeData = mapObjKey(mergeData, (value, key) => {
        return map_merge_id[key] ?? key
      })
      this._process_graph_active_merge_data(_mergeData)

      this._pod.$bulkEdit({ actions, fork, bubble })

      for (const _unit_id in map_unit_id) {
        const _next_unit_id = map_unit_id[_unit_id]

        if (this._is_unit_component(_next_unit_id)) {
          if (!this._component.$subComponent[_next_unit_id]) {
            this._mem_add_unit_component(_next_unit_id, {})
          }
        }
      }

      for (const _unit_id in map_unit_id) {
        const _next_unit_id = map_unit_id[_unit_id]

        if (this._is_unit_component(_next_unit_id)) {
          this._sim_add_sub_component_to_parent(_next_unit_id)
        }
      }

      for (const _unit_id in map_unit_id) {
        const _next_unit_id = map_unit_id[_unit_id]

        if (this._is_unit_component(_next_unit_id)) {
          this._connect_sub_component(_next_unit_id)
        }
      }
    })
  }

  private _toggle_select_subgraph = (node_id: string) => {
    const subgraph_id = this._node_to_subgraph[node_id]
    const subgraph = this._subgraph_to_node[subgraph_id]

    for (const subgraph_node_id of subgraph) {
      if (subgraph_node_id === node_id) {
        //
      } else {
        if (this._is_plug_node_id(subgraph_node_id)) {
          //
        } else {
          this._toggle_select(subgraph_node_id)
        }
      }
    }
  }

  private _on_node_click_hold = (node_id: string, event: UnitPointerEvent) => {
    // console.log('Graph', '_on_node_click_hold')

    if (this._resize_node_id_pointer_id[node_id]) {
      return
    }

    const { screenX, screenY } = event

    if (this._tree_layout) {
      this._animate_pulse(screenX, screenY, 'out')

      this._on_node_long_press(node_id, event)
    } else {
      if (this._mode === 'multiselect' || this._mode === 'info') {
        this._cancel_node_click.add(node_id)

        this._animate_pulse(screenX, screenY, 'out')

        this._on_node_long_press(node_id, event)
      } else {
        if (this._is_unit_node_id(node_id)) {
          this._animate_pulse(screenX, screenY, 'in')

          this._start_gesture(event)
        } else if (this._is_pin_node_id(node_id)) {
          this._start_gesture(event)
        }
      }
    }
  }

  private _merge_pin_pin = (
    pin_0_node_id: string,
    pin_1_node_id: string,
    position?: Position
  ): string => {
    // console.log('Graph', '_merge_pin_pin', pin_0_node_id, pin_1_node_id)

    if (
      this._is_link_pin_node_id(pin_0_node_id) &&
      this._is_link_pin_node_id(pin_1_node_id)
    ) {
      return this._merge_link_pin_link_pin(
        pin_0_node_id,
        pin_1_node_id,
        position
      )
    } else if (
      this._is_link_pin_node_id(pin_0_node_id) &&
      this._is_merge_node_id(pin_1_node_id)
    ) {
      return this.merge_link_pin_merge_pin(pin_0_node_id, pin_1_node_id)
    } else if (
      this._is_merge_node_id(pin_0_node_id) &&
      this._is_link_pin_node_id(pin_1_node_id)
    ) {
      return this.merge_link_pin_merge_pin(pin_1_node_id, pin_0_node_id)
    } else {
      return this.merge_merge_pin_merge_pin(pin_1_node_id, pin_0_node_id)
    }
  }

  private _merge_pin_unit = (pin_node_id: string, unit_id: string) => {
    if (this._is_link_pin_node_id(pin_node_id)) {
      this._merge_link_pin_unit(pin_node_id, unit_id)
    } else {
      this._merge_merge_pin_unit(pin_node_id, unit_id)
    }
  }

  private _merge_link_pin_unit = (
    pin_node_id: string,
    unit_id: string
  ): void => {
    const ref = this._get_link_pin_ref(pin_node_id)

    if (ref) {
      const { type } = segmentLinkPinNodeId(pin_node_id)

      const { pinId, subPinId } =
        this._spec_get_pin_node_plug_spec(type, pin_node_id) ?? {}

      if (pinId && subPinId) {
        this._unplug_exposed_pin(type, pinId, subPinId)
      }
    }

    const ref_node_id = getSelfPinNodeId(unit_id)
    const ref_merge_pin_node_id = this._pin_to_merge[ref_node_id]
    if (ref_merge_pin_node_id) {
      this._merge_link_pin_merge_pin(pin_node_id, ref_merge_pin_node_id)
    } else {
      this._merge_link_pin_link_pin(pin_node_id, ref_node_id)
    }
  }

  private _sim_merge_link_pin_unit = (
    pin_node_id: string,
    unit_id: string
  ): void => {
    const ref_node_id = getSelfPinNodeId(unit_id)
    const ref_merge_pin_node_id = this._pin_to_merge[ref_node_id]
    if (ref_merge_pin_node_id) {
      this._sim_add_link_pin_to_merge(pin_node_id, ref_merge_pin_node_id)
    } else {
      this._sim_merge_link_pin_link_pin(pin_node_id, ref_node_id)
    }
  }

  private _merge_merge_pin_unit = (
    merge_node_id: string,
    unit_id: string
  ): void => {
    const self_pin_node_id = getSelfPinNodeId(unit_id)

    this._merge_link_pin_merge_pin(self_pin_node_id, merge_node_id)
  }

  private _make_merge_merges_actions = (
    merge_0_id: string,
    merge_1_id: string
  ) => {
    const merge_1 = clone(this._spec_get_merge(merge_1_id))

    const actions = []

    actions.push(makeRemoveMergeAction(merge_1_id, merge_1))

    forEachPinOnMerge(merge_1, (unitId, type, pinId) => {
      actions.push(makeAddPinToMergeAction(merge_0_id, type, unitId, pinId))
    })

    return actions
  }

  public merge_merge_pin_merge_pin = (
    merge_0_node_id: string,
    merge_1_node_id: string
  ): string => {
    const { mergeId: merge_0_id } = segmentMergeNodeId(merge_0_node_id)
    const { mergeId: merge_1_id } = segmentMergeNodeId(merge_1_node_id)

    const actions = this._make_merge_merges_actions(merge_0_id, merge_1_id)

    this._dispatch_action(makeBulkEditAction(actions))

    const merge_node_id = this._merge_merge_pin_merge_pin(
      merge_0_node_id,
      merge_1_node_id
    )

    return merge_node_id
  }

  private _merge_merge_pin_merge_pin = (
    merge_0_node_id: string,
    merge_1_node_id: string
  ): string => {
    const { mergeId: merge_0_id } = segmentMergeNodeId(merge_0_node_id)
    const { mergeId: merge_1_id } = segmentMergeNodeId(merge_1_node_id)

    this._pod_merge_merge_pin_merge_pin(merge_0_id, merge_1_id)
    this._state_merge_merge_pin_merge_pin(merge_0_node_id, merge_1_node_id)

    return merge_0_node_id
  }

  private _state_merge_merge_pin_merge_pin = (
    merge_0_node_id: string,
    merge_1_node_id: string
  ): string => {
    const { mergeId: merge_0_id } = segmentMergeNodeId(merge_0_node_id)
    const { mergeId: merge_1_id } = segmentMergeNodeId(merge_1_node_id)

    this._sim_merge_merge_pin_merge_pin(merge_0_node_id, merge_1_node_id)
    this._spec_merge_merge_pin_merge_pin(merge_0_id, merge_1_id)

    return merge_0_node_id
  }

  private _pod_merge_merge_pin_merge_pin = (
    merge_0_id: string,
    merge_1_id: string
  ) => {
    const { fork, bubble } = this.$props

    const actions = this._make_merge_merges_actions(merge_0_id, merge_1_id)

    this._pod.$bulkEdit({
      actions,
      fork,
      bubble,
    })
  }

  private _spec_merge_merge_pin_merge_pin = (
    merge_0_id: string,
    merge_1_id: string
  ) => {
    mergeMerges({ a: merge_0_id, b: merge_1_id }, this._spec)
  }

  private _sim_merge_merge_pin_merge_pin = (
    merge_0_node_id: string,
    merge_1_node_id: string
  ) => {
    const merge_1_to_pin_node_id = {
      ...this._merge_to_pin[merge_1_node_id],
    }

    this._sim_remove_merge(merge_1_node_id)

    for (let pin_node_id in merge_1_to_pin_node_id) {
      this._sim_add_link_pin_to_merge(pin_node_id, merge_0_node_id)
    }
  }

  private _merge_link_pin_link_pin = (
    pin_0_node_id: string,
    pin_1_node_id: string,
    position?: Position
  ): string => {
    // console.log(
    //   'Graph',
    //   '_merge_link_pin_link_pin',
    //   pin_0_node_id,
    //   pin_1_node_id
    // )

    const { fork, bubble } = this.$props

    const {
      unitId: unitId0,
      type: type0,
      pinId: pinId0,
    } = segmentLinkPinNodeId(pin_0_node_id)
    const {
      unitId: unitId1,
      type: type1,
      pinId: pinId1,
    } = segmentLinkPinNodeId(pin_1_node_id)

    const merge = {
      [unitId0]: {
        [type0]: {
          [pinId0]: true,
        },
      },
      [unitId1]: {
        [type1]: {
          [pinId1]: true,
        },
      },
    }

    const actions = []

    const merge_id = this._new_merge_id()

    this._spec_add_merge(merge_id, merge)

    const merge_plugs = findMergePlugs(this._spec, merge_id)

    const merge_node_id = this.__sim_merge_link_pin_link_pin(
      merge_id,
      pin_0_node_id,
      pin_1_node_id,
      position
    )

    actions.push(makeAddMergeAction(merge_id, clone(merge)))

    forIO(merge_plugs, (type, plugs) => {
      forEach(plugs, (plug) => {
        actions.push(
          makePlugPinAction(plug.type, plug.pinId, plug.subPinId, {
            mergeId: merge_id,
          })
        )
      })
    })

    this._dispatch_action_add_merge(merge_id, merge)

    this._pod.$bulkEdit({ actions, fork, bubble })

    return merge_node_id
  }

  private _sim_merge_link_pin_link_pin = (
    pin_0_node_id: string,
    pin_1_node_id: string,
    position?: Position
  ): string => {
    const merge_id = this._new_merge_id()

    return this.__sim_merge_link_pin_link_pin(
      merge_id,
      pin_0_node_id,
      pin_1_node_id,
      position
    )
  }

  private __sim_merge_link_pin_link_pin = (
    merge_id: string,
    pin_0_node_id: string,
    pin_1_node_id: string,
    position?: Position
  ): string => {
    const {
      unitId: pin_0_unit_id,
      type: pin_0_type,
      pinId: pin_0_pin_id,
    } = segmentLinkPinNodeId(pin_0_node_id)

    const {
      unitId: pin_1_unit_id,
      type: pin_1_type,
      pinId: pin_1_pin_id,
    } = segmentLinkPinNodeId(pin_1_node_id)

    const merge_node_id = getMergeNodeId(merge_id)

    const pin_0_link_input = pin_0_type === 'input'
    const pin_1_link_input = pin_1_type === 'input'

    const pin_0_link_ref = this._is_link_pin_ref(pin_0_node_id)
    const pin_1_link_ref = this._is_link_pin_ref(pin_1_node_id)

    const pin_0_output_ref = !pin_0_link_input && pin_0_link_ref
    const pin_1_output_ref = !pin_1_link_input && pin_1_link_ref

    let merge_unit_id: string | undefined
    if (pin_0_output_ref) {
      merge_unit_id = pin_0_unit_id
    } else if (pin_1_output_ref) {
      merge_unit_id = pin_1_unit_id
    }

    const merge = {
      [pin_0_unit_id]: {
        [pin_0_type]: {
          [pin_0_pin_id]: true,
        },
      },
      [pin_1_unit_id]: {
        [pin_1_type]: {
          [pin_1_pin_id]: true,
        },
      },
    }

    if (!merge_unit_id) {
      const { x: x0, y: y0 } = this._node[pin_0_node_id]
      const { x: x1, y: y1 } = this._node[pin_1_node_id]

      const x = (x0 + x1) / 2
      const y = (y0 + y1) / 2

      position = { x, y }
    } else {
      const { x, y } = this._node[merge_unit_id]

      position = { x, y }
    }

    this._sim_add_merge(merge_id, merge, position)

    const anchor_node_id = this._get_merge_anchor_node_id(merge_node_id)

    this._sim_transfer_node_target(pin_0_node_id, anchor_node_id)
    this._sim_transfer_node_target(pin_1_node_id, anchor_node_id)

    this._sim_add_link_pin_to_merge(pin_0_node_id, merge_node_id)
    this._sim_add_link_pin_to_merge(pin_1_node_id, merge_node_id)

    const datum_node_id = this._datum_to_pin[merge_node_id]

    if (datum_node_id) {
      this._refresh_datum_visible(datum_node_id)
    }

    const visible_datum_node_id = this._get_merge_datum_node_id(merge_node_id)

    if (visible_datum_node_id) {
      this._refresh_datum_visible(visible_datum_node_id)
    }

    return merge_node_id
  }

  public merge_link_pin_merge_pin = (
    pin_node_id: string,
    merge_node_id: string
  ): string => {
    // console.log(
    //   'Graph',
    //   'merge_link_pin_merge_pin',
    //   pin_node_id,
    //   merge_node_id
    // )

    const { mergeId } = segmentMergeNodeId(merge_node_id)

    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    this._dispatch_action(makeAddPinToMergeAction(mergeId, type, unitId, pinId))

    return this._merge_link_pin_merge_pin(pin_node_id, merge_node_id)
  }

  private _merge_link_pin_merge_pin = (
    pin_node_id: string,
    merge_node_id: string,
    emit: boolean = true
  ): string => {
    // console.log(
    //   'Graph',
    //   '_merge_link_pin_merge_pin',
    //   pin_node_id,
    //   merge_node_id
    // )

    const { mergeId } = segmentMergeNodeId(merge_node_id)

    const {
      unitId: unit_id,
      type,
      pinId: pin_id,
    } = segmentLinkPinNodeId(pin_node_id)

    this.__state_merge_link_pin_merge_pin(
      pin_node_id,
      merge_node_id,
      unit_id,
      type,
      pin_id,
      mergeId
    )

    emit && this.__pod_add_pin_to_merge(mergeId, unit_id, type, pin_id)

    return merge_node_id
  }

  private _state_merge_link_pin_merge_pin = (
    pin_node_id: string,
    merge_node_id: string
  ): string => {
    // console.log(
    //   'Graph',
    //   '_state_merge_link_pin_merge_pin',
    //   pin_node_id,
    //   merge_node_id
    // )

    const { mergeId } = segmentMergeNodeId(merge_node_id)

    const {
      unitId: unit_id,
      type,
      pinId: pin_id,
    } = segmentLinkPinNodeId(pin_node_id)

    this.__state_merge_link_pin_merge_pin(
      pin_node_id,
      merge_node_id,
      unit_id,
      type,
      pin_id,
      mergeId
    )

    return merge_node_id
  }

  private __state_merge_link_pin_merge_pin = (
    pin_node_id: string,
    merge_node_id: string,
    unit_id: string,
    type: IO,
    pin_id: string,
    merge_id: string
  ): string => {
    // console.log(
    //   'Graph',
    //   '__state_merge_link_pin_merge_pin',
    //   pin_node_id,
    //   merge_node_id
    // )

    this._spec_add_link_pin_to_merge(merge_id, unit_id, type, pin_id)
    this._sim_add_link_pin_to_merge(pin_node_id, merge_node_id)

    return merge_node_id
  }

  private _animate_layout_enter_sub_component(
    sub_component_id: string,
    children: string[]
  ) {
    this._measure_sub_component_base(sub_component_id)

    const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)

    const parent_layer = this._get_layout_layer(parent_id)

    const scroll_top = parent_layer.content.$element.scrollTop

    const finish = () => {
      stop_parent_animation()
      stop_children_animation()

      this._unplug_sub_component_root_base_frame(sub_component_id)
      this._enter_sub_component_frame(sub_component_id)
      this._append_sub_component_root_base(sub_component_id)

      this._end_layout_sub_component_transfer_children_animation(
        sub_component_id,
        'default',
        children
      )

      for (const child_id of children) {
        this._enter_sub_component_frame(child_id)
        this._append_sub_component_base(child_id)
      }
    }

    let parent_finished = false
    let children_finished = false

    for (const child_id of children) {
      this._measure_sub_component_base(child_id)
    }

    for (const child_id of children) {
      if (!this._animating_sub_component_base_id.has(child_id)) {
        this._remove_sub_component_parent_root(sub_component_id, child_id)
        this._remove_sub_component_root_base(child_id)
      }
    }

    this._animate_all_current_layout_layer_node()

    const stop_children_animation =
      this._animate_layout_sub_component_remove_children(
        sub_component_id,
        'default',
        children,
        false,
        async () => {
          if (this._layout_layer_opacity_animation[sub_component_id]) {
            await waitFinish(
              this._layout_layer_opacity_animation[sub_component_id]
            )

            delete this._layout_layer_opacity_animation[sub_component_id]
          }

          children_finished = true

          if (parent_finished) {
            finish()

            return true
          }

          return false
        }
      )

    const layer = this._get_sub_component_layout_layer(sub_component_id)

    const stop_parent_animation = this._animate_parent_component(
      sub_component_id,
      false,
      false,
      [],
      parent_layer.children,
      1,
      false,
      () => ({ x: 0, y: -layer.content.$element.scrollTop }),
      () => {
        parent_finished = true

        if (children_finished) {
          finish()

          return true
        }

        return false
      }
    )
  }

  private __pod_add_pin_to_merge(
    mergeId: string,
    unitId: string,
    type: IO,
    pinId: string
  ) {
    const { fork, bubble } = this.$props

    this._pod.$addPinToMerge({
      mergeId,
      unitId,
      type,
      pinId,
      fork,
      bubble,
    })
  }

  private _state_add_link_pin_to_merge(
    mergeId: string,
    unitId: string,
    type: IO,
    pinId: string
  ) {
    // console.log(
    //   'Graph',
    //   '_state_add_link_pin_to_merge',
    //   mergeId,
    //   unitId,
    //   type,
    //   pinId
    // )

    this._spec_add_link_pin_to_merge(mergeId, unitId, type, pinId)

    const pin_node_id = getPinNodeId(unitId, type, pinId)
    const merge_node_id = getMergeNodeId(mergeId)

    this._sim_add_link_pin_to_merge(pin_node_id, merge_node_id)
  }

  private _spec_add_link_pin_to_merge(
    mergeId: string,
    unitId: string,
    type: IO,
    pinId: string
  ) {
    // console.log(
    //   'Graph',
    //   '_spec_add_link_pin_to_merge',
    //   mergeId,
    //   unitId,
    //   type,
    //   pinId
    // )

    addPinToMerge({ mergeId, unitId, type, pinId }, this._spec)
  }

  private _sim_transfer_node_target = (
    node_id: string,
    next_target_node_id: string
  ) => {
    const targeted_by = this._target_node[node_id]

    if (targeted_by) {
      for (const target_by_node_id of [...targeted_by]) {
        this._remove_node_target(target_by_node_id)

        this._set_node_target(target_by_node_id, next_target_node_id)
      }
    }
  }

  private _sim_add_link_pin_to_merge(
    pin_node_id: string,
    merge_node_id: string,
    refresh: boolean = true
  ) {
    // console.log(
    //   'Graph',
    //   '_sim_add_link_pin_to_merge',
    //   pin_node_id,
    //   merge_node_id,
    //   refresh
    // )

    const { mergeId } = segmentMergeNodeId(merge_node_id)
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    const is_input = type === 'input'
    const is_output = !is_input
    const is_pin_link_ref = this._is_link_pin_ref(pin_node_id)
    const is_pin_output_ref = is_output && is_pin_link_ref
    const is_pin_output_self = pinId === SELF

    const opposite_type = opposite(type)

    const int_node_id = this._pin_to_int[type][pin_node_id]
    const oppposite_int_node_id = this._pin_to_int[opposite_type][pin_node_id]

    const anchor_node_id = this._get_merge_anchor_node_id(merge_node_id)

    this._sim_transfer_node_target(pin_node_id, anchor_node_id)

    if (this._mode === 'remove') {
      if (this._pressed_node_id_pointer_id[pin_node_id]) {
        this._on_unit_red_drag_end(unitId)
      }
    }

    const replug = (type, pinId, subPinId) => {
      this._sim_unplug_exposed_pin(type, pinId, subPinId)
      this._sim_plug_exposed_pin(type, pinId, subPinId, { mergeId })
    }

    if (int_node_id) {
      const { pinId, type, subPinId } = segmentPlugNodeId(int_node_id)

      replug(type, pinId, subPinId)
    }

    if (oppposite_int_node_id) {
      const { pinId, type, subPinId } = segmentPlugNodeId(oppposite_int_node_id)

      replug(type, pinId, subPinId)
    }

    const merge_ref = this._merge_ref[merge_node_id]

    this._pin_to_merge[pin_node_id] = merge_node_id
    this._merge_to_pin[merge_node_id][pin_node_id] = true

    if (is_pin_output_self) {
      this._merge_to_ref_unit[merge_node_id] = unitId
      this._ref_unit_to_merge[unitId] = merge_node_id

      this._sim_change_all_merge_input_to(merge_node_id, unitId)

      if (this._has_node(merge_node_id)) {
        this._sim_remove_merge_node(merge_node_id)
      }
    } else if (is_pin_output_ref) {
      this._merge_to_ref_output[merge_node_id] = pin_node_id
      this._ref_output_to_merge[pin_node_id] = merge_node_id

      this._sim_change_all_merge_input_to(merge_node_id, pin_node_id)

      if (this._has_node(merge_node_id)) {
        this._sim_remove_merge_node(merge_node_id)
      }

      const pin_link_id = getPinLinkIdFromPinNodeId(pin_node_id)

      this._show_link_text(pin_link_id)
      this._hide_link_pin_name(pin_node_id)
    } else {
      this._sim_change_link_pin_to_merge(pin_node_id, merge_node_id)
    }

    const merge_input = this._merge_input[merge_node_id]
    const merge_output = this._merge_output[merge_node_id]

    if (is_input) {
      this._merge_to_input[merge_node_id][pin_node_id] = true

      this._inc_merge_input_count(mergeId)

      if (!merge_ref) {
        this._set_merge_input_visibility(merge_node_id, 'visible')

        merge_input.$element.style.visibility = 'visible'

        const merge_output_width = 2 * PIN_RADIUS - 4

        merge_output.$element.style.width = `${merge_output_width}px`
        merge_output.$element.style.height = `${merge_output_width}px`
        merge_output.$element.style.transform = `translate(${2}px, ${2}px)`
      }
    } else {
      this._merge_to_output[merge_node_id][pin_node_id] = true

      this._inc_merge_output_count(mergeId)

      if (!merge_ref || !is_pin_link_ref) {
        this._set_merge_output_visibility(merge_node_id, 'visible')
      }
    }

    this._inc_merge_pin_count(mergeId)

    if (is_input) {
      const merge_to_output = this._merge_to_output[merge_node_id]

      for (const output_node_id in merge_to_output) {
        const { unitId: _unitId } = segmentLinkPinNodeId(output_node_id)

        const merge_link_id = getLinkId(_unitId, unitId)

        this._unit_to_unit[merge_link_id] =
          this._unit_to_unit[merge_link_id] || 0
        this._unit_to_unit[merge_link_id]++
      }
    } else {
      const merge_to_input = this._merge_to_input[merge_node_id]

      for (const input_node_id in merge_to_input) {
        const { unitId: _unitId } = segmentLinkPinNodeId(input_node_id)

        const merge_link_id = getLinkId(unitId, _unitId)

        this._unit_to_unit[merge_link_id] =
          this._unit_to_unit[merge_link_id] || 0
        this._unit_to_unit[merge_link_id]++
      }
    }

    if (is_pin_output_ref) {
      //
    } else {
      if (this._has_node(pin_node_id)) {
        this._sim_remove_link_pin_pin(pin_node_id)
      }
    }

    deepInc(this._merge_pin_name_count, [merge_node_id, type, pinId])

    this._refresh_merge_name(merge_node_id)

    for (const pin_node_id in this._merge_to_pin[merge_node_id]) {
      const pin_datum_node_id = this._pin_to_datum[pin_node_id]

      if (pin_datum_node_id) {
        this._refresh_datum_visible(pin_datum_node_id)
      }
    }

    const input = is_input

    const link_id = getLinkId(
      input ? pin_node_id : unitId,
      input ? unitId : pin_node_id
    )

    if (this._has_link(link_id)) {
      this._refresh_link_pin_link_color(pin_node_id)
    }

    if (merge_ref) {
      this._refresh_core_border_color(unitId)
    } else {
      this._refresh_merge_pin_color(merge_node_id)
    }

    if (this._merge_pin_count[mergeId] === 1) {
      this._remove_merge_empty(merge_node_id)
    }

    this._refresh_compatible()

    if (is_pin_output_ref) {
      //
    } else {
      this._tick_link(link_id)
    }

    this._start_graph_simulation(LAYER_NONE)
  }

  private _refresh_merge_name = (merge_node_id: string) => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    const merge_pin_name_count = this._merge_pin_name_count[merge_node_id]

    const clear = () => {
      this._set_merge_name(merge_node_id, '')

      this._for_each_merge_pin(mergeId, (unitId, type, pinId) => {
        const pin_node_id = getPinNodeId(unitId, type, pinId)

        const link_id = getPinLinkIdFromPinNodeId(pin_node_id)

        if (this._is_link_pin_visible(pin_node_id)) {
          if (this._is_link_pin_merged(pin_node_id)) {
            this._show_link_text(link_id)
          } else {
            this._hide_link_text(link_id)
            this._show_link_pin_name(pin_node_id)
          }
        }
      })
    }

    if (
      keyCount(merge_pin_name_count.input ?? {}) === 1 &&
      keyCount(merge_pin_name_count.output ?? {}) === 1
    ) {
      const single_input_name = getObjSingleKey(merge_pin_name_count.input)
      const single_output_name = getObjSingleKey(merge_pin_name_count.output)

      if (single_input_name === single_output_name) {
        this._set_merge_name(merge_node_id, single_input_name)

        this._for_each_merge_pin(mergeId, (unitId, type, pinId) => {
          const pin_node_id = getPinNodeId(unitId, type, pinId)

          const link_id = getPinLinkIdFromPinNodeId(pin_node_id)

          this._hide_link_text(link_id)
        })
      } else {
        clear()
      }
    } else {
      clear()
    }
  }

  private _set_ref_link_pin_start_marker_r = (
    pin_node_id: string,
    r: number
  ): void => {
    // console.log('_set_ref_link_pin_start_marker_r', pin_node_id, r)
    const link_id = getPinLinkIdFromPinNodeId(pin_node_id)
    const start_marker = this._link_marker_start[link_id]
    const start_marker_d = describeArrowSemicircle(r)
    start_marker.setProp('d', start_marker_d)
  }

  private _set_ref_link_pin_start_marker_to_node_r = (
    pin_node_id: string,
    node_id: string,
    padding: number = 0
  ): void => {
    const r = this._get_node_r(node_id)

    this._set_ref_link_pin_start_marker_r(pin_node_id, r + padding)
  }

  private _sim_change_link_pin_to_merge = (
    pin_node_id: string,
    merge_node_id: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_sim_change_link_pin_to_merge',
    //   pin_node_id,
    //   merge_node_id
    // )

    const { type } = segmentLinkPinNodeId(pin_node_id)

    const input = type === 'input'

    const datum_node_id = this._pin_to_datum[pin_node_id]
    const merge_unit_id = this._merge_to_ref_unit[merge_node_id]
    const merge_ref_output_id = this._merge_to_ref_output[merge_node_id]

    const pin_link_id = getPinLinkIdFromPinNodeId(pin_node_id)

    if (merge_unit_id) {
      this._sim_change_link_node(pin_link_id, merge_unit_id, input)

      this._set_link_pin_padding_source(pin_node_id, -1.75)
      this._set_link_pin_link_color(pin_node_id, this._theme.data)

      this._refresh_pin_anchor_marker(pin_node_id)
    } else if (merge_ref_output_id) {
      this._sim_change_link_node(pin_link_id, merge_ref_output_id, input)

      this._set_link_pin_padding_source(pin_node_id, -1.75)
      this._set_ref_link_pin_start_marker_to_node_r(
        pin_node_id,
        merge_ref_output_id,
        1.75
      )

      this._refresh_pin_anchor_marker(pin_node_id)
    } else {
      this._sim_change_link_node(pin_link_id, merge_node_id, input)

      if (datum_node_id) {
        const datum_link_id = getLinkId(datum_node_id, pin_node_id)

        this._sim_change_link_target(datum_link_id, merge_node_id)

        this._refresh_datum_visible(datum_node_id)
      }
    }

    if (datum_node_id) {
      if (input) {
        this._inc_merge_input_active(merge_node_id)
      } else {
        this._inc_merge_output_active(merge_node_id)
      }
    }

    this._show_link_text(pin_link_id)
  }

  private _show_link_text = (link_id: string): void => {
    const pin_link_text_path = this._link_text[link_id]

    pin_link_text_path.$element.style.display = 'block'
  }

  private _hide_link_text = (link_id: string): void => {
    const pin_link_text_path = this._link_text[link_id]

    pin_link_text_path.$element.style.display = 'none'
  }

  private _sim_change_link_node = (
    link_id: string,
    node_id: string,
    source: boolean
  ) => {
    if (source) {
      this._sim_change_link_source(link_id, node_id)
    } else {
      this._sim_change_link_target(link_id, node_id)
    }
  }

  private _sim_change_link_source = (link_id: string, source_id: string) => {
    // console.log('Graph', '_sim_change_link_source', link_id, source_id)

    const link = this._link[link_id]

    const prev_source_id = link.source_id

    link.source_id = source_id

    const { target_id } = link

    if (
      this._is_node_id(target_id) &&
      this._is_node_id(prev_source_id) &&
      this._is_node_id(source_id)
    ) {
      this._swap_node_node_link_count(prev_source_id, source_id)
    }

    change_link_source_on_graph(
      this._node_graph,
      prev_source_id,
      source_id,
      target_id
    )

    this._rebuild_subgraph()
  }

  private _sim_change_link_target = (link_id: string, target_id: string) => {
    const link = this._link[link_id]

    const prev_target_id = link.target_id

    const { source_id } = link

    link.target_id = target_id

    if (
      this._is_node_id(source_id) &&
      this._is_node_id(prev_target_id) &&
      this._is_node_id(target_id)
    ) {
      this._swap_node_node_link_count(prev_target_id, target_id)
    }

    change_link_target_on_graph(
      this._node_graph,
      source_id,
      prev_target_id,
      target_id
    )

    this._rebuild_subgraph()
  }

  private _refresh_simulation_stability = (): void => {
    let s: number = 1
    if (this._node_link_heap_root) {
      const {
        value: { count },
      } = this._node_link_heap_root

      s = clamp(Math.ceil(count / 1.25), 1, 4)
    }
    this._simulation.stability(s)
  }

  private _get_pin_datum_value = (pin_node_id: string): string | undefined => {
    const datum_node_id = this._pin_to_datum[pin_node_id]

    if (!datum_node_id) {
      return undefined
    }

    return this._get_datum_value(datum_node_id)
  }

  public move_datum_to_pin = (
    datum_node_id: string,
    pin_node_id: string
  ): void => {
    // console.log('Graph', 'move_datum_to_pin', datum_node_id, pin_node_id)

    const { datumId } = segmentDatumNodeId(datum_node_id)

    const value = this._get_datum_value(datum_node_id)

    const pinSpec = this._get_node_spec(pin_node_id)

    this._dispatch_action(makeAddDatumLinkAction(datumId, value, pinSpec))

    this._move_datum_to_pin(datum_node_id, pin_node_id)
  }

  private _move_datum_to_pin = (
    datum_node_id: string,
    pin_node_id: string
  ): void => {
    // console.log('Graph', '_move_datum_to_pin', datum_node_id, pin_node_id)

    const datum_pin_node_id = this._datum_to_pin[datum_node_id]

    const { datumId } = segmentDatumNodeId(datum_node_id)

    const value = this._get_datum_value(datum_node_id)
    const oldValue = this._get_pin_datum_value(pin_node_id)

    this._spec_move_datum_to_pin(datum_node_id, pin_node_id, value)
    this._sim_move_datum_to_pin(datum_node_id, pin_node_id)

    this._mem_set_pin_datum(pin_node_id, datumId)

    this._pod_move_datum_to_pin(
      datum_pin_node_id,
      pin_node_id,
      value,
      oldValue,
      false
    )
  }

  private _move_datum_to_plug = (
    datum_node_id: string,
    pin_node_id: string
  ): void => {
    // console.log('Graph', '_move_datum_to_plug', datum_node_id, pin_node_id)
    // TODO
  }

  private _pod_move_datum_to_pin = (
    datum_pin_node_id: string | null,
    pin_node_id: string,
    value: string,
    oldValue: string,
    override: boolean
  ) => {
    if (datum_pin_node_id && datum_pin_node_id !== pin_node_id) {
      this._pod_remove_pin_datum(datum_pin_node_id)
    }

    this._pod_set_pin_data(pin_node_id, value, oldValue, override)
  }

  private _sim_move_datum_to_pin = (
    datum_node_id: string,
    pin_node_id: string
  ): void => {
    // console.log('Graph', '_sim_move_datum_to_pin', datum_node_id, pin_node_id)

    const datum_pin_node_id = this._datum_to_pin[datum_node_id]
    if (datum_pin_node_id && datum_pin_node_id !== pin_node_id) {
      this._sim_remove_pin_datum_link(datum_node_id)

      this._mem_remove_pin_datum_tree(datum_pin_node_id)
    }

    const pin_datum_node_id = this._pin_to_datum[pin_node_id]
    if (pin_datum_node_id) {
      this._sim_remove_pin_datum_link(pin_datum_node_id)
    }

    this._sim_add_pin_datum_link(datum_node_id, pin_node_id, true)

    if (this._edit_datum_node_id === datum_node_id) {
      this._edit_datum_committed = true
    }
  }

  private _spec_move_datum_to_pin = (
    datum_node_id: string,
    pin_node_id: string,
    value: string
  ): void => {
    // console.log('Graph', '_spec_move_datum_to_pin', datum_node_id, pin_node_id)

    const is_link_pin = this._is_link_pin_node_id(pin_node_id)

    if (is_link_pin) {
      this._spec_set_pin_data(pin_node_id, value)
    }
  }

  private _pod_push_data = (type: IO, pinId: string, data: string): void => {
    this._pod.$push({ pinId, data })
  }

  private _pod_take_input = (id: string): void => {
    this._pod_take_input__template(id, {
      takeInput: this._pod.$takeInput.bind(this._pod),
    })
  }

  private _pod_take_input__template = (
    pinId: string,
    { takeInput }: { takeInput(data: UnitTakeInputData): void }
  ): void => {
    takeInput({ pinId })
  }

  public set_pin_data = (pin_node_id: string, data: string): void => {
    // console.log('Graph', 'set_pin_data', pin_node_id, data)

    if (this._is_link_pin_node_id(pin_node_id)) {
      this.set_unit_pin_data(pin_node_id, data)
    } else if (this._is_merge_node_id(pin_node_id)) {
      this.set_merge_pin_data(pin_node_id, data)
    }
  }

  public set_unit_pin_data = (pin_node_id: string, data: string): void => {
    // console.log('Graph', 'set_unit_pin_data', pin_node_id, data)

    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    this._dispatch_action(makeSetUnitPinDataAction(unitId, type, pinId, data))

    this._set_unit_pin_data(pin_node_id, data)
  }

  private _set_unit_pin_data = (pin_node_id: string, data: string): void => {
    // console.log('Graph', '_set_unit_pin_data', pin_node_id, data)

    const datum_node_id = this._pin_to_datum[pin_node_id]

    const value = datum_node_id && this._get_datum_value(datum_node_id)

    this._state_set_unit_pin_data(pin_node_id, data)

    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    this._pod_set_unit_pin_data(unitId, type, pinId, data, value)
  }

  private _set_plug_data = (plug_node_id: string, data: string) => {
    // console.log('Graph', '_set_plug_data', plug_node_id, data)

    this._spec_set_plug_data(plug_node_id, data)
    this._sim_set_plug_data(plug_node_id, data)
    this._pod_set_plug_data(plug_node_id, data)
  }

  private _spec_set_plug_data = (plug_node_id: string, data: string) => {
    //
  }

  private _sim_set_plug_data = (plug_node_id: string, data: string) => {
    //
  }

  private _pod_set_plug_data = (plug_node_id: string, data: string) => {
    // console.log('Graph', '_pod_set_plug_data', plug_node_id, data)

    const { pinId, type } = segmentPlugNodeId(plug_node_id)

    this._pod.$setPinData({ type, pinId, data })
  }

  private _sim_set_pin_data_value = (
    pin_node_id: string,
    value: string
  ): void => {
    // console.log('Graph', '_sim_set_pin_data_value', pin_node_id, value)

    this._graph_debug_set_pin_value(pin_node_id, value)

    if (this._is_link_pin_node_id(pin_node_id)) {
      this._refresh_link_pin_color(pin_node_id)
    }
  }

  private _spec_set_pin_data = (
    pin_node_id: string,
    data: string | DataRef
  ): void => {
    if (this._is_link_pin_node_id(pin_node_id)) {
      if (
        this._is_input_pin_node_id(pin_node_id) &&
        this._is_link_pin_constant(pin_node_id)
      ) {
        const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

        this.__spec_set_pin_data(unitId, type, pinId, data)
      }
    } else {
      const merge_pin_node_id = this._merge_to_pin[pin_node_id]

      for (const pin_node_id in merge_pin_node_id) {
        this._spec_set_pin_data(pin_node_id, data)
      }
    }
  }

  public __spec_set_pin_data = (
    unitId: string,
    type: IO,
    pinId: string,
    data: string | DataRef
  ): void => {
    const { classes } = this.$system
    const { specs } = this.$props

    setUnitPinData({ unitId, type, pinId, data }, this._spec, specs, classes)
  }

  private _pod_set_pin_data = (
    pin_node_id: string,
    data: string,
    lastData: string,
    override: boolean
  ): void => {
    // console.log('Graph', '_pod_set_pin_data', pin_node_id, data, lastData)

    if (this._is_link_pin_node_id(pin_node_id)) {
      const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

      this._pod_set_unit_pin_data(unitId, type, pinId, data, lastData)
    } else {
      const { mergeId } = segmentMergeNodeId(pin_node_id)

      this._pod_set_merge_pin_data(mergeId, data)
    }
  }

  private _pod_set_unit_pin_data = (
    unitId: string,
    type: IO,
    pinId: string,
    data: string,
    lastData: string
  ) => {
    // console.log('Graph', '_pod_set_unit_pin_data', unitId, type, pinId, data)

    const $unit = this._pod.$refUnit({
      unitId,
      _: UCGEE,
      detached: false,
    }) as $Graph

    $unit.$setPinData({
      pinId,
      type,
      data,
    })
  }

  private _pod_set_merge_pin_data = (mergeId: string, data: string): void => {
    // console.log('Graph', '_pod_set_merge_pin_data', mergeId, data)

    this._pod.$setMergeData({
      mergeId,
      data,
    })
  }

  private _pod_set_metadata = (path: string[], data: any): void => {
    const { fork, bubble } = this.$props

    this._pod.$setMetadata({ path, data, fork, bubble })
  }

  private _set_core_border_color = (
    unit_id: string,
    borderColor: string
  ): void => {
    // console.log('Graph', '_set_core_border_color', unit_id, borderColor)

    this._set_unit_core_style_attr(unit_id, 'borderColor', borderColor)
  }

  private _set_unit_core_style_attr = (
    unit_id: string,
    name: string,
    value: string
  ): void => {
    // console.log('Graph', '_set_core_style_attr', unit_id, name, value)

    const core = this._core[unit_id]

    if (core) {
      core.$element.style[name] = value
    }
  }

  private _set_core_and_layout_core_border_color = (
    unit_id: string,
    borderColor: string
  ): void => {
    this._set_core_border_color(unit_id, borderColor)
    this._set_layout_core_border_color(unit_id, borderColor)
  }

  private _set_layout_core_border_color = (
    unit_id: string,
    borderColor: string
  ) => {
    const layout_core = this._layout_core[unit_id]
    if (layout_core) {
      layout_core.$element.style.borderColor = borderColor
    }
  }

  private _set_link_pin_opacity = (
    pin_node_id: string,
    opacity: number
  ): void => {
    // console.log('Graph', '_set_link_pin_opacity', pin_node_id, opacity)

    this._set_link_pin_opacity_str(pin_node_id, `${opacity}`)
    this._set_pin_text_opacity(pin_node_id, opacity)
  }

  private _set_link_pin_opacity_str = (
    pin_node_id: string,
    opacity: string
  ): void => {
    const pin = this._pin[pin_node_id]
    if (pin) {
      pin.$element.style.opacity = opacity
    }

    const pin_link_id = getPinLinkIdFromPinNodeId(pin_node_id)
    const pin_link = this._link_base[pin_link_id]

    pin_link.$element.style.opacity = opacity
  }

  private _set_link_pin_pointer_events = (
    pin_node_id: string,
    pointerEvents: string
  ) => {
    const pin = this._pin[pin_node_id]
    if (pin) {
      pin.$element.style.pointerEvents = pointerEvents
    }

    const pin_link_id = getPinLinkIdFromPinNodeId(pin_node_id)
    const pin_link = this._link_comp[pin_link_id]

    pin_link.$element.style.pointerEvents = pointerEvents
  }

  private _set_pin_set_opacity = (
    type: IO,
    pin_id: string,
    opacity: number
  ): void => {
    // console.log('Graph', '_set_pin_set_opacity', type, pin_id, opacity)

    const exposed_pin_spec = this._get_pin_spec(type, pin_id)

    const { plug = {} } = exposed_pin_spec

    for (const sub_pin_id in plug) {
      this._set_plug_opacity(type, pin_id, sub_pin_id, opacity)
    }
  }

  private _set_plug_opacity = (
    type: IO,
    pin_id: string,
    sub_pin_id: string,
    opacity_: number
  ): void => {
    const ext_node_id = getExtNodeId(type, pin_id, sub_pin_id)
    const int_node_id = getIntNodeId(type, pin_id, sub_pin_id)

    const ext_pin = this._pin[ext_node_id]
    const int_pin = this._pin[int_node_id]

    const opacity = `${opacity_}`

    const input = type === 'input'

    const source_id = input ? ext_node_id : int_node_id
    const target_id = input ? int_node_id : ext_node_id

    const link_id = getLinkId(source_id, target_id)

    const pin_name = this._ext_pin_name[ext_node_id]

    const link = this._link_base[link_id]

    link.$element.style.opacity = opacity

    pin_name.$element.style.opacity = opacity

    if (ext_pin) {
      ext_pin.$element.style.opacity = opacity
    }
    if (int_pin) {
      int_pin.$element.style.opacity = opacity
    }
  }

  private _get_exposed_pin_internal_node_id = (
    type: IO,
    pin_id: string,
    sub_pin_id: string
  ): string | null => {
    const sub_pin_spec = this._get_exposed_sub_pin_spec(
      type,
      pin_id,
      sub_pin_id
    )

    return (
      this._get_exposed_pin_spec_internal_node_id(type, sub_pin_spec) ||
      getIntNodeId(type, pin_id, sub_pin_id)
    )
  }

  private _get_exposed_pin_spec_internal_node_id = (
    type: IO,
    sub_pin_spec: GraphSubPinSpec
  ): string | null => {
    const { mergeId, unitId, pinId } = sub_pin_spec

    if (mergeId) {
      const merge_node_id = getMergeNodeId(mergeId)

      const merge_anchor_node_id = this._get_merge_anchor_node_id(merge_node_id)

      return merge_anchor_node_id
    } else if (unitId && pinId) {
      if (pinId === SELF) {
        return unitId
      } else {
        return getPinNodeId(unitId, sub_pin_spec.kind ?? type, pinId)
      }
    } else {
      return null
    }
  }

  private _set_exposed_sub_pin_color = (
    type: IO,
    pin_id: string,
    sub_pin_id: string,
    color: string
  ): void => {
    // console.log('Graph', '_set_exposed_sub_pin_color', type, pin_id, color)

    const int_node_id = getIntNodeId(type, pin_id, sub_pin_id)
    const ext_node_id = getExtNodeId(type, pin_id, sub_pin_id)

    const input = type === 'input'

    const external_pin = this._pin[ext_node_id]

    external_pin.$element.style.borderColor = color

    if (!input) {
      external_pin.$element.style.backgroundColor = color
    }

    const name_comp = this._ext_pin_name[ext_node_id]

    name_comp.$element.style.color = color

    const end_marker = this._exposed_link_end_marker[ext_node_id]
    const start_marker = this._exposed_link_start_marker[ext_node_id]

    if (end_marker) {
      end_marker.$element.style.stroke = color
    }
    if (start_marker) {
      start_marker.$element.style.stroke = color
    }

    const source_id = input ? ext_node_id : int_node_id
    const target_id = input ? int_node_id : ext_node_id

    const link_id = getLinkId(source_id, target_id)

    const link_base = this._link_base[link_id]

    link_base.$element.style.stroke = color

    const datum_node_id = this._plug_to_datum[ext_node_id]

    if (datum_node_id) {
      this._set_datum_color(datum_node_id, color, color)
    }
  }

  private _refresh_exposed_pin_set_color = (type: IO, pin_id: string): void => {
    // console.log('Graph', '_refresh_exposed_pin_set_color', type, pin_id)
    const exposed_pin_spec = this._get_pin_spec(type, pin_id)
    const { plug = {} } = exposed_pin_spec
    for (const sub_pin_id in plug) {
      this._refresh_exposed_sub_pin_color(type, pin_id, sub_pin_id)
    }
  }

  private _reset_exposed_pin_set_color = (type: IO, pin_id: string): void => {
    // console.log('Graph', '_reset_exposed_pin_set_color', type, pin_id)
    const exposed_pin_spec = this._get_pin_spec(type, pin_id)
    const { plug = {} } = exposed_pin_spec
    for (const sub_pin_id in plug) {
      this._reset_exposed_sub_pin_color(type, pin_id, sub_pin_id)
    }
  }

  private _get_exposed_sub_pin_color = (type: IO): string => {
    // const color = type === 'input' ? CYAN : type === 'output' ? MAGENTA : WHITE
    const color = this._theme.node
    return color
  }

  private _refresh_exposed_sub_pin_color = (
    type: IO,
    pin_id: string,
    sub_pin_id: string
  ) => {
    // TODO
    const ext_node_id = getExtNodeId(type, pin_id, sub_pin_id)
    const int_node_id = getIntNodeId(type, pin_id, sub_pin_id)
    if (
      this._is_node_hovered(ext_node_id) ||
      this._is_node_selected(ext_node_id) ||
      this._is_node_ascend(ext_node_id) ||
      this._is_node_hovered(int_node_id) ||
      this._is_node_selected(int_node_id) ||
      this._is_node_ascend(int_node_id)
    ) {
      this._refresh_node_color(ext_node_id)
    } else {
      this._reset_exposed_sub_pin_color(type, pin_id, sub_pin_id)
    }
  }

  private _reset_exposed_sub_pin_color = (
    type: IO,
    pin_id: string,
    sub_pin_id: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_reset_exposed_sub_pin_color',
    //   type,
    //   pin_id,
    //   sub_pin_id
    // )

    let color: string

    if (this._unit_datum[type][pin_id]) {
      color = this._theme.data
    } else {
      color = this._get_exposed_sub_pin_color(type)
    }

    this._set_exposed_sub_pin_color(type, pin_id, sub_pin_id, color)
  }

  private _set_exposed_pin_set_color = (
    type: IO,
    pin_id: string,
    color: string
  ): void => {
    const exposed_pin_spec = this._get_pin_spec(type, pin_id)

    const { plug = {} } = exposed_pin_spec

    for (const sub_pin_id in plug) {
      this._set_exposed_sub_pin_color(type, pin_id, sub_pin_id, color)
    }
  }

  private _set_link_pin_link_color = (
    pin_node_id: string,
    color: string
  ): void => {
    // console.log('Graph', '_set_link_pin_link_color', pin_node_id, color)
    const {
      unitId: unit_id,
      type,
      pinId: pin_id,
    } = segmentLinkPinNodeId(pin_node_id)
    const pin_link_id = getPinLinkId(unit_id, type, pin_id)
    this._set_link_color(pin_link_id, color)
    const pin_memory = this._is_link_pin_ref(pin_node_id)
    const pin_ref = this._is_link_pin_ref(pin_node_id)
    const end_marker = this._pin_link_end_marker[pin_node_id]
    const start_marker = this._pin_link_start_marker[pin_node_id]
    if (end_marker) {
      if (pin_memory || pin_ref) {
        end_marker.$element.style.stroke = color
      } else {
        end_marker.$element.style.fill = color
      }
    }
    if (start_marker) {
      if (pin_memory || pin_ref) {
        start_marker.$element.style.stroke = color
      } else {
        start_marker.$element.style.fill = color
      }
    }
  }

  private _set_link_color = (link_id: string, color: string): void => {
    // console.log('_set_link_color', link_id, color, this._theme.data, this._theme.data_link)

    const link_base = this._link_base[link_id]

    link_base.$element.style.stroke = color
  }

  private _set_link_pin_pin_color = (
    pin_node_id: string,
    color: string,
    icon_color: string
  ): void => {
    const { type } = segmentLinkPinNodeId(pin_node_id)

    const output = type === 'output'

    const pin = this._pin[pin_node_id]

    const ref = this._is_link_pin_ref(pin_node_id)

    const borderColor = ref && !output ? COLOR_NONE : color

    pin.$element.style.borderColor = borderColor
    if (type === 'output' && !ref) {
      pin.$element.style.backgroundColor = color
    }

    const ref_output_pin_icon = this._ref_output_pin_icon[pin_node_id]
    if (ref_output_pin_icon) {
      ref_output_pin_icon.$element.style.stroke = icon_color
    }
  }

  private _refresh_datum_color = (datum_node_id: string) => {
    this._refresh_node_color(datum_node_id)
  }

  private _refresh_pin_color = (pin_node_id: string): void => {
    // console.log('Graph', '_refresh_pin_color', pin_node_id)
    if (this._is_link_pin_node_id(pin_node_id)) {
      this._refresh_link_pin_color(pin_node_id)
    } else {
      this._refresh_merge_pin_pin_color(pin_node_id, 'input')
      this._refresh_merge_pin_pin_color(pin_node_id, 'output')
    }
  }

  private _refresh_link_pin_color = (pin_node_id: string) => {
    // console.log('Graph', '_refresh_link_pin_color', pin_node_id)
    if (this._is_link_pin_displayed(pin_node_id)) {
      this._refresh_node_color(pin_node_id)
    } else {
      this._reset_link_pin_color(pin_node_id)
    }
  }

  private _set_pin_text_opacity = (
    pin_node_id: string,
    opacity: number
  ): void => {
    if (this._is_link_pin_merged(pin_node_id)) {
      this._set_link_pin_link_text_opacity(pin_node_id, opacity)
    } else {
      this._set_link_pin_pin_text_opacity(pin_node_id, opacity)
    }
  }

  private _set_pin_text_color = (pin_node_id: string, color: string): void => {
    if (this._is_link_pin_merged(pin_node_id)) {
      this._set_link_pin_link_text_color(pin_node_id, color)
    } else {
      this._set_link_pin_pin_text_color(pin_node_id, color)
    }
  }

  private _set_link_pin_pin_text_color = (
    pin_node_id: string,
    color: string
  ): void => {
    const pin_name = this._pin_name[pin_node_id]

    pin_name.$element.style.color = color
  }

  private _set_link_pin_pin_text_opacity = (
    pin_node_id: string,
    opacity: number
  ): void => {
    const pin_name = this._pin_name[pin_node_id]

    pin_name.$element.style.opacity = `${opacity}`
  }

  private _get_link_pin_text = (pin_node_id: string) => {
    const link_id = getPinLinkIdFromPinNodeId(pin_node_id)

    const link_text = this._link_text[link_id]

    return link_text
  }

  private _set_link_pin_link_text_opacity = (
    pin_node_id: string,
    opacity: number
  ): void => {
    const link_text = this._get_link_pin_text(pin_node_id)

    link_text.$element.style.opacity = `${opacity}`
  }

  private _set_link_pin_link_text_color = (
    pin_node_id: string,
    fill: string
  ): void => {
    const link_text = this._get_link_pin_text(pin_node_id)

    link_text.$element.style.fill = fill
  }

  public remove_datum = (datum_node_id: string) => {
    // console.log('Graph', 'remove_datum', datum_node_id)

    const { datumId } = segmentDatumNodeId(datum_node_id)

    const value = this._get_datum_value(datum_node_id)

    this._dispatch_action(makeRemoveDatumAction(datumId, value))

    this._remove_datum(datum_node_id)
  }

  private _remove_datum = (datum_node_id: string) => {
    // console.log('Graph', '_remove_datum', datum_node_id)

    const { datum_pin_node_id, datum_plug_node_id } =
      this._get_datum_connected(datum_node_id)

    this._pod_remove_datum(datum_node_id, datum_pin_node_id, datum_plug_node_id)
    this._sim_remove_datum(datum_node_id)
    this._spec_remove_datum(datum_node_id)

    if (datum_pin_node_id) {
      this._spec_remove_pin_data(datum_pin_node_id)
    }
  }

  private _remove_node_datum_link = (
    datum_node_id: string,
    node_id: string
  ): void => {
    if (this._is_link_pin_node_id(node_id)) {
      this._remove_pin_datum_link(datum_node_id)
    } else if (this._is_merge_node_id(node_id)) {
      this._remove_pin_datum_link(datum_node_id)
    } else if (this._is_ext_node_id(node_id)) {
      this._remove_plug_set_datum_link(node_id)
    }
  }

  public remove_node_datum_link = (
    datum_node_id: string,
    node_id: string
  ): void => {
    if (this._is_link_pin_node_id(node_id)) {
      this.remove_pin_datum_link(datum_node_id)
    } else if (this._is_merge_node_id(node_id)) {
      this.remove_pin_datum_link(datum_node_id)
    } else if (this._is_ext_node_id(node_id)) {
      this.remove_plug_set_datum_link(node_id)
    }
  }

  private _remove_plug_set_datum_link = (plug_node_id: string): void => {
    const { type, pinId, subPinId } = segmentPlugNodeId(plug_node_id)

    this._sim_remove_plug_set_datum_link(plug_node_id)
    this._pod_remove_exposed_pin_datum(type, pinId)
  }

  public remove_plug_set_datum_link = (plug_node_id: string): void => {
    this._remove_plug_set_datum_link(plug_node_id)
  }

  private _sim_remove_plug_set_datum_link = (plug_node_id: string): void => {
    const { type, pinId, subPinId } = segmentPlugNodeId(plug_node_id)

    this._sim_remove_plug_datum_link(type, pinId, subPinId)

    this._for_each_plug(type, pinId, (subPinId) => {
      const ext_node_id = getExtNodeId(type, pinId, subPinId)

      const datum_node_id = this._plug_to_datum[ext_node_id]

      if (datum_node_id) {
        this._sim_remove_plug_datum(type, pinId, subPinId)
      }
    })
  }

  public remove_pin_datum_link = (datum_node_id: string): void => {
    // console.log('Graph', 'remove_pin_datum_link', datum_node_id)

    const pin_node_id = this._datum_to_pin[datum_node_id]

    const data = this._get_datum_value(datum_node_id)

    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    this._dispatch_action(
      makeRemoveUnitPinDataAction(unitId, type, pinId, data)
    )

    this._remove_pin_datum_link(datum_node_id)

    this._clear_graph_pin_type(unitId, type, pinId)
  }

  private _clear_graph_pin_type = (unitId: string, type: IO, pinId: string) => {
    if (!this._graph_type_map) {
      return
    }

    deepDelete(this._graph_type_map, [unitId, type, pinId])
  }

  private _remove_pin_datum_link = (datum_node_id: string): void => {
    // console.log('Graph', '_remove_pin_datum_link', datum_node_id)

    const pin_node_id = this._datum_to_pin[datum_node_id]

    this._pod_remove_pin_datum(pin_node_id)
    this._sim_remove_pin_datum_link(datum_node_id)
    this._spec_remove_pin_datum_link(pin_node_id, datum_node_id)
  }

  private _spec_remove_pin_datum_link = (
    pin_node_id: string,
    datum_node_id: string
  ): void => {
    if (this._is_link_pin_node_id(pin_node_id)) {
      // if (this._is_link_pin_constant(pin_node_id)) {
      this._spec_remove_pin_data(pin_node_id)
      // }
    }
  }

  private _spec_remove_pin_data = (pin_node_id: string): void => {
    // console.log('Graph', '_spec_remove_pin_data', pin_node_id)

    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    removeUnitPinData({ unitId, type, pinId }, this._spec)
  }

  private _sim_remove_pin_datum_link = (datum_node_id: string) => {
    // console.log('Graph', '_sim_remove_pin_datum_link', datum_node_id)

    const pin_node_id = this._datum_to_pin[datum_node_id]

    delete this._datum_to_pin[datum_node_id]
    delete this._pin_to_datum[pin_node_id]

    this._sim_remove_datum_link(datum_node_id, pin_node_id)

    if (this._is_node_visible(pin_node_id)) {
      this._refresh_node_color(pin_node_id)
    }
  }

  private _sim_remove_datum_link = (
    datum_node_id: string,
    node_id: string
  ): void => {
    // console.log('Graph', '_sim_remove_datum_link', datum_node_id, node_id)

    const link_id = getLinkId(datum_node_id, node_id)

    delete this._linked_data_node[datum_node_id]
    delete this._visible_linked_data_node[datum_node_id]

    const datum_node = this._data_node[datum_node_id]

    this._unlinked_data_node[datum_node_id] = datum_node

    if (this._visible_data_node[datum_node_id]) {
      this._visible_unlinked_data_node[datum_node_id] = datum_node
      this._set_node_layer(datum_node_id, LAYER_DATA)
    }

    delete this._visible_data_link[link_id]

    delete this._data_link[link_id]

    this._sim_remove_link(link_id)

    this._refresh_node_color(datum_node_id)

    this._refresh_compatible()

    this._start_graph_simulation(LAYER_DATA_LINKED)
  }

  private _mem_remove_pin_datum_tree = (pin_node_id: string): void => {
    // console.log('Graph', '_mem_remove_pin_datum_tree', pin_node_id)

    delete this._pin_datum_tree[pin_node_id]

    if (this._is_link_pin_node_id(pin_node_id)) {
      const { unitId, type } = segmentLinkPinNodeId(pin_node_id)

      if (!this._spec_is_link_pin_ignored(pin_node_id)) {
        this._dec_unit_pin_active(unitId)

        this._set_pin_text_color(pin_node_id, this._theme.pin_text)
      }

      const pin_merge_node_id = this._pin_to_merge[pin_node_id]

      if (pin_merge_node_id) {
        if (type === 'input') {
          this._dec_merge_input_active(pin_merge_node_id)
        } else {
          this._dec_merge_output_active(pin_merge_node_id)
        }

        if (this._has_node(pin_merge_node_id)) {
          this._refresh_merge_pin_color(pin_merge_node_id)
        }
      }
    } else if (this._is_merge_node_id(pin_node_id)) {
      // this._dec_merge_input_active(pin_node_id)
    }

    if (this._is_link_pin_node_id(pin_node_id)) {
      if (this._has_node(pin_node_id)) {
        this._refresh_link_pin_color(pin_node_id)
      }

      this._refresh_link_pin_link_color(pin_node_id)
    }
  }

  private _pod_remove_pin_datum = (pin_node_id: string) => {
    // console.log('Graph', '_pod_remove_pin_datum', pin_node_id)

    this._pod_remove_pin_datum__template(pin_node_id, {
      takeInput: (data) => this._pod.$takeInput(data),
      removeMergeData: (data) => this._pod.$removeMergeData(data),
      removeUnitPinData: (data) => this._pod.$removeUnitPinData(data),
    })
  }

  private _pod_remove_pin_datum__template = (
    pin_node_id: string,
    {
      takeInput,
      removeMergeData,
      removeUnitPinData,
    }: {
      takeInput: (data: UnitTakeInputData) => void
      removeMergeData(data: GraphRemoveMergeDataData): void
      removeUnitPinData(data: GraphRemoveUnitPinDataData): void
    }
  ) => {
    const { fork } = this.$props

    if (this._is_merge_node_id(pin_node_id)) {
      const { mergeId } = segmentMergeNodeId(pin_node_id)

      removeMergeData({ mergeId, fork })
    } else {
      const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

      const data = undefined

      removeUnitPinData({
        unitId,
        type,
        pinId,
        data,
        fork,
      })
    }
  }

  public remove_pin_from_merge = (
    merge_node_id: string,
    pin_node_id: string
  ): void => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    this._dispatch_action(
      makeRemovePinFromMergeAction(mergeId, type, unitId, pinId)
    )

    this._remove_pin_from_merge(merge_node_id, pin_node_id)
  }

  private _remove_pin_from_merge = (
    merge_node_id: string,
    pin_node_id: string,
    emit: boolean = true
  ): void => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    emit && this.__pod_remove_pin_from_merge(mergeId, unitId, type, pinId)
    this._state_remove_pin_from_merge(merge_node_id, pin_node_id)
  }

  private _state_remove_pin_from_merge = (
    merge_node_id: string,
    pin_node_id: string
  ): void => {
    // console.log('Graph', '_spec_remove_pin_from_merge')
    this._sim_remove_pin_from_merge(merge_node_id, pin_node_id)
    this._spec_remove_pin_from_merge(merge_node_id, pin_node_id)
  }

  private __state_remove_pin_from_merge = (
    mergeId: string,
    unitId: string,
    type: IO,
    pinId: string
  ): void => {
    // console.log('Graph', '_spec_remove_pin_from_merge', mergeId, unitId, type, pinId)
    this.__sim_remove_pin_from_merge(mergeId, unitId, type, pinId)
    this.__spec_remove_pin_from_merge(mergeId, unitId, type, pinId)
  }

  private _spec_remove_pin_from_merge = (
    merge_node_id: string,
    pin_node_id: string
  ): void => {
    // console.log('Graph', '_spec_remove_pin_from_merge')

    const { mergeId } = segmentMergeNodeId(merge_node_id)
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    this.__spec_remove_pin_from_merge(mergeId, unitId, type, pinId)
  }

  private __spec_remove_pin_from_merge = (
    mergeId: string,
    unitId: string,
    type: IO,
    pinId: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '__spec_remove_pin_from_merge',
    //   mergeId,
    //   unitId,
    //   type,
    //   pinId
    // )

    removePinFromMerge({ mergeId, unitId, type, pinId }, this._spec)
  }

  private _sim_change_all_merge_input_to = (
    merge_node_id: string,
    node_id: string
  ): void => {
    const merge_to_input = this._merge_to_input[merge_node_id]

    for (const input_node_id in merge_to_input) {
      const link_id = getPinLinkIdFromPinNodeId(input_node_id)

      this._sim_change_link_source(link_id, node_id)
      this._refresh_link_pin_marker(input_node_id, node_id)

      const datum_node_id = this._pin_to_datum[input_node_id]

      if (datum_node_id) {
        const datum_link_id = getLinkId(datum_node_id, input_node_id)

        this._sim_change_link_target(datum_link_id, node_id)
      }
    }
  }

  private _refresh_link_pin_marker = (pin_node_id: string, node_id: string) => {
    // console.log('Graph', '_refresh_link_pin_marker', pin_node_id, node_id)

    const link_id = getPinLinkIdFromPinNodeId(pin_node_id)

    const node_shape = this._get_node_shape(node_id)
    const node_r = this._get_node_r(node_id)

    const link_start_marker = this._link_marker_start[link_id]

    const arrow_shape = describeArrowShape(node_shape, node_r)

    link_start_marker.setProp('d', arrow_shape)
  }

  private __sim_remove_pin_from_merge = (
    mergeId: string,
    unitId: string,
    type: IO,
    pinId: string,
    position?: Position
  ): void => {
    const merge_node_id = getMergeNodeId(mergeId)
    const pin_node_id = getPinNodeId(unitId, type, pinId)

    this._sim_remove_pin_from_merge(merge_node_id, pin_node_id, position)
  }

  private _sim_remove_pin_from_merge = (
    merge_node_id: string,
    pin_node_id: string,
    position?: Position
  ): void => {
    // console.log(
    //   'Graph',
    //   '_sim_remove_pin_from_merge',
    //   merge_node_id,
    //   pin_node_id
    // )

    position = position || this._get_merge_position(merge_node_id)

    const { mergeId } = segmentMergeNodeId(merge_node_id)
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    const pin_ref = this._is_link_pin_ref(pin_node_id)
    const merge_ref = this._is_merge_ref(merge_node_id)

    deepDec(this._merge_pin_name_count, [merge_node_id, type, pinId])

    const is_input = type === 'input'

    const is_output = !is_input

    const output_ref = is_output && pin_ref

    const merge_unit_id = this._merge_to_ref_unit[merge_node_id]
    const merge_output_ref = this._merge_to_ref_output[merge_node_id]

    const merge: GraphMergeSpec = this._spec_get_merge(mergeId)

    delete this._pin_to_merge[pin_node_id]

    delete this._merge_to_pin[merge_node_id][pin_node_id]
    delete this._merge_to_input[merge_node_id][pin_node_id]
    delete this._merge_to_output[merge_node_id][pin_node_id]

    const is_pin_output_self = isSelfPin(type, pinId)

    if (is_pin_output_self) {
      delete this._merge_to_ref_unit[merge_node_id]
      delete this._ref_unit_to_merge[unitId]
    }

    if (output_ref) {
      delete this._merge_to_ref_output[merge_node_id]
      delete this._ref_output_to_merge[pin_node_id]
    }

    if (is_input) {
      this._dec_merge_input_count(mergeId)
    } else {
      this._dec_merge_output_count(mergeId)
    }
    this._dec_merge_pin_count(mergeId)

    if (!is_pin_output_self && !output_ref) {
      this._sim_add_link_pin_node(unitId, type, pinId, position)

      const source_id = is_input ? pin_node_id : unitId
      const target_id = is_input ? unitId : pin_node_id

      const link_id = getLinkId(source_id, target_id)

      this._sim_change_link_source(link_id, source_id)
      this._sim_change_link_target(link_id, target_id)

      this._hide_link_text(link_id)
    } else {
      let position: Position

      if (is_pin_output_self) {
        position = this._get_node_position(unitId)
      } else {
        position = this._get_node_position(pin_node_id)
      }

      this._sim_add_merge_pin_node(mergeId, position)
      this._sim_change_all_merge_input_to(merge_node_id, merge_node_id)

      if (is_pin_output_self) {
        //
      } else {
        const pin_link_id = getPinLinkIdFromPinNodeId(pin_node_id)

        this._hide_link_text(pin_link_id)
        this._show_link_pin_name(pin_node_id)
      }

      if (this._merge_pin_count[mergeId] === 0) {
        this._set_node_layer(merge_node_id, LAYER_EXPOSED)
      }
    }

    const merge_input = this._merge_input[merge_node_id]
    const merge_output = this._merge_output[merge_node_id]

    if (is_input) {
      if (this._merge_input_count[mergeId] === 0) {
        if (!merge_ref) {
          const merge_output_width = 2 * PIN_RADIUS

          merge_input.$element.style.visibility = 'hidden'

          merge_output.$element.style.width = `${merge_output_width}px`
          merge_output.$element.style.height = `${merge_output_width}px`
          merge_output.$element.style.transform = ''
        }
      }
    } else {
      if (this._merge_output_count[mergeId] === 0) {
        if (!merge_ref) {
          merge_output.$element.style.visibility = 'hidden'
        }
      }
    }

    const datum_node_id = this._pin_to_datum[pin_node_id]
    if (datum_node_id) {
      if (is_input) {
        this._dec_merge_input_active(merge_node_id)
      } else {
        this._dec_merge_output_active(merge_node_id)
      }

      const datum_link_id = getLinkId(datum_node_id, pin_node_id)

      this._sim_change_link_target(datum_link_id, pin_node_id)

      if (!merge_ref) {
        const { x, y } = this._predict_pin_datum_initial_position(pin_node_id)

        const datum_node = this._node[datum_node_id]

        datum_node.x = x
        datum_node.y = y
      }

      this._refresh_datum_visible(datum_node_id)

      if (this._is_node_ascend(pin_node_id) || this._is_node_ascend(unitId)) {
        this._ascend_node(datum_node_id)
      }
    }

    if (is_input && (merge_ref || merge_output_ref)) {
      this._set_link_pin_padding_source(pin_node_id, -1.5)
      this._set_link_pin_start_marker_hidden(pin_node_id, false)
      this._set_ref_link_pin_start_marker_r(pin_node_id, PIN_RADIUS)
    }

    if (is_input) {
      const merge_to_output = this._merge_to_output[merge_node_id]
      for (const output_node_id in merge_to_output) {
        const { unitId: _unitId } = segmentLinkPinNodeId(output_node_id)
        const merge_link_id = getLinkId(_unitId, unitId)
        this._unit_to_unit[merge_link_id]--
        if (this._unit_to_unit[merge_link_id] === 0) {
          delete this._unit_to_unit[merge_link_id]
        }
      }
    } else {
      const merge_to_input = this._merge_to_input[merge_node_id]
      for (const input_node_id in merge_to_input) {
        const { unitId: _unitId } = segmentLinkPinNodeId(input_node_id)
        const merge_link_id = getLinkId(unitId, _unitId)
        this._unit_to_unit[merge_link_id]--
        if (this._unit_to_unit[merge_link_id] === 0) {
          delete this._unit_to_unit[merge_link_id]
        }
      }
    }

    if (!merge_ref) {
      this._refresh_merge_pin_pin_color(merge_node_id, type)

      const merge_datum_node_id = this._get_merge_datum_node_id(merge_node_id)

      if (merge_datum_node_id) {
        this._refresh_datum_visible(merge_datum_node_id)
      }
    }

    if (merge_ref) {
      this._refresh_core_border_color(unitId)
    }

    if (this._is_node_ascend(unitId)) {
      if (this._has_node(pin_node_id)) {
        this.__ascend_node(pin_node_id)
      }
    }

    if (this._collapse_init_node_id_set.has(merge_node_id)) {
      if (!this._collapse_init_node_id_set.has(unitId)) {
        this._start_node_long_press_collapse(pin_node_id)
      }
    }

    this._refresh_merge_name(merge_node_id)
  }

  private _pod_remove_pin_from_merge = (
    merge_node_id: string,
    pin_node_id: string
  ) => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    this.__pod_remove_pin_from_merge(mergeId, unitId, type, pinId)
  }

  private __pod_remove_pin_from_merge = (
    mergeId: string,
    unitId: string,
    type: IO,
    pinId: string
  ) => {
    const { config, fork, bubble } = this.$props

    const take = !!config?.unlinkTake

    this._pod.$removePinFromMerge({
      mergeId,
      unitId,
      type,
      pinId,
      take,
      fork,
      bubble,
    })
  }

  private _get_merge_pin_not_equal = (
    merge_node_id: string,
    pin_node_id: string
  ): string => {
    return this._get_merge_pin_not_equal__template(
      merge_node_id,
      pin_node_id,
      () => {
        return keys(this._merge_to_pin[merge_node_id])
      }
    )
  }

  private _get_merge_pin_not_equal__template = (
    merge_node_id: string,
    pin_node_id: string,
    get_merge_pins: (merge_node_id: string) => string[]
  ): string => {
    const merge_pin_node_ids = get_merge_pins(merge_node_id)

    let other_pin_node_id: string

    for (const merge_pin_node_id of merge_pin_node_ids) {
      if (merge_pin_node_id !== pin_node_id) {
        other_pin_node_id = merge_pin_node_id

        break
      }
    }

    return other_pin_node_id
  }

  private _is_blue_drag_init_anchor = (node_id: string): boolean => {
    const blue_drag_init_anchor_node_id =
      this._blue_drag_init_anchor_to_pin[node_id]

    return !!blue_drag_init_anchor_node_id
  }

  private _update_blue_drag_init_anchor = (
    anchor_node_id: string,
    new_anchor_node_id: string
  ): void => {
    const blue_drag_init_anchor_node_id =
      this._blue_drag_init_anchor_to_pin[anchor_node_id]

    if (blue_drag_init_anchor_node_id) {
      delete this._blue_drag_init_anchor_to_pin[anchor_node_id]

      this._blue_drag_init_anchor_to_pin[anchor_node_id] =
        blue_drag_init_anchor_node_id
      this._blue_drag_init_pin_to_anchor[blue_drag_init_anchor_node_id] =
        anchor_node_id
    }
  }

  private _get_pin_merge_node_id = (pin_node_id: string) => {
    return this._pin_to_merge[pin_node_id]
  }

  private _get_pin_merge_id = (pin_node_id: string) => {
    const merge_node_id = this._get_pin_merge_node_id(pin_node_id)

    if (!merge_node_id) {
      return null
    }

    const { mergeId } = segmentMergeNodeId(merge_node_id)

    return mergeId
  }

  private _get_merge_node_pin_count = (merge_node_id: string) => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    return this._merge_pin_count[mergeId]
  }

  private _get_merge_node_pins = (merge_node_id: string): string[] => {
    return keys(this._merge_to_pin[merge_node_id])
  }

  private _spec_get_pin_merge_node_id = (
    pin_node_id: string
  ): string | null => {
    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    const { merges } = this._spec

    for (const merge_id in merges) {
      const merge = merges[merge_id]

      const pin = deepGetOrDefault(merge, [unitId, type, pinId], null)

      if (pin) {
        const merge_node_id = getMergeNodeId(merge_id)

        return merge_node_id
      }
    }

    return null
  }

  private _spec_get_merge_node_pin_count = (merge_node_id: string): number => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    return this._spec_get_merge_pin_count(mergeId)
  }

  private _spec_get_merge_pin_count = (merge_id: string): number => {
    const merge = this._spec_get_merge(merge_id)

    const merge_pin_count = getMergePinCount(merge)

    return merge_pin_count
  }

  private _spec_get_merge_node_pins = (merge_node_id: string): string[] => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    const { merges } = this._spec

    const merge = merges[mergeId]

    const pin_node_ids = []

    forEachPinOnMerge(merge, (unitId, type, pinId) => {
      const pin_node_id = getPinNodeId(unitId, type, pinId)

      pin_node_ids.push(pin_node_id)
    })

    return pin_node_ids
  }

  private _dry_remove_pin_or_merge = (
    pin_node_id: string,
    remove_pin: (merge_node_id: string) => void = NOOP,
    remove_merge: (
      merge_node_id: string,
      other_link_pin_node_id: string
    ) => void = NOOP
  ): string => {
    // console.log('Graph', '_dry_remove_pin_or_merge')

    return this._dry_remove_pin_or_merge__template(
      pin_node_id,
      remove_pin,
      remove_merge,
      this._get_pin_merge_node_id,
      this._get_merge_node_pin_count,
      this._get_merge_node_pins
    )
  }

  private _spec_dry_remove_pin_or_merge = (
    pin_node_id: string,
    remove_pin: (merge_node_id: string) => void = NOOP,
    remove_merge: (
      merge_node_id: string,
      other_link_pin_node_id: string
    ) => void = NOOP
  ) => {
    return this._dry_remove_pin_or_merge__template(
      pin_node_id,
      remove_pin,
      remove_merge,
      this._spec_get_pin_merge_node_id,
      this._spec_get_merge_node_pin_count,
      this._spec_get_merge_node_pins
    )
  }

  private _dry_remove_pin_or_merge__template = (
    pin_node_id: string,
    remove_pin: (merge_node_id: string) => void = NOOP,
    remove_merge: (
      merge_node_id: string,
      other_link_pin_node_id: string
    ) => void = NOOP,
    get_pin_merge: (pin_node_id: string) => string,
    get_merge_pin_count: (merge_node_id: string) => number,
    get_merge_pins: (merge_node_id: string) => string[]
  ): string => {
    // console.log('Graph', '_remove_pin_or_merge')

    const merge_node_id = get_pin_merge(pin_node_id)

    if (merge_node_id) {
      const merge_pin_count = get_merge_pin_count(merge_node_id)

      if (merge_pin_count > 2) {
        remove_pin(merge_node_id)

        return merge_node_id
      } else {
        const other_pin_node_id = this._get_merge_pin_not_equal__template(
          merge_node_id,
          pin_node_id,
          get_merge_pins
        )

        remove_merge(merge_node_id, other_pin_node_id)

        return other_pin_node_id
      }
    }
  }

  private _remove_pin_or_merge = (
    pin_node_id: string,
    position?: Position
  ): string => {
    // console.log('Graph', '_remove_pin_or_merge', pin_node_id)
    return this._dry_remove_pin_or_merge(
      pin_node_id,
      (merge_node_id) => {
        this.remove_pin_from_merge(merge_node_id, pin_node_id)
      },
      (merge_node_id, other_pin_node_id: string) => {
        if (this._is_blue_drag_init_anchor(merge_node_id)) {
          this._update_blue_drag_init_anchor(merge_node_id, other_pin_node_id)
        }

        const unplug = (int_node_id: string): void => {
          if (int_node_id) {
            const { pinId, type, subPinId } = segmentPlugNodeId(int_node_id)

            this._unplug_exposed_pin(type, pinId, subPinId)
          }
        }

        const plug = (int_node_id: string): void => {
          if (int_node_id) {
            const { pinId, type, subPinId } = segmentPlugNodeId(int_node_id)
            const {
              unitId,
              type: _type,
              pinId: _pinId,
            } = segmentLinkPinNodeId(other_pin_node_id)
            this._plug_exposed_pin(type, pinId, subPinId, {
              unitId,
              pinId: _pinId,
              kind: _type,
            })
          }
        }

        const anchor_node_id = this._get_merge_anchor_node_id(merge_node_id)

        const int_input_node_id = this._pin_to_int['input'][anchor_node_id]
        const int_output_node_id = this._pin_to_int['output'][anchor_node_id]

        unplug(int_input_node_id)
        unplug(int_output_node_id)

        this.remove_merge(merge_node_id)

        plug(int_input_node_id)
        plug(int_output_node_id)
      }
    )
  }

  private _sim_remove_pin_or_merge = (
    pin_node_id: string,
    position?: Position
  ): string => {
    // console.log('Graph', '_sim_remove_pin_or_merge', pin_node_id)
    return this._dry_remove_pin_or_merge(
      pin_node_id,
      (merge_node_id) => {
        this._sim_remove_pin_from_merge(merge_node_id, pin_node_id, position)
      },
      (merge_node_id, other_pin_node_id: string | undefined) => {
        const ext_input_node_id = this._pin_to_ext['input'][merge_node_id]
        const ext_output_node_id = this._pin_to_ext['output'][merge_node_id]

        if (ext_input_node_id) {
          const { pinId: _pinId, subPinId } =
            segmentPlugNodeId(ext_input_node_id)

          this._sim_unplug_exposed_pin('input', _pinId, subPinId)
        }
        if (ext_output_node_id) {
          const { pinId: _pinId, subPinId } =
            segmentPlugNodeId(ext_output_node_id)

          this._sim_unplug_exposed_pin('output', _pinId, subPinId)
        }

        this._sim_remove_merge(merge_node_id)

        if (other_pin_node_id) {
          const { unitId, type, pinId } =
            segmentLinkPinNodeId(other_pin_node_id)

          if (this._is_blue_drag_init_anchor(merge_node_id)) {
            this._update_blue_drag_init_anchor(merge_node_id, other_pin_node_id)
          }

          const should_plug_input = !!ext_input_node_id
          const should_plug_output = !!ext_output_node_id

          if (should_plug_input) {
            const { pinId: _pinId, subPinId } =
              segmentPlugNodeId(ext_input_node_id)

            this._sim_plug_exposed_pin('input', _pinId, subPinId, {
              unitId,
              pinId,
              kind: type,
            })
          }

          if (should_plug_output) {
            const { pinId: _pinId, subPinId } =
              segmentPlugNodeId(ext_output_node_id)

            this._sim_plug_exposed_pin('output', _pinId, subPinId, {
              unitId,
              pinId,
              kind: type,
            })
          }
        }
      }
    )
  }

  private _spec_remove_pin_or_merge = (pin_node_id: string): string => {
    // console.log('Graph', '_spec_remove_pin_or_merge', pin_node_id)

    return this._spec_dry_remove_pin_or_merge(
      pin_node_id,
      (merge_node_id) => {
        this._spec_remove_pin_from_merge(merge_node_id, pin_node_id)
      },
      (merge_node_id, other_pin_node_id: string) => {
        const { mergeId } = segmentMergeNodeId(merge_node_id)

        const merge_plugs = findMergePlugs(this._spec, mergeId)

        forIO(merge_plugs, (type, plugs) => {
          forEach(plugs, (plug) => {
            this._spec_unplug_sub_pin(type, plug.pinId, plug.subPinId)
          })
        })

        this._spec_remove_merge(mergeId)

        const {
          unitId,
          type: kind,
          pinId,
        } = segmentLinkPinNodeId(other_pin_node_id)

        forIO(merge_plugs, (type, plugs) => {
          forEach(plugs, (plug) => {
            this._spec_plug_sub_pin(type, plug.pinId, plug.subPinId, {
              unitId,
              pinId,
              kind,
            })
          })
        })
      }
    )
  }

  private _state_remove_pin_or_merge = (pin_node_id: string): string => {
    // console.log('Graph', '_sim_remove_pin_or_merge', pin_node_id)

    return this._dry_remove_pin_or_merge(
      pin_node_id,
      (merge_node_id) => {
        this._state_remove_pin_from_merge(merge_node_id, pin_node_id)
      },
      (merge_node_id, other_pin_node_id: string) => {
        this._state_remove_merge(merge_node_id)
      }
    )
  }

  private _pod_remove_pin_or_merge = (pin_node_id: string): string => {
    // console.log('Graph', '_sim_remove_pin_or_merge')
    return this._dry_remove_pin_or_merge(
      pin_node_id,
      (merge_node_id) => {
        this._pod_remove_pin_from_merge(merge_node_id, pin_node_id)
      },
      (merge_node_id, other_pin_node_id: string) => {
        this._pod_remove_merge(merge_node_id)
      }
    )
  }

  private _sim_remove_pin_type = (pin_node_id: string): void => {
    return this._sim_remove_node_type(pin_node_id)
  }

  private _sim_remove_node_type = (node_id: string): void => {
    // console.log('Graph', '_sim_remove_node_type', node_id)

    const type_node_id = getTypeNodeId(node_id)

    if (!this._has_node(type_node_id)) {
      return
    }

    const type_link_id = getLinkId(type_node_id, node_id)

    this._mem_remove_node_type(node_id)

    this._sim_remove_link(type_link_id)
    this._sim_remove_node(type_node_id)
  }

  private _mem_remove_node_type = (node_id: string) => {
    const type_node_id = getTypeNodeId(node_id)

    const type_link_id = getLinkId(type_node_id, node_id)

    delete this._type_link[type_link_id]

    delete this._type_container[type_node_id]
    delete this._type_node[type_node_id]
    delete this._type[type_node_id]

    delete this._node_type[type_node_id]
  }

  private _sim_remove_link_pin_pin = (pin_node_id: string): void => {
    // console.log('Graph', '_sim_remove_link_pin_pin', pin_node_id)

    this._sim_remove_pin_type(pin_node_id)

    delete this._pin[pin_node_id]
    delete this._pin_node[pin_node_id]
    delete this._pin_name[pin_node_id]

    delete this._normal_node[pin_node_id]
    delete this._ignored_node[pin_node_id]

    if (this._node_link_heap[pin_node_id]) {
      this._remove_node_link_heap(pin_node_id)
    }

    this._sim_remove_node(pin_node_id)
  }

  private _sim_remove_link_pin_link = (pin_node_id: string): void => {
    // console.log('Graph', '_sim_remove_link_pin_link', pin_node_id)

    const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

    const link_id = getPinLinkId(unitId, type, pinId)

    delete this._pin_link_start_marker[pin_node_id]
    delete this._pin_link_end_marker[pin_node_id]

    this._link_pin_input_set.delete(pin_node_id)
    this._link_pin_output_set.delete(pin_node_id)
    this._link_pin_ref_set.delete(pin_node_id)

    delete this._pin_link[link_id]

    this._sim_remove_link(link_id)
  }

  public remove_merge = (merge_node_id: string): void => {
    // console.log('Graph', 'remove_merge', merge_node_id)

    this._dispatch_action_remove_merge(merge_node_id)

    this._remove_merge(merge_node_id)
  }

  private _remove_merge = (
    merge_node_id: string,
    emit: boolean = true
  ): void => {
    const { mergeId } = segmentMergeNodeId(merge_node_id)

    emit && this._pod_remove_merge(merge_node_id)
    this._sim_remove_merge(merge_node_id)
    this._spec_remove_merge(mergeId)
  }

  private _state_remove_merge = (merge_node_id: string): void => {
    // console.log('_state_remove_merge', merge_node_id)

    const { mergeId } = segmentMergeNodeId(merge_node_id)

    this._sim_remove_merge(merge_node_id)
    this._spec_remove_merge(mergeId)
  }

  private __state_remove_merge = (merge_id: string): void => {
    this.__sim_remove_merge(merge_id)
    this._spec_remove_merge(merge_id)
  }

  private _pod_remove_merge = (merge_node_id: string): void => {
    // console.log('Graph', '_pod_remove_merge', merge_node_id)

    const { config, fork, bubble } = this.$props

    const { mergeId } = segmentMergeNodeId(merge_node_id)

    const merge = this._spec_get_merge(mergeId)
    const position = this._get_merge_position(merge_node_id)

    const take = !!config?.unlinkTake

    this._pod.$removeMerge({
      mergeId,
      mergeSpec: merge,
      position,
      take,
      fork,
      bubble,
    })
  }

  private _spec_remove_merge = (mergeId: string): void => {
    // console.log('Graph', '_spec_remove_merge', mergeId)

    removeMerge({ mergeId }, this._spec)
  }

  private _is_link_pin_output_ref = (type: IO, pinId: string): boolean => {
    return isSelfPin(type, pinId)
  }

  private _sim_remove_merge = (merge_node_id: string): void => {
    // console.log('Graph', '_sim_remove_merge', merge_node_id)

    const { mergeId } = segmentMergeNodeId(merge_node_id)

    const anchor_node_id = this._get_merge_anchor_node_id(merge_node_id)
    const anchor_position = this._get_node_position(anchor_node_id)

    const merge_to_pin = clone(this._merge_to_pin[merge_node_id])
    const merge_to_input = clone(this._merge_to_input[merge_node_id])

    for (let pin_node_id in merge_to_pin) {
      this._sim_remove_pin_from_merge(
        merge_node_id,
        pin_node_id,
        anchor_position
      )
    }

    const int_input_node_id = this._pin_to_int['input'][merge_node_id]

    if (int_input_node_id) {
      const { type, pinId, subPinId } = segmentPlugNodeId(int_input_node_id)

      this._sim_unplug_exposed_pin(type, pinId, subPinId)
    }

    const int_output_node_id = this._pin_to_int['output'][merge_node_id]

    if (int_output_node_id) {
      const { type, pinId, subPinId } = segmentPlugNodeId(int_output_node_id)

      this._sim_unplug_exposed_pin(type, pinId, subPinId)
    }

    const merge_datum_node_id = this._pin_to_datum[merge_node_id]

    if (merge_datum_node_id) {
      this._sim_remove_datum(merge_datum_node_id)
    }

    const merge_ref = this._is_merge_ref(merge_node_id)

    const merge_ref_unit_id = this._merge_to_ref_unit[merge_node_id]
    const merge_ref_output_id = this._merge_to_ref_output[merge_node_id]

    delete this._merge_pin_count[mergeId]
    delete this._merge_input_count[mergeId]
    delete this._merge_output_count[mergeId]

    delete this._merge_to_pin[merge_node_id]
    delete this._merge_to_input[merge_node_id]
    delete this._merge_to_output[merge_node_id]
    delete this._merge_active_output_count[merge_node_id]
    delete this._merge_active_input_count[merge_node_id]
    delete this._merge_ref[merge_node_id]
    delete this._merge_to_ref_output[merge_node_id]
    delete this._merge[merge_node_id]
    delete this._merge_input[merge_node_id]
    delete this._merge_output[merge_node_id]
    delete this._pin_datum_tree[merge_node_id]

    if (merge_ref) {
      if (merge_ref_unit_id) {
        delete this._merge_to_ref_unit[merge_node_id]
        delete this._ref_unit_to_merge[merge_ref_unit_id]

        this._refresh_core_border_color(merge_ref_unit_id)

        for (const input_node_id in merge_to_input) {
          const { unitId } = segmentLinkPinNodeId(input_node_id)

          this._refresh_core_border_color(unitId)
          this._refresh_link_pin_link_color(input_node_id)
        }
      } else {
        delete this._merge_to_ref_output[merge_node_id]
        delete this._ref_output_to_merge[merge_ref_output_id]
      }
    }

    const has_merge_node = this._has_node(merge_node_id)

    if (has_merge_node) {
      this._sim_remove_pin_type(merge_node_id)
      this._sim_remove_merge_node(merge_node_id)
    }

    this._start_graph_simulation(LAYER_NONE)
  }

  private _sim_remove_merge_node = (merge_node_id: string): void => {
    // console.log('Graph', '_sim_remove_merge_node', merge_node_id)

    delete this._pin_node[merge_node_id]
    delete this._normal_node[merge_node_id]
    delete this._empty_merge_node[merge_node_id]
    delete this._merge_pin_name_count[merge_node_id]
    delete this._merge_name[merge_node_id]

    if (this._empty_merge_node[merge_node_id]) {
      this._remove_merge_empty(merge_node_id)
    }

    this._sim_remove_node(merge_node_id)

    this._remove_node_link_heap(merge_node_id)

    delete this._node_type[merge_node_id]
  }

  private __sim_remove_merge = (merge_id: string): void => {
    // console.log('Graph', '__sim_remove_merge', merge_id)
    const merge_node_id = getMergeNodeId(merge_id)
    this._sim_remove_merge(merge_node_id)
  }

  private _sim_remove_link = (link_id: string): void => {
    // console.log('Graph', '_sim_remove_link', link_id)

    const link = this._link[link_id]

    const { source_id, target_id } = link

    this._unlisten_link(link_id)

    const link_el = this._link_comp[link_id]

    this._zoom_comp.removeChild(link_el)

    const hover_pointer_id = this._link_id_hover_pointer_id[link_id]
    if (hover_pointer_id) {
      delete this._link_id_hover_pointer_id[link_id]
      delete this._pointer_id_hover_link_id[hover_pointer_id]
    }

    delete this._link_comp[link_id]
    delete this._link_base[link_id]
    delete this._link_base_area[link_id]
    delete this._link_text[link_id]
    delete this._link_text_value[link_id]
    delete this._link_text_path[link_id]
    delete this._link_marker_end[link_id]
    delete this._link_marker_start[link_id]
    delete this._link_force_count_k[link_id]

    const layer = Math.abs(this._link_layer[link_id])

    delete this._layer_link[layer][link_id]
    delete this._link_layer[link_id]

    this._remove_max_link_length_to_node_heap(source_id, link_id)
    this._remove_max_link_length_to_node_heap(target_id, link_id)

    delete this._link[link_id]

    this._dec_node_node_link_count(source_id, target_id)

    remove_link_from_graph(this._node_graph, source_id, target_id)

    this._rebuild_subgraph()
  }

  private _unlisten_node = (node_id: string): void => {
    const unwatch = this._node_unlisten[node_id]
    delete this._node_unlisten[node_id]
    unwatch()
  }

  private _unlisten_link = (link_id: string): void => {
    const unwatch = this._link_unlisten[link_id]
    delete this._link_unlisten[link_id]
    unwatch()
  }

  private __set_node_pressed = (
    node_id: string,
    pointerId: number,
    pressed: boolean
  ): void => {
    // console.log('Graph', '__set_node_pressed', node_id, pointerId, pressed)
    if (pressed) {
      this._pressed_node_pointer_count++
      this._node_pressed_count[node_id] = this._node_pressed_count[node_id] || 0
      this._node_pressed_count[node_id]++
      if (this._node_pressed_count[node_id] === 1) {
        this._pressed_node_count++
      }
      this._pressed_node_id_pointer_id[node_id] =
        this._pressed_node_id_pointer_id[node_id] || {}
      this._pressed_node_id_pointer_id[node_id][pointerId] = true
      this._pointer_id_pressed_node_id[pointerId] = node_id
    } else {
      this._pressed_node_pointer_count--
      this._node_pressed_count[node_id]--
      if (this._node_pressed_count[node_id] === 0) {
        this._pressed_node_count--
      }
      delete this._pressed_node_id_pointer_id[node_id][pointerId]
      if (this._node_pressed_count[node_id] === 0) {
        delete this._pressed_node_id_pointer_id[node_id]
      }
      delete this._pointer_id_pressed_node_id[pointerId]
    }
  }

  private _sim_remove_node = (node_id: string): void => {
    // console.log('Graph', '_sim_remove_node', node_id)

    this._node_count--

    const was_selected = this._selected_node_id[node_id]

    if (was_selected) {
      this.__deselect_node(node_id)
    }

    if (this._is_node_unlocked(node_id)) {
      this._lock_node(node_id)
    }

    const targeted_from = this._target_node[node_id]

    if (targeted_from) {
      for (const source_id of targeted_from) {
        this._remove_node_target(source_id)
      }
    }

    const target_to = this._node_target[node_id]

    if (target_to) {
      this._remove_node_target(node_id)
    }

    if (this._drag_along_node[node_id]) {
      const pointerId = this._drag_node_pointer_id[node_id]

      for (const drag_along_node_id of this._drag_along_node[node_id]) {
        if (this._drag_node_pointer_id[drag_along_node_id] === pointerId) {
          this._on_node_drag_end(drag_along_node_id)

          this._set_drag_node(drag_along_node_id, pointerId, false)
        }
      }
    }

    if (this._drag_node_id[node_id]) {
      const pointerId = this._drag_node_pointer_id[node_id]

      this._on_node_drag_end(node_id)

      this._set_drag_node(node_id, pointerId, false)
    }

    const drag_along_node_id = this._drag_along_source[node_id]
    if (drag_along_node_id) {
      this._remove_node_drag_along(drag_along_node_id, node_id)
    }

    if (this._collapse_node_id.has(node_id)) {
      this._stop_node_long_press_collapse(node_id)
    }

    if (this._pressed_node_id_pointer_id[node_id]) {
      for (const pointer_id in this._pressed_node_id_pointer_id[node_id]) {
        this.__set_node_pressed(node_id, Number.parseInt(pointer_id, 10), false)
      }

      delete this._pressed_node_id_pointer_id[node_id]
      delete this._node_pressed_count[node_id]
    }

    if (this._hover_node_id[node_id]) {
      delete this._hover_node_id[node_id]
      delete this._hover_node_pointer_count[node_id]

      for (let pointer_id in this._hover_node_id_pointer_id[node_id]) {
        delete this._pointer_id_hover_node_id[pointer_id]
      }

      delete this._hover_node_id_pointer_id[node_id]

      this._hover_node_count--
    }

    delete this._static_count[node_id]
    delete this._static_position[node_id]

    const node_charge = this._node_charge[node_id] ?? {}

    for (const other_node_id in node_charge) {
      delete this._node_charge[other_node_id][node_id]
    }

    delete this._node_charge[node_id]

    this._unlisten_node(node_id)

    const node_el = this._node_comp[node_id]

    if (this._ascend_node_dict[node_id]) {
      this._zoom_comp_alt.removeChild(node_el)
    } else {
      this._zoom_comp.removeChild(node_el)
    }

    delete this._ascend_node_dict[node_id]

    delete this._node[node_id]
    delete this._node_z[node_id]
    delete this._node_fixed[node_id]
    delete this._node_draggable[node_id]
    delete this._node_selection[node_id]
    delete this._node_comp[node_id]
    delete this._node_content[node_id]
    delete this._node_link_count[node_id]
    // delete this._node_graph[node_id]

    delete this._node_max_link_length_heap[node_id]
    delete this._node_link_heap_node[node_id]

    const compatible_node_id = this._compatible_node_id[node_id]

    if (compatible_node_id) {
      delete this._compatible_node_id[node_id]

      this._compatible_node_count--
    }

    const layer = Math.abs(this._node_layer[node_id])

    delete this._node_layer[node_id]
    delete this._layer_node[layer][node_id]

    remove_node_from_graph(this._node_graph, node_id)

    this._rebuild_subgraph()
  }

  private _rebuild_subgraph = () => {
    // console.count('_rebuild_subgraph')

    // PERF

    if (this._drag_count > 0) {
      for (const drag_node_id in this._drag_node_id) {
        this._stop_drag_node_static(drag_node_id)
      }
    }

    this._node_to_subgraph = {}
    this._subgraph_to_node = {}

    build_subgraph(
      this._node_graph,
      this._node_to_subgraph,
      this._subgraph_to_node,
      {}
    )

    if (this._drag_count > 0) {
      for (const drag_node_id in this._drag_node_id) {
        this._start_drag_node_static(drag_node_id)
      }
    }
  }

  private _drag_anchor_animation: Dict<Unlisten> = {}

  private _on_link_pointer_down = (
    link_id: string,
    event: UnitPointerEvent
  ): void => {
    // console.log('Graph', '_on_link_pointer_down', link_id)

    if (this._mode === 'none') {
      const node_id = this._link_id_to_node_id(link_id)

      if (node_id) {
        const { clientX, clientY, pointerId } = event

        const pointer_position = this._screen_to_world(clientX, clientY)

        const anchor_position = this._get_anchor_node_position(node_id)
        const anchor_node = this._get_anchor_node(node_id)

        if (this._is_link_pin_node_id(node_id)) {
          if (this._node_target[node_id]) {
            this._remove_node_target(node_id)

            if (this._is_link_pin_ref(node_id)) {
              this._refresh_pin_anchor_marker(node_id)
            }
          }

          if (this._is_link_pin_merged(node_id)) {
            this._remove_pin_or_merge(node_id)
          }
        } else if (this._is_int_node_id(node_id)) {
          if (this._int_to_node[node_id]) {
            const { type, pinId, subPinId } = segmentPlugNodeId(node_id)

            this._unplug_exposed_pin(type, pinId, subPinId)
          }
        }

        const u = pointUnitVector(anchor_position, pointer_position)
        const r = centerToSurfaceDistance(anchor_node, u)

        const start_position = addVector(
          anchor_position,
          resizeVector(u, r - PIN_RADIUS)
        )

        this._set_node_position(node_id, start_position)

        this._on_node_pointer_enter(node_id, event)
        this._on_node_pointer_down(node_id, event)
        this._drag_start(node_id, event)

        const node = this._node[node_id]

        node.hx -= pointer_position.x - start_position.x
        node.hy -= pointer_position.y - start_position.y

        this._drag_anchor_animation[node_id] = animateSimulate(
          this.$system,
          this._get_node_position(node_id),
          () => {
            const pointer_position = this._pointer_position[pointerId]

            const pointer_world_position = this._screen_to_world(
              pointer_position.x,
              pointer_position.y
            )

            return pointer_world_position
          },
          [
            ['x', ANIMATION_DELTA_THRESHOLD * 6],
            ['y', ANIMATION_DELTA_THRESHOLD * 6],
          ],
          ({ x, y }) => {
            this._set_node_position(node_id, { x, y })
          },
          () => {
            delete this._drag_anchor_animation[node_id]
          }
        )

        this._node_drag_max_distance[node_id] = MIN_DRAG_DROP_MAX_D + 1
      }
    }
  }

  private _link_id_to_node_id = (link_id: string): string | null => {
    if (isPinLinkId(link_id)) {
      const { pinNodeId } = segmentPinLinkId(link_id)

      return pinNodeId
    } else if (isDatumLinkId(link_id)) {
      const { datumNodeId } = segmentDatumLinkId(link_id)

      return datumNodeId
    } else if (isExternalLinkId(link_id)) {
      const { externalNodeId } = segmentExternalLinkId(link_id)

      return externalNodeId
    } else {
      return null
    }
  }

  private _on_link_pointer_enter = (
    link_id: string,
    event: UnitPointerEvent
  ) => {
    // console.log('Graph', '_on_link_pointer_enter', link_id)
    const { pointerId } = event

    this._pointer_id_hover_link_id[pointerId] = link_id
    this._link_id_hover_pointer_id[link_id] = pointerId

    const node_id = this._link_id_to_node_id(link_id)
    if (node_id) {
      this._on_node_pointer_enter(node_id, event)
    }
  }

  private _on_link_pointer_leave = (
    link_id: string,
    event: UnitPointerEvent
  ) => {
    // console.log('Graph', '_on_link_pointer_leave', link_id)
    const { pointerId } = event

    delete this._pointer_id_hover_link_id[pointerId]
    delete this._link_id_hover_pointer_id[link_id]

    const node_id = this._link_id_to_node_id(link_id)
    if (node_id) {
      if (this._pointer_id_pressed_node_id[pointerId] !== node_id) {
        this._on_node_pointer_leave(node_id, event)
      }
    }
  }

  private _on_link_long_click = (
    link_id: string,
    event: UnitPointerEvent
  ): void => {
    if (isPinLinkId(link_id)) {
      const { pinNodeId } = segmentPinLinkId(link_id)
      if (
        this._mode === 'remove' ||
        this._mode === 'change' ||
        this._mode === 'add' ||
        this._mode === 'data'
      ) {
        this._on_node_long_click(pinNodeId, event)
      }
    }
  }

  private _on_link_long_press = (
    link_id: string,
    event: UnitPointerEvent
  ): void => {
    if (isPinLinkId(link_id)) {
      const { pinNodeId } = segmentPinLinkId(link_id)

      if (
        this._mode === 'remove' ||
        this._mode === 'change' ||
        this._mode === 'add' ||
        this._mode === 'data'
      ) {
        this._on_node_long_press(pinNodeId, event)
      }
    }
  }

  private _on_link_click = (link_id: string, event: UnitPointerEvent): void => {
    if (isPinLinkId(link_id)) {
      const { pinNodeId } = segmentPinLinkId(link_id)
      if (
        this._mode === 'remove' ||
        this._mode === 'change' ||
        this._mode === 'add' ||
        this._mode === 'data'
      ) {
        this._on_node_click(pinNodeId, event)
      }
    } else if (isExternalLinkId(link_id)) {
      const { externalNodeId } = segmentExternalLinkId(link_id)
      this._on_node_click(externalNodeId, event)
    } else if (isDatumLinkId(link_id)) {
      const { datumNodeId } = segmentDatumLinkId(link_id)
      this._on_node_click(datumNodeId, event)
    }
  }

  private _on_component_resize_start = (
    unit_id: string,
    { direction, pointerId }: IOResizeEvent
  ) => {
    // console.log('Graph', '_on_component_resize_start', unit_id)

    this._resize_node_id_pointer_id[unit_id] = pointerId
    this._resize_pointer_id_node_id[pointerId] = unit_id
    this._resize_pointer_count++

    const cursor = `${direction}-resize`

    this._graph.$element.style.cursor = cursor

    if (this._selected_node_id[unit_id]) {
      for (let selected_node_id in this._selected_node_id) {
        if (
          isUnitNodeId(selected_node_id) &&
          this._is_unit_component(selected_node_id)
        ) {
          const size = this._get_node_size(selected_node_id)

          this._resize_start_component(selected_node_id, size)
        }
      }
    } else {
      const size = this._get_node_size(unit_id)

      this._resize_start_component(unit_id, size)
    }
  }

  private _is_layout_component_layer_visible = (
    sub_component_id: string
  ): boolean => {
    const visible = this._layout_path.includes(sub_component_id)

    return visible
  }

  private _is_layout_component_layer_current = (
    sub_component_id: string
  ): boolean => {
    const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)

    const current_layout_layer_id = this._get_current_layout_layer_id()

    const visible = parent_id === current_layout_layer_id

    return visible
  }

  private _on_component_resize = (
    unit_id: string,
    { dx, dy, dw, dh }: IOResizeEvent
  ): void => {
    // console.log('Graph', '_on_component_resize')
    if (this._drag_count > 0) {
      return
    }

    if (this._selected_node_id[unit_id]) {
      for (let selected_node_id in this._selected_node_id) {
        let should_resize = false

        const is_unit = isUnitNodeId(selected_node_id)

        if (is_unit) {
          const is_unit_component = this._is_unit_component(selected_node_id)

          if (is_unit_component) {
            if (this._tree_layout) {
              if (this._is_layout_component_layer_current(selected_node_id)) {
                should_resize = true
              }
            } else {
              should_resize = true
            }
          }
        }

        if (should_resize) {
          this._delta_resize_component(selected_node_id, dx, dy, dw, dh)
        }
      }
    } else {
      this._delta_resize_component(unit_id, dx, dy, dw, dh)
    }
  }

  private _on_component_resize_end = (unit_id: string, event: {}) => {
    // console.log('Graph', '_on_component_resize_end', unit_id, event)

    const cursor = 'inherit'

    this._graph.$element.style.cursor = cursor

    const pointer_id = this._resize_node_id_pointer_id[unit_id]

    delete this._resize_node_id_pointer_id[unit_id]
    delete this._resize_pointer_id_node_id[pointer_id]

    this._resize_pointer_count--

    if (this._selected_node_id[unit_id]) {
      for (let selected_node_id in this._selected_node_id) {
        if (
          isUnitNodeId(selected_node_id) &&
          this._is_unit_component(selected_node_id)
        ) {
          this._resize_end_component(selected_node_id)
        }
      }
    } else {
      this._resize_end_component(unit_id)
    }
  }

  private _get_datum_tree = (datum_node_id: string): TreeNode | undefined => {
    const { datumId } = segmentDatumNodeId(datum_node_id)

    return this.__get_datum_tree(datumId)
  }

  private __get_datum_tree = (datum_id: string): TreeNode | undefined => {
    const tree = this._datum_tree[datum_id]
    return tree
  }

  private _get_datum_value = (datum_node_id: string): string => {
    const tree = this._get_datum_tree(datum_node_id)

    const { value } = tree

    return value
  }

  private _is_datum_tree_valid = (datum_node_id: string): boolean => {
    const tree = this._get_datum_tree(datum_node_id)

    const [tree_] = _filterEmptyNodes(tree, getTree__cached)

    return _isValidValue(tree_, getTree__cached)
  }

  private _get_datum_tree_shape = (tree: TreeNode): Shape => {
    const { classes } = this.$system
    const { specs } = this.$props

    if (tree.type === TreeNodeType.Unit) {
      const bundle = evaluateBundleStr(tree.value, specs, classes)

      const { unit } = bundle

      if (isComponentId(weakMerge(specs, bundle.specs ?? {}), unit.id)) {
        return 'rect'
      } else {
        return 'circle'
      }
    } else {
      return 'rect'
    }
  }

  private _get_datum_tree_size = (tree: TreeNode): Size => {
    const {
      classes,
      api: {
        text: { measureText },
      },
    } = this.$system

    const { specs } = this.$props

    if (tree.type === TreeNodeType.Unit) {
      const bundle = evaluateBundleStr(tree.value, specs, this.$system.classes)

      const { unit } = bundle

      const r =
        getSpecRadius(
          weakMerge(specs, bundle.specs ?? {}),
          classes,
          unit.id,
          true
        ) - 1.5

      return {
        width: 2 * r,
        height: 2 * r,
      }
    } else {
      let { width, height } = getDatumSize(tree, DATUM_FONT_SIZE, measureText)

      const overflow = width > DATUM_MAX_WIDTH || height > DATUM_MAX_HEIGHT

      const overflowX = overflow ? 6 : 0
      const overflowY = overflow ? 6 : 0

      width = Math.min(width, DATUM_MAX_WIDTH) + overflowY
      height = Math.min(height, DATUM_MAX_HEIGHT) + overflowX

      return { width, height }
    }
  }

  private _on_datum_change = (
    datum_id: string,
    { data }: { data: TreeNode }
  ) => {
    // console.log('Graph', '_on_datum_change', datum_id, data)

    if (datum_id === this._edit_datum_id) {
      this._edit_datum_committed = false
      this._edit_datum_never_changed = false
    }

    this._sim_set_datum(datum_id, data)
  }

  private _focus_datum = (datum_id: string, path: number[]): void => {
    // console.log('Graph', '_focus_datum')

    this._datum_to_be_focused = true

    const datum_node_id = getDatumNodeId(datum_id)
    const datum = this._datum[datum_node_id]

    if (datum && datum instanceof Datum) {
      datum.focusChild(path, { preventScroll: true })
    }
  }

  private _blur_datum = (datum_node_id: string, path: number[] = []): void => {
    // console.log('Graph', '_blur_datum', datum_node_id, path)

    const datum = this._datum[datum_node_id]

    if (datum && datum instanceof Datum) {
      datum.blurChild(path)
    }
  }

  private _for_each_unit_pin = (
    unit_id: string,
    callback: (pin_node_id: string, type: IO, pin_id: string) => void,
    include_self: boolean = false
  ) => {
    const spec = this._get_unit_spec(unit_id)

    this._for_each_spec_input(spec, (input_id) => {
      const input_node_id = getInputNodeId(unit_id, input_id)

      callback(input_node_id, 'input', input_id)
    })
    this._for_each_spec_output(spec, (output_id) => {
      const output_node_id = getOutputNodeId(unit_id, output_id)

      callback(output_node_id, 'output', output_id)
    })

    if (include_self) {
      const self_pin_node_id = getSelfPinNodeId(unit_id)

      callback(self_pin_node_id, 'output', SELF)
    }
  }

  private _for_each_unit_input = (
    unit_id: string,
    callback: (input_node_id: string, input_id: string) => void
  ) => {
    const spec = this._get_unit_spec(unit_id)

    this._for_each_spec_input(spec, (input_id: string) => {
      const input_node_id = getInputNodeId(unit_id, input_id)

      callback(input_node_id, input_id)
    })
  }

  private _for_each_unit_ref_input = (
    unit_id: string,
    callback: (input_node_id: string, input_id: string) => void
  ) => {
    this._for_each_unit_input(unit_id, (input_node_id, input_id) => {
      if (this._is_link_pin_ref(input_node_id)) {
        callback(input_node_id, input_id)
      }
    })
  }

  private _for_each_unit_merged_pin = (
    unit_id: string,
    callback: (input_node_id: string, input_id: string) => void
  ) => {}

  private _for_each_merge_pin = (
    merge_id: string,
    callback: (unit_id: string, type: IO, pin_id: string) => void
  ) => {
    const merge = this._spec_get_merge(merge_id)

    forEachPinOnMerge(merge, callback)
  }

  private _for_each_spec_id_pin = (
    id: string,
    callback: (type: IO, pin_id: string) => void
  ) => {
    this._for_each_spec_id_input(id, (input_id) => {
      callback('input', input_id)
    })
    this._for_each_spec_id_output(id, (output_id) => {
      callback('output', output_id)
    })
  }

  private _for_each_spec_id_input = (
    id: string,
    callback: (pin_id: string) => void
  ) => {
    const { getSpec } = this.$props

    const spec = getSpec(id)

    return this._for_each_spec_input(spec, callback)
  }

  private _for_each_spec_input = (
    spec: Spec,
    callback: (input_id: string) => void
  ) => {
    const { inputs = {} } = spec
    for (let input_id in inputs) {
      callback(input_id)
    }
  }

  private _for_each_spec_id_output = (
    id: string,
    callback: (output_id: string) => void
  ) => {
    const { getSpec } = this.$props

    const spec = getSpec(id)

    const { outputs = {} } = spec

    for (let output_id in outputs) {
      callback(output_id)
    }
  }

  private _for_each_spec_output = (
    spec: Spec,
    callback: (pin_id: string) => void
  ) => {
    const { outputs = {} } = spec
    for (let output_id in outputs) {
      callback(output_id)
    }
  }

  private _for_each_unit_output = (
    unit_id: string,
    callback: (pin_node_id: string, output_id: string) => void
  ) => {
    const spec = this._get_unit_spec(unit_id)
    this._for_each_spec_output(spec, (output_id: string) => {
      const output_node_id = getOutputNodeId(unit_id, output_id)
      callback(output_node_id, output_id)
    })
  }

  private _for_each_visible_unit_output = (
    unit_id: string,
    callback: (pin_node_id: string, output_id: string) => void
  ) => {
    this._for_each_unit_output(unit_id, (output_node_id, input_id) => {
      if (!this._spec_is_link_pin_ignored(output_node_id)) {
        callback(output_node_id, input_id)
      }
    })
  }

  private _set_datum = (datum_id: string, tree: TreeNode) => {
    this._sim_set_datum(datum_id, tree)
  }

  private _sim_set_datum = (datum_id: string, tree: TreeNode) => {
    const { classes } = this.$system
    const { specs } = this.$props

    this._datum_tree[datum_id] = tree
    const datum_node_id = getDatumNodeId(datum_id)

    let datum = this._datum[datum_node_id]

    if (tree.type === TreeNodeType.Unit) {
      datum = datum as ClassDatum

      const id = idFromUnitValue(tree.value, specs, classes)

      datum.setProp('id', id)
      datum.dispatchEvent('datumchange', { data: tree })
    } else {
      this._refresh_datum_color(datum_node_id)
    }

    this._refresh_datum_size(datum_node_id, tree)
    this._refresh_compatible()
  }

  private _edit_datum_just_blurred: boolean = false
  private _edit_datum_never_changed: boolean = true

  private _unlocked_datum: Set<string> = new Set()

  private _unlock_datum = (datum_node_id: string): void => {
    this._unlocked_datum.add(datum_node_id)

    this._disable_datum_overlay(datum_node_id)

    this._refresh_datum_overflow(datum_node_id)

    this._unlock_node(datum_node_id)
  }

  private _refresh_datum_overflow = (datum_node_id: string) => {
    const datum = this._datum_container[datum_node_id]

    if (this._is_datum_unlocked(datum_node_id)) {
      datum.$element.style.overflow = 'visible'

      const tree = this._get_datum_tree(datum_node_id)

      const datum_size = this._get_datum_tree_size(tree)

      if (datum_size.width > DATUM_MAX_WIDTH) {
        datum.$element.style.overflowX = 'auto'
      }
      if (datum_size.height >= DATUM_MAX_HEIGHT) {
        datum.$element.style.overflowY = 'auto'
      }
    } else {
      datum.$element.style.overflowX = 'hidden'
      datum.$element.style.overflowY = 'hidden'
    }
  }

  private _lock_datum = (datum_node_id: string): void => {
    this._unlocked_datum.delete(datum_node_id)

    this._enable_datum_overlay(datum_node_id)

    this._refresh_datum_overflow(datum_node_id)

    this._lock_node(datum_node_id)
  }

  private _unlocked_node: Set<string> = new Set()

  private _unlock_node = (node_id: string): void => {
    this._unlocked_node.add(node_id)

    this._refresh_node_selection(node_id)
  }

  private _lock_node = (node_id: string): void => {
    this._unlocked_node.delete(node_id)

    this._refresh_node_selection(node_id)
  }

  private _is_node_unlocked = (node_id: string): boolean => {
    return this._unlocked_node.has(node_id)
  }

  private _lock_all_datum = (): void => {
    for (const unlocked_datum_node_id of new Set(this._unlocked_datum)) {
      this._lock_datum(unlocked_datum_node_id)
    }
  }

  private _is_datum_unlocked = (datum_node_id: string): boolean => {
    return this._unlocked_datum.has(datum_node_id)
  }

  private _should_prevent_datum_commit = () => {
    return (
      this._edit_datum_committed ||
      this._edit_datum_never_changed ||
      this._edit_datum_last_manually_committed
    )
  }

  private _on_datum_blur = (
    datum_id: string,
    { data, path }: { data: TreeNode; path: number[] }
  ) => {
    // console.log('Graph', '_on_datum_blur', datum_id, data, path)

    const {
      api: {
        window: { setTimeout },
      },
    } = this.$system

    const datum_node_id = getDatumNodeId(datum_id)

    if (this._edit_datum_id === datum_id) {
      const edit_datum_id = this._edit_datum_id

      this._edit_datum_id = null
      this._edit_datum_node_id = null
      this._edit_datum_path = null

      const prevent = this._should_prevent_datum_commit()

      this._lock_datum(datum_node_id)

      const [tree] = _filterEmptyNodes(data, getTree__cached)

      const datum_anchor_node_id = this._get_node_anchor_node_id(datum_node_id)

      this._sim_set_datum_value(
        edit_datum_id,
        datum_node_id,
        datum_anchor_node_id,
        tree.value,
        tree
      )

      this._commit_data_value(edit_datum_id, tree, prevent)

      if (removeWhiteSpace(tree.value) === '') {
        if (this._has_node(datum_node_id)) {
          this._sim_remove_datum(datum_node_id)
        }
      }

      this._edit_datum_just_blurred = true

      setTimeout(() => {
        this._edit_datum_just_blurred = false
      }, 0)
    }

    if (!this._disabled && this._control_lock) {
      this._enable_crud()
      this._enable_keyboard()
    }
  }

  private _commit_data_value = (
    datum_id: string,
    tree: TreeNode,
    prevent: boolean = false
  ) => {
    // console.log('Graph', '_commit_data_value', datum_id, tree)

    this._edit_datum_committed = true

    const datum_node_id = getDatumNodeId(datum_id)

    if (this._dispatch_add_datum_on_commit) {
      this._dispatch_action(makeAddDatumAction(datum_id, tree.value))
    }

    const datum_pin_node_id = this._datum_to_pin[datum_node_id]
    const datum_plug_node_id = this._datum_to_plug[datum_node_id]

    if (datum_pin_node_id) {
      if (this._is_output_pin_node_id(datum_pin_node_id)) {
        if (!prevent) {
          this._remove_pin_datum_link(datum_node_id)
        }
      } else {
        const { specs } = this.$props

        const pin_type = this._pin_type_of_kind(datum_pin_node_id, 'input')

        if (_isValidTree(tree) && _isTypeMatch__cached(specs, tree, pin_type)) {
          if (!prevent) {
            this.set_pin_data(datum_pin_node_id, tree.value)
          } else {
            if (!this._is_pin_active(datum_pin_node_id)) {
              this._sim_remove_datum(datum_node_id)
            }
          }
        } else {
          if (tree.value === '') {
            this._pod_remove_pin_datum(datum_pin_node_id)
          } else {
            this._remove_pin_datum_link(datum_node_id)
          }
        }
      }
    } else if (datum_plug_node_id) {
      if (this._is_datum_plug_type_match(datum_node_id, datum_plug_node_id)) {
        if (!prevent) {
          this._set_plug_data(datum_plug_node_id, tree.value)
        }
      } else {
        this._remove_plug_set_datum_link(datum_plug_node_id)
      }
    }
  }

  private _on_datum_focus = (
    datum_id: string,
    { data, path }: { data: any; path: number[] }
  ) => {
    // console.log('Graph', '_on_datum_focus', datum_id)

    const datum_node_id = getDatumNodeId(datum_id)

    if (!this._is_node_selected(datum_node_id)) {
      this._deselect_all()
    }

    if (!this._is_node_unlocked(datum_node_id)) {
      this._unlock_datum(datum_node_id)
    }

    this._edit_datum_id = datum_id
    this._edit_datum_node_id = datum_node_id
    this._edit_datum_path = path
    this._edit_datum_never_changed = true

    this._refresh_node_selection(datum_node_id)

    this._disable_crud()
    this._disable_keyboard()
  }

  private _sim_remove_datum = (datum_node_id: string): void => {
    // console.log('Graph', '_sim_remove_datum', datum_node_id)

    const { datumId } = segmentDatumNodeId(datum_node_id)

    const unlisten = this._datum_unlisten[datumId]

    unlisten()

    delete this._datum_unlisten[datumId]

    if (this._is_datum_unlocked(datum_node_id)) {
      this._lock_datum(datum_node_id)
    }

    if (this._edit_datum_node_id === datum_node_id) {
      this._edit_datum_node_id = null
      this._edit_datum_id = null
      this._edit_datum_path = null

      this._enable_crud()
      this._enable_keyboard()

      this.focus()
    }

    const datum_pin_node_id = this._datum_to_pin[datum_node_id]

    if (datum_pin_node_id) {
      this._sim_remove_pin_datum_link(datum_node_id)
    }

    const datum_plug = this._datum_to_plug[datum_node_id]

    if (datum_plug) {
      const { type, pinId, subPinId } = segmentPlugNodeId(datum_plug)

      this._sim_remove_plug_datum_link(type, pinId, subPinId)
    }

    delete this._data_node[datum_node_id]

    delete this._node_type[datum_node_id]

    this._sim_remove_node(datum_node_id)

    delete this._visible_data_node[datum_node_id]
    delete this._hidden_data_node[datum_node_id]
    delete this._linked_data_node[datum_node_id]
    delete this._visible_linked_data_node[datum_node_id]
    delete this._visible_unlinked_data_node[datum_node_id]
    delete this._unlinked_data_node[datum_node_id]

    delete this._invalid_datum_data[datum_node_id]
    delete this._invalid_datum_node_id[datum_node_id]

    delete this._datum[datum_node_id]
    delete this._datum_container[datum_node_id]
    delete this._datum_area[datum_node_id]
    delete this._datum_overlay[datum_node_id]

    delete this._datum_tree[datumId]

    if (datum_pin_node_id) {
      this._refresh_node_color(datum_pin_node_id)
    }

    if (!datum_pin_node_id) {
      this._dispatch_data_removed(datumId)
    }

    this._start_graph_simulation(LAYER_DATA_LINKED)
  }

  private _remove_unit_merges = (unit_id: string): Dict<string> => {
    return this._remove_unit_merges__predicated(unit_id, () => true)
  }

  private _remove_unit_merges__predicated = (
    unit_id: string,
    predicate: (merge_node_id: string, pin_node_id: string) => boolean
  ): Dict<string> => {
    const anchor_node_id: Dict<string> = {}

    this._for_each_unit_pin(unit_id, (pin_node_id: string) => {
      const merge_node_id = this._pin_to_merge[pin_node_id]

      if (merge_node_id) {
        if (predicate(pin_node_id, merge_node_id)) {
          const a_id = this._remove_pin_or_merge(pin_node_id)

          anchor_node_id[pin_node_id] = a_id

          this._refresh_link_pin_color(pin_node_id)
        }
      }
    })

    return anchor_node_id
  }

  private _sim_remove_unit_merges = (unit_id: string): Dict<string> => {
    const anchor_node_id: Dict<string> = {}

    this._for_each_unit_pin(unit_id, (pin_node_id: string) => {
      const merge_node_id = this._pin_to_merge[pin_node_id]

      if (merge_node_id) {
        const a_id = this._sim_remove_pin_or_merge(pin_node_id)

        anchor_node_id[pin_node_id] = a_id

        this._refresh_link_pin_color(pin_node_id)
      }
    })

    if (this._ref_unit_to_merge[unit_id]) {
      const self_pin_node_id = getSelfPinNodeId(unit_id)

      this._sim_remove_pin_or_merge(self_pin_node_id)
    }

    return anchor_node_id
  }

  private _spec_remove_unit_merges = (unit_id: string): void => {
    this._for_each_unit_pin(
      unit_id,
      (pin_node_id: string, type: IO, pin_id: string) => {
        this._spec_remove_pin_or_merge(pin_node_id)
      },
      true
    )
  }

  private _state_remove_unit_merges = (unit_id: string) => {
    this._sim_remove_unit_merges(unit_id)
    this._spec_remove_unit_merges(unit_id)
  }

  private _state_remove_unit_plugs__template = (
    unit_id: string,
    unit_plugs: GraphUnitPlugs
  ) => {
    forIOObjKV(
      unit_plugs,
      (type, unitPinId, { pinId, subPinId, type: type_ }) => {
        this._state_unplug_exposed_pin(type_, pinId, subPinId)
      }
    )
  }

  private _state_remove_unit_plugs = (unit_id: string) => {
    const unit_plugs = this._get_unit_plugs(unit_id)

    this._state_remove_unit_plugs__template(unit_id, unit_plugs)
  }

  public remove_unit = (unit_id: string) => {
    this._remove_unit(unit_id)

    this._dispatch_action_remove_unit(unit_id)
  }

  private _remove_unit = (unit_id: string, emit: boolean = true) => {
    // console.log('Graph', '_remove_unit', unit_id)

    const is_component = this._is_unit_component(unit_id)

    emit && this._pod_remove_unit(unit_id, is_component)
    this._state_remove_unit(unit_id)
  }

  public state_remove_unit = (unit_id: string) => {
    this._state_remove_unit(unit_id)
  }

  private _state_remove_unit = (
    unit_id: string,
    unregister: boolean = true,
    deep: boolean = true
  ) => {
    // console.log('Graph', '_state_remove_unit', unit_id)

    this._sim_remove_unit(unit_id)
    this._spec_remove_unit(unit_id, unregister, deep)
  }

  private _spec_remove_unit = (
    unitId: string,
    unregister: boolean = true,
    deep: boolean = true
  ) => {
    // console.log('Graph', '_spec_remove_unit', unitId, unregister, deep)

    const unit = this._get_unit(unitId)

    if (this._is_unit_component(unitId)) {
      this._spec_remove_component(unitId)
    }

    if (!parent) {
      if (unregister) {
        this._unregister_unit(unit.id, deep)
      }
    }

    removeUnit({ unitId }, this._spec)

    this._spec_update_metadata_complexity()
  }

  private _spec_remove_component = (unit_id: string) => {
    // console.log('Graph', '_spec_remove_component', unit_id)

    const parent_id = this._spec_get_sub_component_parent_id(unit_id)

    this._spec_remove_component_children(unit_id, parent_id)

    removeSubComponent({ unitId: unit_id }, this._spec.component || {})

    if (parent_id) {
      removeSubComponentChild(
        { subComponentId: parent_id, childId: unit_id },
        this._spec.component || {}
      )
    } else {
      removeRoot({ childId: unit_id }, this._spec.component || {})
    }

    delete this._layout_node[unit_id]
    delete this._layout_target_node[unit_id]
    delete this._layout_layer[unit_id]

    this._refresh_tree_sub_component_index()
    this._refresh_layout_node_target_position(parent_id)

    if (this._tree_layout) {
      this._move_all_layout_node_target_position(parent_id)
    }
  }

  private _pod_remove_unit = (unitId: string, is_component: boolean): void => {
    const { fork, bubble } = this.$props

    const take = false

    this._pod.$removeUnit({ unitId, fork, take, bubble })

    if (is_component) {
      this._disconnect_sub_component(unitId)
    }
  }

  private _pod_remove_unit__template = (
    unitId: string,
    is_component: boolean,
    { removeUnit }: { removeUnit(unitId: string): void }
  ): void => {
    const { fork, bubble } = this.$props

    this._pod.$removeUnit({ unitId, fork, bubble })

    if (is_component) {
      this._disconnect_sub_component(unitId)
    }
  }

  private _sim_graph_unit_remove_pin = (pin_node_id: string): void => {
    // console.log('Graph', '_sim_graph_unit_remove_pin', pin_node_id)

    const { type, unitId, pinId } = segmentLinkPinNodeId(pin_node_id)

    const opposite_type = opposite(type)

    const int_node_id = this._pin_to_int[type][pin_node_id]
    const opposite_int_node_id = this._pin_to_int[opposite_type][pin_node_id]

    if (int_node_id) {
      const { type, pinId, subPinId } = segmentPlugNodeId(int_node_id)

      this._sim_unplug_exposed_pin(type, pinId, subPinId)
    }

    if (opposite_int_node_id) {
      const { type, pinId, subPinId } = segmentPlugNodeId(opposite_int_node_id)

      this._sim_unplug_exposed_pin(type, pinId, subPinId)
    }

    const output_ref_merge_node_id = this._ref_output_to_merge[pin_node_id]
    if (output_ref_merge_node_id) {
      this._sim_remove_merge(output_ref_merge_node_id)
    }

    const datum_node_id = this._pin_to_datum[pin_node_id]
    if (datum_node_id) {
      this._sim_remove_datum(datum_node_id)

      this._mem_remove_pin_datum_tree_if(pin_node_id)
    }

    const pin_datum_tree = this._pin_datum_tree[pin_node_id]
    if (pin_datum_tree) {
      this._dec_unit_pin_active(unitId)

      delete this._pin_datum_tree[pin_node_id]
    }

    const merge_node_id = this._pin_to_merge[pin_node_id]
    if (merge_node_id) {
      this._sim_remove_pin_or_merge(pin_node_id)
    }

    const is_self_output_pin = isSelfPin(type, pinId)

    if (is_self_output_pin) {
      //
    } else {
      this._sim_remove_link_pin_link(pin_node_id)
    }

    if (!this._is_link_pin_merged(pin_node_id) && !is_self_output_pin) {
      this._sim_remove_link_pin_pin(pin_node_id)
    }

    if (this._node_link_heap[pin_node_id]) {
      this._remove_node_link_heap(pin_node_id)
    }

    this._start_graph_simulation(LAYER_NONE)
  }

  private _sim_remove_component = (
    unit_id: string,
    remove_roots: boolean,
    pull_from_root: boolean = true,
    destroy: boolean = true
  ): void => {
    // console.log('Graph', '_sim_remove_component', unit_id, remove_roots)

    const sub_component = this._get_sub_component(unit_id)

    const parent_id = this._spec_get_sub_component_parent_id(unit_id)
    const children = clone(this._spec_get_sub_component_children(unit_id))

    const animating = this._is_sub_component_animating(unit_id)

    this._cancel_parent_animation(unit_id)
    this._cancel_layout_core_animation(unit_id)
    this._cancel_enter_sub_component_animation(unit_id)
    this._cancel_leave_sub_component_animation(unit_id)

    if (this._tree_layout) {
      if (children.length > 0) {
        for (const child_id of children) {
          this._measure_sub_component_base(child_id)
        }
      }
    }

    if (this._search_unit_id === unit_id) {
      //
    } else {
      if (this._in_component_control) {
        if (remove_roots) {
          if (!animating) {
            this._displace_sub_component(unit_id)
          }
        }
      }

      if (pull_from_root) {
        this.__move_sub_component(
          unit_id,
          (parent_id) => {
            const parent = this._get_sub_component(parent_id)

            parent.pullParentRoot(sub_component)
          },
          () => {
            this._component.pullRoot(sub_component)
          }
        )
      }
    }

    if (this._animating_sub_component_base_id.has(unit_id)) {
      this._unplug_sub_component_base_frame(unit_id)

      this._animating_sub_component_base_id.delete(unit_id)
    }

    if (this._tree_layout) {
      if (children.length > 0) {
        const current_layer = this._get_current_layout_layer_id()

        const current_slot = 'default'

        for (const child_id of children) {
          this._remove_sub_component_child(unit_id, child_id)
          this._remove_sub_component_root_base(child_id)

          this._mem_push_sub_component(current_layer, child_id, current_slot)
        }

        this._animate_layout_sub_component_remove_children(
          unit_id,
          'default',
          children,
          true,
          () => {
            this._end_layout_sub_component_transfer_children_animation(
              unit_id,
              'default',
              children
            )

            for (const child_id of children) {
              this._append_sub_component_base(child_id)
              this._enter_sub_component_frame(child_id)
            }
          }
        )
      }
    }

    if (this._is_sub_component_fullwindow(unit_id)) {
      // this._decouple_sub_component(unit_id)

      this._fullwindow_component_set.delete(unit_id)

      pull(this._fullwindow_component_ids, unit_id)
    }

    this._sim_move_out_sub_component_layout_children(unit_id, parent_id)

    if (remove_roots) {
      if (!this._tree_layout) {
        this._sim_move_out_sub_component_children(unit_id, parent_id)
      }

      this._sim_remove_sub_component_roots(unit_id)
    }

    this._sim_remove_layout_core(unit_id)

    this._mem_remove_component(unit_id)

    if (destroy && sub_component) {
      sub_component.destroy()
    }
  }

  private _refresh_pin_anchor_marker(pin_node_id: string) {
    const anchor_node_id = this._get_node_anchor_node_id(pin_node_id)

    this._refresh_link_pin_marker(pin_node_id, anchor_node_id)
  }

  private _mem_remove_component(unit_id: string): void {
    // console.log('Graph', '_mem_remove_component', unit_id)

    this._unit_component_count--

    delete this._layout_component_count[unit_id]
    delete this._layout_sub_component_parent[unit_id]

    if (this._layout_core_abort_animation[unit_id]) {
      this._layout_core_abort_animation[unit_id]()

      delete this._layout_core_abort_animation[unit_id]

      this._layout_core_animation_count--
    }

    const selected = this._selected_component[unit_id]

    if (selected) {
      this._selected_component_count--
    }

    delete this._selected_component[unit_id]
    delete this._component_nodes[unit_id]
    delete this._core_component_frame_context[unit_id]
    delete this._core_component_resize[unit_id]
    delete this._core_component_overlay[unit_id]
    delete this._core_component_frame[unit_id]

    delete this._resize_component_start_size[unit_id]

    delete this._sub_component[unit_id]
  }

  private _sim_remove_sub_component_roots = (unit_id: string) => {
    const sub_component = this._get_sub_component(unit_id)

    if (sub_component) {
      if (
        this._abort_sub_component_enter_base_animation[unit_id] ||
        this._abort_sub_component_leave_base_animation[unit_id]
      ) {
        const base = this._get_sub_component_base(unit_id)

        this._unplug_base_frame(unit_id, base)
      }

      const sub_component_parent_id =
        this._spec_get_sub_component_parent_id(unit_id)

      const parent_sub_component = this._get_sub_component(
        sub_component_parent_id
      )

      if (sub_component_parent_id) {
        if (parent_sub_component.hasParentRoot(sub_component)) {
          parent_sub_component.pullParentRoot(sub_component)
        }
      } else {
        if (this._component.hasRoot(sub_component)) {
          this._component.pullRoot(sub_component)
        }
      }

      this._component.removeSubComponent(unit_id)

      sub_component.destroy()
    }
  }

  private _sim_remove_layout_core = (unit_id: string): void => {
    // console.log('Graph', '_sim_remove_layout_core', unit_id)

    const parent_id = this._spec_get_sub_component_parent_id(unit_id)
    const children = this._spec_get_sub_component_children(unit_id)

    const layout_core = this._layout_core[unit_id]

    const parent_layout_layer = this._ensure_parent_layout_layer(unit_id)
    const layout_layer = this._get_layout_layer(unit_id)

    if (parent_layout_layer.children.$children.includes(layout_core)) {
      parent_layout_layer.children.removeChild(layout_core)
    }

    if (layout_layer) {
      if (parent_layout_layer.layers.$children.includes(layout_layer.layer)) {
        parent_layout_layer.layers.removeChild(layout_layer.layer)
      }
    }

    const layout_parent_id = this._layout_sub_component_parent[unit_id] || null
    if (layout_parent_id) {
      this._refresh_component_children_counter_up(
        layout_parent_id,
        -(1 + (this._layout_component_count[unit_id] || 0))
      )
    }

    delete this._layout_core[unit_id]
  }

  private _cancel_graph_core_size_animation = (unit_id: string) => {
    const abort = this._abort_graph_node_transition[unit_id]

    if (abort) {
      abort()

      delete this._abort_graph_node_transition[unit_id]
    }
  }

  private _sim_remove_unit_core = (unit_id: string) => {
    // console.log('Graph', '_sim_remove_core', unit_id)

    this._cancel_graph_core_size_animation(unit_id)

    const unit_self_output_id = getSelfPinNodeId(unit_id)

    const ref_merge_node_id = this._ref_unit_to_merge[unit_id]

    if (ref_merge_node_id) {
      this._sim_remove_pin_or_merge(unit_self_output_id)
    }

    const unit_self_output_outer_plug_spec = this._spec_get_pin_node_plug_spec(
      'output',
      unit_self_output_id
    )

    const { pinId, subPinId } = unit_self_output_outer_plug_spec ?? {}

    if (pinId && subPinId) {
      this._sim_unplug_exposed_pin('output', pinId, subPinId)
    }

    delete this._node_type[unit_self_output_id]

    if (this._err[unit_id] !== undefined) {
      this._sim_remove_unit_err(unit_id)
    }

    delete this._node_type[unit_id]

    this._sim_remove_node(unit_id)

    this._remove_node_link_heap(unit_id)

    delete this._core[unit_id]
    delete this._core_content[unit_id]
    delete this._core_area[unit_id]
    delete this._core_name[unit_id]
    delete this._core_description[unit_id]
    delete this._core_icon[unit_id]
    delete this._core_prevent_selection_unlisten[unit_id]

    delete this._normal_node[unit_id]

    const core_graph = this._subgraph_cache[unit_id]

    if (core_graph) {
      if (this._subgraph_unit_id === unit_id) {
        this._leave_subgraph()
      }

      this._subgraph.removeChild(core_graph)

      core_graph.destroy()
    }

    delete this._subgraph_cache[unit_id]
    delete this._subgraph_pod_cache[unit_id]

    delete this._unit_node[unit_id]

    delete this._err[unit_id]

    this._unit_count--

    if (this._minimap) {
      this._minimap.tick()
    }

    if (this._unit_count === 0) {
      if (this._minimap_screen) {
        this._minimap_screen.$element.style.display = 'none'
      }
    }

    if (this._abort_graph_node_transition[unit_id]) {
      const unlinsten = this._abort_graph_node_transition[unit_id]

      unlinsten()
    }
  }

  private _sim_remove_unit_pins = (unit_id: string): void => {
    this._for_each_unit_pin(unit_id, (pin_node_id: string) => {
      this._sim_graph_unit_remove_pin(pin_node_id)

      delete this._node_type[pin_node_id]
    })

    const self_pin_node_id = getSelfPinNodeId(unit_id)

    this._sim_graph_unit_remove_pin(self_pin_node_id)
  }

  private _sim_remove_unit = (unit_id: string): void => {
    // console.log('Graph', '_sim_remove_unit', unit_id)

    if (this._is_unit_component(unit_id)) {
      this._sim_remove_component(unit_id, true)
    }

    this._sim_remove_unit_body(unit_id)
  }

  private _sim_remove_unit_body = (unit_id: string) => {
    this._sim_remove_unit_pins(unit_id)
    this._sim_remove_unit_core(unit_id)
  }

  private _remove_nodes = (
    node_ids: string[],
    remove_data: boolean = false
  ) => {
    // console.log('Graph', '_remove_nodes', node_ids)

    const { fork, bubble } = this.$props

    const {
      unit_ids,
      merge_node_ids,
      link_pin_node_ids,
      exposed_node_ids,
      datum_node_ids,
      err_node_ids,
    } = this._decant_node_ids(node_ids)

    this._flush_debugger()

    let removed_exposed_sub_pin_id: IOOf<Dict<Set<string>>> = emptyIO({}, {})
    let removed_exposed_pin_id: { input: Set<string>; output: Set<string> } = {
      input: new Set(),
      output: new Set(),
    }

    const actions = []

    const removed_unit = new Set<string>()
    const removed_merge = new Set<string>()
    const removed_plugs: IOOf<Dict<string>> = emptyIO({}, {})

    for (const exposed_pin_node_id of exposed_node_ids) {
      const { type, pinId, subPinId } = segmentPlugNodeId(exposed_pin_node_id)

      deepSet(removed_plugs, [type, pinId, subPinId], true)

      if (!removed_exposed_pin_id[type].has(pinId)) {
        const pin_count = this._get_exposed_pin_set_count(exposed_pin_node_id)

        if (pin_count === 1 || pin_count === 0) {
          removed_exposed_pin_id[type].add(pinId)

          const pin = this._get_pin(type, pinId)

          actions.push(makeCoverPinSetAction(type, pinId, pin))
        } else {
          if (
            !removed_exposed_sub_pin_id[type][pinId] ||
            !removed_exposed_sub_pin_id[type][pinId].has(subPinId)
          ) {
            removed_exposed_sub_pin_id[type][pinId] =
              removed_exposed_sub_pin_id[type][pinId] || new Set()
            removed_exposed_sub_pin_id[type][pinId].add(subPinId)

            const sub_pin_spec = this._get_exposed_sub_pin_spec(
              type,
              pinId,
              subPinId
            )

            actions.push(
              makeCoverPinAction(type, pinId, subPinId, sub_pin_spec)
            )
          }
        }
      }
    }

    for (const merge_node_id of merge_node_ids) {
      removed_merge.add(merge_node_id)

      actions.push(this._make_remove_merge_action(merge_node_id))

      this._dispatch_action_remove_merge(merge_node_id)
    }

    for (const unit_id of unit_ids) {
      removed_unit.add(unit_id)

      if (this._search_unit_id === unit_id) {
        this._mem_remove_search_unit_id()

        this._hide_search()
      } else {
        const is_component = this._is_unit_component(unit_id)

        actions.push(this._make_remove_unit_action(unit_id))

        if (is_component) {
          this._disconnect_sub_component(unit_id)
        }

        this._dispatch_action_remove_unit(unit_id)
      }
    }

    const push_remove_datum_bulk_action = (
      datum_node_id,
      datum_pin_node_id,
      datum_plug_node_id
    ) => {
      this._pod_remove_datum__template(
        datum_node_id,
        datum_pin_node_id,
        datum_plug_node_id,
        {
          takeInput(data) {
            actions.push(wrapTakeInputAction(data))
          },
          removeMergeData(data) {
            actions.push(wrapRemoveMergeDataAction(data))
          },
          removeUnitPinData(data) {
            actions.push(wrapRemoveUnitPinDataAction(data))
          },
          removePinData(data) {
            actions.push(wrapRemovePinDataAction(data))
          },
        }
      )
    }

    for (const datum_node_id of datum_node_ids) {
      const { datum_pin_node_id, datum_plug_node_id } =
        this._get_datum_connected(datum_node_id)

      if (datum_pin_node_id) {
        if (this._is_link_pin_node_id(datum_pin_node_id)) {
          const { unitId } = segmentLinkPinNodeId(datum_pin_node_id)
          if (!removed_unit.has(unitId)) {
            push_remove_datum_bulk_action(
              datum_node_id,
              datum_pin_node_id,
              null
            )
          }
        } else {
          if (!removed_merge.has(datum_pin_node_id)) {
            push_remove_datum_bulk_action(
              datum_node_id,
              datum_pin_node_id,
              null
            )
          }
        }
      } else if (datum_plug_node_id) {
        const { type, pinId, subPinId } = segmentPlugNodeId(datum_plug_node_id)

        if (deepGetOrDefault(removed_plugs, [type, pinId, subPinId], false)) {
          //
        } else {
          push_remove_datum_bulk_action(
            datum_node_id,
            datum_pin_node_id,
            datum_plug_node_id
          )
        }
      } else {
        push_remove_datum_bulk_action(
          datum_node_id,
          datum_pin_node_id,
          datum_plug_node_id
        )
      }
    }

    this._pod.$bulkEdit({ actions, fork, bubble })

    for (const datum_node_id of datum_node_ids) {
      if (this._search_unit_datum_node_id === datum_node_id) {
        this._search_unit_datum_node_id = null

        this._hide_search()
      }
    }

    for (const datum_node_id of datum_node_ids) {
      if (this._has_node(datum_node_id)) {
        const datum_pin_node_id = this._datum_to_pin[datum_node_id]

        if (
          datum_pin_node_id &&
          !link_pin_node_ids.includes(datum_pin_node_id)
        ) {
          this._spec_remove_pin_data(datum_pin_node_id)
        }

        this._sim_remove_datum(datum_node_id)
      }
    }

    removed_exposed_sub_pin_id = emptyIO({}, {})
    removed_exposed_pin_id = { input: new Set(), output: new Set() }

    for (const exposed_pin_node_id of exposed_node_ids) {
      const { type, pinId, subPinId } = segmentPlugNodeId(exposed_pin_node_id)
      if (!removed_exposed_pin_id[type].has(pinId)) {
        const pin_count = this._get_exposed_pin_set_count(exposed_pin_node_id)
        if (pin_count === 1 || pin_count === 0) {
          removed_exposed_pin_id[type].add(pinId)
          this._sim_cover_pin_set(type, pinId)
        } else {
          if (
            !removed_exposed_sub_pin_id[type][pinId] ||
            !removed_exposed_sub_pin_id[type][pinId].has(subPinId)
          ) {
            removed_exposed_sub_pin_id[type][pinId] =
              removed_exposed_sub_pin_id[type][pinId] || new Set()
            removed_exposed_sub_pin_id[type][pinId].add(subPinId)
            this.__sim_remove_exposed_sub_pin(type, pinId, subPinId)
          }
        }
      }
    }

    for (const err_id of err_node_ids) {
      const { unitId } = segmentErrNodeId(err_id)

      this._sim_remove_unit_err(unitId)
      this._refresh_node_color(unitId)

      if (!unit_ids.includes(unitId)) {
        this._pod_take_unit_err(unitId)
      }
    }

    for (const merge_node_id of merge_node_ids) {
      this._sim_remove_merge(merge_node_id)
    }

    for (const unit_id of unit_ids) {
      const merge_node_id = this._ref_unit_to_merge[unit_id]

      if (merge_node_id) {
        const self_pin_node_id = getSelfPinNodeId(unit_id)

        this._sim_remove_pin_or_merge(self_pin_node_id)
      }

      this._state_remove_unit(unit_id)
    }

    for (const datum_node_id of datum_node_ids) {
      this._spec_remove_datum(datum_node_id)
    }

    removed_exposed_sub_pin_id = emptyIO({}, {})
    removed_exposed_pin_id = { input: new Set(), output: new Set() }

    const referenced_exposed_pin_count: IOOf<Dict<number>> = {
      input: {},
      output: {},
    }

    for (const exposed_pin_node_id of exposed_node_ids) {
      const { type, pinId } = segmentPlugNodeId(exposed_pin_node_id)

      const pin_count = this._get_exposed_pin_set_count(exposed_pin_node_id)

      deepSet(referenced_exposed_pin_count, [type, pinId], pin_count)
    }

    for (const exposed_pin_node_id of exposed_node_ids) {
      const { type, pinId, subPinId } = segmentPlugNodeId(exposed_pin_node_id)

      if (!removed_exposed_pin_id[type].has(pinId)) {
        const pin_count = deepGet(referenced_exposed_pin_count, [type, pinId])

        if (pin_count === 1 || pin_count === 0) {
          removed_exposed_pin_id[type].add(pinId)

          this._spec_cover_pin_set(type, pinId)
        } else {
          if (
            !removed_exposed_sub_pin_id[type][pinId] ||
            !removed_exposed_sub_pin_id[type][pinId].has(subPinId)
          ) {
            removed_exposed_sub_pin_id[type][pinId] =
              removed_exposed_sub_pin_id[type][pinId] || new Set()
            removed_exposed_sub_pin_id[type][pinId].add(subPinId)

            this.__spec_remove_exposed_sub_pin(type, pinId, subPinId)
          }
        }
      }
    }

    for (const merge_node_id of merge_node_ids) {
      const { mergeId } = segmentMergeNodeId(merge_node_id)

      this._spec_remove_merge(mergeId)
    }

    this._dispatch_action(makeBulkEditAction(actions))
  }

  private _spec_remove_nodes = (node_ids: string[]) => {
    for (const node_id of node_ids) {
      this._spec_remove_node(node_id)
    }
  }

  private _pod_remove_nodes = (node_ids: string[]) => {
    for (const node_id of node_ids) {
      this._pod_remove_node(node_id)
    }
  }

  private _sim_cover_pin_set = (type: IO, pin_id: string): void => {
    // console.log('Graph', '_sim_cover_pin_set', type, pin_id)

    this._exposed_pin_set_count--

    const exposed_pin_spec = this._get_pin_spec(type, pin_id)

    const { plug = {} } = exposed_pin_spec

    for (const sub_pin_id in plug) {
      this.__sim_remove_exposed_sub_pin(type, pin_id, sub_pin_id)
    }

    delete this._unit_datum[type][pin_id]
  }

  public cover_pin_set = (type: IO, pin_id: string): void => {
    const pin = this._get_pin_spec(type, pin_id)

    this._dispatch_action(makeCoverPinSetAction(type, pin_id, pin))

    this._cover_pin_set(type, pin_id)
  }

  private _cover_pin_set = (type: IO, pin_id: string): void => {
    // console.log('Graph', '_cover_pin_set', type, id)

    const pin_spec = this._get_pin(type, pin_id)

    this._state_cover_pin_set(type, pin_id)
    this._pod_cover_pin_set(type, pin_id, pin_spec)
  }

  private _state_cover_pin_set = (type: IO, pinId: string): void => {
    // console.log('Graph', '_state_cover_pin_set', type, pinId)

    this._sim_cover_pin_set(type, pinId)
    this._spec_cover_pin_set(type, pinId)
  }

  private _spec_cover_pin_set = (type: IO, pinId: string): void => {
    // console.log('Graph', '_spec_remove_exposed_pin_set', type, id)

    coverPinSet({ pinId, type }, this._spec)
  }

  private _pod_cover_pin_set = (
    type: IO,
    pinId: string,
    pinSpec: GraphPinSpec
  ): void => {
    // console.log('Graph', '_pod_cover_pin_set', type, pinId, pinSpec)

    const { fork, bubble } = this.$props

    this._pod.$coverPinSet({
      type,
      pinId,
      pinSpec,
      fork,
      bubble,
    })
  }

  private __plug_exposed_pin_to = (
    type: IO,
    pin_id: string,
    sub_pin_id: string,
    node_id: string
  ): void => {
    let sub_pin_spec: GraphSubPinSpec

    if (this._is_link_pin_node_id(node_id)) {
      const { unitId, type, pinId } = segmentLinkPinNodeId(node_id)

      sub_pin_spec = { unitId, pinId, kind: type }
    } else if (this._is_merge_node_id(node_id)) {
      const { mergeId } = segmentMergeNodeId(node_id)

      sub_pin_spec = { mergeId }
    } else if (this._is_unit_node_id(node_id)) {
      sub_pin_spec = {
        unitId: node_id,
        type: 'output',
        pinId: SELF,
        kind: type,
      }
    } else {
      throw new Error(`cannot plug to node id: ${node_id}`)
    }

    const pin_internal_pin_id = this._pin_to_int[type][node_id]
    if (pin_internal_pin_id) {
      if (
        !this._is_merge_node_id(node_id) ||
        !this._spec_is_empty_merge(node_id)
      ) {
        const { pinId, subPinId } = segmentPlugNodeId(pin_internal_pin_id)

        this._unplug_exposed_pin(type, pinId, subPinId)
      }
    }

    this.plug_exposed_pin(type, pin_id, sub_pin_id, sub_pin_spec)
  }

  public plug_exposed_pin = (
    type: IO,
    pin_id: string,
    sub_pin_id: string,
    sub_pin_spec: GraphSubPinSpec
  ): void => {
    this._dispatch_action(
      makePlugPinAction(type, pin_id, sub_pin_id, sub_pin_spec)
    )

    this._plug_exposed_pin(type, pin_id, sub_pin_id, sub_pin_spec)
  }

  private _plug_exposed_pin = (
    type: IO,
    pin_id: string,
    sub_pin_id: string,
    sub_pin_spec: GraphSubPinSpec
  ): void => {
    // console.log('Graph', '_plug_exposed_pin')
    this._spec_plug_sub_pin(type, pin_id, sub_pin_id, sub_pin_spec)
    this._sim_plug_exposed_pin(type, pin_id, sub_pin_id, sub_pin_spec)
    this._pod_plug_exposed_pin(type, pin_id, sub_pin_id, sub_pin_spec)
  }

  private _spec_plug_sub_pin = (
    type: IO,
    pinId: string,
    subPinId: string,
    subPinSpec: GraphSubPinSpec
  ): void => {
    // console.log(
    //   'Graph',
    //   '_spec_plug_sub_pin',
    //   type,
    //   pinId,
    //   subPinId,
    //   subPinSpec
    // )

    const pin_node_id = getSubPinSpecNodeId(type, subPinSpec)

    const ref = this._is_pin_node_ref(pin_node_id)

    if (ref) {
      this._spec_set_exposed_pin_ref(type, pinId, true)
    }

    plugPin(
      {
        type,
        pinId,
        subPinId,
        subPinSpec,
      },
      this._spec
    )

    this._spec_refresh_exposed_pin_set_type(type, pinId)
  }

  private _get_exposed_pin_marker_path = (
    type: IO,
    ext_node_id: string,
    int_node_id: string
  ): SVGPath => {
    const input = type === 'input'

    const link_id_source_id = input ? ext_node_id : int_node_id
    const link_id_target_id = input ? int_node_id : ext_node_id

    const link_id = getLinkId(link_id_source_id, link_id_target_id)

    const start_marker = this._link_marker_start[link_id]
    const end_marker = this._link_marker_end[link_id]

    const marker = input ? end_marker : start_marker

    return marker
  }

  private _set_exposed_pin_marker_to_node = (
    type: IO,
    ext_node_id: string,
    int_node_id: string,
    anchor_node_id: string,
    padding: number = 0
  ): void => {
    const path = this._get_exposed_pin_marker_path(
      type,
      ext_node_id,
      int_node_id
    )

    if (!path) {
      return
    }

    const start_marker_d = this._get_pin_default_marker(
      type,
      ext_node_id,
      anchor_node_id,
      padding
    )

    path.setProp('d', start_marker_d)
  }

  private _set_plug_marker_to_default = (
    type: IO,
    ext_node_id: string,
    int_node_id: string
  ): void => {
    // console.log('_set_plug_marker_to_default', type, ext_node_id, int_node_id)

    const path = this._get_exposed_pin_marker_path(
      type,
      ext_node_id,
      int_node_id
    )

    const anchor_node_id = this._get_int_pin_anchor_node_id(int_node_id)

    const start_marker_d = this._get_pin_default_marker(
      type,
      ext_node_id,
      anchor_node_id
    )

    path.setProp('d', start_marker_d)
  }

  private _get_pin_default_marker = (
    type,
    ext_node_id: string,
    anchor_node_id: string,
    padding: number = 0
  ): string => {
    const functional = this._is_exposed_pin_functional(ext_node_id)

    const anchor_shape = this._get_node_shape(anchor_node_id)
    const anchor_r = this._get_node_r(anchor_node_id)

    const r = anchor_r + padding

    let d: string = ''

    if (functional) {
      d += ARROW_MEMORY
    }

    d += describeArrowShape(anchor_shape, r)

    return d
  }

  private _sim_refresh_unit_ref_output_icon = (
    unitId: string,
    type: IO,
    pinId: string
  ): void => {
    const icon = this._get_unit_pin_icon_name(unitId, type, pinId)

    this._sim_set_unit_ref_output_icon(unitId, type, pinId, icon)
  }

  private _sim_set_unit_ref_output_icon = (
    unitId: string,
    type: IO,
    pinId: string,
    icon: string
  ) => {
    const pin_node_id = getPinNodeId(unitId, type, pinId)

    const icon_comp = this._ref_output_pin_icon[pin_node_id]

    icon_comp.setProp('icon', icon)
  }

  private _sim_refresh_exposed_pin_marker = (
    type: IO,
    ext_node_id: string,
    int_node_id: string,
    anchor_node_id: string | null
  ): void => {
    if (anchor_node_id) {
      this._set_exposed_pin_marker_to_node(
        type,
        ext_node_id,
        int_node_id,
        anchor_node_id
      )
    } else {
      this._set_plug_marker_to_default(type, ext_node_id, int_node_id)
    }
  }

  private _state_plug_exposed_pin = (
    type: IO,
    pin_id: string,
    sub_pin_id: string,
    sub_pin_spec: GraphSubPinSpec
  ): void => {
    // console.log('Graph', '_state_plug_exposed_pin', type, pin_id, sub_pin_id, sub_pin_spec)

    this._spec_plug_sub_pin(type, pin_id, sub_pin_id, sub_pin_spec)
    this._sim_plug_exposed_pin(type, pin_id, sub_pin_id, sub_pin_spec)
  }

  private _sim_plug_exposed_pin = (
    type: IO,
    pin_id: string,
    sub_pin_id: string,
    sub_pin_spec: GraphSubPinSpec
  ): void => {
    // console.log(
    //   'Graph',
    //   '_sim_plug_exposed_pin',
    //   type,
    //   sub_pin_id,
    //   sub_pin_spec
    // )

    if (isEmptyObject(sub_pin_spec)) {
      return
    }

    const ext_node_id = getExtNodeId(type, pin_id, sub_pin_id)
    const int_node_id = getIntNodeId(type, pin_id, sub_pin_id)

    const input = type === 'input'

    this._exposed_pin_plugged_count++
    this._exposed_pin_unplugged_count--

    const anchor_node_id: string = this._get_exposed_pin_spec_internal_node_id(
      type,
      sub_pin_spec
    )

    this._sim_refresh_exposed_pin_marker(
      type,
      ext_node_id,
      int_node_id,
      anchor_node_id
    )

    this._ext_to_node[ext_node_id] = anchor_node_id
    this._int_to_node[int_node_id] = anchor_node_id

    this._node_to_ext[anchor_node_id] =
      this._node_to_ext[anchor_node_id] ?? new Set()
    this._node_to_ext[anchor_node_id].add(ext_node_id)

    this._pin_to_int[type][anchor_node_id] = int_node_id
    this._pin_to_ext[type][anchor_node_id] = ext_node_id

    delete this._exposed_ext_unplugged[ext_node_id]
    delete this._exposed_int_unplugged[int_node_id]

    const source_id = input ? ext_node_id : int_node_id
    const target_id = input ? int_node_id : ext_node_id

    const link_id = getLinkId(source_id, target_id)

    this._sim_change_link_node(link_id, anchor_node_id, !input)

    this._sim_set_link_d(
      link_id,
      LINK_DISTANCE_EXPOSED / LINK_DISTANCE_EXPOSED_PLUGGED_FACTOR
    )

    this._sim_remove_exposed_int_node(int_node_id)

    this._refresh_pin_datum_visible(anchor_node_id)

    if (sub_pin_spec.mergeId) {
      const merge_pin_count = this._spec_get_merge_pin_count(
        sub_pin_spec.mergeId
      )

      const merge_node_id = getMergeNodeId(sub_pin_spec.mergeId)

      if (merge_pin_count === 0) {
        this._set_node_layer(merge_node_id, LAYER_EXPOSED)

        this._sim_set_link_d(link_id, LINK_DISTANCE_EXPOSED)
      }
    }

    this._start_graph_simulation(LAYER_EXPOSED)
  }

  private _pod_plug_exposed_pin = (
    type: IO,
    pinId: string,
    subPinId: string,
    subPinSpec: GraphSubPinSpec
  ): void => {
    // console.log('Graph', '_pod_plug_exposed_pin', type, id, subPinId, subPin)

    const { fork, bubble } = this.$props

    this._pod.$plugPin({
      type,
      pinId,
      subPinId,
      subPinSpec,
      fork,
      bubble,
    })
  }

  public unplug_exposed_pin = (
    type: IO,
    pin_id: string,
    sub_pin_id: string
  ): void => {
    const sub_pin_spec = this._get_exposed_sub_pin_spec(
      type,
      pin_id,
      sub_pin_id
    )

    this._dispatch_action(
      makeUnplugPinAction(type, pin_id, sub_pin_id, sub_pin_spec)
    )

    this._unplug_exposed_pin(type, pin_id, sub_pin_id)
  }

  private _unplug_exposed_pin = (
    type: IO,
    pin_id: string,
    sub_pin_id: string
  ): void => {
    // console.log('Graph', '_unplug_exposed_pin')

    this._state_unplug_exposed_pin(type, pin_id, sub_pin_id)
    this._pod_unplug_exposed_pin(type, pin_id, sub_pin_id)
  }

  private _spec_unplug_sub_pin = (
    type: IO,
    pinId: string,
    subPinId: string
  ): void => {
    // console.log('Graph', '_spec_unplug_sub_pin', type, pinId, subPinId)

    const sub_pin_spec = this._get_exposed_sub_pin_spec(type, pinId, subPinId)

    unplugPin({ type, pinId, subPinId }, this._spec)

    const { mergeId } = sub_pin_spec

    if (mergeId) {
      const merge = this._spec_get_merge(mergeId)

      const merge_pin_count = getMergePinCount(merge)
      const merge_node_id = getMergeNodeId(mergeId)

      if (this._spec_has_merge(merge_node_id)) {
        if (merge_pin_count === 0) {
          const plug_count = countMergePlugs(this._spec, mergeId)

          if (plug_count > 2) {
            //
          } else {
            this._spec_remove_merge(mergeId)
          }
        }
      }
    }

    this._spec_refresh_exposed_pin_set_type(type, pinId)
  }

  private _state_unplug_exposed_pin = (
    type: IO,
    pin_id: string,
    sub_pin_id: string
  ) => {
    this._sim_unplug_exposed_pin(type, pin_id, sub_pin_id)
    this._spec_unplug_sub_pin(type, pin_id, sub_pin_id)

    this._refresh_compatible()
  }

  private _sim_unplug_exposed_pin = (
    type: IO,
    pin_id: string,
    sub_pin_id: string
  ): void => {
    // console.log('Graph', '_sim_unplug_exposed_pin', type, pin_id, sub_pin_id)

    const sub_pin_spec = this._get_exposed_sub_pin_spec(
      type,
      pin_id,
      sub_pin_id
    )

    if (isEmptyObject(sub_pin_spec ?? {})) {
      return
    }

    const ext_node_id = getExtNodeId(type, pin_id, sub_pin_id)
    const int_node_id = getIntNodeId(type, pin_id, sub_pin_id)

    const input = type === 'input'

    // const anchor_node_id: string = this._get_exposed_pin_spec_internal_node_id(
    //   type,
    //   sub_pin_spec
    // )

    const anchor_node_id = this._int_to_node[int_node_id]

    this._sim_refresh_exposed_pin_marker(type, ext_node_id, int_node_id, null)

    const { mergeId } = sub_pin_spec

    const pin_node_id = this._ext_to_node[ext_node_id]

    delete this._ext_to_node[ext_node_id]
    delete this._int_to_node[int_node_id]

    delete this._pin_to_int[type][pin_node_id]
    delete this._pin_to_ext[type][pin_node_id]

    if (this._node_to_ext[anchor_node_id]) {
      this._node_to_ext[anchor_node_id].delete(ext_node_id)

      if (this._node_to_ext[anchor_node_id].size === 0) {
        delete this._node_to_ext[anchor_node_id]
      }
    }

    this._exposed_ext_unplugged[ext_node_id] = true
    this._exposed_int_unplugged[int_node_id] = true

    this._exposed_pin_plugged_count--
    this._exposed_pin_unplugged_count++

    const anchor_node = this.get_node(anchor_node_id)
    const pin_position = this._get_node_position(anchor_node_id)
    const ext_node_position = this._get_node_position(ext_node_id)

    const u = pointUnitVector(pin_position, ext_node_position)
    const r = centerToSurfaceDistance(anchor_node, u)

    const internal_pin_position = addVector(
      pin_position,
      resizeVector(u, r - PIN_RADIUS)
    )

    const source_id = input ? ext_node_id : int_node_id
    const target_id = input ? int_node_id : ext_node_id

    const link_id = getLinkId(source_id, target_id)

    this._sim_add_internal_pin(type, pin_id, sub_pin_id, internal_pin_position)
    this._sim_change_link_node(link_id, int_node_id, !input)
    this._sim_set_link_d(link_id, LINK_DISTANCE_EXPOSED)

    this._refresh_pin_datum_visible(anchor_node_id)
    this._refresh_exposed_sub_pin_color(type, pin_id, sub_pin_id)

    if (mergeId) {
      const merge_pin_count = this._merge_pin_count[mergeId]

      const merge_node_id = getMergeNodeId(mergeId)

      if (this._spec_has_merge(merge_node_id)) {
        const merge_to_int_input = this._pin_to_int['input'][merge_node_id]
        const merge_to_int_output = this._pin_to_int['output'][merge_node_id]

        if (
          merge_pin_count === 0 &&
          (merge_to_int_input || merge_to_int_output)
        ) {
          this._sim_remove_merge(merge_node_id)
        }
      }
    }

    if (this._is_node_dragged(ext_node_id)) {
      this._set_ext_node_compatible_charge(ext_node_id)
    }
  }

  private _pod_unplug_exposed_pin = (
    type: IO,
    pinId: string,
    subPinId: string
  ): void => {
    const { config, fork } = this.$props

    const take = config?.unlinkTake ? true : false

    this._pod.$unplugPin({
      type,
      pinId,
      subPinId,
      subPinSpec: {},
      take,
      fork,
    })
  }

  private _has_node = (node_id: string): boolean => {
    return !!this.get_node(node_id)
  }

  private _has_anchor_node = (node_id: string): boolean => {
    const anchor_node_id = this._get_node_anchor_node_id(node_id)

    return this._has_node(anchor_node_id)
  }

  private _has_link = (link_id: string): boolean => {
    return !!this._link[link_id]
  }

  private _resize_start_component = (unit_id: string, size: Size): void => {
    // console.log('Graph', '_resize_start_component')
    if (this._tree_layout) {
      this._resize_component_start_size[unit_id] = size
    } else {
      this._sim_resize_start_component(unit_id, size)
    }
  }

  private _resize_component_start_size: Dict<Size> = {}

  private _sim_resize_start_component = (unit_id: string, size: Size): void => {
    const node = this._node[unit_id]

    node.fx = node.x
    node.fy = node.y

    this._resize_component_start_size[unit_id] = size
  }

  private _delta_resize_component = (
    unit_id: string,
    dx: number,
    dy: number,
    dw: number,
    dh: number
  ): void => {
    // console.log('Graph', unit_id, dx, dy, dw, dh)
    if (this._tree_layout) {
      this._layout_delta_resize_component(unit_id, dx, dy, dw, dh)
    } else {
      this._spec_delta_resize_component(unit_id, dx, dy, dw, dh)
    }
  }

  private _spec_delta_resize_component = (
    unit_id: string,
    dx: number,
    dy: number,
    dw: number,
    dh: number
  ): void => {
    const { $sx } = this.$context

    const { width, height } = this._get_unit_component_graph_size(unit_id)

    let nextWidth = width
    let nextHeight = height

    const k = this._zoom.z * $sx
    dw = dw / k
    dh = dh / k
    dx = dx / k
    dy = dy / k

    const tryWidth = width + dw
    const tryHeight = height + dh

    let resized = false
    if (
      dw !== 0 &&
      (dw > 0 || tryWidth >= MIN_WIDTH) &&
      (dw < 0 || tryWidth <= MAX_WIDTH)
    ) {
      nextWidth = tryWidth
      resized = true
    }
    if (
      dh !== 0 &&
      (dh > 0 || tryHeight >= MIN_HEIGHT) &&
      (dh < 0 || tryHeight <= MAX_HEIGHT)
    ) {
      nextHeight = tryHeight
      resized = true
    }
    if (resized) {
      this._sim_set_unit_size(unit_id, nextWidth, nextHeight)
      this._spec_set_unit_size(unit_id, nextWidth, nextHeight)

      const node = this._node[unit_id]
      node.fx += dx
      node.fy += dy
      node.x = node.fx
      node.y = node.fy

      this._start_graph_simulation(LAYER_NONE)
    }
  }

  private _get_layout_max_width = (): number => {
    const { $width } = this.$context

    const max_width = Math.min(
      MAX_WIDTH,
      $width - 2 * LAYOUT_HORIZONTAL_PADDING
    )

    return max_width
  }

  private _layout_delta_resize_component = (
    unit_id: string,
    dx: number,
    dy: number,
    dw: number,
    dh: number
  ): void => {
    const { $width } = this.$context
    const { width, height } = this._get_unit_component_layout_size(unit_id)

    let nextWidth = width
    let nextHeight = height

    const _dw = 2 * dw
    const _dh = 2 * dh

    const tryWidth = width + _dw
    const tryHeight = height + _dh

    const max_width = this._get_layout_max_width()

    let resized = false
    if (
      dw !== 0 &&
      (dw > 0 || tryWidth >= MIN_WIDTH) &&
      (dw < 0 || tryWidth <= max_width)
    ) {
      nextWidth = tryWidth
      resized = true
    }
    if (
      dh !== 0 &&
      (dh > 0 || tryHeight >= MIN_HEIGHT) &&
      (dh < 0 || tryHeight <= MAX_HEIGHT)
    ) {
      nextHeight = tryHeight
      resized = true
    }

    if (resized) {
      this._sim_layout_resize_sub_component(unit_id, nextWidth, nextHeight)
      this._spec_component_set_unit_graph_size(unit_id, nextWidth, nextHeight)
    }
  }

  private _resize_end_component = (unit_id: string): void => {
    // console.log('Graph', '_resize_end_component', unit_id)

    const { fork, bubble } = this.$props

    const node = this._node[unit_id]

    node.fx = undefined
    node.fy = undefined

    const defaultWidth =
      this._core_component_max_width[this._core_component_max_width.length - 1]
    const defaultHeight =
      this._core_component_max_height[
        this._core_component_max_height.length - 1
      ]

    const actions = []

    const start_size = this._resize_component_start_size[unit_id]

    if (this._tree_layout) {
      const { width, height } = this._layout_node[unit_id]

      actions.push(
        makeSetSubComponentSizeAction(
          unit_id,
          width,
          height,
          start_size.width,
          start_size.height
        )
      )
    } else {
      const { width, height } = this._get_unit_component_graph_size(unit_id)

      actions.push(
        makeSetUnitSizeAction(
          unit_id,
          width,
          height,
          start_size.width,
          start_size.height
        )
      )
    }
    actions.push(
      makeSetComponentSizeAction(
        defaultWidth,
        defaultHeight,
        start_size.width,
        start_size.height
      )
    )

    const bulk_edit_action = makeBulkEditAction(actions)

    this._dispatch_action(bulk_edit_action)

    this._pod.$bulkEdit({ actions, fork, bubble })
  }

  private _pod_set_unit_size = (
    unit_id: string,
    width: number,
    height: number
  ): void => {
    this._pod_set_metadata(['units', unit_id, 'metadata', 'component'], {
      width,
      height,
    })
  }

  private _pod_set_sub_component_size(
    unit_id: string,
    width: number,
    height: number
  ) {
    //
  }

  private _is_node_selectable = (node_id: string): boolean => {
    // if (this._is_external_pin_node_id(node_id)) {
    //   return false
    // }
    if (this._is_datum_node_id(node_id) && this._hidden_data_node[node_id]) {
      return false
    }

    if (this._is_link_pin_node_id(node_id)) {
      if (this._spec_is_link_pin_ignored(node_id)) {
        return false
      }
    }

    return true
  }

  private _get_unit_spec_render = (unit_id: string): boolean | undefined => {
    const { specs } = this.$props

    const spec_id = this._get_unit_spec_id(unit_id)

    return getSpecRenderById(specs, spec_id)
  }

  private _is_unit_component = (unit_id: string): boolean => {
    const unit_spec_render = this._get_unit_spec_render(unit_id)

    if (unit_spec_render === undefined) {
      const spec = this._get_unit_spec(unit_id)

      if (isBaseSpec(spec)) {
        return false
      } else {
        const is_component_defined = hasSubComponents(spec as GraphSpec)

        return is_component_defined
      }
    } else {
      return unit_spec_render
    }
  }

  private _is_unit_base = (unit_id: string): boolean => {
    const { specs } = this.$props

    const spec_id = this._get_unit_spec_id(unit_id)

    return isBaseSpecId(specs, spec_id)
  }

  private _is_system_unit = (unit_id: string) => {
    const spec = this._get_unit_spec(unit_id)

    return isSystemSpec(spec)
  }

  private _is_datum_class_literal = (datum_node_id: string): boolean => {
    const datum_tree = this._get_datum_tree(datum_node_id)
    const is_class_literal = datum_tree.type === TreeNodeType.Unit
    return is_class_literal
  }

  private _get_unit_pin_node_position = (unit_id: string): Dict<Position> => {
    const position: Dict<Position> = {}

    position[unit_id] = this._get_node_position(unit_id)

    this._for_each_unit_pin(unit_id, (pin_node_id: string) => {
      const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)

      position[pin_node_id] = this._get_node_position(anchor_node_id)
    })

    return position
  }

  private _get_unit_pin_position = (unit_id: string): UnitPinPosition => {
    const unit_pin_position: UnitPinPosition = {
      input: {},
      output: {},
    }
    this._for_each_unit_pin(unit_id, (pin_node_id, type, pin_id) => {
      const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)
      unit_pin_position[type][pin_id] = this._get_node_position(anchor_node_id)
    })
    return unit_pin_position
  }

  private _get_merge_position = (merge_node_id: string): Position => {
    const merge_unit_id = this._merge_to_ref_unit[merge_node_id]
    if (merge_unit_id) {
      const unit_node = this._node[merge_unit_id]
      const { x, y } = unit_node
      return { x, y }
    }

    const merge_ref_output_id = this._merge_to_ref_output[merge_node_id]
    if (merge_ref_output_id) {
      const ref_output_node = this._node[merge_ref_output_id]
      const { x, y } = ref_output_node
      return { x, y }
    }

    const merge_node = this._node[merge_node_id]
    const { x, y } = merge_node
    return { x, y }
  }

  private _get_exposed_pin_set_position = (
    type: IO,
    pinId: string
  ): Dict<{ int?: Position; ext?: Position }> => {
    const position = {}
    const pin_spec = this._get_pin_spec(type, pinId)
    const { plug = {} } = pin_spec
    for (const sub_pin_id in plug) {
      const ext_node_id = getExtNodeId(type, pinId, sub_pin_id)
      const int_node_id = getIntNodeId(type, pinId, sub_pin_id)

      const internal_pin_anchor_node_id =
        this._get_int_pin_anchor_node_id(int_node_id) || int_node_id

      const int = this._get_node_position(internal_pin_anchor_node_id)
      const ext = this._get_node_position(ext_node_id)

      position[sub_pin_id] = { int, ext }
    }
    return position
  }

  private _on_pointer_down = (
    event: UnitPointerEvent,
    _event: PointerEvent
  ) => {
    // console.log('Graph', '_on_pointer_down')

    const {
      api: {
        window: { setTimeout },
      },
    } = this.$system

    const { pointerId, clientX, clientY } = event

    if (this._restart_gesture || this._is_alt_pressed()) {
      this._main.setPointerCapture(pointerId)

      this._start_gesture(event)

      return
    }

    if (!this._search_hidden || this._resize_pointer_id_node_id[pointerId]) {
      _event.preventDefault()
    }

    this.__on_pointer_down(pointerId, clientX, clientY)
  }

  private _temp_lock_control = () => {
    // console.log('Graph', '_temp_lock_control', this._id)

    this._temp_control_lock = true

    this._control.dispatchEvent('temp_lock', {}, false)

    this._lock_control()
  }

  private _temp_unlock_control = () => {
    // console.log('Graph', '_temp_unlock_control', this._id)

    this._temp_control_lock = false

    this._unlock_control()

    this._control.dispatchEvent('temp_unlock', {}, false)
  }

  private __on_pointer_down = (
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    // console.log('Graph', '__on_pointer_down', clientX, clientY)

    if (
      this._resize_pointer_count === 0 &&
      !this._datum_to_be_focused_by_click
    ) {
      if (this._control) {
        if (!this._control_lock) {
          // if (this._focused) {
          this._temp_lock_control()
          // }
        }
      }
    }

    const position = { x: clientX, y: clientY }

    this._pointer_position[pointerId] = position

    if (!this._pointer_down[pointerId]) {
      this._pointer_down[pointerId] = true
      this._pointer_down_move_count[pointerId] = 0
      this._pointer_down_position[pointerId] = position
      this._pointer_down_count++
    }

    const is_background_pointer = this._is_background_pointer(pointerId)

    if (is_background_pointer) {
      this._main.setPointerCapture(pointerId)

      if (this._mode === 'multiselect') {
        if (this._pointer_down_count === 1) {
          this._on_multiselect_area_start(pointerId, clientX, clientY)
        } else {
          if (this._multiselect_area_ing) {
            this._on_multiselect_area_end()
          }
        }
      }
    }

    if (!this._collapsing) {
      if (this._pointer_down_count === 2) {
        const [pointer_id_0, pointer_id_1] = keys(this._pointer_down)
        const { x: x0, y: y0 } = this._pointer_position[pointer_id_0]
        const { x: x1, y: y1 } = this._pointer_position[pointer_id_1]
        const d = distance(x0, y0, x1, y1)
        if (this._pressed_node_pointer_count === 0) {
          const x = (x0 + x1) / 2
          const y = (y0 + y1) / 2
          const position = {
            x,
            y,
          }
          this._touch_zoom_position_start = position
          this._touch_zoom_position = position
          this._touch_zoom_d = d
        } else if (
          this._pressed_node_pointer_count === 2 &&
          keys(this._pressed_node_id_pointer_id).length === 1
        ) {
          const [[node_id]] = Object.entries(this._pressed_node_id_pointer_id)
          const node = this.get_node(node_id)
          const { x, y, width, height } = node
          const position = {
            x: x + width / 2 - this._zoom.x,
            y: y + height / 2 - this._zoom.y,
          }
          this._touch_zoom_position_start = position
          this._touch_zoom_position = position
          this._touch_zoom_d = d
        }
      }
    }
  }

  private _zoom_center_at_node = (node_id: string) => {
    const { x, y } = this.get_node(node_id)

    this._zoom_center_at(x, y)
  }

  private _zoom_center_at = (x: number, y: number): void => {
    const { $width, $height } = this.$context

    const zoom = zoomTransformCenteredAt(x, y, this._zoom.z, $width, $height)

    this.set_zoom(zoom)
  }

  private _animate_zoom_center_unlisten: Unlisten

  private _animate_zoom_center_at = (x: number, y: number): void => {
    // console.log('Graph', '_animate_zoom_center_at', x, y)

    const { $width, $height } = this.$context

    const n0 = this._zoom
    const n1 = zoomTransformCenteredAt(x, y, this._zoom.z, $width, $height)

    this._animate_zoom_center_unlisten = animateSimulate(
      this.$system,
      n0,
      () => n1,
      [
        ['x', 0.1],
        ['y', 0.1],
      ],
      ({ x, y }) => {
        const zoom = { x, y, z: this._zoom.z }

        this._set_zoom(zoom)
      },
      () => {
        //
      }
    )
  }

  private _state_reorder_sub_component = (unit_id: string, i: number): void => {
    // console.log('Graph', '_state_reorder_sub_component', unit_id, i)

    this._spec_reorder_sub_component(unit_id, i)
    this._sim_reorder_sub_component(unit_id, i)

    if (this._is_fullwindow) {
      this._reorder_all_fullwindow()
    }

    this._animate_all_current_layout_layer_node()
  }

  private _reorder_sub_component = (
    unit_id: string,
    i: number,
    emit: boolean
  ): void => {
    // console.log('Graph', '_reorder_sub_component', unit_id, i)

    this._state_reorder_sub_component(unit_id, i)

    const parent_id = this._spec_get_sub_component_parent_id(unit_id)

    emit && this._pod_reorder_sub_component(parent_id, unit_id, i)
  }

  private _spec_reorder_sub_component = (unit_id: string, i: number): void => {
    // console.log('Graph', '_spec_reorder_sub_component', i)

    const parent_id = this._spec_get_sub_component_parent_id(unit_id)
    const children = this._get_sub_component_spec_layer(unit_id)

    reorderSubComponent(
      { parentId: parent_id, childId: unit_id, to: i },
      this._spec.component
    )

    this._refresh_tree_sub_component_index()
  }

  private _sim_reorder_sub_component = (unit_id: string, i: number): void => {
    // console.log('Graph', '_sim_reorder_sub_component-', unit_id, i)

    const parent_id = this._spec_get_sub_component_parent_id(unit_id)

    const sub_component = this._get_sub_component(unit_id)

    if (parent_id) {
      const parent_sub_component = this._get_sub_component(parent_id)

      const parent_layer_visible =
        this._is_layout_component_layer_visible(parent_id)

      if (!parent_layer_visible) {
        parent_sub_component.removeParentRoot(sub_component)
      }

      parent_sub_component.pullParentRoot(sub_component)

      const slot = this._get_sub_component_slot_name(unit_id)

      parent_sub_component.insertParentRoot(sub_component, i, slot)

      if (!parent_layer_visible) {
        parent_sub_component.insertParentRootAt(sub_component, i, slot)
      }
    } else {
      const { component } = this.$props

      component.pullRoot(sub_component)
      component.fitRoot(sub_component, i)
    }

    this._refresh_layout_node_target_position(parent_id)
  }

  private _pod_reorder_sub_component = (
    parentId: string | null,
    childId: string,
    to: number
  ): void => {
    // console.log('Graph', '_pod_reorder_sub_component', parentId, childId)

    const { fork, bubble } = this.$props

    this._pod.$reorderSubComponent({ parentId, childId, to, fork, bubble })
  }

  private _on_layout_component_drag_start = (
    unit_id: string,
    event: UnitPointerEvent
  ): void => {
    // console.log('Graph', '_on_layout_component_drag_start', unit_id)

    const { clientX, clientY } = event

    this.__on_layout_component_drag_start(unit_id, clientX, clientY)
  }

  private __on_layout_component_drag_start = (
    unit_id: string,
    clientX: number,
    clientY: number
  ): void => {
    // console.log(
    //   'Graph',
    //   '_on_layout_component_drag_start',
    //   unit_id,
    //   clientX,
    //   clientY
    // )

    this._layout_drag_node_count++
    if (this._layout_drag_node_count === 1) {
      this._layout_dragging = true
    }
    this._layout_drag_node[unit_id] = true
    this._layout_drag_index[unit_id] =
      this._get_sub_component_tree_index(unit_id)
    this._layout_drag_direction[unit_id] = undefined

    const parent_layout_layer = this._ensure_parent_layout_layer(unit_id)

    this._layout_drag_start_scroll_top[unit_id] =
      parent_layout_layer.content.$element.scrollTop
    this._layout_drag_start_scroll_height[unit_id] =
      parent_layout_layer.content.$element.scrollHeight
    this._layout_drag_start_position[unit_id] = { x: clientX, y: clientY }

    const children = this._get_sub_component_spec_layer(unit_id)

    this._layout_drag_start_children[unit_id] = children

    for (const child_id of children) {
      const layout_target_node = this._layout_target_node[child_id]

      const { x, y } = layout_target_node

      this._layout_drag_init_position[child_id] = { x, y }
    }

    const layout_core = this._layout_core[unit_id]

    layout_core.$element.style.zIndex = '1000'
  }

  private _on_layout_component_drag_move = (
    unit_id: string,
    event: UnitPointerEvent
  ) => {
    const { clientX, clientY } = event

    this.__on_layout_component_drag_move(unit_id, clientX, clientY)
  }

  private __on_layout_component_drag_move = (
    unit_id: string,
    clientX: number,
    clientY: number
  ) => {
    // console.log('Graph', '__on_layout_component_drag_move', unit_id)

    const drag_start_position = this._layout_drag_start_position[unit_id]
    const scroll_top_start = this._layout_drag_start_scroll_top[unit_id]
    const position = this._layout_drag_init_position[unit_id] ?? { x: 0, y: 0 }

    this._layout_drag_client_position[unit_id] = { x: clientX, y: clientY }

    const parent_layout_layer = this._ensure_parent_layout_layer(unit_id)

    const { scrollTop = 0 } = parent_layout_layer.content.$element

    if (drag_start_position.y >= clientY) {
      this._layout_drag_direction[unit_id] = 'down'
    } else {
      this._layout_drag_direction[unit_id] = 'up'
    }

    const x = clientX + position.x - drag_start_position.x
    const y =
      clientY +
      position.y -
      drag_start_position.y +
      (scrollTop - scroll_top_start)

    this._set_layout_core_position(unit_id, x, y)

    const layout_target_node = this._layout_target_node[unit_id]

    layout_target_node.x = x
    layout_target_node.y = y

    this._refresh_drag_layout_component_index(unit_id)
    this._refresh_drag_layout_component_scroll(unit_id)
  }

  private _refresh_drag_layout_component_index = (unit_id: string) => {
    const { x, y, width, height } = this._layout_node[unit_id]

    const node = { x, y, width, height, shape: 'rect' as Shape, r: width }

    let closest_unit_id: string | null = null

    let D = Number.MAX_SAFE_INTEGER

    const layout_layer_node = this._get_layout_layer_parent_children(unit_id)

    for (const layout_unit_id of layout_layer_node) {
      if (unit_id !== layout_unit_id) {
        const layout_drag_init_position =
          this._layout_drag_init_position[layout_unit_id]
        const layout_unit_node = this._layout_node[layout_unit_id]

        const { x: _x, y: _y } = layout_drag_init_position
        const { width: _width, height: _height } = layout_unit_node

        const { d, l } = surfaceDistance(node, {
          x: _x,
          y: _y,
          width: _width,
          height: _height,
          r: _width / 2,
          shape: 'rect',
        })
        if (l < 0) {
          if (d < D) {
            closest_unit_id = layout_unit_id
            D = d
          }
        }
      }
    }

    const start_children = this._layout_drag_start_children[unit_id]
    const init_drag_index = this._layout_drag_index[unit_id]
    const layout_drag_swap = this._layout_drag_swap[unit_id]
    const layout_drag_swap_index = this._layout_drag_swap_index[unit_id]

    const reset = () => {
      const layout_drag_swap = this._layout_drag_swap[unit_id]

      if (layout_drag_swap) {
        delete this._layout_drag_swap[unit_id]
        delete this._layout_drag_swap_index[unit_id]

        this._state_reorder_sub_component(unit_id, init_drag_index)
      }
    }

    if (closest_unit_id) {
      if (layout_drag_swap !== closest_unit_id) {
        reset()

        const closest_unit_index = start_children.indexOf(closest_unit_id)

        this._layout_drag_swap[unit_id] = closest_unit_id
        this._layout_drag_swap_index[unit_id] = closest_unit_index

        this._state_reorder_sub_component(unit_id, closest_unit_index)
      }
    } else {
      reset()
    }
  }

  private _refresh_drag_layout_component_scroll = (unit_id: string) => {
    // console.log('Graph', '_refresh_drag_layout_component_scroll', unit_id)

    const start_scroll_height = this._layout_drag_start_scroll_height[unit_id]
    const drag_direction = this._layout_drag_direction[unit_id]
    const D = 1 / 2

    this._refresh_layout_component_scroll(
      unit_id,
      start_scroll_height,
      drag_direction,
      D,
      (d: number) => {
        const node = this._layout_node[unit_id]
        // this._set_layout_core_position(unit_id, node.x, node.y + d)

        this._refresh_drag_layout_component_index(unit_id)
        this._refresh_drag_layout_component_scroll(unit_id)
      }
    )
  }

  private _refresh_layout_component_scroll = (
    unit_id: string,
    start_scroll_height: number,
    drag_direction: 'up' | 'down',
    D: number,
    tick: (d: number) => void
  ): void => {
    // console.log('Graph', '_refresh_layout_component_scroll', unit_id)
    const { $height } = this.$context

    const node = this._layout_node[unit_id]

    if (this._layout_scroll_animation) {
      cancelAnimationFrame(this._layout_scroll_animation)

      this._layout_scroll_animation = undefined
    }

    let animate = false
    let d = 0

    const parent_layout_layer = this._ensure_parent_layout_layer(unit_id)

    const { scrollTop = 0, scrollHeight } = parent_layout_layer.content.$element

    const PADDING = 60

    const { y, height } = node

    if (drag_direction === 'up' && scrollTop < start_scroll_height - $height) {
      const dy = y + height / 2 - scrollTop - $height / 2 + PADDING

      if (dy > 0) {
        animate = true
        d = D * dy
      }
    } else if (drag_direction === 'down' && scrollTop > 0) {
      const dy = y - height / 2 + $height / 2 - scrollTop - PADDING

      if (dy < 0) {
        animate = true
        d = D * dy
      }
    }

    if (animate) {
      const frame = () => {
        parent_layout_layer.content.$element.scrollTop = Math.min(
          scrollTop + d,
          scrollHeight
        )

        tick(d)
      }

      this._layout_scroll_animation = requestAnimationFrame(frame)
    }
  }

  private _on_layout_component_drag_end = (unit_id: string): void => {
    // console.log('Graph', '_on_layout_component_drag_end', unit_id)

    const init_index = this._layout_drag_index[unit_id]
    const final_index = this._layout_drag_swap_index[unit_id]

    const layout_core = this._layout_core[unit_id]

    layout_core.$element.style.zIndex = ''

    this._layout_drag_node_count--

    if (this._layout_drag_node_count === 0) {
      this._layout_dragging = false
    }

    delete this._layout_drag_node[unit_id]
    delete this._layout_drag_index[unit_id]
    delete this._layout_drag_swap[unit_id]
    delete this._layout_drag_swap_index[unit_id]
    delete this._layout_drag_start_position[unit_id]
    delete this._layout_drag_direction[unit_id]
    delete this._layout_drag_start_scroll_height[unit_id]
    delete this._layout_drag_start_scroll_top[unit_id]

    const children = this._spec_get_component_children()

    for (const child_id of children) {
      delete this._layout_drag_init_position[child_id]
    }

    if (this._layout_scroll_animation) {
      cancelAnimationFrame(this._layout_scroll_animation)

      this._layout_scroll_animation = undefined
    }

    const parent_id = this._layout_sub_component_parent[unit_id] || null

    this._refresh_layout_node_target_position(parent_id)
    this._animate_all_layout_layer_node(parent_id)

    if (final_index !== undefined) {
      if (init_index === final_index) {
        //
      } else {
        this._commit_reorder_sub_component(
          parent_id,
          unit_id,
          init_index,
          final_index
        )
      }
    }
  }

  private _commit_reorder_sub_component = (
    parent_id: string,
    unit_id: string,
    init_index: number,
    final_index: number
  ) => {
    this._dispatch_action(
      makeReorderSubComponentAction(parent_id, unit_id, init_index, final_index)
    )

    this._pod_reorder_sub_component(parent_id, unit_id, final_index)
  }

  private _drag_start = (node_id: string, event: UnitPointerEvent): void => {
    // console.log('_drag_start', node_id)

    const { clientX, clientY, pointerId } = event

    this.__drag_start(node_id, pointerId, clientX, clientY)
  }

  private _extend_drag_along_to_subgraph = (node_id: string) => {
    const subgraph_node_ids = this._get_node_subgraph_node_ids(node_id)

    for (const subgraph_node_id of subgraph_node_ids) {
      if (subgraph_node_id !== node_id) {
        this._set_node_drag_along(node_id, subgraph_node_id)
      }
    }
  }

  private _get_node_subgraph_node_ids = (node_id: string) => {
    const subgraph_id = this._node_to_subgraph[node_id]
    const subgraph_node_ids = this._subgraph_to_node[subgraph_id]

    return subgraph_node_ids
  }

  private _de_extend_drag_along_to_subgraph = (node_id: string) => {
    const subgraph_id = this._node_to_subgraph[node_id]
    const subgraph_node_ids = this._subgraph_to_node[subgraph_id]

    for (const subgraph_node_id of subgraph_node_ids) {
      if (subgraph_node_id !== node_id) {
        this._remove_node_drag_along(node_id, subgraph_node_id)
      }
    }
  }

  private __drag_start = (
    node_id: string,
    pointerId: number,
    clientX: number,
    clientY: number
  ) => {
    // console.log('Graph', '__drag_start', node_id, pointerId)

    const layer = this._get_node_default_layer(node_id)

    this._start_graph_simulation(clamp(layer - 1, 0, Infinity))

    const [x, y] = this._client_to_graph(clientX, clientY)

    this.__on_node_drag_start(node_id, pointerId, x, y)

    this._tick_closest_compatible_selection(node_id)

    if (this._selected_node_id[node_id]) {
      for (const selected_node_id in this._selected_node_id) {
        if (selected_node_id !== node_id) {
          this._set_node_drag_along(node_id, selected_node_id)
        }
      }
    }

    if (this._mode == 'multiselect' && node_id !== this._collapse_unit_id) {
      this._extend_drag_along_to_subgraph(node_id)
    }

    if (this._drag_along_node[node_id]) {
      for (const drag_along_node_id of this._drag_along_node[node_id]) {
        if ((this._node_pressed_count[drag_along_node_id] ?? 0) === 0) {
          this._start_node_drag_along(
            node_id,
            pointerId,
            drag_along_node_id,
            x,
            y
          )
        }
      }
    }

    if (this._is_ext_node_id(node_id)) {
      this._set_ext_node_compatible_charge(node_id)
    } else if (this._is_int_node_id(node_id)) {
      //
    }
  }

  private _start_node_drag_along = (
    node_id: string,
    pointerId: number,
    drag_along_node_id: string,
    x: number,
    y: number
  ) => {
    this._drag_node_pointer_id[drag_along_node_id] = pointerId

    const relative = deepGetOrDefault(
      this._drag_along_relative_position,
      [node_id, drag_along_node_id],
      NULL_VECTOR
    )

    const node = this._node[node_id]

    this.__on_node_drag_start(
      drag_along_node_id,
      pointerId,
      x + relative.x - node.hx,
      y + relative.y - node.hy
    )
  }

  private _set_ext_node_compatible_charge = (node_id: string): void => {
    const int_node_id = getIntNodeIdFromExtNodeId(node_id)

    const k = 0.05

    this._set_all_node_to_node_charge(int_node_id, k)
    this._set_all_node_to_compatible_node_charge(int_node_id, -k)
  }

  private _set_all_node_to_node_charge(a_node_id: string, charge: number) {
    for (const node_id in this._node) {
      this._set_node_to_node_charge(a_node_id, node_id, charge)
      this._set_node_to_node_charge(node_id, a_node_id, charge)
    }
  }

  private _delete_all_node_to_node_charge(a_node_id: string) {
    // console.log('Graph', '_delete_all_node_to_node_charge', a_node_id)

    for (const node_id in this._node) {
      this._delete_node_to_node_charge(a_node_id, node_id)
      this._delete_node_to_node_charge(node_id, a_node_id)
    }
  }

  private _set_all_node_to_compatible_node_charge(
    a_node_id: string,
    charge: number
  ) {
    for (const compatible_node_id in this._compatible_node_id) {
      this._set_node_to_node_charge(a_node_id, compatible_node_id, charge)
      this._set_node_to_node_charge(compatible_node_id, a_node_id, charge)
    }
  }

  private _set_node_to_node_charge = (
    a_node_id: string,
    b_node_id: string,
    charge: number
  ) => {
    // console.log(
    //   'Graph',
    //   '_set_node_to_node_charge',
    //   a_node_id,
    //   b_node_id,
    //   charge
    // )

    deepSet(this._node_charge, [a_node_id, b_node_id], charge)
  }

  private _delete_node_to_node_charge = (
    a_node_id: string,
    b_node_id: string
  ) => {
    // console.log('Graph', '_delete_node_to_node_charge', a_node_id, b_node_id)

    delete this._node_charge[a_node_id]?.[b_node_id]
  }

  private _drag_edge_animation: number

  private _drag_edge_animation_tick = () => {
    // console.log('Graph', '_drag_edge_animation_tick')

    if (this._drag_count === 0) {
      this._drag_edge_animation = undefined

      return
    }

    const { z } = this._zoom

    for (const drag_node_id in this._pressed_node_id_pointer_id) {
      const { x0, y0, x1, y1 } = this._get_node_edge_offset(drag_node_id, 1)

      let dx: number = 0
      let dy: number = 0

      const MAX_V = 24

      if (x1 >= 0) {
        dx = Math.min(x1, MAX_V)
      } else if (x0 <= 0) {
        dx = Math.max(x0, -MAX_V)
      }

      if (y1 >= 0) {
        dy = Math.min(y1, MAX_V)
      } else if (y0 <= 0) {
        dy = Math.max(y0, -MAX_V)
      }

      const k = (z - 1) / z

      const cx = k * dx
      const cy = k * dy

      const translate_node = (node_id: string) => {
        const node = this._node[node_id]

        const next_position = addVector(node, {
          x: dx / z + cx,
          y: dy / z + cy,
        })

        this._set_node_position(node_id, next_position)
      }

      const drag_node = this._node[drag_node_id]

      drag_node.hx -= (2 * dx) / z + cx
      drag_node.hy -= (2 * dy) / z + cy

      translate_node(drag_node_id)

      if (this._drag_along_node[drag_node_id]) {
        for (const drag_along_node_id of this._drag_along_node[drag_node_id]) {
          translate_node(drag_along_node_id)
        }
      }

      const zoom = translate(this._zoom, -z * dx, -z * dy)

      this.set_zoom(zoom)
    }

    this._drag_edge_animation = requestAnimationFrame(
      this._drag_edge_animation_tick
    )
  }

  private _start_drag_edge_animation = () => {
    if (this._drag_edge_animation) {
      return
    }

    this._drag_edge_animation_tick()
  }

  private _get_node_edge_offset = (
    node_id: string,
    offset: number = 0
  ): Line => {
    const node = this._node[node_id]

    const { z } = this._zoom

    const { x: _x, y: _y } = node

    const screen_position = this._world_to_screen(_x, _y)

    const { $width, $height } = this.$context

    const _x0 = screen_position.x - (node.width / 2 + offset) * z
    const _y0 = screen_position.y - (node.height / 2 + offset) * z

    const x0 = _x0
    const y0 = _y0
    const x1 = screen_position.x - $width + (node.width / 2 - offset) * z
    const y1 = screen_position.y - $height + (node.height / 2 - offset) * z

    return { x0, x1, y0, y1 }
  }

  private _cancel_drag_edge_animation = () => {
    // console.log('_cancel_drag_edge_animation')

    if (this._drag_edge_animation) {
      cancelAnimationFrame(this._drag_edge_animation)

      this._drag_edge_animation = undefined
    }
  }

  private _get_subgraph_count = (): number => {
    return keyCount(this._subgraph_to_node)
  }

  private _drag_move = (node_id: string, event: UnitPointerEvent): void => {
    // console.log('_drag_move', node_id)

    const { config } = this.$props

    const { clientX, clientY, pointerId } = event

    const node_layer = this._get_node_default_layer(node_id)

    this._start_graph_simulation(clamp(node_layer - 1, 0, Infinity))

    const [x, y] = this._client_to_graph(clientX, clientY)

    if (this._is_draggable_mode()) {
      if (this._should_edge_drag_on_this_mode()) {
        const { x0, y0, x1, y1 } = this._get_node_edge_offset(node_id, 0)

        let prevent_edge_drag: boolean = false

        if (this._is_datum_node_id(node_id)) {
          if (this._datum_to_pin[node_id] || this._datum_to_plug[node_id]) {
            this._drag_node_init_edge_overflow[node_id] = {
              x0: x0 < 0,
              y0: y0 < 0,
              x1: x1 > 0,
              y1: y1 > 0,
            }

            prevent_edge_drag = true
          }
        }

        if (
          config?.edgeDrag &&
          !prevent_edge_drag &&
          this._get_subgraph_count() > 1
        ) {
          const {
            x0: overflow_x0,
            y0: overflow_y0,
            x1: overflow_x1,
            y1: overflow_y1,
          } = this._drag_node_init_edge_overflow[node_id]

          if (x0 > 0) {
            this._drag_node_init_edge_overflow[node_id].x0 = false
          }
          if (y0 > 0) {
            this._drag_node_init_edge_overflow[node_id].y0 = false
          }
          if (x1 < 0) {
            this._drag_node_init_edge_overflow[node_id].x1 = false
          }
          if (y1 < 0) {
            this._drag_node_init_edge_overflow[node_id].y1 = false
          }

          const drag_init_overflow_count =
            bit(overflow_x0) +
            bit(overflow_y0) +
            bit(overflow_x1) +
            bit(overflow_y1)

          if (drag_init_overflow_count < 2) {
            const node = this._node[node_id]

            const dx = x - node.hx - node.x
            const dy = y - node.hy - node.y

            const drag_edge_animating = !!this._drag_edge_animation

            const lock_x0 =
              (drag_edge_animating || x0 <= 0) && dx <= 0 && !overflow_x0
            const lock_x1 =
              (drag_edge_animating || x1 >= 0) && dx >= 0 && !overflow_x1

            const lock_y0 =
              (drag_edge_animating || y0 <= 0) && dy <= 0 && !overflow_y0
            const lock_y1 =
              (drag_edge_animating || y1 >= 0) && dy >= 0 && !overflow_y1

            const lock_x = lock_x0 || lock_x1
            const lock_y = lock_y0 || lock_y1

            if (lock_x || lock_y) {
              this._start_drag_edge_animation()
            } else {
              this._cancel_drag_edge_animation()
            }
          } else {
            this._cancel_drag_edge_animation()
          }
        }
      }

      this._node_drag_move(node_id, x, y)

      if (this._drag_along_node[node_id]) {
        for (const drag_along_node_id of this._drag_along_node[node_id]) {
          if ((this._node_pressed_count[drag_along_node_id] ?? 0) === 0) {
            const relative_position = deepGetOrDefault(
              this._drag_along_relative_position,
              [node_id, drag_along_node_id],
              NULL_VECTOR
            )

            const node = this._node[node_id]

            if (this._drag_node_pointer_id[drag_along_node_id] !== pointerId) {
              this._drag_node_pointer_id[drag_along_node_id] = pointerId

              if (!this._drag_node_id[drag_along_node_id]) {
                this.__on_node_drag_start(
                  drag_along_node_id,
                  pointerId,
                  x + relative_position.x - node.hx,
                  y + relative_position.y - node.hy
                )
              }
            }

            this._node_drag_move(
              drag_along_node_id,
              x + relative_position.x - node.hx,
              y + relative_position.y - node.hy
            )
          }
        }
      }
    }

    if (this._is_datum_node_id(node_id)) {
      const pull_datum = (datum_node_id: string) => {
        const datum_anchor_node_id =
          this._get_datum_pin_anchor_node_id(datum_node_id)

        if (datum_anchor_node_id) {
          const datum_anchor_node = this._node[datum_anchor_node_id]
          const datum_node = this._node[datum_node_id]

          const { l } = surfaceDistance(datum_anchor_node, datum_node)

          if (l > 2 * LINK_DISTANCE) {
            this._mem_remove_pin_datum_tree(datum_anchor_node_id)

            this.remove_node_datum_link(datum_node_id, datum_anchor_node_id)
          }
        }
      }

      if (config?.dataUnlink) {
        pull_datum(node_id)

        if (this._drag_along_node[node_id]) {
          for (let drag_along_node_id of this._drag_along_node[node_id]) {
            if (this._is_datum_node_id(drag_along_node_id)) {
              pull_datum(drag_along_node_id)
            }
          }
        }
      }
    } else if (this._is_int_node_id(node_id)) {
      //
    } else if (this._is_ext_node_id(node_id)) {
      const { type, pinId, subPinId } = segmentPlugNodeId(node_id)
      const int_node_id = getIntNodeId(type, pinId, subPinId)
      if (this._has_node(int_node_id)) {
        //
      } else {
        if (this._mode === 'none') {
          let anchor_node_id: string | undefined =
            this._get_exposed_pin_internal_node_id(type, pinId, subPinId)

          if (anchor_node_id) {
            const exposed_pin_node = this.get_node(node_id)

            const pin_node = this._node[anchor_node_id]

            const { l } = surfaceDistance(exposed_pin_node, pin_node)

            if (l > SURFACE_UNPLUG_DISTANCE) {
              this.unplug_exposed_pin(type, pinId, subPinId)

              this._refresh_compatible()
            }
          }
        }
      }
    } else if (this._is_err_node_id(node_id)) {
      const { unitId } = segmentErrNodeId(node_id)

      const err_node = this.get_node(node_id)

      const unit_node = this._node[unitId]

      const { l } = surfaceDistance(unit_node, err_node)

      if (l > 1.5 * LINK_DISTANCE) {
        this._removing_err = true

        this._sim_remove_unit_err(unitId)
        this._pod_take_unit_err(unitId)
      }
    }
  }

  private _state_duplicate_node = (node_id: string): string | null => {
    // console.log('Graph', '_sim_duplicate_node', node_id)

    let new_node_id: string | null
    if (this._is_unit_node_id(node_id)) {
      new_node_id = this._state_duplicate_unit(node_id)
    } else if (this._is_datum_node_id(node_id)) {
      new_node_id = this._sim_duplicate_datum(node_id)
    } else if (this._is_plug_node_id(node_id)) {
      new_node_id = this._sim_duplicate_exposed_pin(node_id)
    }

    return new_node_id
  }

  private _set_node_drag_along = (
    node_id: string,
    drag_along_node_id: string
  ): void => {
    // console.log('_set_node_drag_along', node_id)

    this._drag_along_node[node_id] = this._drag_along_node[node_id] ?? []
    this._drag_along_node[node_id].push(drag_along_node_id)

    this._drag_along_source[drag_along_node_id] = node_id
  }

  private _remove_node_drag_along = (
    node_id: string,
    drag_along_node_id: string
  ): void => {
    // console.log('_remove_node_drag_along', node_id, drag_along_node_id)

    if (!this._drag_along_node[node_id]) {
      return
    }

    remove(this._drag_along_node[node_id], drag_along_node_id)

    delete this._drag_along_source[drag_along_node_id]

    if (!this._drag_along_node[node_id].length) {
      delete this._drag_along_node[node_id]
    }

    delete this._drag_along_node[drag_along_node_id]
    delete this._drag_along_relative_position[drag_along_node_id]
  }

  private _on_node_clone_drag_start = (
    node_id: string,
    node_ids: string[],
    pointerId: number,
    clientX: number,
    clientY: number,
    deep: boolean
  ): string | null => {
    // console.log(
    //   'Graph',
    //   '_on_node_clone_drag_start',
    //   node_id,
    //   node_ids,
    //   pointerId,
    //   clientX,
    //   clientY,
    //   deep
    // )

    const { specs } = this.$props

    let new_node_id: string | null = null
    let new_node_ids: string[] = []
    let new_node_id_map: Dict<string> = {}

    if (!node_ids) {
      if (
        this._is_node_selected(node_id) &&
        (this._is_node_id(node_id) ||
          this._is_plug_node_id(node_id) ||
          this._is_datum_node_id(node_id))
      ) {
        node_ids = keys(this._selected_node_id)
      } else {
        node_ids = [node_id]
      }
    }

    const node_position = this._get_node_position(node_id)

    const new_bundle = this._sub_graph_selection(node_ids, deep)

    const position = this._screen_center()

    const { map_unit_id, map_merge_id, map_plug_id, map_datum_id, actions } =
      this.paste_bundle(new_bundle, position, false, false, deep)

    this._clone_drag_actions = actions

    new_node_ids = node_ids.map((node_id) => {
      return this._node_type__template(node_id, {
        unit: (unit_id: string) => {
          const new_unit_id = map_unit_id[unit_id]

          if (!new_unit_id) {
            return null
          }

          new_node_id_map[node_id] = new_unit_id

          return new_unit_id
        },
        link: (pin_node_id: string) => {
          const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

          if (!node_ids.includes(unitId)) {
            return null
          }

          const new_unit_id = map_unit_id[unitId]

          if (!new_unit_id) {
            return null
          }

          const new_pin_node_id = getPinNodeId(new_unit_id, type, pinId)

          new_node_id_map[node_id] = new_pin_node_id

          return new_pin_node_id
        },
        merge: (merge_node_id: string) => {
          const { mergeId } = segmentMergeNodeId(merge_node_id)

          const new_merge_id = map_merge_id[mergeId]

          if (!new_merge_id) {
            return null
          }

          const new_merge_node_id = getMergeNodeId(new_merge_id)

          new_node_id_map[node_id] = new_merge_node_id

          return new_merge_node_id
        },
        plug: (plug_node_id: string) => {
          const { type, pinId, subPinId } = segmentPlugNodeId(plug_node_id)

          const new_plug_sub_pin_id = map_plug_id[type][pinId][subPinId]

          if (!new_plug_sub_pin_id) {
            return null
          }

          const new_plug_node_id = getExtNodeId(
            type,
            pinId,
            new_plug_sub_pin_id
          )

          new_node_id_map[node_id] = new_plug_node_id

          return new_plug_node_id
        },
        datum: (datum_node_id: string) => {
          const { datumId } = segmentDatumNodeId(datum_node_id)

          const newDatumId = map_datum_id[datumId]

          if (newDatumId) {
            const new_datum_node_id = getDatumNodeId(newDatumId)

            new_node_id_map[datum_node_id] = new_datum_node_id

            return new_datum_node_id
          }

          return null
        },
        err: (err_node_id: string) => {
          return null
        },
      })
    })

    const datum_node_ids = node_ids.filter((node_id) => {
      return this._is_datum_node_id(node_id)
    })

    for (const datum_node_id of datum_node_ids) {
      const { datumId } = segmentDatumNodeId(datum_node_id)

      const datum_pin_node_id = this._datum_to_pin[datum_node_id]

      if (datum_pin_node_id) {
        const new_datum_pin_node_id = new_node_id_map[datum_pin_node_id]

        if (new_datum_pin_node_id) {
          const new_datum_node_id = this._pin_to_datum[new_datum_pin_node_id]

          if (new_datum_node_id) {
            new_node_id_map[datum_node_id] = new_datum_node_id
          }
        }
      }
    }

    new_node_ids = new_node_ids.filter((n) => !!n)

    new_node_id = new_node_id_map[node_id] ?? node_id

    const drag = (selected_node_id: string, next_node_id: string) => {
      if (!this._has_node(next_node_id)) {
        return
      }

      const selected_node_position =
        this._get_anchor_node_position(selected_node_id)

      const relative_position = subtractVector(
        selected_node_position,
        node_position
      )

      deepSet(
        this._drag_along_relative_position,
        [new_node_id, next_node_id],
        relative_position
      )

      const next_position = selected_node_position

      this._set_node_position(next_node_id, next_position)

      if (this._is_ext_node_id(selected_node_id)) {
        const int_node_id = getIntNodeIdFromExtNodeId(selected_node_id)
        const next_int_node_id = getIntNodeIdFromExtNodeId(next_node_id)

        const int_pin_node_id = this._int_to_node[int_node_id]
        const next_int_pin_node_id = this._int_to_node[next_int_node_id]

        if (int_pin_node_id && !next_int_pin_node_id) {
          const int_pin_node_position = this._get_node_position(int_pin_node_id)

          this._set_node_position(next_int_node_id, int_pin_node_position)
        }
      }

      if (selected_node_id !== node_id) {
        this._set_node_drag_along(new_node_id, next_node_id)

        this._drag_node_pointer_id[next_node_id] = pointerId

        this.__on_node_drag_start(
          next_node_id,
          pointerId,
          next_position.x,
          next_position.y
        )
      }

      this._set_node_fixed(next_node_id, true)
    }

    for (const selected_node_id of node_ids) {
      const next_node_id = new_node_id_map[selected_node_id]

      if (!next_node_id) {
        continue
      }

      drag(selected_node_id, next_node_id)

      if (this._is_unit_node_id(selected_node_id)) {
        this._for_each_unit_pin(
          selected_node_id,
          (pin_node_id, type, pin_id) => {
            if (!this._is_node_selected(pin_node_id)) {
              const next_pin_node_id = getPinNodeId(next_node_id, type, pin_id)

              drag(pin_node_id, next_pin_node_id)
            }
          }
        )
      }
    }

    this._clone_drag = true
    this._clone_drag_node_id = node_id
    this._clone_drag_clone_id = new_node_id
    this._clone_node_ids = new_node_ids

    this._force_pointer_drag_swap(
      node_id,
      new_node_id,
      pointerId,
      clientX,
      clientY
    )

    if (deep) {
      for (const node_id of node_ids) {
        if (this._is_unit_node_id(node_id)) {
          const new_unit_id = new_node_id_map[node_id]

          const new_data_node_ids = this._sim_replicate_unit_data(
            node_id,
            new_unit_id
          )

          for (const new_datum_node_id of new_data_node_ids) {
            new_node_ids.push(new_datum_node_id)

            this._set_node_drag_along(new_node_id, new_datum_node_id)

            const new_datum_pin_node_id = this._datum_to_pin[new_datum_node_id]

            if (new_datum_pin_node_id) {
              const { type, pinId } = segmentLinkPinNodeId(
                new_datum_pin_node_id
              )

              const pin_node_id = getPinNodeId(node_id, type, pinId)

              const datum_node_id = this._pin_to_datum[pin_node_id]

              if (datum_node_id) {
                const datum_position = this._get_node_position(datum_node_id)

                this._set_node_position(new_datum_node_id, datum_position)
              }
            }
          }
        }
      }
    }

    for (const new_node_id of new_node_ids) {
      this._ascend_node(new_node_id)
    }

    for (const node_id of node_ids) {
      this._refresh_node_color(node_id)
    }

    for (const new_node_id of new_node_ids) {
      this._refresh_node_color(new_node_id)
    }

    this._set_node_pointer_capture(node_id, pointerId)

    return new_node_id
  }

  private _on_node_clone_drag_end = (clone_node_id: string) => {
    // console.log('Graph', '_on_node_clone_drag_end', node_id)

    const actions = this._clone_drag_actions

    const bulk = { actions }

    this._pod.$bulkEdit(bulk)

    for (const cloned_node_id of this._clone_node_ids) {
      if (this._is_unit_node_id(cloned_node_id)) {
        if (this._is_unit_component(cloned_node_id)) {
          this._sim_add_sub_component(cloned_node_id, {}, undefined, true)
          this._connect_sub_component(cloned_node_id)
        }
      }

      this._refresh_node_color(cloned_node_id)
    }

    const bulk_action = makeBulkEditAction(actions)

    this._clone_drag = false
    this._clone_drag_node_id = null
    this._clone_drag_clone_id = null
    this._clone_drag_actions = []
    this._clone_node_ids = []

    this._dispatch_action(bulk_action)
  }

  private _on_node_red_drag_start = (
    node_id: string,
    pointer_id: number,
    selected_node_ids: string[]
  ): void => {
    // console.log(
    //   '_on_node_red_drag_start',
    //   node_id,
    //   pointer_id,
    //   selected_node_ids
    // )

    this._ascend_node(node_id)

    if (this._is_unit_node_id(node_id)) {
      this._on_unit_red_drag_start(node_id, pointer_id, selected_node_ids)
    } else if (this._is_link_pin_node_id(node_id)) {
      const { unitId } = segmentLinkPinNodeId(node_id)

      this._on_unit_red_drag_start(unitId, pointer_id, selected_node_ids)
    }
  }

  private _on_node_red_drag_end = (node_id: string): void => {
    if (this._is_unit_node_id(node_id)) {
      this._on_unit_red_drag_end(node_id)
    } else if (this._is_link_pin_node_id(node_id)) {
      const { unitId } = segmentLinkPinNodeId(node_id)
      this._on_unit_red_drag_end(unitId)
    } else if (this._is_datum_node_id(node_id)) {
      this._on_datum_red_drag_end(node_id)
    }
  }

  private _on_datum_red_drag_end = (datum_node_id: string): void => {
    // console.log('Graph', '_on_datum_red_drag_end' , datum_node_id)

    this._drop_datum(datum_node_id)
  }

  private _on_unit_red_drag_end = (unit_id: string): void => {
    this._descend_node(unit_id)
  }

  private _on_unit_red_drag_start = (
    unit_id: string,
    pointer_id: number,
    selected_node_ids: string[]
  ): void => {
    // console.log('Graph', '_on_unit_red_drag_start', unit_id, pointer_id)

    let node_ids = { [unit_id]: true }

    if (selected_node_ids.includes(unit_id)) {
      for (const selected_node_id of selected_node_ids) {
        node_ids[selected_node_id] = true
      }
    }

    for (const node_id in node_ids) {
      if (this._is_unit_node_id(node_id)) {
        this._remove_unit_merges__predicated(
          node_id,
          (pin_node_id, merge_node_id) => {
            if (selected_node_ids.includes(merge_node_id)) {
              const merge = this._get_merge(merge_node_id)

              const unit_ids = keys(merge)

              let not_selected_count = 0

              const not_selected_merge = {}

              for (const unit_id of unit_ids) {
                if (!selected_node_ids.includes(unit_id)) {
                  not_selected_count++

                  not_selected_merge[unit_id] = clone(merge[unit_id])
                }
              }

              forEachPinOnMerge(not_selected_merge, (unitId, type, pinId) => {
                const pin_node_id = getPinNodeId(unitId, type, pinId)

                this._remove_pin_from_merge(merge_node_id, pin_node_id)
              })

              if (not_selected_count > 1) {
                const new_merge_id = this._new_merge_id()

                this._add_merge(new_merge_id, not_selected_merge)
              }
            } else {
              return true
            }
          }
        )
      }

      for (const node_id in node_ids) {
        if (this._is_unit_node_id(node_id)) {
          this._for_each_unit_pin(node_id, (pin_node_id) => {
            if (this._has_node(pin_node_id)) {
              node_ids[pin_node_id] = true
            }
          })
        }
      }

      for (const node_id in node_ids) {
        this._ascend_node(node_id)

        if (this._is_unit_node_id(node_id)) {
          this._for_each_unit_pin(node_id, (pin_node_id) => {
            const merge_node_id = this._get_pin_merge_node_id(pin_node_id)

            const anchor_node_id = merge_node_id ?? pin_node_id

            const drag_along_node = this._drag_along_node[node_id] ?? []

            if (!drag_along_node.includes(anchor_node_id)) {
              this._set_node_drag_along(node_id, anchor_node_id)
            }

            const datum_node_id = this._pin_to_datum[pin_node_id]

            if (datum_node_id) {
              if (this._is_node_visible(datum_node_id)) {
                this._set_node_drag_along(node_id, datum_node_id)
              }
            }
          })
        }
      }
    }

    const unit_merge_node_id = this._ref_unit_to_merge[unit_id]

    if (unit_merge_node_id) {
      const self_pin_node_id = getSelfPinNodeId(unit_id)

      this._remove_pin_from_merge(unit_merge_node_id, self_pin_node_id)
    }

    this._set_node_pointer_capture(unit_id, pointer_id)

    for (const node_id in node_ids) {
      this._refresh_node_color(node_id)
    }
  }

  private _on_node_blue_drag_start = (
    node_id: string,
    pointer_id: number
  ): void => {
    if (this._is_unit_node_id(node_id)) {
      this._on_unit_blue_drag_start(node_id, pointer_id)
    } else if (this._is_datum_node_id(node_id)) {
      this._on_datum_blue_drag_start(node_id, pointer_id)
    } else if (this._is_plug_node_id(node_id)) {
      this._on_plug_blue_drag_start(node_id, pointer_id)
    }

    this._set_node_pointer_capture(node_id, pointer_id)
  }

  private _on_node_blue_drag_end = (
    node_id: string,
    pointer_id: number
  ): void => {
    if (this._is_unit_node_id(node_id)) {
      this._on_unit_blue_drag_end(node_id)
    } else if (this._is_link_pin_node_id(node_id)) {
      const { unitId } = segmentLinkPinNodeId(node_id)
      this._on_unit_blue_drag_end(unitId)
    } else if (this._is_datum_node_id(node_id)) {
      this._on_datum_blue_drag_end(node_id)
    }
  }

  private _on_unit_blue_drag_start = (
    unit_id: string,
    pointer_id: number
  ): void => {
    this._blue_drag = true
    this._blue_drag_init_id = unit_id
    this._blue_drag_init_start_position =
      this._get_unit_pin_node_position(unit_id)
    this._blue_drag_init_pin_to_anchor = this._remove_unit_merges(unit_id)
    this._blue_drag_init_anchor_to_pin = invertObj(
      this._blue_drag_init_pin_to_anchor
    )

    this._set_all_unit_node_fixed(true)
    this._refresh_unit_fixed(unit_id)

    this._refresh_unit_blue_drag_anchor(
      this._blue_drag_init_pin_to_anchor,
      true
    )

    this._ascend_node(unit_id)
  }

  private _on_plug_blue_drag_start = (
    unit_id: string,
    pointer_id: number
  ): void => {
    this._blue_drag = true
    this._blue_drag_init_id = unit_id
    this._blue_drag_init_start_position =
      this._get_unit_pin_node_position(unit_id)
    this._blue_drag_init_pin_to_anchor = this._remove_unit_merges(unit_id)
    this._blue_drag_init_anchor_to_pin = invertObj(
      this._blue_drag_init_pin_to_anchor
    )

    this._set_all_unit_node_fixed(true)
    this._refresh_unit_fixed(unit_id)

    this._refresh_unit_blue_drag_anchor(
      this._blue_drag_init_pin_to_anchor,
      true
    )

    this._ascend_node(unit_id)
  }

  private _on_datum_blue_drag_start = (
    datum_node_id: string,
    pointer_id: number
  ): void => {
    this._ascend_node(datum_node_id)
  }

  private _on_datum_blue_drag_end = (datum_node_id: string): void => {
    //
  }

  private _abort_blue_drag_hover = () => {
    this._blue_drag_hover_return()

    this._refresh_unit_fixed(this._blue_drag_init_id)

    this._for_each_unit_output(this._blue_drag_init_id, (output_node_id) => {
      this._set_output_reduced(output_node_id, false)
    })

    this._blue_drag_hover_unit_id = null
  }

  private _refresh_unit_blue_drag_anchor = (
    unit_merge_anchor: Dict<string>,
    anchored: boolean
  ): void => {
    for (const pin_node_id in unit_merge_anchor) {
      const { type } = segmentLinkPinNodeId(pin_node_id)
      const merge_anchor_node_id = unit_merge_anchor[pin_node_id]
      if (anchored) {
        const merge_anchor_position =
          this._get_node_position(merge_anchor_node_id)
        this._set_node_position(pin_node_id, merge_anchor_position)
      }
      if (merge_anchor_node_id) {
        if (type === 'input') {
          if (this._is_output_pin_node_id(merge_anchor_node_id)) {
            this._set_output_reduced(merge_anchor_node_id, anchored)
          }
        } else {
          this._set_output_reduced(pin_node_id, anchored)
        }
        this._set_node_fixed(pin_node_id, anchored)
      }
    }
  }

  private _on_unit_blue_drag_move = (unit_id: string): void => {
    if (this._blue_drag_init_id === unit_id) {
      const init_unit_position = this._node[this._blue_drag_init_id]
      const init_unit_start_position =
        this._blue_drag_init_start_position[unit_id]

      if (this._blue_drag_hover_unit_id) {
        const hover_init_position =
          this._blue_drag_hover_position[this._blue_drag_hover_unit_id]

        const d = pointDistance(init_unit_position, hover_init_position)

        if (d > NEAR / 2) {
          this._abort_blue_drag_hover()
        }
      } else {
        if (
          pointDistance(init_unit_position, init_unit_start_position) >
          NEAR / 2
        ) {
          this._refresh_unit_fixed(unit_id)
          this._refresh_unit_blue_drag_anchor(
            this._blue_drag_init_pin_to_anchor,
            false
          )
        } else {
          this._refresh_unit_blue_drag_anchor(
            this._blue_drag_init_pin_to_anchor,
            true
          )
        }
      }

      const nearest_unit_id = this._find_nearest_core_id(
        unit_id,
        NEAR / 2,
        (a, b) => pointDistance(a, b),
        (node_id: string) => {
          if (node_id === this._blue_drag_hover_unit_id) {
            return false
          }
          return true
        }
      )

      if (nearest_unit_id) {
        if (this._blue_drag_hover_unit_id) {
          this._blue_drag_hover_return()
        }

        this._blue_drag_hover_unit_id = nearest_unit_id

        this._blue_drag_hover_merge_anchor =
          this._remove_unit_merges(nearest_unit_id)

        this._blue_drag_hover_position =
          this._get_unit_pin_node_position(nearest_unit_id)

        this._set_all_unit_node_fixed(true)

        this._refresh_unit_fixed(unit_id)

        this._refresh_unit_fixed(nearest_unit_id)
        this._negate_unit_layer(nearest_unit_id)

        const blue_drag_init_unit_position =
          this._blue_drag_init_start_position[this._blue_drag_init_id]

        this._set_node_position(nearest_unit_id, blue_drag_init_unit_position)
        this._set_node_fixed(nearest_unit_id, true)

        let remaining_init_merge_anchor = clone(
          this._blue_drag_init_pin_to_anchor
        )

        this._for_each_unit_pin(
          this._blue_drag_hover_unit_id,
          (pin_node_id: string, type: IO) => {
            let matched = false

            for (const init_pin_node_id in remaining_init_merge_anchor) {
              const { type: _type } = segmentLinkPinNodeId(init_pin_node_id)

              if (type === _type) {
                if (
                  this._is_pin_pin_type_match(
                    pin_node_id,
                    type,
                    init_pin_node_id,
                    _type
                  )
                ) {
                  const init_anchor_node_id =
                    remaining_init_merge_anchor[init_pin_node_id]
                  const init_pin_node_position =
                    this._blue_drag_init_start_position[init_pin_node_id]

                  this._blue_drag_hover_merge_swap[pin_node_id] =
                    init_anchor_node_id

                  this._set_node_position(pin_node_id, init_pin_node_position)

                  if (type === 'input') {
                    if (this._is_output_pin_node_id(init_anchor_node_id)) {
                      this._set_output_reduced(init_anchor_node_id, true)
                    }
                  } else {
                    this._set_output_reduced(pin_node_id, true)
                  }

                  this._set_node_fixed(pin_node_id, true)

                  remaining_init_merge_anchor = _dissoc(
                    remaining_init_merge_anchor,
                    init_pin_node_id
                  )

                  matched = true

                  break
                }
              }
            }

            if (!matched) {
              // TODO
            }
          }
        )

        let remaining_hover_merge_anchor = clone(
          this._blue_drag_hover_merge_anchor
        )

        this._for_each_unit_pin(
          this._blue_drag_init_id,
          (pin_node_id: string, type) => {
            for (const hover_pin_node_id in remaining_hover_merge_anchor) {
              const { type: _type } = segmentLinkPinNodeId(hover_pin_node_id)
              if (type === _type) {
                if (
                  this._is_pin_pin_type_match(
                    pin_node_id,
                    type,
                    hover_pin_node_id,
                    _type
                  )
                ) {
                  const hover_anchor_node_id =
                    remaining_hover_merge_anchor[hover_pin_node_id]
                  const hover_pin_node_position =
                    this._blue_drag_hover_position[hover_pin_node_id]

                  this._blue_drag_init_merge_swap[pin_node_id] =
                    hover_anchor_node_id

                  this._set_node_position(pin_node_id, hover_pin_node_position)

                  if (type === 'input') {
                    if (this._is_output_pin_node_id(hover_anchor_node_id)) {
                      this._set_output_reduced(hover_anchor_node_id, true)
                    }
                  } else {
                    this._set_output_reduced(pin_node_id, true)
                  }

                  this._set_node_fixed(pin_node_id, true)

                  remaining_hover_merge_anchor = _dissoc(
                    remaining_hover_merge_anchor,
                    hover_pin_node_id
                  )
                  break
                }
              }
            }
          }
        )
      }
    }
  }

  private _abort_blue_drag = (unit_id: string) => {
    this._refresh_all_node_fixed()
    this._refresh_unit_layer(unit_id)

    this._blue_drag = false
    this._blue_drag_init_id = null
    this._blue_drag_init_start_position = {}
    this._blue_drag_init_pin_to_anchor = {}
    this._blue_drag_init_anchor_to_pin = {}
    this._blue_drag_init_merge_swap = {}
    this._blue_drag_hover_unit_id = null
    this._blue_drag_hover_position = {}
    this._blue_drag_hover_merge_anchor = {}
    this._blue_drag_hover_merge_swap = {}

    this._descend_node(unit_id)
  }

  private _on_unit_blue_drag_end = (unit_id: string): void => {
    if (this._blue_drag_hover_unit_id) {
      this._refresh_unit_layer(this._blue_drag_hover_unit_id)
      this._refresh_unit_fixed(this._blue_drag_hover_unit_id)

      for (const pin_node_id in this._blue_drag_hover_merge_swap) {
        const merge_anchor_node_id =
          this._blue_drag_hover_merge_swap[pin_node_id]

        if (merge_anchor_node_id) {
          this._merge_pin_pin(pin_node_id, merge_anchor_node_id)
        }
      }
    } else {
      for (const node_id in this._blue_drag_init_start_position) {
        const position = this._blue_drag_init_start_position[node_id]

        this._set_node_position(node_id, position)
      }

      for (const pin_node_id in this._blue_drag_init_pin_to_anchor) {
        this._drop_node(pin_node_id)
      }
    }

    this._abort_blue_drag(unit_id)
  }

  private _force_pointer_drag_swap = (
    node_id: string,
    new_node_id: string,
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    this._force_pointer_drop_node(node_id, pointerId, clientX, clientY)
    this._force_pointer_drag_node(new_node_id, pointerId, clientX, clientY)
  }

  private _sim_replicate_unit_data = (
    unit_id: string,
    new_unit_id: string
  ): string[] => {
    // console.log('Graph', '_sim_replicate_unit_data', node_id)

    const unit_data = this._get_unit_data(unit_id)

    const { input, output } = unit_data

    const new_data_node_ids = []

    const set_pin_datum = (type: IO, pin_id: string) => {
      const new_pin_node_id = getPinNodeId(new_unit_id, type, pin_id)

      const tree = deepGetOrDefault(unit_data, [type, pin_id], undefined)

      const position = this._predict_pin_datum_initial_position(new_pin_node_id)

      const current_datum_node_id = this._pin_to_datum[new_pin_node_id]

      if (current_datum_node_id) {
        new_data_node_ids.push(current_datum_node_id)

        if (tree) {
          this.__graph_debug_set_pin_data(
            new_pin_node_id,
            current_datum_node_id,
            tree.value
          )
        }
      } else {
        const new_datum_id = this._new_datum_id()

        const new_datum_node_id = getDatumNodeId(new_datum_id)

        new_data_node_ids.push(new_datum_node_id)

        this._sim_add_pin_datum_tree(
          new_unit_id,
          type,
          pin_id,
          new_datum_id,
          tree,
          position,
          false
        )
      }
    }

    for (const input_id in input) {
      set_pin_datum('input', input_id)
    }

    for (const output_id in output) {
      set_pin_datum('output', output_id)
    }

    if (this._is_unit_component(unit_id)) {
      const component = this._get_sub_component(unit_id)

      const { $children } = component

      // const children = $children.map((c) => {
      //   const { id } = c.constructor as typeof Component
      //   return {
      //     id,
      //   }
      // })

      // unit.children = children
    }

    return new_data_node_ids
  }

  private _on_multiselect_area_start = (
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    // console.log('Graph', '_on_multiselect_area_start')

    this._multiselect_area_ing = true
    this._multiselect_area_start_position = {
      x: clientX,
      y: clientY,
    }
    this._multiselect_area_svg.$element.style.display = 'block'
  }

  private _on_multiselect_area = (event: UnitPointerEvent): void => {
    const { pointerId, clientX, clientY } = event
    const { x, y } = this._multiselect_area_start_position
    const minX = Math.min(x, clientX)
    const maxX = Math.max(x, clientX)
    const minY = Math.min(y, clientY)
    const maxY = Math.max(y, clientY)
    this._multiselect_area_rect = {
      x0: minX,
      y0: minY,
      x1: maxX,
      y1: maxY,
    }
    this._tick_multiselect_area()
  }

  private _on_multiselect_area_end = (): void => {
    // console.log('Graph', '_on_multiselect_area_end')

    this._multiselect_area_ing = false
    this._multiselect_area_rect = NOT_SELECTED_AREA
    this._multiselect_area_node = {}
    this._multiselect_area_svg.$element.style.display = 'none'

    this._tick_multiselect_area()

    this._refresh_all_selected_pin_datum_visible()
  }

  private _tick_multiselect_area = (): void => {
    const { x0, y0, x1, y1 } = this._multiselect_area_rect

    const { $width, $height } = this.$context

    this._multiselect_area_svg_rect.setProp('x', x0)
    this._multiselect_area_svg_rect.setProp('y', y0)
    this._multiselect_area_svg_rect.setProp('width', x1 - x0)
    this._multiselect_area_svg_rect.setProp('height', y1 - y0)

    const on = (node_id: string) => {
      if (!this._multiselect_area_node[node_id]) {
        this._multiselect_area_node[node_id] = true

        if (this._selected_node_id[node_id]) {
          this.deselect_node(node_id)
        } else {
          this._select_node(node_id)
        }
      }
    }

    const off = (node_id: string) => {
      if (this._multiselect_area_node[node_id]) {
        this._multiselect_area_node[node_id] = false

        this.deselect_node(node_id)
      }
    }

    const toggle = (inside: boolean, node_id: string) => {
      if (inside) {
        on(node_id)
      } else {
        off(node_id)
      }
    }

    if (this._tree_layout) {
      const children = this._get_current_layout_layer_children()

      const parent_layout_layer = this._get_current_layout_layer()

      const { scrollTop = 0 } = parent_layout_layer.content.$element

      for (let i = 0; i < children.length; i++) {
        const child_id = children[i]

        const layout_node = this._layout_node[child_id]

        const cx = layout_node.x + $width / 2
        const cy = layout_node.y + $height / 2

        const y0_ = y0 + scrollTop
        const y1_ = y1 + scrollTop

        const inside = cx >= x0 && cx <= x1 && cy >= y0_ && cy <= y1_

        toggle(inside, child_id)
      }
    } else {
      const { x: ix0, y: iy0 } = this._screen_to_world(x0, y0)
      const { x: ix1, y: iy1 } = this._screen_to_world(x1, y1)

      for (let node_id in this._node) {
        const node = this.get_node(node_id)

        if (this._is_node_selectable(node_id)) {
          const { x, y } = node

          const inside = x >= ix0 && x <= ix1 && y >= iy0 && y <= iy1

          toggle(inside, node_id)
        }
      }
    }
  }

  private _on_translate = (event: UnitPointerEvent): void => {
    // console.log('Graph', '_on_translate')

    const { pointerId, clientX, clientY } = event

    const { x, y } = this._pointer_position[pointerId]

    this._translate_x = clientX - x
    this._translate_y = clientY - y

    const zoom = translate(this._zoom, this._translate_x, this._translate_y)

    this.set_zoom(zoom)

    this._translate_pressed_node()

    if (!this._search_hidden) {
      this._start_graph_simulation(LAYER_SEARCH)
    }
  }

  private _ascend_z_count: number = 0
  private _ascend_node_dict: Dict<boolean> = {}

  private _ascend_node_z = (node_id: string): void => {
    // console.log('Graph', '_ascend_node_z', node_id)

    this._ascend_z_count++
    this._ascend_node_dict[node_id] = true

    if (this._ascend_z_count === 1) {
      this._zoom_comp_alt.$element.style.pointerEvents = 'inherit'
    }

    const node_comp = this._get_node_comp(node_id)

    this._zoom_comp.removeChild(node_comp)
    this._zoom_comp_alt.appendChild(node_comp, 'default')

    if (this._is_link_pin_node_id(node_id)) {
      const link_id = getPinLinkIdFromPinNodeId(node_id)

      const link_comp = this._link_comp[link_id]

      this._zoom_comp.removeChild(link_comp)
      this._zoom_comp_alt.appendChild(link_comp, 'svg')
    }
  }

  private _descend_node_z = (node_id: string): void => {
    if (!this._ascend_node_dict[node_id]) {
      return
    }
    // console.log('Graph', '_descend_node_z', node_id)

    this._ascend_z_count--
    delete this._ascend_node_dict[node_id]

    const node_comp = this._get_node_comp(node_id)
    this._zoom_comp_alt.removeChild(node_comp)
    this._zoom_comp.appendChild(node_comp, 'default')

    if (this._is_link_pin_node_id(node_id)) {
      const link_id = getPinLinkIdFromPinNodeId(node_id)
      const link_comp = this._link_comp[link_id]
      this._zoom_comp_alt.removeChild(link_comp)
      this._zoom_comp.appendChild(link_comp, 'svg')
    }

    if (this._ascend_z_count === 0) {
      this._zoom_comp_alt.$element.style.pointerEvents = 'none'
    }
  }

  private _negate_unit_layer = (unit_id: string): void => {
    // console.log('Graph', '_negate_unit_layer', unit_id)

    this._set_unit_layer(unit_id, -LAYER_NORMAL)
  }

  private _negate_node_layer = (node_id: string): void => {
    // console.log('Graph', '_negate_node_layer', node_id)

    const default_layer = this._get_node_default_layer(node_id)

    this._set_node_layer(node_id, -default_layer)
  }

  private _set_node_pointer_capture = (
    node_id: string,
    pointer_id: number
  ): void => {
    // console.log('Graph', '_set_node_pointer_capture', node_id, pointer_id)

    const node_comp = this._get_node_comp(node_id)

    node_comp.setPointerCapture(pointer_id)
  }

  private _set_node_pointer_events = (
    node_id: string,
    pointerEvents: string
  ): void => {
    const node_comp = this._get_node_comp(node_id)
    node_comp.$element.style.pointerEvents = pointerEvents
  }

  private _release_node_pointer_capture = (
    node_id: string,
    pointer_id: number
  ): void => {
    // console.log('Graph', '_release_node_pointer_capture', node_id, pointer_id)

    const node_comp = this._get_node_comp(node_id)

    if (node_comp.hasPointerCapture(pointer_id)) {
      node_comp.releasePointerCapture(pointer_id)
    }
  }

  private _ascend_node = (node_id: string): void => {
    // console.log('Graph', '_ascend_node', node_id)

    this.__ascend_node(node_id)

    if (this._is_unit_node_id(node_id)) {
      const ascend_pin = (pin_node_id: string, type: IO) => {
        if (!this._is_link_pin_merged(pin_node_id)) {
          this.__ascend_node(pin_node_id)

          const datum_node_id = this._pin_to_datum[pin_node_id]

          if (datum_node_id) {
            this.__ascend_node(datum_node_id)
          }
        }

        const { pinId, subPinId } =
          this._spec_get_pin_node_plug_spec(type, pin_node_id) ?? {}

        if (pinId && subPinId) {
          const ext_node_id = getExtNodeId(type, pinId, subPinId)

          this.__ascend_node(ext_node_id)
        }
      }

      this._for_each_unit_pin(node_id, ascend_pin)

      if (this._err[node_id]) {
        const err_node_id = getErrNodeId(node_id)

        this.__ascend_node(err_node_id)
      }
    } else if (this._is_ext_node_id(node_id)) {
      const { pinId, type, subPinId } = segmentPlugNodeId(node_id)

      const int_node_id = getIntNodeId(type, pinId, subPinId)

      if (this._has_node(int_node_id)) {
        this.__ascend_node(int_node_id)
      }

      const datum_node_id = this._plug_to_datum[node_id]

      if (datum_node_id) {
        this.__ascend_node(datum_node_id)
      }
    } else if (this._is_int_node_id(node_id)) {
      const { pinId, type, subPinId } = segmentPlugNodeId(node_id)

      const ext_node_id = getExtNodeId(type, pinId, subPinId)

      this.__ascend_node(ext_node_id)
    }
  }

  private __ascend_node = (node_id: string) => {
    if (this._ascend_node_dict[node_id]) {
      return
    }

    this._ascend_node_z(node_id)
    this._negate_node_layer(node_id)
  }

  private __descend_node = (node_id: string) => {
    if (!this._ascend_node_dict[node_id]) {
      return
    }

    this._descend_node_z(node_id)
    this._refresh_node_layer(node_id)
  }

  private _descend_node = (node_id: string): void => {
    // console.log('Graph', '_descend_node', node_id)

    this.__descend_node(node_id)

    if (this._is_unit_node_id(node_id)) {
      this._for_each_unit_pin(node_id, (pin_node_id: string, type: IO) => {
        if (!this._is_link_pin_merged(pin_node_id)) {
          this.__descend_node(pin_node_id)

          const datum_node_id = this._pin_to_datum[pin_node_id]

          if (datum_node_id) {
            this.__descend_node(datum_node_id)
          }
        }

        const ext_node_id = this._pin_to_ext[type][pin_node_id]

        if (ext_node_id) {
          const int_node_id = this._pin_to_ext[type][pin_node_id]

          this._refresh_plug_layer(ext_node_id, int_node_id)
        }
      })

      if (this._err[node_id]) {
        const err_node_id = getErrNodeId(node_id)

        this.__descend_node(err_node_id)
      }
    } else if (this._is_ext_node_id(node_id)) {
      const { pinId, type, subPinId } = segmentPlugNodeId(node_id)

      const int_node_id = getIntNodeId(type, pinId, subPinId)

      this.__descend_node(int_node_id)

      const datum_node_id = this._plug_to_datum[node_id]

      if (datum_node_id) {
        this.__descend_node(datum_node_id)
      }
    } else if (this._is_int_node_id(node_id)) {
      const { pinId, type, subPinId } = segmentPlugNodeId(node_id)

      const ext_node_id = getExtNodeId(type, pinId, subPinId)

      this._descend_node(ext_node_id)
    }
  }

  private _selection_rotation_unlisten: Dict<Unlisten> = {}

  private _drag_node_closest_compatible_node_id: Dict<string> = {}

  private _start_selection_rotation = (node_id: string): void => {
    const selection = this._node_selection[node_id]

    const { paddingX, paddingY } = this._get_selection_opt(node_id)

    const strokeDashOffset = this._get_node_selection_dashoffset(
      node_id,
      paddingX,
      paddingY
    )

    let offset = 0

    this._selection_rotation_unlisten[node_id] = animateSimulate(
      this.$system,
      { offset },
      () => {
        offset = (offset + 0.6) % Number.MAX_SAFE_INTEGER

        return {
          offset,
        }
      },
      [['offset', ANIMATION_DELTA_THRESHOLD / 10]],
      ({ offset }) => {
        selection.setProp('strokeDashOffset', strokeDashOffset + offset)

        return false
      },
      () => {
        //
      }
    )
  }

  private _stop_selection_rotation = (node_id: string) => {
    const selection = this._node_selection[node_id]

    const unlisten = this._selection_rotation_unlisten[node_id]

    if (unlisten) {
      unlisten()

      delete this._selection_rotation_unlisten[node_id]

      selection._selection.$element.style.transform = `translate(-50%, -50%)`
    }
  }

  private _set_pressed_node_closest_compatible = (
    pressed_node_id: string,
    closest_compatible_node_id: string
  ) => {
    this._start_selection_rotation(closest_compatible_node_id)

    this._drag_node_closest_compatible_node_id[pressed_node_id] =
      closest_compatible_node_id
  }

  private _remove_pressed_node_closest_compatible = (
    pressed_node_id: string
  ) => {
    const closest_compatible_node_id =
      this._drag_node_closest_compatible_node_id[pressed_node_id]

    this._stop_selection_rotation(closest_compatible_node_id)

    delete this._drag_node_closest_compatible_node_id[pressed_node_id]
  }

  private _tick_closest_compatible_selection = (pressed_node_id: string) => {
    const { node_id: closest_compatible_node_id } =
      this._get_closest_compatible(pressed_node_id)

    const current_closest_compatible_node_id =
      this._drag_node_closest_compatible_node_id[pressed_node_id]

    if (closest_compatible_node_id) {
      if (current_closest_compatible_node_id) {
        if (current_closest_compatible_node_id === closest_compatible_node_id) {
          //
        } else {
          this._stop_selection_rotation(current_closest_compatible_node_id)

          this._set_pressed_node_closest_compatible(
            pressed_node_id,
            closest_compatible_node_id
          )
        }
      } else {
        this._set_pressed_node_closest_compatible(
          pressed_node_id,
          closest_compatible_node_id
        )
      }
    } else {
      if (current_closest_compatible_node_id) {
        this._remove_pressed_node_closest_compatible(pressed_node_id)
      }
    }
  }

  private _on_pointer_move = (
    event: UnitPointerEvent,
    _event: PointerEvent
  ) => {
    // console.log('Graph', '_on_pointer_move')

    const { specs } = this.$props

    const { pointerId, clientX, clientY } = event

    const pointer_down_position = this._pointer_down_position[pointerId]

    if (this._pointer_down[pointerId]) {
      this._pointer_down_move_count[pointerId]++
    }

    if (!this._collapsing && !this._capturing_gesture && !this._removing_err) {
      if (
        this._multiselect_area_ing &&
        this._pointer_down_count === 1 &&
        this._pressed_node_pointer_count === 0
      ) {
        this._on_multiselect_area(event)
      }
    }

    const pressed_node_id = this._pointer_id_pressed_node_id[pointerId]
    const resize_unit_id = this._resize_pointer_id_node_id[pointerId]

    if (
      !pressed_node_id &&
      !resize_unit_id &&
      !this._collapsing &&
      !this._capturing_gesture &&
      !this._tree_layout &&
      !this._multiselect_area_ing &&
      !this._removing_err &&
      !this._drag_and_drop
    ) {
      if (
        (this._pointer_down_count === this._pressed_node_pointer_count + 1 ||
          this._pointer_down_count === this._resize_pointer_count + 1) &&
        !this._pointer_id_pressed_node_id[pointerId] &&
        this._pointer_position[pointerId]
      ) {
        this._on_translate(event)
      }
    }

    this._pointer_position[pointerId] = {
      x: clientX,
      y: clientY,
    }

    if (pressed_node_id) {
      if (this._edit_node_name_id === pressed_node_id) {
        return
      }

      if (
        this._node_pressed_count[pressed_node_id] === 1 &&
        this._edit_datum_node_id !== pressed_node_id &&
        !this._resize_node_id_pointer_id[pressed_node_id] &&
        !this._core_component_unlocked[pressed_node_id] &&
        !this._capturing_gesture
      ) {
        if (this._tree_layout) {
          if (this._is_unit_node_id(pressed_node_id)) {
            if (this._is_unit_component(pressed_node_id)) {
              if (this._layout_drag_node[pressed_node_id]) {
                this._on_layout_component_drag_move(pressed_node_id, event)
              } else {
                this._on_layout_component_drag_start(pressed_node_id, event)
              }
            }
          }
        } else {
          this._tick_closest_compatible_selection(pressed_node_id)

          if (this._is_draggable_mode()) {
            // delay "drag start" conditioning it to pointer's "first move"
            if (!this._drag_node_id[pressed_node_id]) {
              if (this._is_freeze_mode()) {
                const pointer_down_position =
                  this._pointer_down_position[pointerId]

                const pointer_screen_position = {
                  x: clientX,
                  y: clientY,
                }

                const d = pointDistance(
                  pointer_down_position,
                  pointer_screen_position
                )

                if (d < POINTER_CLICK_RADIUS) {
                  return
                }
              }

              let drag_node_id = pressed_node_id

              if (
                this._is_unit_node_id(pressed_node_id) ||
                this._is_datum_node_id(pressed_node_id) ||
                this._is_plug_node_id(pressed_node_id)
              ) {
                if (this._mode === 'add' || this._mode === 'data') {
                  if (!this._clone_drag) {
                    const deep = this._mode === 'data'

                    if (this._mode === 'add') {
                      for (const unit_id in this._unit_node) {
                        this._hide_unit_ignored_pins(unit_id)
                      }
                    }

                    drag_node_id = this._on_node_clone_drag_start(
                      pressed_node_id,
                      undefined,
                      pointerId,
                      clientX,
                      clientY,
                      deep
                    )
                  }
                } else if (this._mode === 'remove') {
                  this._on_node_red_drag_start(
                    drag_node_id,
                    pointerId,
                    keys(this._selected_node_id)
                  )
                } else if (this._mode === 'change') {
                  if (this._is_unit_node_id(drag_node_id)) {
                    this._on_node_blue_drag_start(drag_node_id, pointerId)
                  } else if (this._is_datum_node_id(drag_node_id)) {
                    const { datumId } = segmentDatumNodeId(drag_node_id)

                    const tree = this._datum_tree[datumId]

                    const tree_type = _getValueType(specs, tree)

                    const new_datum_node_id =
                      this._sim_duplicate_datum(drag_node_id)

                    let value: string
                    do {
                      value = randomValueOfType(specs, tree_type)
                    } while (value === tree.value && value !== 'null')
                    const new_tree = _getValueTree__cached(value)
                    const new_datum = this._datum[new_datum_node_id] as Datum

                    new_datum.setProp('data', new_tree)
                    new_datum.dispatchEvent('datumchange', { data: new_tree })

                    this._clone_drag = true
                    this._clone_drag_node_id = pressed_node_id
                    this._clone_drag_clone_id = new_datum_node_id

                    this._on_node_pointer_leave(pressed_node_id, event)
                    this._on_pointer_up(event)

                    this._on_node_pointer_down(new_datum_node_id, event)

                    drag_node_id = new_datum_node_id

                    this._ascend_node(drag_node_id)
                  }
                }
              }

              this._drag_start(drag_node_id, event)

              // on Add Drag, the node is only duplicated after the pointer "has
              // moved enough" - in which case we need to correct its `hx` and `hy`
              if (this._is_freeze_mode()) {
                const { x, y } = this._get_node_position(drag_node_id)

                const { x: px, y: py } = pointer_down_position

                const [_px, _py] = this._client_to_graph(px, py)

                const node = this._node[drag_node_id]

                node.hx = _px - x
                node.hy = _py - y
              }
            } else {
              if (!this._is_node_unlocked(pressed_node_id)) {
                this._drag_move(pressed_node_id, event)

                if (this._is_unit_node_id(pressed_node_id)) {
                  if (this._blue_drag) {
                    this._on_unit_blue_drag_move(pressed_node_id)
                  }

                  if (this._collapse_next_unit_id === pressed_node_id) {
                    this._collapse_world_position =
                      this._get_node_position(pressed_node_id)
                  }
                }
              }
            }
          }
        }
      }
    }

    if (
      this._pointer_down_count === 2 &&
      keyCount(this._resize_node_id_pointer_id) === 0
    ) {
      const [pointer_id_0, pointer_id_1] = keys(this._pointer_down)

      const { x: x0, y: y0 } = this._pointer_position[pointer_id_0]
      const { x: x1, y: y1 } = this._pointer_position[pointer_id_1]

      if (this._multiselect_area_ing) {
        const minX = Math.min(x0, x1)
        const maxX = Math.max(x0, x1)
        const minY = Math.min(y0, y1)
        const maxY = Math.max(y0, y1)

        this._multiselect_area_rect = {
          x0: minX,
          y0: minY,
          x1: maxX,
          y1: maxY,
        }

        this._tick_multiselect_area()
      } else {
        if (this._tree_layout) {
          return
        }

        if (this._subgraph_graph) {
          return
        }

        const d = distance(x0, y0, x1, y1)

        if (!this._zooming) {
          if (Math.abs(d - this._touch_zoom_d) > 60) {
            this._zooming = true
            this._touch_zoom_d = d
          }
        } else {
          const delta = this._touch_zoom_d - d
          if (this._pressed_node_pointer_count === 0) {
            const delta = this._touch_zoom_d - d
            this._zoom_in(
              delta,
              this._touch_zoom_position_start.x,
              this._touch_zoom_position_start.y
            )
          } else if (
            this._pressed_node_pointer_count === 2 &&
            this._pressed_node_count === 1 &&
            pressed_node_id
          ) {
            const pressed_node = this._node[pressed_node_id]
            const { x, y, width, height } = pressed_node
            this._zoom_in(
              delta / 2,
              x + width / 2 - this._zoom.x,
              y + height / 2 - this._zoom.y
            )
          }
          this._touch_zoom_d = d
        }
      }
    }
  }

  private _translate_pressed_node = () => {
    for (let node_id in this._pressed_node_id_pointer_id) {
      const pointer_id = keys(this._pressed_node_id_pointer_id[node_id])[0]

      if (!this._pointer_position[pointer_id]) {
        return
      }

      const { x: pointer_x, y: pointer_y } = this._pointer_position[pointer_id]

      const [p_x, p_y] = zoomInvert(this._zoom, pointer_x, pointer_y)

      if (this._selected_node_id[node_id]) {
        for (let selected_node_id in this._selected_node_id) {
          this._translate_node(
            selected_node_id,
            p_x,
            p_y,
            this._translate_x,
            this._translate_y
          )
        }
      } else {
        this._translate_node(
          node_id,
          p_x,
          p_y,
          this._translate_x,
          this._translate_y
        )

        if (this._is_ext_node_id(node_id)) {
          const { type, pinId, subPinId } = segmentPlugNodeId(node_id)

          const int_node_id = getIntNodeId(type, pinId, subPinId)

          if (this._has_node(int_node_id)) {
            this._translate_node(
              int_node_id,
              p_x,
              p_y,
              this._translate_x,
              this._translate_y
            )
          }
        } else if (this._is_int_node_id(node_id)) {
          const { type, pinId, subPinId } = segmentPlugNodeId(node_id)

          const ext_node_id = getExtNodeId(type, pinId, subPinId)

          this._translate_node(
            ext_node_id,
            p_x,
            p_y,
            this._translate_x,
            this._translate_y
          )
        }
      }
    }
  }

  private _translate_search_node = () => {
    if (this._search_unit_id && this._mode === 'add') {
      const { x: pointer_x, y: pointer_y } = this._world_screen_center()

      const [p_x, p_y] = zoomInvert(this._zoom, pointer_x, pointer_y)

      this._translate_node(
        this._search_unit_id,
        p_x,
        p_y,
        this._translate_x,
        this._translate_y
      )
      this._for_each_unit_pin(this._search_unit_id, (pin_node_id: string) => {
        this._translate_node(
          pin_node_id,
          p_x,
          p_y,
          this._translate_x,
          this._translate_y
        )
      })
    }
  }

  private _translate_node = (
    node_id: string,
    x: number,
    y: number,
    translate_x: number,
    translate_y: number
  ): void => {
    const node = this.get_node(node_id)
    const nx = node.x - translate_x / this._zoom.z
    const ny = node.y - translate_y / this._zoom.z
    node.hx = x - node.x
    node.hy = y - node.y
    node.fx = nx
    node.fy = ny
    node.x = nx
    node.y = ny
  }

  private _state_expose_unit_pin_set = (
    unitId: string,
    type: IO,
    pinId: string,
    pinSpec: GraphPinSpec,
    position: Position
  ) => {
    const { specs, setSpec, forkSpec } = this.$props

    const unit = this._get_unit(unitId)

    const { id } = unit

    if (isBaseSpecId(specs, id)) {
      throw new Error('cannot expose base unit pin set')
    } else {
      const next_spec = clone(this._get_unit_spec(unitId)) as GraphSpec

      exposePinSet(
        {
          pinId,
          type,
          pinSpec,
        },
        next_spec
      )

      setSpec(next_spec.id, next_spec)

      this._sim_graph_unit_expose_pin_set(unitId, type, pinId, position)

      this.temp_fixate_node(unitId)
    }
  }

  public expose_unit_pin_set = (
    unitId: string,
    type: IO,
    pinId: string,
    pinSpec: GraphPinSpec,
    position: Position
  ) => {
    this._dispatch_action(
      makeExposeUnitPinSetAction(unitId, type, pinId, pinSpec, position)
    )

    this._expose_unit_pin_set(unitId, type, pinId, pinSpec, position)
  }

  private _expose_unit_pin_set = (
    unitId: string,
    type: IO,
    pinId: string,
    pinSpec: GraphPinSpec,
    position: Position
  ) => {
    this._state_expose_unit_pin_set(unitId, type, pinId, pinSpec, position)
    this._pod_expose_unit_pin_set(unitId, type, pinId, pinSpec)
  }

  private _state_cover_unit_pin_set = (
    unitId: string,
    type: IO,
    pinId: string,
    pinSpec: GraphPinSpec,
    position: Position
  ) => {
    const { specs, setSpec, forkSpec } = this.$props

    const unit = this._get_unit(unitId)

    const { id } = unit

    if (isBaseSpecId(specs, id)) {
      throw new Error('cannot cover base unit pin set')
    } else {
      const next_spec = clone(this._get_unit_spec(unitId)) as GraphSpec

      const pin_node_id = getPinNodeId(unitId, type, pinId)

      this._sim_graph_unit_remove_pin(pin_node_id)

      coverPinSet(
        {
          pinId,
          type,
        },
        next_spec
      )

      setSpec(next_spec.id, next_spec)
    }
  }

  private _pod_cover_unit_pin_set = (
    unitId: string,
    type: IO,
    pinId: string,
    pinSpec: GraphPinSpec
  ) => {
    const { fork, bubble } = this.$props

    this._pod.$coverUnitPinSet({
      unitId,
      type,
      pinId,
      pinSpec,
      fork,
      bubble,
    })
  }

  public cover_unit_pin_set = (
    unitId: string,
    type: IO,
    pinId: string,
    pinSpec: GraphPinSpec,
    position: Position
  ) => {
    this._dispatch_action(
      makeCoverUnitPinSetAction(unitId, type, pinId, pinSpec, position)
    )

    this._cover_unit_pin_set(unitId, type, pinId, pinSpec, position)
  }

  private _cover_unit_pin_set = (
    unitId: string,
    type: IO,
    pinId: string,
    pinSpec: GraphPinSpec,
    position: Position
  ) => {
    const { specs, setSpec, forkSpec } = this.$props

    this._state_cover_unit_pin_set(unitId, type, pinId, pinSpec, position)
    this._pod_cover_unit_pin_set(unitId, type, pinId, pinSpec)
  }

  public add_new_exposed_pin_set_at = (
    pin_id: string,
    type: IO,
    pin_spec: GraphPinSpec,
    data: string,
    ext: Point,
    int: Point
  ) => {
    this.add_exposed_pin_set(type, pin_id, pin_spec, data, { 0: { ext, int } })
  }

  private _on_line_gesture_end(line: Line) {
    // console.log('Graph', '_on_line_gesture_end')

    const { specs, forkSpec } = this.$props

    const { $x, $y, $sx, $sy } = this.$context

    const { x: zx, y: zy, z: zk } = this._zoom

    const _x = (x: number): number => {
      return (x - $x) / $sx / zk + zx
    }

    const _y = (y: number): number => {
      return (y - $y) / $sy / zk + zy
    }

    const add_unit_pin = (
      unit_id: string,
      type: IO,
      position: Position
    ): string => {
      const { shouldFork, newSpecId } = this.$props

      const spec = this._get_unit_spec(unit_id) as GraphSpec

      const new_pin_id = newSpecPinIdStart(spec, type)

      this.expose_unit_pin_set(
        unit_id,
        type,
        new_pin_id,
        {
          plug: { 0: {} },
        },
        position
      )

      return new_pin_id
    }

    if (this._mode === 'none') {
      const x0 = _x(line.x0)
      const y0 = _y(line.y0)
      const x1 = _x(line.x1)
      const y1 = _y(line.y1)

      const p0 = { x: x0, y: y0 }
      const p1 = { x: x1, y: y1 }

      const padding = NODE_PADDING / 2

      const source_node_id = this._find_inside_core_and_pin_id(p0, padding)
      const target_node_id = this._find_inside_core_and_pin_id(p1, padding)

      if (source_node_id && target_node_id) {
        const source_position = this._get_node_position(source_node_id)
        const target_position = this._get_node_position(target_node_id)

        if (
          this._is_unit_node_id(source_node_id) &&
          this._is_unit_node_id(target_node_id)
        ) {
          if (
            this._is_unit_base(source_node_id) ||
            this._is_unit_base(target_node_id)
          ) {
            return
          }

          const position = mediumPoint(source_position, target_position)

          const source_new_pin_id = add_unit_pin(
            source_node_id,
            'output',
            position
          )
          const target_new_pin_id = add_unit_pin(
            target_node_id,
            'input',
            position
          )

          const source_pin_node_id = getPinNodeId(
            source_node_id,
            'output',
            source_new_pin_id
          )
          const target_pin_node_id = getPinNodeId(
            target_node_id,
            'input',
            target_new_pin_id
          )

          this._merge_pin_pin(source_pin_node_id, target_pin_node_id, position)
        } else if (
          this._is_pin_node_id(source_node_id) &&
          this._is_pin_node_id(target_node_id)
        ) {
          this._add_unit_between_pins(source_node_id, target_node_id)
        } else if (
          this._is_pin_node_id(source_node_id) &&
          this._is_unit_node_id(target_node_id)
        ) {
          const position = mediumPoint(source_position, target_position)

          const { unitId: source_unit_id } =
            segmentLinkPinNodeId(target_node_id)

          if (source_unit_id === target_node_id) {
            return
          }

          const target_new_pin_id = add_unit_pin(
            target_node_id,
            'input',
            position
          )

          const target_pin_node_id = getPinNodeId(
            target_node_id,
            'input',
            target_new_pin_id
          )

          this._merge_pin_pin(source_node_id, target_pin_node_id, position)
        } else if (
          this._is_unit_node_id(source_node_id) &&
          this._is_pin_node_id(target_node_id)
        ) {
          const position = mediumPoint(source_position, target_position)

          const { unitId: target_unit_id } =
            segmentLinkPinNodeId(target_node_id)

          if (target_unit_id === source_node_id) {
            return
          }

          const source_new_pin_id = add_unit_pin(
            source_node_id,
            'output',
            position
          )

          const source_pin_node_id = getPinNodeId(
            source_node_id,
            'output',
            source_new_pin_id
          )

          this._merge_pin_pin(source_pin_node_id, target_node_id, position)
        }
      } else if (source_node_id || target_node_id) {
        const node_id = (source_node_id || target_node_id) as string

        const node_position = this._get_node_position(node_id)

        const { x, y } = node_position

        const d0 = distance(x0, y0, x, y)
        const d1 = distance(x1, y1, x, y)

        let type: IO
        if (d0 > d1) {
          type = 'input'
        } else {
          type = 'output'
        }

        if (this._is_unit_node_id(node_id)) {
          if (this._is_unit_base(node_id)) {
            //
          } else {
            const position = type === 'input' ? p0 : p1

            add_unit_pin(node_id, type, position)
          }
        } else if (this._is_pin_node_id(node_id)) {
          let _type: IO

          let is_link_pin_node_id = this._is_link_pin_node_id(node_id)

          if (is_link_pin_node_id) {
            const { type: __type } = segmentLinkPinNodeId(node_id)
            _type = __type
          } else {
            if (this._is_input_only_merge(node_id)) {
              _type = 'input'
            } else if (this._is_output_only_merge(node_id)) {
              _type = 'output'
            } else {
              _type = type
            }
          }

          let new_pin_sub_pin_id = '0'

          let new_pin_id: string
          let new_pin_sub_spec: GraphSubPinSpec
          let new_pin_datum_value: string

          if (is_link_pin_node_id) {
            const { unitId, pinId } = segmentLinkPinNodeId(node_id)

            const pin_node_id = getPinNodeId(unitId, type, pinId)

            new_pin_id = newSpecPinId(this._spec, _type, pinId)

            new_pin_sub_spec = {
              unitId,
              pinId,
              kind: _type,
            }

            const pin_datum_node_id = this._get_pin_datum_node_id(pin_node_id)

            if (pin_datum_node_id) {
              const pin_datum_value = this._get_datum_value(pin_datum_node_id)

              new_pin_datum_value = pin_datum_value
            }
          } else {
            const first_merge_pin = this._find_merge_pin(node_id, () => true)

            const first_merge_pin_of_type = this._find_merge_pin(
              node_id,
              (pin_node_id) => segmentLinkPinNodeId(pin_node_id).type === _type
            )

            const selected_merge_pin_node_id =
              first_merge_pin_of_type ?? first_merge_pin

            const { mergeId } = segmentMergeNodeId(node_id)
            const { pinId } = segmentLinkPinNodeId(selected_merge_pin_node_id)

            const merge_node_id = getMergeNodeId(mergeId)

            new_pin_id = newSpecPinId(this._spec, _type, pinId)
            new_pin_sub_spec = {
              mergeId,
            }

            const merge_datum_node_id =
              this._get_merge_datum_node_id(merge_node_id)

            if (merge_datum_node_id) {
              const merge_datum_value =
                this._get_datum_value(merge_datum_node_id)

              new_pin_datum_value = merge_datum_value
            }
          }

          const u = unitVector(x0, y0, x1, y1)
          const p0u = applyVector(p0, u, LINK_DISTANCE)

          const ext_node_position = _type === 'input' ? p0 : p0u
          const int_node_position = _type === 'input' ? p0u : p0

          const pin_exposed_pin = this._spec_get_pin_node_plug_spec(
            _type,
            node_id
          )

          const {
            pinId: pin_exposed_pin_pin_id,
            subPinId: pin_exposed_pin_sub_pin_id,
          } = pin_exposed_pin ?? {}

          if (pin_exposed_pin_pin_id && pin_exposed_pin_sub_pin_id) {
            new_pin_sub_pin_id = this._new_sub_pin_id(
              _type,
              pin_exposed_pin_pin_id
            )

            this.add_exposed_pin(
              _type,
              pin_exposed_pin_pin_id,
              {},
              new_pin_sub_pin_id,
              {},
              {
                ext: ext_node_position,
                int: int_node_position,
              }
            )
          } else {
            const pin_node_id = getSubPinSpecNodeId(_type, new_pin_sub_spec)

            const ref = this._is_pin_node_ref(pin_node_id)

            const pin_spec = {
              plug: {
                [new_pin_sub_pin_id]: new_pin_sub_spec,
              },
              ref,
            }

            const data = this._get_pin_datum_value(pin_node_id)

            this.add_new_exposed_pin_set_at(
              new_pin_id,
              _type,
              pin_spec,
              data,
              ext_node_position,
              int_node_position
            )

            if (_type === 'output') {
              if (new_pin_datum_value) {
                this._sim_set_pin_set_data(
                  _type,
                  new_pin_id,
                  new_pin_datum_value
                )
              }
            }
          }
        }
      } else {
        const center = this._world_screen_center()

        const { x: cx, y: cy } = center

        const d = distance(x0, y0, x1, y1)

        if (d > LINK_DISTANCE) {
          const d0 = distance(x0, y0, cx, cy)
          const d1 = distance(x1, y1, cx, cy)

          let type: IO
          if (d0 > d1) {
            type = 'input'
          } else {
            type = 'output'
          }

          const newPinId = newSpecPinIdStart(this._spec, type)

          const u = unitVector(x0, y0, x1, y1)
          const p0u = applyVector(p0, u, LINK_DISTANCE)

          const ext_node_position = type === 'input' ? p0 : p0u
          const int_node_position = type === 'input' ? p0u : p0

          const pin_spec = {
            plug: {
              0: {},
            },
          }

          this.add_new_exposed_pin_set_at(
            newPinId,
            type,
            pin_spec,
            undefined,
            ext_node_position,
            int_node_position
          )
        }
      }
    }
  }

  private _on_circle_gesture_end = (
    x: number,
    y: number,
    r: number,
    contained_nodes: string[]
  ) => {
    const { specs } = this.$props

    const position = { x, y }

    if (this._mode === 'none') {
      const new_unit_id = this._compose_contained_nodes(
        contained_nodes,
        { render: false },
        position,
        true
      )

      const contains_rect = contained_nodes.find((node_id) => {
        const shape = this._get_node_shape(node_id)

        if (shape === 'rect') {
          return true
        }

        return false
      })

      if (!contains_rect) {
        const n1 = clone(this.get_node(new_unit_id))

        const n0 = { width: 2 * r, height: 2 * r }

        this.__animate_core_style(
          new_unit_id,
          n0,
          () => n1,
          [
            ['width', 1],
            ['height', 1],
          ],
          ({ width, height }) => {
            this._resize_core_width(new_unit_id, width)
            this._resize_node_width(new_unit_id, width)

            this._resize_core_height(new_unit_id, height)
            this._resize_node_height(new_unit_id, height)
          },
          () => {
            //
          }
        )
      }
    } else if (this._mode === 'add') {
      this._search_unit_graph_position = position

      this._set_search_filter((id: string) => {
        if (!isComponentId(specs, id)) {
          return true
        } else {
          return false
        }
      })
      this._show_search()
    }
  }

  private _on_rectangle_gesture_end = (
    x: number,
    y: number,
    width: number,
    height: number,
    contained_nodes: string[]
  ): void => {
    const { specs, getSpec } = this.$props

    const position = { x, y }

    if (this._mode === 'none') {
      const id = newSpecId(specs)

      this._add_empty_spec(id, {
        render: true,
        component: {
          defaultWidth: width,
          defaultHeight: height,
        },
      })

      const unit = {
        id,
      }

      const new_spec = getSpec(id) as GraphSpec

      const bundle: UnitBundleSpec = {
        unit,
        specs: {
          [id]: new_spec,
        },
      }

      const new_unit_id = this._new_unit_id(id)

      const pin_position = emptyIO<Dict<Position>>({}, {})

      const layout_position = { x: 0, y: 0 }

      this._add_unit(
        new_unit_id,
        bundle,
        position,
        pin_position,
        layout_position,
        null
      )

      this._sim_add_sub_component(new_unit_id)
      this._connect_sub_component(new_unit_id)

      this._move_contained_nodes(new_unit_id, contained_nodes, true)
    } else if (this._mode === 'add') {
      this._search_unit_graph_position = position
      this._search_unit_component_size = {
        width,
        height,
      }

      this._set_search_filter((id: string) => {
        if (isComponentId(specs, id)) {
          return true
        } else {
          return false
        }
      })

      this._show_search()
    }
  }

  private _move_contained_nodes = (
    new_unit_id: string,
    contained_nodes: string[],
    animate: boolean,
    partial_collapse_map?: Partial<GraphMoveSubGraphData>
  ) => {
    const { fork, bubble } = this.$props

    if (contained_nodes.length > 0) {
      const collapse_map = deepMerge(
        this._predict_collapse_map(new_unit_id, contained_nodes),
        partial_collapse_map ?? {}
      )

      const data: GraphMoveSubGraphIntoData = {
        graphId: new_unit_id,
        graphBundle: null,
        graphSpec: null,
        ...collapse_map,
        fork,
        bubble,
      }

      const position = this._jiggle_world_screen_center()

      let there_is_selected_sub_component = false

      for (const contained_node_id of contained_nodes) {
        this._start_node_long_press_collapse(contained_node_id)
      }

      this._collapse_init_node_id_set = new Set(this._collapse_node_id)

      const should_predict_size =
        this._get_unit_spec_render(new_unit_id) === undefined &&
        there_is_selected_sub_component
      const do_not_animate_graph_size =
        this._get_unit_spec_render(new_unit_id) !== undefined

      this._state_move_subgraph_into(
        new_unit_id,
        data,
        should_predict_size,
        do_not_animate_graph_size,
        position,
        animate
      )

      // console.log(data)

      this._pod.$moveSubgraphInto(data)
    }
  }

  private _on_capture_gesture_end = (
    event: UnitPointerEvent,
    track: Point[]
  ): void => {
    // console.log('Graph', '_on_capture_gesture_end')

    const { specs, getSpec, newSpec } = this.$props

    const { $x, $y, $sx, $sy } = this.$context

    const { x: zx, y: zy, z: zk } = this._zoom

    let l = track.length

    this._capturing_gesture = false

    // const t = Math.round(0.1 * l) // trim
    // track.splice(0, t)
    // track.splice(l - t, t)

    let line: Line | null = null
    let rect: Rect | null = null
    let circle: Circle | null = null

    l = track.length

    const _x = (x: number): number => {
      return (x - $x) / $sx / zk + zx
    }

    const _y = (y: number): number => {
      return (y - $y) / $sy / zk + zy
    }

    if (l > 6) {
      line = getLine(track, 25)

      if (line) {
        this._on_line_gesture_end(line)
      } else {
        const fallback = () => {
          const first_point = track[0]
          const last_point = track[track.length - 1]

          const x0 = _x(first_point.x)
          const y0 = _y(first_point.y)
          const x1 = _x(last_point.x)
          const y1 = _y(last_point.y)

          const p0 = { x: x0, y: y0 }
          const p1 = { x: x1, y: y1 }

          const padding = NODE_PADDING / 2

          const source_node_id = this._find_inside_core_and_pin_id(p0, padding)
          const target_node_id = this._find_inside_core_and_pin_id(p1, padding)

          if (source_node_id && target_node_id) {
            this._add_unit_between_pins(source_node_id, target_node_id)
          }
        }

        if (pointDistance(track[0], track[l - 1]) > 3 * NEAR) {
          fallback()
        } else {
          // close track
          track.push(track[0])

          const contained_nodes: string[] = []

          // const pointer_track_sample = linearSample(
          //   pointer_track.slice(6, l - 6),
          //   10
          // )
          const pointer_track_sample = track

          const _is_node_inside = (node_id: string): boolean => {
            if (!this._is_node_visible(node_id)) {
              return false
            }

            const node = this.get_node(node_id)

            let intersect_count = 0

            for (let i = 1; i < pointer_track_sample.length; i++) {
              const point = pointer_track_sample[i]
              const px = _x(point.x)
              const py = _y(point.y)

              const previous = pointer_track_sample[i - 1]

              const ppx = _x(previous.x)
              const ppy = _y(previous.y)

              const intersect = lineIntersect(
                px,
                py,
                ppx,
                ppy,
                node.x,
                node.y,
                Number.MAX_SAFE_INTEGER,
                Number.MAX_SAFE_INTEGER
              )

              if (intersect) {
                intersect_count++
              }
            }

            const intersected = intersect_count % 2 === 1

            return intersected
          }

          for (let node_id in this._node) {
            if (_is_node_inside(node_id)) {
              contained_nodes.push(node_id)
            }
          }

          if ((rect = getRectangle(track))) {
            const x = _x(rect.x + rect.width / 2)
            const y = _y(rect.y + rect.height / 2)

            const width = Math.max(rect.width / $sx / this._zoom.z, MIN_WIDTH)
            const height = Math.max(
              rect.height / $sx / this._zoom.z,
              MIN_HEIGHT
            )

            this._on_rectangle_gesture_end(x, y, width, height, contained_nodes)
          } else if ((circle = getCircle(track, 0.3))) {
            const x = _x(circle.x)
            const y = _y(circle.y)

            this._on_circle_gesture_end(x, y, circle.r, contained_nodes)
          } else {
            fallback()
          }
        }
      }
    }

    if (
      this._pointer_down_count === 2 ||
      (this._capturing_gesture && this._is_alt_pressed())
    ) {
      this._restart_gesture = true
    } else {
      this._restart_gesture = false
    }
  }

  private _is_draggable_mode = (): boolean => {
    return this.__is_draggable_mode(this._mode)
  }

  private _is_droppable_mode = (): boolean => {
    return this.__is_droppable_mode(this._mode)
  }

  private __is_draggable_mode = (mode: Mode): boolean => {
    return (
      mode === 'none' ||
      mode === 'info' ||
      mode === 'data' ||
      mode === 'add' ||
      mode === 'remove' ||
      mode === 'change' ||
      mode === 'multiselect'
    )
  }

  private __is_droppable_mode = (mode: Mode): boolean => {
    return (
      mode === 'none' ||
      mode === 'data' ||
      mode === 'add' ||
      mode === 'remove' ||
      mode === 'change'
    )
  }

  private _is_freeze_mode = (): boolean => {
    return this.__is_freeze_mode(this._mode)
  }

  private __is_freeze_mode = (mode: Mode): boolean => {
    return (
      mode === 'add' ||
      mode === 'remove' ||
      mode === 'change' ||
      mode === 'data'
    )
  }

  private _blue_drag_hover_return = (): void => {
    // console.log('Graph', '_blue_drag_hover_return')

    if (this._blue_drag_hover_unit_id) {
      const unit_id = this._blue_drag_hover_unit_id

      this._refresh_unit_layer(unit_id)
      this._refresh_unit_fixed(unit_id)

      for (const node_id in this._blue_drag_hover_position) {
        const position = this._blue_drag_hover_position[node_id]
        if (this._has_node(node_id)) {
          this._set_node_position(node_id, position)
        }
      }

      this._for_each_unit_output(unit_id, (output_node_id) => {
        this._set_output_reduced(output_node_id, false)
      })

      for (const pin_node_id in this._blue_drag_hover_merge_anchor) {
        const merge_anchor_pin_node_id =
          this._blue_drag_hover_merge_anchor[pin_node_id]
        if (
          this._has_node(pin_node_id) &&
          this._has_node(merge_anchor_pin_node_id)
        ) {
          this._merge_pin_pin(pin_node_id, merge_anchor_pin_node_id)
        }
      }

      this._blue_drag_hover_unit_id = null
    } else {
      throw new ShouldNeverHappenError()
    }
  }

  private __on_pointer_up = (pointerId: number, drop: boolean = true): void => {
    // console.log('Graph', '__on_pointer_up', this._id)

    if (this._collapse_pointer_to_unit[pointerId]) {
      delete this._collapse_pointer_to_unit[pointerId]
    }

    if (this._control) {
      if (this._temp_control_lock) {
        if (!this._subgraph_unit_id) {
          this._temp_unlock_control()
        }
      }
    }

    if (this._pointer_down[pointerId]) {
      const node_id = this._pointer_id_pressed_node_id[pointerId]

      delete this._pointer_down[pointerId]
      delete this._pointer_down_position[pointerId]
      delete this._pointer_down_move_count[pointerId]

      this._pointer_down_count--
    }

    if (this._long_press_pointer.has(pointerId)) {
      this._long_press_pointer.delete(pointerId)

      this._long_press_count--
    }

    if (this._long_press_background_pointer.has(pointerId)) {
      this._long_press_background_pointer.delete(pointerId)

      this._long_press_background_count--
    }

    this._removing_err = false

    if (this._main.hasPointerCapture(pointerId)) {
      this._main.releasePointerCapture(pointerId)
    }

    const pressed_node_id = this._pointer_id_pressed_node_id[pointerId]

    if (pressed_node_id) {
      this.__set_node_pressed(pressed_node_id, pointerId, false)

      if (this._tree_layout) {
        if (this._is_unit_node_id(pressed_node_id)) {
          if (this._is_unit_component(pressed_node_id)) {
            if (this._layout_drag_node[pressed_node_id]) {
              this._on_layout_component_drag_end(pressed_node_id)
            }
          }
        }
      } else {
        if (this._drag_node_id[pressed_node_id]) {
          const closest_compatible_node_id =
            this._drag_node_closest_compatible_node_id[pressed_node_id]

          if (closest_compatible_node_id) {
            this._remove_pressed_node_closest_compatible(pressed_node_id)
          }

          if (this._is_draggable_mode()) {
            if (this._is_freeze_mode()) {
              if (
                this._is_unit_node_id(pressed_node_id) ||
                this._is_datum_node_id(pressed_node_id) ||
                this._is_plug_node_id(pressed_node_id)
              ) {
                this._descend_node(pressed_node_id)

                if (this._drag_along_node[pressed_node_id]) {
                  for (const drag_along_node_id of this._drag_along_node[
                    pressed_node_id
                  ]) {
                    this._descend_node(drag_along_node_id)
                  }
                }
              }
            }

            if (this._is_link_pin_node_id(pressed_node_id)) {
              if (this._mode === 'remove') {
                const { unitId } = segmentLinkPinNodeId(pressed_node_id)

                this._on_unit_red_drag_end(unitId)
              }
            }

            if (pressed_node_id === this._clone_drag_clone_id) {
              this._on_node_clone_drag_end(this._clone_drag_clone_id)
            }

            if (this._blue_drag) {
              if (this._is_unit_node_id(pressed_node_id)) {
                this._on_unit_blue_drag_end(this._blue_drag_init_id)
              }
            }

            if (this._drag_along_node[pressed_node_id]) {
              const drag_along_node = clone(
                this._drag_along_node[pressed_node_id]
              )

              for (const drag_along_node_id of drag_along_node) {
                if ((this._node_pressed_count[drag_along_node_id] ?? 0) === 0) {
                  this._remove_node_drag_along(
                    pressed_node_id,
                    drag_along_node_id
                  )

                  this._on_node_drag_end_and_drop(
                    drag_along_node_id,
                    pointerId,
                    drop &&
                      (this._is_node_id(drag_along_node_id) ||
                        this._is_plug_node_id(drag_along_node_id))
                  )
                }
              }
            }

            if (!this._collapse_node_id.has(pressed_node_id)) {
              this._on_node_drag_end_and_drop(pressed_node_id, pointerId, drop)
            } else {
              this.__on_node_drag_end(pressed_node_id, pointerId)
            }

            if (this._drag_anchor_animation[pressed_node_id]) {
              this._drag_anchor_animation[pressed_node_id]()

              delete this._drag_anchor_animation[pressed_node_id]
            }

            if (this._is_freeze_mode()) {
              if (this._is_unit_node_id(pressed_node_id)) {
                if (
                  !this._clone_drag ||
                  this._clone_drag_clone_id == pressed_node_id
                ) {
                  type Target = { node_id: string; l: number }

                  const pin_drop_min_distance: Dict<Heap<Target>> = {}
                  const pin_drop_min_target: Dict<
                    Heap<Target & { heap: Heap<Target> }>
                  > = {}

                  const target_candidates = {
                    ...this._normal_node,
                    ...this._exposed_int_node,
                  }

                  const predicate = (a: Target, b: Target) => {
                    return a.l < b.l
                  }

                  const pins_to_process = new Set<string>()

                  this._for_each_unit_pin(
                    pressed_node_id,
                    (pin_node_id: string) => {
                      if (!this._is_link_pin_merged(pin_node_id)) {
                        if (!this._is_link_pin_merged(pin_node_id)) {
                          pins_to_process.add(pin_node_id)

                          for (const target_node_id in target_candidates) {
                            const surface_distance =
                              this._node_node_surface_distance(
                                pin_node_id,
                                target_node_id
                              )

                            const { l } = surface_distance

                            if (
                              l < NEAR &&
                              this._is_pin_node_match(
                                pin_node_id,
                                target_node_id
                              )
                            ) {
                              const source_heap_node = {
                                parent: null,
                                value: { node_id: target_node_id, l },
                                left: null,
                                right: null,
                              }

                              if (pin_drop_min_distance[pin_node_id]) {
                                pin_drop_min_distance[pin_node_id] =
                                  addHeapNode(
                                    pin_drop_min_distance[pin_node_id],
                                    source_heap_node,
                                    predicate
                                  )
                              } else {
                                pin_drop_min_distance[pin_node_id] =
                                  source_heap_node
                              }

                              const target_heap_node = {
                                parent: null,
                                value: {
                                  node_id: pin_node_id,
                                  l,
                                  heap: source_heap_node,
                                },
                                left: null,
                                right: null,
                              }

                              if (pin_drop_min_target[target_node_id]) {
                                pin_drop_min_target[target_node_id] =
                                  addHeapNode<Target & { heap: Heap<Target> }>(
                                    pin_drop_min_target[target_node_id],
                                    target_heap_node,
                                    predicate
                                  )
                              } else {
                                pin_drop_min_target[target_node_id] =
                                  target_heap_node
                              }
                            }
                          }
                        }
                      }
                    }
                  )

                  const final_pin_target_id: Dict<string> = {}

                  const process_pin = (pin_node_id: string): string | null => {
                    let final_target_id = null

                    if (pin_drop_min_distance[pin_node_id]) {
                      const min_target = pin_drop_min_distance[pin_node_id]

                      const { node_id: target_node_id } = min_target.value

                      const target_heap = pin_drop_min_target[target_node_id]

                      if (target_heap) {
                        if (target_heap.value.node_id === pin_node_id) {
                          pin_drop_min_target[target_node_id] = removeHeapNode(
                            target_heap,
                            predicate
                          ) as Heap<Target & { heap: Heap<Target> }>

                          if (pin_drop_min_target[target_node_id]) {
                            traverseHeap(
                              pin_drop_min_target[target_node_id],
                              ({ node_id, heap }) => {
                                pin_drop_min_distance[node_id] = removeHeapNode(
                                  heap,
                                  predicate
                                )
                              }
                            )
                          }

                          final_pin_target_id[pin_node_id] = target_node_id
                        } else {
                          process_pin(target_heap.value.node_id)
                        }
                      }
                    }

                    pins_to_process.delete(pin_node_id)

                    return final_target_id
                  }

                  while (pins_to_process.size > 0) {
                    for (const pin_node_id of pins_to_process) {
                      process_pin(pin_node_id)
                    }
                  }

                  for (const pin_node_id in final_pin_target_id) {
                    const final_target_node_id =
                      final_pin_target_id[pin_node_id]

                    if (
                      this._is_link_pin_node_id(final_target_node_id) &&
                      this._spec_is_link_pin_ignored(final_target_node_id)
                    ) {
                      this._set_link_pin_ignored(final_target_node_id, false)
                    }
                    if (
                      this._is_link_pin_node_id(pin_node_id) &&
                      this._spec_is_link_pin_ignored(pin_node_id)
                    ) {
                      this._set_link_pin_ignored(pin_node_id, false)
                    }

                    this.__drop_pin(pin_node_id, final_target_node_id)
                  }

                  this._refresh_node_color(pressed_node_id)
                }
              }
            }
          }

          if (this._is_ext_node_id(pressed_node_id)) {
            const { type, pinId, subPinId } = segmentPlugNodeId(pressed_node_id)

            const int_node_id = getIntNodeId(type, pinId, subPinId)

            if (this._has_node(int_node_id)) {
              if (this._is_draggable_mode()) {
                this._on_node_drag_end_and_drop(int_node_id, pointerId, drop)
              }
            }
          } else if (this._is_int_node_id(pressed_node_id)) {
            const { type, pinId, subPinId } = segmentPlugNodeId(pressed_node_id)
            const ext_node_id = getExtNodeId(type, pinId, subPinId)
            if (this._is_draggable_mode()) {
              this._on_node_drag_end_and_drop(ext_node_id, pointerId, drop)
            }
          }
        }
      }

      if (this._has_node(pressed_node_id)) {
        this._refresh_node_color(pressed_node_id)
        this._refresh_node_selection(pressed_node_id)
      }
    }

    if (this._long_press_pointer.has(pointerId)) {
      this._long_press_pointer.delete(pointerId)
      if (this._long_click_cancel_pointer_id.has(pointerId)) {
        this._long_click_cancel_pointer_id.delete(pointerId)
      }
      this._long_press_count--
    }

    // if (pointerId === this._long_press_collapse_pointer_id) {
    //   this._stop_long_press_collapse()
    // }

    // if (this._zooming && this._pointer_down_count === 0 && this._zoom.k < 1) {
    //   this._on_zoom_end()
    // }

    if (this._pointer_down_count === 0) {
      this._zooming = false
    }

    if (this._multiselect_area_ing) {
      this._on_multiselect_area_end()
    }

    this._translating = false
  }

  private _on_pointer_up = (event: UnitPointerEvent) => {
    // console.log('Graph', '_on_pointer_up')

    const { pointerId } = event

    this.__on_pointer_up(pointerId)
  }

  private _on_wheel = (
    {
      deltaY,
      altKey,
      ctrlKey,
      screenX,
      screenY,
      clientX,
      clientY,
    }: IOWheelEvent,
    _event: WheelEvent
  ) => {
    // console.log('Graph', '_on_wheel')

    if (this._tree_layout) {
      return
    }

    if (this._subgraph_graph) {
      return
    }

    if (this._disabled) {
      return
    }

    _event.preventDefault()

    const { $x: x, $y: y, $width: width, $height: height } = this.$context

    if (
      screenX >= x &&
      screenY >= y &&
      screenX <= x + width &&
      screenY <= y + height
    ) {
      this._zoom_in(deltaY, clientX, clientY)
    }
  }

  private _on_scroll = (
    { deltaY, screenX, screenY, clientX, clientY }: IOWheelEvent,
    _event: WheelEvent
  ) => {
    // console.log('Graph', '_on_scroll')
  }

  private _is_background_pointer = (pointerId: number): boolean => {
    if (
      this._pointer_id_hover_node_id[pointerId] ||
      this._pointer_id_hover_link_id[pointerId] ||
      this._pointer_id_pressed_node_id[pointerId]
    ) {
      return false
    } else {
      return true
    }
  }

  private _click_just_cancelled: Set<number> = new Set()

  private _on_click_cancel = (event: UnitPointerEvent) => {
    // console.log('Graph', 'on_click_cancel')

    const { pointerId } = event

    this._click_just_cancelled.add(pointerId)
  }

  private _on_click = (event: UnitPointerEvent, _event: PointerEvent): void => {
    // console.log('Graph', '_on_click')

    const {
      api: {
        window: { setTimeout },
      },
    } = this.$system

    if (this._just_node_long_clicked) {
      return
    }

    if (keyCount(this._resize_node_id_pointer_id) > 0) {
      return
    }

    if (!this._control_lock) {
      if (this._core_component_unlocked_count === 0) {
        this._lock_control()
      }
    }

    const { pointerId, clientX, clientY, pointerType } = event

    if (this._cancel_click) {
      this._cancel_click = false

      return
    }

    if (this._is_background_pointer(pointerId)) {
      this._on_background_click()
    }

    if (this._datum_to_be_focused_by_click) {
      this._datum_to_be_focused_by_click = false
    } else if (this._name_to_be_focused) {
      this._name_to_be_focused = false
    } else if (this._search_to_be_focused_by_click) {
      this._search_to_be_focused_by_click = false
    } else {
      if (this._focused) {
        //
      } else {
        // blur any focused input (search, edit datum, etc.)
        if (this._temp_control_lock) {
          this._temp_unlock_control()
        }

        this.focus()
      }
    }
  }

  private _on_background_click = (): void => {
    // console.log('Graph', '_on_background_click')

    if (this._core_component_unlocked_count > 0) {
      this._lock_all_component()
    } else if (this._unlocked_datum.size > 0) {
      this._lock_all_datum()
    } else {
      if (this._edit_datum_id) {
        //
      } else if (this._edit_datum_just_blurred) {
        //
      } else if (this._mode === 'multiselect') {
        //
      } else {
        this._deselect_all_visible()
      }
    }
  }

  private _deselect_all_visible = () => {
    if (this._tree_layout) {
      const current_layer = this._get_current_layout_layer_id()
      for (const selected_node_id in this._selected_node_id) {
        if (
          this._is_unit_node_id(selected_node_id) &&
          this._is_unit_component(selected_node_id)
        ) {
          const parent_id =
            this._spec_get_sub_component_parent_id(selected_node_id)
          if (parent_id === current_layer) {
            this._deselect_node(selected_node_id)
          }
        }
      }
    } else {
      this._deselect_all()
    }
  }

  private _hide_minimap = (): void => {
    // console.log('Graph', '_hide_minimap')

    if (this._cabinet) {
      this._cabinet.setActive('minimap', false)
    }
  }

  private _show_minimap = (): void => {
    // console.log('Graph', '_show_minimap')

    if (this._cabinet) {
      this._cabinet.setActive('minimap', true)
    }
  }

  private _minimap_hidden: boolean

  private _toggle_minimap = (): void => {
    // console.log('Graph', '_toggle_minimap')

    if (this._minimap) {
      if (this._minimap_hidden) {
        this._show_minimap()
      } else {
        this._hide_minimap()
      }
    }
  }

  private _set_crud_mode = (mode: Mode): void => {
    // console.log('Graph', '_set_crud_mode', mode)

    if (this._modes) {
      this._modes.setProp('mode', mode)
    }
  }

  private _on_double_click = (event: UnitPointerEvent): void => {
    // console.log('Graph', '_on_double_click')

    const { pointerId } = event

    if (this._cancel_double_click) {
      return
    }

    if (this._mode === 'multiselect') {
      this._restart_gesture = false
    }

    if (this._is_background_pointer(pointerId)) {
      this._on_background_double_click(event)
    }

    this._name_to_be_focused = false
  }

  private _on_background_double_click = (event: UnitPointerEvent): void => {
    const { pointerId, clientX, clientY } = event

    this._double_click_background(pointerId, clientX, clientY)
  }

  private _double_click_background = (
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    if (this._tree_layout) {
      //
    } else {
      const position = this._screen_to_world(clientX, clientY)

      if (this._mode === 'none') {
        this._none_double_click_background(position)
      } else if (this._mode === 'add') {
        this._paste_clipboard(position)
      } else if (this._mode === 'data') {
        this.__on_data_background_double_click(pointerId, clientX, clientY)
      } else if (this._mode === 'multiselect') {
        this._toggle_select_all_visible()
      }
    }
  }

  private _none_double_click_background = (position: Position) => {
    const { config } = this.$props

    if (config?.dataCreate) {
      if (this._selected_node_count > 0) {
        this._deselect_all()
      }

      const datum_id = this._new_datum_id()

      const datum_node_id = getDatumNodeId(datum_id)

      this._add_empty_datum(datum_id, position)
      this._unlock_datum(datum_node_id)
      this._focus_datum(datum_id, [])
    }
  }

  private _on_data_background_double_click = (
    event: UnitPointerEvent
  ): void => {
    const { pointerId, clientX, clientY } = event

    this.__on_data_background_double_click(pointerId, clientX, clientY)
  }

  private __on_data_background_double_click = (
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    const position = this._screen_to_world(clientX, clientY)

    const datum_id = this._new_datum_id()

    this._add_random_datum(datum_id, position)
  }

  private _add_empty_spec = (
    id: string,
    partial: Partial<GraphSpec> = {}
  ): GraphSpec => {
    const { setSpec } = this.$props

    const new_spec = deepMerge(emptySpec(), partial) as GraphSpec

    new_spec.id = id

    setSpec(id, new_spec)

    return new_spec
  }

  private _dispatch_add_datum_on_commit = false

  private _add_empty_datum = (datum_id: string, { x, y }: Position): void => {
    const {
      api: {
        window: { setTimeout },
      },
    } = this.$system

    // console.log('Graph', '_add_empty_datum')

    this._add_datum(datum_id, '', { x, y })

    this._dispatch_add_datum_on_commit = true

    const datum_node_id = getDatumNodeId(datum_id)

    if (this._selected_node_count > 0) {
      this._deselect_all()
    }

    this._set_crud_mode('none')

    setTimeout(() => {
      this._focus_datum(datum_id, [])
    }, 0)
  }

  private _add_random_datum = (datum_id: string, { x, y }: Position): void => {
    const value = randomInArray([
      '0',
      '1',
      '2',
      '3',
      `'foo'`,
      `'bar'`,
      `'zaz'`,
      'true',
      'false',
      '{}',
      '[]',
    ])

    this.add_datum(datum_id, value, { x, y }, true)
  }

  private _on_long_click = (event: UnitPointerEvent): void => {
    // console.log('Graph', '_on_long_click')
    if (this._cancel_long_click) {
      this._cancel_long_click = false
      return
    }

    const { pointerId } = event

    if (this._is_background_pointer(pointerId)) {
      this._on_background_long_click(event)
    }
  }

  private _on_background_long_click = (event: UnitPointerEvent) => {
    const {
      api: {
        window: { setTimeout },
      },
    } = this.$system

    if (this._tree_layout) {
      const current_layout_layer = this._get_current_layout_layer_id()

      if (current_layout_layer) {
        if (this._mode === 'none') {
          this._layout_leave_sub_component()
        }
      }
    } else {
      if (this._mode === 'none') {
        setTimeout(() => {
          if (this._can_leave()) {
            this.leave()
          }
        }, 0)
      }
    }
  }

  private _spec_get_graph_core_size = (
    unit_id: string,
    use_cache: boolean
  ): Size => {
    const { classes } = this.$system
    const { specs } = this.$props

    const unit_spec_id = this._get_unit_spec_id(unit_id)

    const is_component: boolean = isComponentId(specs, unit_spec_id)

    let width: number
    let height: number

    if (is_component) {
      return this._get_unit_component_graph_size(unit_id)
    } else {
      const r = getSpecRadius(specs, classes, unit_spec_id, use_cache)

      width = 2 * r
      height = 2 * r
    }

    return {
      width,
      height,
    }
  }

  private _start_long_press_collapse = (
    pointer_id: number,
    init_unit_id: string | null,
    selected_node_ids: string[],
    position: Position
  ): boolean => {
    // console.log(
    //   'Graph',
    //   '_start_long_press_collapse',
    //   pointer_id,
    //   init_unit_id,
    //   position
    // )

    const { fork, bubble, setSpec, forkSpec, shouldFork } = this.$props

    const { specs } = this.$props

    const { x: clientX, y: clientY } = position

    selected_node_ids = selected_node_ids.filter((node_id) => {
      if (this._is_err_node_id(node_id) || this._is_type_node_id(node_id)) {
        return false
      }

      return true
    })

    const selected_sub_component_ids = []

    for (const selected_node_id of selected_node_ids) {
      if (this._is_unit_node_id(selected_node_id)) {
        if (this._is_unit_component(selected_node_id)) {
          selected_sub_component_ids.push(selected_node_id)
        }
      }
    }

    let lowest_common_ancestor = null
    let traversed_parent_count: Dict<number> = {}

    for (const selected_component_id of selected_sub_component_ids) {
      let parent_id = selected_component_id

      do {
        parent_id = this._spec_get_sub_component_parent_id(parent_id)

        traversed_parent_count[parent_id] =
          traversed_parent_count[parent_id] ?? 0
        traversed_parent_count[parent_id]++

        if (
          traversed_parent_count[parent_id] ===
          selected_sub_component_ids.length
        ) {
          lowest_common_ancestor = parent_id

          break
        }
      } while (parent_id !== null)
    }

    const none_selected = selected_node_ids.length === 0

    if (init_unit_id && none_selected) {
      return false
    }

    const init_unit_is_render =
      init_unit_id && this._get_unit_spec_render(init_unit_id)

    const { x, y } = this._screen_to_world(clientX, clientY)

    let next_spec_id: string
    let next_spec: GraphSpec

    let init_unit_spec: GraphSpec
    let init_unit_spec_id: string

    if (init_unit_id) {
      init_unit_spec = this._get_unit_spec(init_unit_id) as GraphSpec
      init_unit_spec_id = this._get_unit_spec_id(init_unit_id)

      next_spec_id = init_unit_spec_id
      next_spec = init_unit_spec
    }

    let graph_id: string = init_unit_id
    let graph_spec_id: string = next_spec_id
    let graph_spec: GraphSpec = next_spec
    let graph_unit_bundle: UnitBundleSpec = null

    const graph_render =
      init_unit_id === null
        ? undefined
        : this._get_unit_spec_render(init_unit_id)

    const there_is_selected_sub_component = selected_node_ids.some(
      (node_id) =>
        this._is_unit_node_id(node_id) && this._is_unit_component(node_id)
    )

    let next_parent_component_id = null

    const should_graph_become_component =
      graph_render === undefined &&
      there_is_selected_sub_component &&
      (!init_unit_id || !isSystemSpecId(specs, init_unit_spec_id))

    if (graph_id === null) {
      graph_spec = emptyGraphSpec({ type: '`U`&`G`' })

      const new_name = 'untitled'

      graph_spec.name = new_name
      graph_spec.metadata = graph_spec.metadata || {}
      graph_spec.metadata.icon = null

      if (there_is_selected_sub_component) {
        graph_spec.type = '`U`&`G`&`C`'
        graph_spec.render = true
        graph_spec.component = graph_spec.component || {
          subComponents: {},
          children: [],
        }
        graph_spec.component.subComponents =
          graph_spec.component.subComponents || {}
        graph_spec.component.children = graph_spec.component.children || []

        if (!init_unit_is_render) {
          const { width, height } = this.get_sub_components_max_graph_size(
            selected_sub_component_ids
          )

          graph_spec.component.defaultWidth = width
          graph_spec.component.defaultHeight = height
        }
      }

      const new_spec_id = newSpecId(specs)

      graph_spec.id = new_spec_id

      setSpec(new_spec_id, graph_spec)

      const new_unit_id = this._new_unit_id(new_spec_id)

      const new_unit_bundle = unitBundleSpecById(new_spec_id, specs)

      graph_id = new_unit_id
      graph_spec_id = new_spec_id
      graph_unit_bundle = new_unit_bundle

      this._state_add_unit(
        new_unit_id,
        new_unit_bundle,
        { x, y },
        { width: 2, height: 2 },
        { input: {}, output: {} },
        { x: 0, y: 0 },
        lowest_common_ancestor,
        undefined,
        true,
        false
      )

      if (there_is_selected_sub_component) {
        this._sim_add_sub_component(new_unit_id)
      }

      this._force_pointer_drag_node(new_unit_id, pointer_id, clientX, clientY)
    } else {
      if (init_unit_spec.system) {
        graph_spec = clone(graph_spec)

        delete graph_spec.system

        graph_spec.render = init_unit_spec.render ?? false

        setSpec(graph_spec.id, graph_spec)
      }
    }

    for (const selected_node_id of selected_node_ids) {
      if (this._static_position[selected_node_id]) {
        this._stop_node_static(selected_node_id)
      }

      if (this._is_datum_node_id(selected_node_id)) {
        const datum_pin_node_id = this._datum_to_pin[selected_node_id]
        const datum_plug_node_id = this._datum_to_plug[selected_node_id]

        if (datum_pin_node_id) {
          if (selected_node_ids.includes(datum_pin_node_id)) {
            continue
          } else {
            if (this._is_link_pin_node_id(datum_pin_node_id)) {
              const merge_node_id = this._pin_to_merge[datum_pin_node_id]

              if (selected_node_ids.includes(merge_node_id)) {
                continue
              }
            }

            this._remove_pin_datum_link(selected_node_id)
          }
        } else if (datum_plug_node_id) {
          if (selected_node_ids.includes(datum_plug_node_id)) {
            continue
          } else {
            this._remove_plug_set_datum_link(datum_plug_node_id)
          }
        }
      }
    }

    for (const selected_node_id of selected_node_ids) {
      if (this._is_ext_node_id(selected_node_id)) {
        const int_node_id = getIntNodeIdFromExtNodeId(selected_node_id)

        const anchor_node_id = this._int_to_node[int_node_id]

        if (anchor_node_id) {
          this._start_node_long_press_collapse(selected_node_id)
        } else {
          this._start_node_long_press_collapse(int_node_id)
        }
      } else {
        this._start_node_long_press_collapse(selected_node_id)
      }
    }

    this._collapse_unit_id = init_unit_id
    this._collapse_commit = true
    this._collapse_init_node_id_set = new Set(selected_node_ids)
    this._collapse_pointer_to_unit[pointer_id] = graph_id

    const collapse_map = this._predict_collapse_map(graph_id, selected_node_ids)

    const should_predict_size =
      (graph_render || should_graph_become_component) &&
      (!init_unit_id || !init_unit_is_render)

    this._flush_debugger()
    this._pause_debugger()

    const started = this._state_move_subgraph_into(
      graph_id,
      collapse_map,
      should_predict_size,
      graph_render,
      { x, y },
      true
    )

    const graph_bundle = this._get_graph_unit_bundle_spec(graph_id)

    const data: GraphMoveSubGraphIntoData = {
      graphId: this._collapse_next_unit_id,
      nextSpecId: this._collapse_next_spec_id,
      graphBundle: graph_bundle,
      graphSpec: graph_spec,
      nodeIds: {
        unit: this._collapse_units,
        link: this._collapse_link_pins,
        merge: this._collapse_merges,
        plug: this._collapse_plugs,
      },
      nextIdMap: this._collapse_next_id_map,
      nextPinIdMap: this._collapse_unit_next_pin_map,
      nextMergePinId: this._collapse_merge_next_pin_map,
      nextPlugSpec: this._collapse_next_plug_spec_map,
      nextSubComponentParentMap: this._collapse_sub_component_next_parent_id,
      nextSubComponentChildrenMap: this._collapse_sub_component_next_children,
      nextUnitPinMergeMap: this._collapse_next_unit_pin_merge_map,
      nextSubComponentIndexMap: this._collapse_next_sub_component_index_map,
      nextSubComponentParentSlot: this._collapse_next_sub_component_parent_slot,
      nextSubComponentSlot: this._collapse_next_sub_component_slot,
      position,
    }

    // console.log(data)

    const new_bundle = graph_unit_bundle ?? {
      unit: { id: graph_spec_id },
      specs: {
        [graph_spec_id]: {
          id: graph_spec_id,
        },
      },
    }

    stringifyBundleSpec(new_bundle)

    const actions = []

    if (!this._collapse_unit_id) {
      actions.push(
        makeAddUnitAction(
          graph_id,
          clone(new_bundle),
          position,
          undefined,
          undefined,
          lowest_common_ancestor
        )
      )
    }

    actions.push(wrapMoveSubgraphIntoData(data))

    const action = makeBulkEditAction(actions)

    this._dispatch_action(clone(action))

    this._pod.$bulkEdit({
      actions: clone(actions),
      fork,
      bubble,
    })

    return started
  }

  private _pod_move_unit_into = (
    graph_id: string,
    new_bundle,
    collapse_map: GraphMoveSubGraphIntoData
  ) => {
    const { fork, bubble } = this.$props

    const actions = []

    if (!this._collapse_unit_id) {
      actions.push(makeAddUnitAction(graph_id, new_bundle))
    }

    actions.push(wrapMoveSubgraphIntoData(collapse_map))

    const action = makeBulkEditAction(actions)

    this._pod.$bulkEdit({
      actions,
      fork,
      bubble,
    })
  }

  private _state_move_subgraph_into = (
    graph_unit_id: string,
    collapse_map: GraphMoveSubGraphData,
    should_predict_size: boolean,
    do_not_animate_graph_size: boolean,
    { x, y }: Position,
    animate: boolean
  ): boolean => {
    // console.log(
    //   'Graph',
    //   '_state_move_subgraph_into',
    //   graph_unit_id,
    //   should_predict_size,
    //   do_not_animate_graph_size
    // )

    const {
      nodeIds: { unit = [], link = [], merge = [], plug = [], data = [] },
      nextIdMap,
      nextSpecId,
      nextPinIdMap,
      nextMergePinId,
      nextUnitPinMergeMap,
      nextPlugSpec,
      nextSubComponentParentMap,
      nextSubComponentIndexMap,
      nextSubComponentChildrenMap,
    } = collapse_map

    this._collapsing = true
    this._collapse_init_spec = clone(this._spec)
    this._collapse_next_unit_id = graph_unit_id
    this._collapse_next_spec_id = nextSpecId
    this._collapse_world_position = this._get_node_position(graph_unit_id)
    this._collapse_next_map = collapse_map
    this._collapse_next_id_map = nextIdMap
    this._collapse_unit_next_pin_map = nextPinIdMap
    this._collapse_merge_next_pin_map = nextMergePinId
    this._collapse_next_plug_spec_map = nextPlugSpec
    this._collapse_next_unit_pin_merge_map = nextUnitPinMergeMap
    this._collapse_next_sub_component_index_map = nextSubComponentIndexMap

    this._collapse_next_sub_component_index_map = nextSubComponentIndexMap
    this._collapse_sub_component_children = nextSubComponentChildrenMap
    this._collapse_sub_component_next_parent_id = nextSubComponentParentMap
    this._collapse_sub_component_next_children = nextSubComponentChildrenMap
    this._collapse_units = unit
    this._collapse_link_pins = link
    this._collapse_merges = merge
    this._collapse_plugs = plug

    const none_node_selected =
      unit.length === 0 &&
      link.length === 0 &&
      plug.length === 0 &&
      merge.length === 0 &&
      data.length === 0

    const there_is_selected_sub_component = unit.some(
      (node_id) =>
        this._is_unit_node_id(node_id) && this._is_unit_component(node_id)
    )

    const sub_component_ids = []

    const graph_is_component = this._is_unit_component(graph_unit_id)

    if (graph_is_component) {
      this._set_sub_component_controlled(graph_unit_id, true)
    }

    const should_graph_become_component =
      !(this._get_node_shape(graph_unit_id) === 'rect') &&
      this._get_unit_spec_render(graph_unit_id) === undefined &&
      !this._is_system_unit(graph_unit_id) &&
      there_is_selected_sub_component

    if (should_graph_become_component) {
      this._componentify_core(graph_unit_id, {}, true)
      this._set_sub_component_controlled(graph_unit_id, true)
    }

    const graph_component = this._get_sub_component(graph_unit_id)

    for (const unit_id of unit) {
      this._collapse_unit_spec[unit_id] = this._get_unit_spec(unit_id)

      const unit_is_component = this._is_unit_component(unit_id)

      const unit_node = this.get_node(unit_id)

      const n0 = { ...unit_node, opacity: 1 }

      const n1 = () => {
        const graph_node = this.get_node(graph_unit_id)

        const { x, y } = graph_node

        const { width, height } = get_final_size()

        const trait = { x, y, width, height, opacity: 1 }

        return trait
      }

      if (unit_is_component) {
        sub_component_ids.push(unit_id)
      }

      if (!unit_is_component && graph_component) {
        //
      } else {
        this._animate_core_size_and_opacity(
          unit_id,
          n0,
          n1,
          ({ width, height }) => {
            this._resize_core_width(unit_id, width)
            this._resize_node_width(unit_id, width)

            this._resize_core_height(unit_id, height)
            this._resize_node_height(unit_id, height)
          },
          () => {
            //
          }
        )
      }
    }

    const ordered_sub_component_ids =
      this._order_sub_component_ids(sub_component_ids)

    let max_width = -Infinity
    let max_height = -Infinity

    if (graph_is_component || should_graph_become_component) {
      for (const sub_component_id of ordered_sub_component_ids) {
        const sub_component = this._get_sub_component(sub_component_id)
        const children = this._spec_get_sub_component_children(sub_component_id)

        for (const child_id of children) {
          if (!sub_component_ids.includes(child_id)) {
            const child_component = this._get_sub_component(child_id)

            sub_component.pullParentRoot(child_component)

            this._component.pushRoot(child_component)
          }
        }
      }

      const sub_components = []

      for (const sub_component_id of ordered_sub_component_ids) {
        const sub_component = this._get_sub_component(sub_component_id)

        sub_components.push(sub_component)

        const parent_id =
          this._spec_get_sub_component_parent_id(sub_component_id)
        const children = this._spec_get_sub_component_children(sub_component_id)

        const { width, height } = this._get_node_size(sub_component_id)

        max_width = Math.max(max_width, width)
        max_height = Math.max(max_height, height)

        const next_sub_component_id =
          this._collapse_next_id_map.unit[sub_component_id] ?? sub_component_id

        this._component.removeSubComponent(sub_component_id)

        graph_component.setSubComponent(next_sub_component_id, sub_component)

        const push = () => {
          const next_parent_id =
            collapse_map.nextSubComponentParentMap[sub_component_id]

          if (next_parent_id) {
            const graph_sub_parent =
              graph_component.getSubComponent(next_parent_id)

            const graph_sub_parent_slot_name =
              collapse_map.nextSubComponentParentSlot[sub_component_id] ??
              'default'

            graph_sub_parent.pushParentRoot(
              sub_component,
              graph_sub_parent_slot_name
            )
          } else {
            graph_component.pushRoot(sub_component)
          }
        }

        if (parent_id) {
          const parent_component = this._get_sub_component(parent_id)

          let parent_root_id = parent_id

          while (parent_root_id && !this._collapse_node_id.has(parent_id)) {
            parent_root_id =
              this._spec_get_sub_component_parent_id(parent_root_id)
          }

          if (parent_root_id) {
            const parent_root_sub_component =
              graph_component.getSubComponent(parent_root_id)

            if (parent_root_id === parent_id) {
              //
            } else {
              parent_component.pullParentRoot(sub_component)
              parent_root_sub_component.pushParentRoot(sub_component, 'default')
            }
          } else {
            parent_component.pullParentRoot(sub_component)

            push()
          }
        } else {
          this._component.pullRoot(sub_component)

          push()
        }

        const slot = collapse_map.nextSubComponentSlot[sub_component_id] ?? null

        if (slot) {
          graph_component.$slot[slot] = sub_component
        }
      }

      if (ordered_sub_component_ids.length) {
        const finish = () => {
          for (const unit_id of ordered_sub_component_ids) {
            this._mem_remove_component(unit_id)
          }
        }

        if (animate) {
          const sub_component = this._get_sub_component(graph_unit_id)
          const base = this._get_sub_component_base(graph_unit_id)

          this._measure_sub_component_base(graph_unit_id, base)

          for (const sub_component_id of ordered_sub_component_ids) {
            const next_sub_component_id =
              this._collapse_next_id_map.unit[sub_component_id] ??
              sub_component_id

            const sub_component = graph_component.getSubComponent(
              next_sub_component_id
            )

            this.__leave_sub_component_frame(sub_component_id, sub_component)
          }

          this._decompose_sub_component(graph_unit_id)

          this._animate_sub_component_graph_leave(
            graph_unit_id,
            base,
            [],
            () => {
              const style = {}

              const { x, y } = this._get_node_screen_position(graph_unit_id)

              const { z } = this._zoom

              const { width, height } = get_final_size()

              const color = sub_component.getColor()

              const trait: LayoutNode = {
                x: x - 1,
                y: y - 1,
                width,
                height,
                sx: z,
                sy: z,
                opacity: 1,
                fontSize: 14,
                color,
              }

              return {
                style,
                trait,
              }
            },
            async () => {
              finish()

              return true
            }
          )
        } else {
          finish()
        }
      }
    }

    const init_unit_node = this.get_node(graph_unit_id)

    const n0 = graph_unit_id
      ? {
          x: init_unit_node.x,
          y: init_unit_node.y,
          width: init_unit_node.width,
          height: init_unit_node.height,
          opacity: 1,
        }
      : { x, y, width: 2, height: 2, opacity: 1 }

    let { x: collapse_client_x, y: collapse_client_y } = { x, y }

    const get_final_size = (): Size => {
      const { width, height } = this._spec_get_graph_core_size(
        graph_unit_id,
        false
      )

      const final_width = should_predict_size ? max_width : width
      const final_height = should_predict_size ? max_height : height

      return {
        width: final_width,
        height: final_height,
      }
    }

    const n1: () => Rect & { opacity: number } = () => {
      const {
        api: {
          window: { setTimeout },
        },
      } = this.$system

      if (this._pressed_node_id_pointer_id[graph_unit_id]) {
        const { x, y } = this._get_node_screen_position(graph_unit_id)

        collapse_client_x = x
        collapse_client_y = y
      }

      const { x, y } = this._screen_to_world(
        collapse_client_x,
        collapse_client_y
      )

      const { width, height } = get_final_size()

      return {
        x,
        y,
        width,
        height,
        opacity: 1,
      }
    }

    if (!do_not_animate_graph_size && animate) {
      this._animate_core_size_and_opacity(
        graph_unit_id,
        n0,
        n1,
        ({ width, height }) => {
          this._resize_core_width(graph_unit_id, width)
          this._resize_node_width(graph_unit_id, width)

          this._resize_core_height(graph_unit_id, height)
          this._resize_node_height(graph_unit_id, height)
        },
        () => {
          //
        }
      )
    }

    if (graph_unit_id) {
      this._set_node_layer(graph_unit_id, LAYER_NONE)
    }

    if (!animate) {
      for (const collapse_node_id of this._collapse_node_id) {
        this._stop_node_long_press_collapse(collapse_node_id)
        this._state_move_node_into_graph(
          graph_unit_id,
          collapse_node_id,
          collapse_map
        )
      }

      this._stop_collapse()

      this._refresh_unit_layer(graph_unit_id)
      this._set_unit_fixed(graph_unit_id, false)
    } else if (none_node_selected) {
      setTimeout(() => {
        this._stop_collapse()
      }, 0)
    }

    this._simulation.alphaDecay(0)

    this._start_graph_simulation(LAYER_NONE)

    return true
  }

  private _state_make_this_graph_interface = (
    position?: Position
  ): GraphLike => {
    const graph_interface: GraphLike = {
      removeUnit: (unitId: string) => {
        return this._state_remove_unit(unitId)
      },
      addPinToMerge: (mergeId, unitId, type, pinId) => {
        return this._state_add_link_pin_to_merge(mergeId, unitId, type, pinId)
      },
      addMerge: (mergeSpec: GraphMergeSpec, mergeId: string) => {
        position = position ?? this._init_merge_spec_position(mergeSpec)

        this._state_add_merge(mergeId, mergeSpec, position)

        this._sim_collapse_merge(mergeId)
      },
      plugPin: (
        type: IO,
        pinId: string,
        subPinId: string,
        subPinSpec: GraphSubPinSpec
      ) => {
        const plug_node_id = getExtNodeId(type, pinId, subPinId)

        const datum_node_id = this._plug_to_datum[plug_node_id]

        this._state_plug_exposed_pin(type, pinId, subPinId, subPinSpec)

        if (datum_node_id) {
          const value = this._get_datum_value(datum_node_id)

          if (value) {
            const pin_node_id = getSubPinSpecNodeId(type, subPinSpec)

            if (subPinSpec.unitId) {
              this._state_set_unit_pin_data(pin_node_id, value)
            } else if (subPinSpec.mergeId) {
              this._state_set_merge_pin_data(pin_node_id, value)
            }
          }
        }
      },
      hasMerge: (mergeId: string): boolean => {
        return this.__spec_has_merge(mergeId)
      },
      exposePinSet: (type: IO, pinId: string, pinSpec: GraphPinSpec) => {
        return this._state_add_exposed_pin_set(type, pinId, pinSpec)
      },
      exposePin: (type: IO, pinId: string, subPinId: string, plugSpec) => {
        return this._state_add_exposed_pin(type, pinId, subPinId, plugSpec, {})
      },
      coverPin: (type: IO, pinId: string, subPinId: string) => {
        return this.__state_remove_exposed_sub_pin(type, pinId, subPinId)
      },
      setUnitPinConstant: (
        unitId: string,
        type: IO,
        pinId: string,
        constant: boolean,
        emit?: boolean
      ) => {
        throw new MethodNotImplementedError()
      },
      coverPinSet: (type: IO, pinId: string) => {
        return this._state_cover_pin_set(type, pinId)
      },
      unplugPin: (type: IO, pinId: string, subPinId: string) => {
        return this._state_unplug_exposed_pin(type, pinId, subPinId)
      },
      getSubPinSpec: (type: IO, pinId: string, subPinId: string) => {
        return this._spec_get_sub_pin_spec(type, pinId, subPinId)
      },
      getMergesSpec: function (): GraphMergesSpec {
        throw new MethodNotImplementedError()
      },
      getMergeSpec: (mergeId: string): GraphMergeSpec => {
        return this._spec_get_merge(mergeId)
      },
      hasPinNamed: (type: IO, name: string): boolean => {
        return this._spec_has_pin_named(type, name)
      },
      getUnit: (unitId: string): U => {
        return this._state_get_unit_interface(unitId)
      },
      getUnitPinData: (unitId: string, type: IO, name: string) => {
        const pin_node_id = getPinNodeId(unitId, type, name)

        return this._get_pin_datum_value(pin_node_id)
      },
      getMergeData: (mergeId: string) => {
        const merge_node_id = getMergeNodeId(mergeId)

        const datum_node_id = this._get_merge_datum_node_id(merge_node_id)

        if (!datum_node_id) {
          return undefined
        }

        const value = this._get_datum_value(datum_node_id)

        return value
      },
      hasUnit: (id: string): boolean => {
        return this._spec_has_unit(id)
      },
      addUnit: (unitId: string, unit: U) => {
        position = position ?? this._jiggle_world_screen_center()

        const bundle = unit.getUnitBundleSpec()

        this._state_add_unit(
          unitId,
          bundle,
          position,
          {},
          {},
          position,
          null,
          null
        )

        if (this._is_unit_component(unitId)) {
          this._sim_add_sub_component(unitId)
          this._connect_sub_component(unitId)
        }
      },
      removeMerge: (mergeId: string): void => {
        const merge_node_id = getMergeNodeId(mergeId)

        return this._state_remove_merge(merge_node_id)
      },
      moveRoot: (
        parentId: string,
        childId: string,
        to: number,
        slotName: string
      ): void => {
        throw new MethodNotImplementedError()
      },
      setPinData: (type: IO, pinId: string, data: any): void => {
        throw new MethodNotImplementedError()
      },
      getPinPlugCount: (type: IO, pinId: string): number => {
        return this._spec_get_pin_plug_count(type, pinId)
      },
      getPinData: (
        type: IO,
        pinId: string
      ): { input: Dict<any>; output: Dict<any> } => {
        return deepGetOrDefault(this._unit_datum, [type, pinId], undefined)
      },
      setPinConstant: (type: IO, pinId: string, constant: boolean): void => {
        throw new MethodNotImplementedError()
      },
      hasPlug: (type: IO, pinId: string, subPinId: string): boolean => {
        return this._spec_has_plug(type, pinId, subPinId)
      },
      isUnitPinRef: (unitId: string, type: IO, pinId: string): boolean => {
        throw new MethodNotImplementedError()
      },
      getExposedPinSpec: (type: IO, pinId: string): GraphPinSpec => {
        return this._get_pin_spec(type, pinId)
      },
      removePinOrMerge: (
        mergeId: string,
        unitId: string,
        type: IO,
        pinId: string,
        emit?: boolean,
        propagate?: boolean
      ): void => {
        const pin_node_id = getPinNodeId(unitId, type, pinId)

        this._state_remove_pin_or_merge(pin_node_id)
      },
      getExposedPinSpecs: (): IOOf<GraphPinsSpec> => {
        return this._spec_get_exposed_pin_specs()
      },
      isPinConstant: (type: IO, name: string): boolean => {
        return false
      },
      removePinFromMerge: (mergeId, unitId, type, pinId) => {
        this.__state_remove_pin_from_merge(mergeId, unitId, type, pinId)
      },
      hasMergePin: (mergeId, unitId, type, pinId) => {
        return this._spec_has_merge_pin(mergeId, unitId, type, pinId)
      },
      getPlugSpecs: () => {
        throw new MethodNotImplementedError()
      },
      getSpec: () => {
        return this._spec
      },
      setUnitSize: (unitId: string, width: number, height: number): void => {
        this._resize_core(unitId, width, height)
      },
      setSubComponentSize: function (
        unitId: string,
        width: number,
        height: number
      ): void {
        throw new MethodNotImplementedError()
      },
      isUnitPinConstant: function (
        unitId: string,
        type: IO,
        pinId: string
      ): boolean {
        throw new MethodNotImplementedError()
      },
      removeUnitPinData: function (
        unitId: string,
        type: IO,
        pinId: string,
        ...extra: any[]
      ) {
        throw new MethodNotImplementedError()
      },
      setSlot: function (slotName: string, subComponentId: string): void {
        //
      },
    }

    return graph_interface
  }
  public get state_make_this_graph_interface() {
    return this._state_make_this_graph_interface
  }
  public set state_make_this_graph_interface(value) {
    this._state_make_this_graph_interface = value
  }

  private _state_get_subgraph_graph_interface = (
    graph_id: string
  ): GraphLike => {
    const { specs } = this.$props

    const spec = clone(this._get_unit_spec(graph_id)) as GraphSpec

    const graph_interface: GraphLike = {
      removeUnit: (unitId: string, destroy: boolean): void => {
        const unit = spec.units[unitId]

        const bundle = unitBundleSpec(unit, specs)

        this._on_graph_unit_remove_unit_moment({
          unitId,
          bundle,
          destroy,
          path: [graph_id],
        })
      },
      getMergeData: (mergeId: string) => {
        return undefined
      },
      getPlugSpecs: () => {
        return this._spec_graph_unit_plug_specs(graph_id)
      },
      addPinToMerge: (
        mergeId: string,
        unitId: string,
        type: IO,
        pinId: string
      ) => {
        return this._spec_graph_unit_add_pin_to_merge(
          graph_id,
          mergeId,
          unitId,
          type,
          pinId
        )
      },
      addMerge: (mergeSpec: GraphMergeSpec, mergeId: string) => {
        this._spec_graph_unit_add_merge(graph_id, mergeId, mergeSpec)
      },
      plugPin: (
        type: IO,
        pinId: string,
        subPinId: string,
        subPinSpec: GraphSubPinSpec
      ) => {
        const { specs } = this.$props

        const ref = false // TODO

        this._spec_graph_unit_add_sub_pin(
          graph_id,
          type,
          pinId,
          ref,
          subPinId,
          subPinSpec
        )
      },
      hasMerge: (mergeId: string): boolean => {
        return this._spec_graph_unit_has_merge(graph_id, mergeId)
      },
      exposePinSet: (
        type: IO,
        pinId: string,
        pinSpec: GraphPinSpec,
        data: string
      ) => {
        const graph_node = this._node[graph_id]

        const graph_position = this._get_node_position(graph_id)

        const u = randomUnitVector()
        const position = pointInNode(graph_node, u, 3)

        this._spec_graph_unit_expose_pin_set(graph_id, type, pinId, pinSpec)
        this._sim_graph_unit_expose_pin_set(graph_id, type, pinId, position)

        if (data !== undefined) {
          const pin_node_id = getPinNodeId(graph_id, type, pinId)

          this._state_set_unit_pin_data(pin_node_id, data)
        }
      },
      exposePin: (
        type: IO,
        pinId: string,
        subPinId: string,
        subPinSpec: GraphSubPinSpec
      ) => {
        return this._on_graph_unit_expose_pin({
          type,
          pinId,
          subPinId,
          subPinSpec,
          path: [graph_id],
        })
      },
      coverPin: (type: IO, pinId: string, subPinId: string) => {
        const subPinSpec = this._spec_graph_unit_get_sub_pin_spec(
          graph_id,
          type,
          pinId,
          subPinId
        )

        this._on_graph_unit_cover_pin({
          type,
          pinId,
          subPinId,
          subPinSpec,
          path: [graph_id],
        })
      },
      setUnitPinConstant: (
        unitId: string,
        type: IO,
        pinId: string,
        constant: boolean
      ): void => {
        this._on_graph_unit_set_unit_pin_constant({
          unitId,
          type,
          pinId,
          constant,
          data: undefined,
          path: [graph_id],
        })
      },
      coverPinSet: (type: IO, pinId: string, emit?: boolean): void => {
        const pin_spec = this._spec_graph_get_pin_spec(graph_id, type, pinId)

        this._on_graph_unit_cover_pin_set({
          type,
          pinId,
          path: [graph_id],
          pinSpec: pin_spec,
          data: undefined,
        })
      },
      unplugPin: (type: IO, pinId: string, subPinId: string): void => {
        const subPinSpec = this._spec_graph_unit_get_sub_pin_spec(
          graph_id,
          type,
          pinId,
          subPinId
        )

        this._on_graph_unit_unplug_pin_moment({
          type,
          pinId,
          subPinId,
          subPinSpec,
          path: [graph_id],
        })
      },
      getMergesSpec: (): GraphMergesSpec => {
        return this._spec_graph_get_merges_spec(graph_id)
      },
      getMergeSpec: (mergeId: string): GraphMergeSpec => {
        return this._spec_graph_get_merge_spec(graph_id, mergeId)
      },
      hasPinNamed: (type: IO, name: string): boolean => {
        return this._spec_unit_has_pin_named(graph_id, type, name)
      },
      getUnit: (unitId: string): U => {
        return this._spec_graph_get_unit_interface_from_spec(spec, unitId, {})
      },
      getUnitPinData: (unitId: string, type: IO, pinId: string) => {
        return this._spec_graph_get_unit_pin_data(graph_id, unitId, type, pinId)
      },
      hasUnit: (unitId: string): boolean => {
        return this._spec_graph_unit_has_unit(graph_id, unitId)
      },
      addUnit: (unitId: string, unit: U) => {
        const bundle = unit.getUnitBundleSpec()
        const spec = unit.getSpec()

        const graph_unit = {
          id: spec.id,
        }

        this._on_graph_unit_add_unit_moment({
          unitId,
          bundle,
          path: [graph_id],
        })
      },
      removeMerge: (mergeId: string): void => {
        return this._spec_graph_unit_remove_merge(graph_id, mergeId)
      },
      moveRoot: (
        parentId: string,
        childId: string,
        to: number,
        slotName: string
      ): void => {
        throw new MethodNotImplementedError()
      },
      setPinData: (type: IO, pinId: string, data: any): void => {
        throw new MethodNotImplementedError()
      },
      getPinPlugCount: (type: IO, pinId: string): number => {
        return this._spec_graph_unit_get_pin_plug_count(graph_id, type, pinId)
      },
      getPinData: (type: IO, pinId: string): any => {
        const pin_node_id = getPinNodeId(graph_id, type, pinId)

        return this._get_pin_datum_value(pin_node_id)
      },
      setPinConstant: (type: IO, pinId: string, constant: boolean): void => {
        throw new MethodNotImplementedError()
      },
      hasPlug: (type: IO, pinId: string, subPinId: string): boolean => {
        return this._spec_graph_unit_has_plug(graph_id, type, pinId, subPinId)
      },
      isUnitPinRef: (unitId: string, type: IO, pinId: string): boolean => {
        throw new MethodNotImplementedError()
      },
      getExposedPinSpecs: (): IOOf<GraphPinsSpec> => {
        return getExposedPinSpecs(spec)
      },
      getExposedPinSpec: (type: IO, pinId: string): GraphPinSpec => {
        return getExposePinSpec(spec, type, pinId)
      },
      removePinOrMerge: (
        mergeId: string,
        unitId: string,
        type: IO,
        pinId: string
      ): void => {
        return this._spec_graph_unit_remove_pin_or_merge(
          graph_id,
          mergeId,
          unitId,
          type,
          pinId
        )
      },
      isPinConstant: (type: IO, name: string): boolean => {
        return isUnitPinConstant(spec, graph_id, type, name)
      },
      removePinFromMerge: (
        mergeId: string,
        unitId: string,
        type: IO,
        pinId: string
      ) => {
        return this._spec_graph_unit_remove_pin_or_merge(
          graph_id,
          mergeId,
          unitId,
          type,
          pinId
        )
      },
      hasMergePin: (mergeId, unitId, type, pinId) => {
        return hasMergePin(spec, mergeId, unitId, type, pinId)
      },
      getSubPinSpec: (
        type: IO,
        pinId: string,
        subPinId: string
      ): GraphSubPinSpec => {
        throw new MethodNotImplementedError()
      },
      getSpec: () => {
        return spec
      },
      setUnitSize: (unitId: string, width: number, height: number): void => {
        //
      },
      setSubComponentSize: function (
        unitId: string,
        width: number,
        height: number
      ): void {
        //
      },
      isUnitPinConstant: function (
        unitId: string,
        type: IO,
        pinId: string
      ): boolean {
        throw new MethodNotImplementedError()
      },
      removeUnitPinData: function (
        unitId: string,
        type: IO,
        pinId: string,
        ...extra: any[]
      ) {
        throw new MethodNotImplementedError()
      },
      setSlot: function (slotName: string, subComponentId: string): void {
        //
      },
    }

    return graph_interface
  }

  private _spec_get_subgraph_graph_interface = (
    graph_id: string
  ): GraphLike => {
    const { specs } = this.$props

    const spec = clone(this._get_unit_spec(graph_id)) as GraphSpec

    const graph_interface: GraphLike = {
      removeUnit: (unitId: string): void => {
        const unit = spec.units[unitId]

        const bundle = unitBundleSpec(unit, specs)

        this._spec_graph_unit_remove_unit(graph_id, unitId)
      },
      getMergeData: (mergeId: string) => {
        return undefined
      },
      getPlugSpecs: this._spec_graph_unit_plug_specs.bind(graph_id),
      addPinToMerge: this._spec_graph_unit_add_pin_to_merge.bind(graph_id),
      addMerge: this._spec_graph_unit_add_merge.bind(graph_id),
      plugPin: this._spec_graph_unit_plug_pin.bind(graph_id),
      hasMerge: this._spec_graph_unit_has_merge.bind(graph_id),
      exposePinSet: this._spec_graph_unit_expose_pin_set.bind(graph_id),
      exposePin: this._spec_graph_unit_expose_pin.bind(graph_id),
      coverPin: this._spec_graph_unit_cover_pin.bind(graph_id),
      setUnitPinConstant:
        this._spec_graph_unit_set_unit_pin_constant.bind(graph_id),
      coverPinSet: this._spec_graph_unit_cover_pin_set.bind(graph_id),
      unplugPin: (type: IO, pinId: string, subPinId: string): void => {
        const subPinSpec = this._spec_graph_unit_get_sub_pin_spec(
          graph_id,
          type,
          pinId,
          subPinId
        )

        this._on_graph_unit_unplug_pin_moment({
          type,
          pinId,
          subPinId,
          subPinSpec,
          path: [graph_id],
        })
      },
      getMergesSpec: (): GraphMergesSpec => {
        return this._spec_graph_get_merges_spec(graph_id)
      },
      getMergeSpec: (mergeId: string): GraphMergeSpec => {
        return this._spec_graph_get_merge_spec(graph_id, mergeId)
      },
      hasPinNamed: (type: IO, name: string): boolean => {
        return this._spec_unit_has_pin_named(graph_id, type, name)
      },
      getUnit: (unitId: string): U => {
        return this._spec_graph_get_unit_interface_from_spec(spec, unitId, {})
      },
      getUnitPinData: (unitId: string, type: IO, pinId: string) => {
        return this._spec_graph_get_unit_pin_data(graph_id, unitId, type, pinId)
      },
      hasUnit: (unitId: string): boolean => {
        return this._spec_graph_unit_has_unit(graph_id, unitId)
      },
      addUnit: (unitId: string, unit: U) => {
        const bundle = unit.getUnitBundleSpec()
        const spec = unit.getSpec()

        const graph_unit = {
          id: spec.id,
        }

        this._on_graph_unit_add_unit_moment({
          unitId,
          bundle,
          path: [graph_id],
        })
      },
      removeMerge: (mergeId: string): void => {
        return this._spec_graph_unit_remove_merge(graph_id, mergeId)
      },
      moveRoot: (
        parentId: string,
        childId: string,
        to: number,
        slotName: string
      ): void => {
        throw new MethodNotImplementedError()
      },
      setPinData: (type: IO, pinId: string, data: any): void => {
        throw new MethodNotImplementedError()
      },
      getPinPlugCount: (type: IO, pinId: string): number => {
        return this._spec_graph_unit_get_pin_plug_count(graph_id, type, pinId)
      },
      getPinData: (type: IO, pinId: string): any => {
        const pin_node_id = getPinNodeId(graph_id, type, pinId)

        return this._get_pin_datum_value(pin_node_id)
      },
      setPinConstant: (type: IO, pinId: string, constant: boolean): void => {
        throw new MethodNotImplementedError()
      },
      hasPlug: (type: IO, pinId: string, subPinId: string): boolean => {
        return this._spec_graph_unit_has_plug(graph_id, type, pinId, subPinId)
      },
      isUnitPinRef: (unitId: string, type: IO, pinId: string): boolean => {
        throw new MethodNotImplementedError()
      },
      getExposedPinSpecs: (): IOOf<GraphPinsSpec> => {
        return getExposedPinSpecs(spec)
      },
      getExposedPinSpec: (type: IO, pinId: string): GraphPinSpec => {
        return getExposePinSpec(spec, type, pinId)
      },
      removePinOrMerge: (
        mergeId: string,
        unitId: string,
        type: IO,
        pinId: string
      ): void => {
        return this._spec_graph_unit_remove_pin_or_merge(
          graph_id,
          mergeId,
          unitId,
          type,
          pinId
        )
      },
      isPinConstant: (type: IO, name: string): boolean => {
        return isUnitPinConstant(spec, graph_id, type, name)
      },
      removePinFromMerge: (
        mergeId: string,
        unitId: string,
        type: IO,
        pinId: string
      ) => {
        return this._spec_graph_unit_remove_pin_or_merge(
          graph_id,
          mergeId,
          unitId,
          type,
          pinId
        )
      },
      hasMergePin: (mergeId, unitId, type, pinId) => {
        return hasMergePin(spec, mergeId, unitId, type, pinId)
      },
      getSubPinSpec: (
        type: IO,
        pinId: string,
        subPinId: string
      ): GraphSubPinSpec => {
        throw new MethodNotImplementedError()
      },
      getSpec: () => {
        return spec
      },
      setUnitSize: (unitId: string, width: number, height: number): void => {
        //
      },
      setSubComponentSize: function (
        unitId: string,
        width: number,
        height: number
      ): void {
        //
      },
      isUnitPinConstant: function (
        unitId: string,
        type: IO,
        pinId: string
      ): boolean {
        throw new MethodNotImplementedError()
      },
      removeUnitPinData: function (
        unitId: string,
        type: IO,
        pinId: string,
        ...extra: any[]
      ) {
        throw new MethodNotImplementedError()
      },
      setSlot: function (slotName: string, subComponentId: string): void {
        //
      },
    }

    return graph_interface
  }

  private _state_get_graph_unit_graph_unit_interface = (
    graph_id: string,
    unit_id: string
  ): GraphLike => {
    const spec = clone(this._get_graph_unit_unit_spec(graph_id, unit_id))

    return this._make_graph_spec_interface(spec)
  }

  private _make_spec_unit_interface = (unit: GraphUnitSpec, spec: Spec): U => {
    const interface_: U = {
      setParent: function (parent: Unit<any, any, UnitEvents<U_EE>>) {
        throw new MethodNotImplementedError()
      },
      setInputs: function (inputs: Pins<any>, opts: PinOpts): void {
        throw new MethodNotImplementedError()
      },
      setPinIgnored: function (type: IO, name: string, ignored: boolean): void {
        throw new MethodNotImplementedError()
      },
      setOutputIgnored: function (name: string, ignore?: boolean): boolean {
        throw new MethodNotImplementedError()
      },
      setPinRef: function (type: IO, name: string, ref: boolean): void {
        throw new MethodNotImplementedError()
      },
      setInputRef: function (name: string, ref: boolean): void {
        throw new MethodNotImplementedError()
      },
      setOutputRef: function (name: string, ref: boolean): void {
        throw new MethodNotImplementedError()
      },
      setInput: function (name: string, input: Pin<any>, opt: PinOpt): void {
        throw new MethodNotImplementedError()
      },
      isPinConstant: function (type: IO, name: string): boolean {
        return (
          deepGetOrDefault(unit, [type, name, 'constant'], undefined) ??
          deepGetOrDefault(spec, [`${type}s`, name, 'defaultIgnored'], false)
        )
      },
      isPinIgnored: function (type: IO, name: string): boolean {
        return false
      },
      isPinRef: function (type: IO, name: string): boolean {
        return isPinRef({ type, pinId: name }, spec)
      },
      addInput: function (name: string, input: Pin<any>, opt: PinOpt): void {
        throw new MethodNotImplementedError()
      },
      removeInput: function (name: string): void {
        throw new MethodNotImplementedError()
      },
      setOutputs: function (outputs: Pins<any>, opts: PinOpts) {
        throw new MethodNotImplementedError()
      },
      setOutput: function (name: string, output: Pin<any>, opt: PinOpt) {
        throw new MethodNotImplementedError()
      },
      addOutput: function (name: string, output: Pin<any>): void {
        throw new MethodNotImplementedError()
      },
      removeOutput: function (name: string): void {
        throw new MethodNotImplementedError()
      },
      removePin: function (type: IO, name: string) {
        throw new MethodNotImplementedError()
      },
      getPin: function (type: IO, name: string): Pin<any> {
        throw new MethodNotImplementedError()
      },
      getInputs: function (): Pins<any> {
        throw new MethodNotImplementedError()
      },
      getDataInputs: function (): Pins<Partial<any>> {
        throw new MethodNotImplementedError()
      },
      getRefInputs: function (): Pins<Partial<any>> {
        throw new MethodNotImplementedError()
      },
      getInput: function <K>(name: K): Pin<K> {
        throw new MethodNotImplementedError()
      },
      getOutputs: function (): Pins<any> {
        throw new MethodNotImplementedError()
      },
      getDataOutputs: function (): Pins<Partial<any>> {
        throw new MethodNotImplementedError()
      },
      getRefOutputs: function (): Pins<Partial<any>> {
        throw new MethodNotImplementedError()
      },
      pushAllInput: function <K extends string>(data: Dict<any>): void {
        throw new MethodNotImplementedError()
      },
      pushAllOutput: function <K extends string>(data: Dict<any>): void {
        throw new MethodNotImplementedError()
      },
      pushAll: function <K extends string>(data: Dict<any>): void {
        throw new MethodNotImplementedError()
      },
      peakAllOutput: function (): Dict<any> {
        throw new MethodNotImplementedError()
      },
      peakAll: function (): Dict<any> {
        throw new MethodNotImplementedError()
      },
      getInputCount: function (): number {
        throw new MethodNotImplementedError()
      },
      getOutputCount: function (): number {
        throw new MethodNotImplementedError()
      },
      getInputNames: function (): string[] {
        return keys(spec.inputs)
      },
      getOutputNames: function (): string[] {
        return keys(spec.outputs)
      },
      setPinData: function (type: IO, name: string, data: any): void {
        throw new MethodNotImplementedError()
      },
      removePinData: function (type: IO, name: string): void {
        throw new MethodNotImplementedError()
      },
      setInputConstant: function (name: string, constant: boolean): void {
        throw new MethodNotImplementedError()
      },
      setOutputConstant: function (name: string, constant: boolean): void {
        throw new MethodNotImplementedError()
      },
      getCatchErr: function (): boolean {
        throw new MethodNotImplementedError()
      },
      getConfig: function (): Opt {
        throw new MethodNotImplementedError()
      },
      reset: function (): void {
        throw new MethodNotImplementedError()
      },
      pause: function (): void {
        throw new MethodNotImplementedError()
      },
      play: function (): void {
        throw new MethodNotImplementedError()
      },
      paused: function (): boolean {
        throw new MethodNotImplementedError()
      },
      snapshot: function (): Memory {
        throw new MethodNotImplementedError()
      },
      restore: function (state: Memory): void {
        throw new MethodNotImplementedError()
      },
      getSelfPin: function (): Pin<U<any, any>> {
        throw new MethodNotImplementedError()
      },
      err: function (err?: string | Error): string {
        throw new MethodNotImplementedError()
      },
      hasErr: function (): boolean {
        throw new MethodNotImplementedError()
      },
      getErr: function (): string {
        throw new MethodNotImplementedError()
      },
      takeErr: function (): string {
        throw new MethodNotImplementedError()
      },
      getPinsData: function (): { input: Dict<any>; output: Dict<any> } {
        throw new MethodNotImplementedError()
      },
      getInputData: function (): Dict<any> {
        throw new MethodNotImplementedError()
      },
      getRefInputData: function (): Dict<Unit<any, any, UnitEvents<U_EE>>> {
        throw new MethodNotImplementedError()
      },
      getSpec: function (): Spec {
        return spec
      },
      getPinData: function (type: IO, name: string) {
        return undefined
      },
      setPinConstant: function (
        type: IO,
        name: string,
        constant: boolean
      ): void {
        throw new MethodNotImplementedError()
      },
      getUnitBundleSpec: (): UnitBundleSpec => {
        const { specs } = this.$props

        const bundle = unitBundleSpec(unit, specs)

        return bundle
      },
      setPin: function <
        T extends IO,
        K extends T extends 'input'
          ? string | number | symbol
          : string | number | symbol,
      >(type: T, name: K, pin: Pin<any>, opt: PinOpt) {
        throw new MethodNotImplementedError()
      },
      setInputIgnored: function <K extends string | number | symbol>(
        name: K,
        ignore?: boolean
      ): boolean {
        throw new MethodNotImplementedError()
      },
      getOutput: function <K extends string | number | symbol>(
        name: K
      ): Pin<any> {
        throw new MethodNotImplementedError()
      },
      push: function <K extends string | number | symbol>(
        name: K,
        data: any
      ): void {
        throw new MethodNotImplementedError()
      },
      pushInput: function <K extends string | number | symbol>(
        name: K,
        data: any
      ): void {
        throw new MethodNotImplementedError()
      },
      pushOutput: function <K extends string | number | symbol>(
        name: K,
        data: any
      ): void {
        throw new MethodNotImplementedError()
      },
      takeInput: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      takeOutput: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      take: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      takeAll: function (): Dict<any> {
        throw new MethodNotImplementedError()
      },
      peakInput: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      peakOutput: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      peak: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      renamePin: function <
        T extends IO,
        K extends T extends 'input'
          ? string | number | symbol
          : string | number | symbol,
      >(type: T, name: K, newName: K): void {
        throw new MethodNotImplementedError()
      },
      renameInput: function <K extends string | number | symbol>(
        name: K,
        newName: K
      ): void {
        throw new MethodNotImplementedError()
      },
      renameOutput: function (name: string, newName: string): void {
        throw new MethodNotImplementedError()
      },
      hasRefPinNamed: function <
        T extends IO,
        K extends T extends 'input'
          ? string | number | symbol
          : string | number | symbol,
      >(type: T, name: K): boolean {
        throw new MethodNotImplementedError()
      },
      hasRefInputNamed: function <K extends string | number | symbol>(
        name: K
      ): boolean {
        throw new MethodNotImplementedError()
      },
      hasRefOutputNamed: function <K extends string | number | symbol>(
        name: K
      ): boolean {
        throw new MethodNotImplementedError()
      },
      hasPinNamed: function (type: IO, name: string): boolean {
        throw new MethodNotImplementedError()
      },
      hasInputNamed: function <K extends string | number | symbol>(
        name: K
      ): boolean {
        throw new MethodNotImplementedError()
      },
      hasOutputNamed: function <K extends string | number | symbol>(
        name: K
      ): boolean {
        throw new MethodNotImplementedError()
      },
    }

    return interface_
  }

  private _make_graph_spec_interface = (spec: GraphSpec): GraphLike => {
    // console.log('make_graph_spec_interface', spec)

    const { specs, getSpec } = this.$props

    const spec_interface: GraphLike = {
      removeUnit: (unitId: string): void => {
        if (isUnitComponent(specs, spec, unitId)) {
          removeSubComponent({ unitId }, spec.component)
          removeRoot({ childId: unitId }, spec.component)
        }
        removeUnit({ unitId }, spec)
      },
      getMergeData: (mergeId: string) => {
        return {}
      },
      getPlugSpecs: () => {
        return getPlugSpecs(spec)
      },
      addPinToMerge: (
        mergeId: string,
        unitId: string,
        type: IO,
        pinId: string
      ) => {
        return addPinToMerge({ mergeId, unitId, type, pinId }, spec)
      },
      addMerge: (mergeSpec: GraphMergeSpec, mergeId: string) => {
        return addMerge({ mergeId, mergeSpec }, spec)
      },
      plugPin: (
        type: IO,
        pinId: string,
        subPinId: string,
        subPinSpec: GraphSubPinSpec
      ) => {
        return plugPin({ type, pinId, subPinId, subPinSpec }, spec)
      },
      hasMerge: (mergeId: string): boolean => {
        return hasMerge(spec, mergeId)
      },
      exposePinSet: (
        type: IO,
        pinId: string,
        pinSpec: GraphPinSpec,
        data: string
      ) => {
        return exposePinSet({ type, pinId, pinSpec }, spec)
      },
      exposePin: (
        type: IO,
        pinId: string,
        subPinId: string,
        subPinSpec: GraphSubPinSpec
      ) => {
        return exposePin({ type, pinId, subPinId, subPinSpec }, spec)
      },
      coverPin: (type: IO, pinId: string, subPinId: string) => {
        return coverPin({ type, pinId, subPinId }, spec)
      },
      setUnitPinConstant: function (
        unitId: string,
        type: IO,
        pinId: string,
        constant: boolean
      ): void {
        return setUnitPinConstant({ unitId, type, pinId, constant }, spec)
      },
      coverPinSet: (type: IO, pinId: string, emit?: boolean): void => {
        return coverPinSet({ type, pinId }, spec)
      },
      unplugPin: (type: IO, pinId: string, subPinId: string): void => {
        return unplugPin({ type, pinId, subPinId }, spec)
      },
      getMergesSpec: (): GraphMergesSpec => {
        const { merges = {} } = spec

        return merges
      },
      getMergeSpec: (mergeId: string): GraphMergeSpec => {
        return deepGetOrDefault(spec, ['merges', mergeId], undefined)
      },
      hasPinNamed: (type: IO, name: string): boolean => {
        return hasPinNamed(spec, type, name)
      },
      getUnit: (unitId: string): U => {
        const { units = {} } = spec

        const unit = units[unitId]

        const { id } = unit

        const unit_spec = getSpec(id)

        return this._make_spec_unit_interface(unit, unit_spec)
      },
      getUnitPinData: (unitId: string, type: IO, pinId: string) => {
        return {}
      },
      hasUnit: (unitId: string): boolean => {
        return hasUnit(spec, unitId)
      },
      addUnit: (unitId: string, _: any, bundle: UnitBundleSpec) => {
        addUnit({ unitId, unit: bundle.unit }, spec)

        if (
          getSpecRenderById(
            weakMerge(specs, bundle.specs ?? {}),
            bundle.unit.id
          )
        ) {
          appendRoot({ childId: unitId }, spec.component)
          setSubComponent({ unitId, subComponent: {} }, spec.component)
        }
      },
      removeMerge: (mergeId: string): void => {
        return removeMerge({ mergeId }, spec)
      },
      moveRoot: (
        parentId: string,
        childId: string,
        at: number,
        slotName: string
      ): void => {
        return moveRoot({ parentId, childId, at, slotName }, spec.component)
      },
      setPinData: function (type: IO, pinId: string, data: any): void {
        //
      },
      getPinPlugCount: (type: IO, pinId: string): number => {
        throw new MethodNotImplementedError()
      },
      getPinData: function (type: IO, pinId: string): any {
        return undefined
      },
      setPinConstant: function (
        type: IO,
        pinId: string,
        constant: boolean
      ): void {
        //
      },
      hasPlug: (type: IO, pinId: string, subPinId: string): boolean => {
        return hasPlug(spec, type, pinId, subPinId)
      },
      isUnitPinRef: function (
        unitId: string,
        type: IO,
        pinId: string
      ): boolean {
        throw new MethodNotImplementedError()
      },
      getExposedPinSpecs: (): IOOf<GraphPinsSpec> => {
        const { inputs, outputs } = spec

        return {
          input: inputs,
          output: outputs,
        }
      },
      getExposedPinSpec: (type: IO, pinId: string): GraphPinSpec => {
        return getPinSpec(spec, type, pinId)
      },
      removePinOrMerge: function (
        mergeId: string,
        unitId: string,
        type: IO,
        pinId: string,
        emit?: boolean,
        propagate?: boolean
      ): void {
        throw new MethodNotImplementedError()
      },
      isPinConstant: (type: IO, name: string): boolean => {
        return false
      },
      removePinFromMerge: (
        mergeId: string,
        unitId: string,
        type: IO,
        pinId: string
      ) => {
        return removePinFromMerge({ mergeId, unitId, type, pinId }, spec)
      },
      hasMergePin: (
        mergeId: string,
        unitId: string,
        type: IO,
        pinId: string
      ) => {
        return hasMergePin(spec, mergeId, unitId, type, pinId)
      },
      getSubPinSpec: function (
        type: IO,
        pinId: string,
        subPinId: string
      ): GraphSubPinSpec {
        throw new MethodNotImplementedError()
      },
      getSpec: () => {
        return spec
      },
      setUnitSize: (unitId: string, width: number, height: number): void => {
        return setUnitSize({ unitId, width, height }, spec)
      },
      setSubComponentSize: function (
        unitId: string,
        width: number,
        height: number
      ): void {
        throw new MethodNotImplementedError()
      },
      isUnitPinConstant: function (
        unitId: string,
        type: IO,
        pinId: string
      ): boolean {
        throw new MethodNotImplementedError()
      },
      removeUnitPinData: function (
        unitId: string,
        type: IO,
        pinId: string,
        ...extra: any[]
      ) {
        throw new MethodNotImplementedError()
      },
      setSlot: function (slotName: string, subComponentId: string): void {
        //
      },
    }

    return spec_interface
  }

  private _state_move_subgraph_out_of = (
    graph_id: string,
    collapse_map: GraphMoveSubGraphOutOfData
  ): boolean => {
    // console.log(
    //   'Graph',
    //   '_state_move_subgraph_out_of',
    //   graph_unit_id,
    //   collapse_map
    // )

    const position = this._get_node_position(graph_id)

    const connect_opt: GraphUnitConnect = clone({
      merges: this._get_unit_merges(graph_id),
      plugs: this._get_unit_plugs(graph_id),
    })

    moveSubgraph<UCG<any, any, U>>(
      this._state_get_subgraph_graph_interface(graph_id),
      this._state_make_this_graph_interface(position),
      graph_id,
      collapse_map,
      connect_opt,
      true
    )

    return true
  }

  private _predict_collapse_map = (
    graph_unit_id: string | null,
    selected_node_ids: string[]
  ): GraphMoveSubGraphData => {
    // console.log('Graph', '_predict_collapse_map')

    const { specs, newSpecId } = this.$props

    const {
      unit_ids,
      merge_node_ids,
      link_pin_node_ids,
      datum_node_ids,
      exposed_node_ids,
    } = this._decant_node_ids(selected_node_ids)

    const node_id_set = new Set(selected_node_ids)

    const merge_ids = []
    const datum_ids = []
    const link_pins: GraphUnitPinOuterSpec[] = []
    const plugs: GraphPlugOuterSpec[] = []

    const next_sub_component_parent_id_map: GraphMoveSubGraphData['nextSubComponentParentMap'] =
      {}
    const next_sub_component_index_map: GraphMoveSubGraphData['nextSubComponentIndexMap'] =
      {}
    const next_sub_component_children_map: GraphMoveSubGraphData['nextSubComponentChildrenMap'] =
      {}

    const next_id_map: GraphMoveSubGraphData['nextIdMap'] = {
      unit: {},
      merge: {},
      link: {},
      plug: {},
      data: {},
    }
    const next_pin_id_map: GraphMoveSubGraphData['nextPinIdMap'] = {}
    const next_merge_pin_id: GraphMoveSubGraphData['nextMergePinId'] = {}
    const next_plug_spec_map: GraphMoveSubGraphData['nextPlugSpec'] = {
      input: {},
      output: {},
    }
    const next_unit_pin_merge_map: GraphMoveSubGraphData['nextUnitPinMergeMap'] =
      {}

    const opposite_pin_id_map = {}
    const opposite_merge_id_map = {}

    const graph_unit_spec = this._get_unit_spec(graph_unit_id) as GraphSpec

    const graph_spec_pin_id_set = {
      input: new Set(keys(graph_unit_spec.inputs || {})),
      output: new Set(keys(graph_unit_spec.outputs || {})),
    }

    const merge_to_exposed_pin_id: IOOf<Dict<string>> = {
      input: {},
      output: {},
    }
    const exposed_pin_id_count: {
      input: Dict<number>
      output: Dict<number>
    } = { input: {}, output: {} }

    const next_unit_id_blacklist = new Set<string>()
    const next_merge_id_blacklist = new Set<string>()

    const next_spec = clone(this._spec)

    const exposed_pin_sets: {
      input: Dict<Set<string>>
      output: Dict<Set<string>>
    } = { input: {}, output: {} }

    const next_merge_set = new Set<string>()

    const opposite_merge_id_blacklist = new Set<string>(
      keys(this._spec.merges ?? {})
    )

    const new_pin_id = (type: IO, pin_id: string): string => {
      let next_pin_id = pin_id
      let i = 0

      while (graph_spec_pin_id_set[type].has(next_pin_id)) {
        next_pin_id = `${pin_id}${i}`
        i++
      }

      return next_pin_id
    }

    const expose_link_pin = (
      unit_id: string,
      type: IO,
      pin_id: string,
      next_pin_id: string
    ) => {
      exposed_pin_id_count[type][next_pin_id] =
        exposed_pin_id_count[type][next_pin_id] ?? -1
      exposed_pin_id_count[type][next_pin_id]++

      const next_sub_pin_id = exposed_pin_id_count[type][next_pin_id]

      graph_spec_pin_id_set[type].add(next_pin_id)

      const pin_node_id = getPinNodeId(unit_id, type, pin_id)

      const merge_node_id = this._pin_to_merge[pin_node_id]

      let merge_id: string | null = null
      let merge: GraphMergeSpec | null = null

      if (merge_node_id) {
        deepSet(merge_to_exposed_pin_id, [type, merge_node_id], next_pin_id)

        const { mergeId } = segmentMergeNodeId(merge_node_id)

        merge_id = mergeId
        merge = clone(this._spec_get_merge(merge_id))

        for (const unit_id of unit_ids) {
          delete merge[unit_id]
        }
      }

      merge_id = deepGetOrDefault(
        next_merge_pin_id,
        [merge_id, type, 'mergeId'],
        merge_id
      )

      const ref = this._is_link_pin_ref(pin_node_id)
      const ignored = this._spec_is_link_pin_ignored(pin_node_id)

      deepSet(next_pin_id_map, [unit_id, type, pin_id], {
        pinId: next_pin_id,
        subPinId: `${next_sub_pin_id}`,
        ref,
        defaultIgnored: ignored,
        mergeId: merge_id,
        merge,
      })
    }

    const try_expose_link_pin = (
      pin_node_id: string,
      unit_id: string,
      type: IO,
      pin_id: string,
      next_pin_id: string | null
    ) => {
      let should_expose = !node_id_set.has(pin_node_id)

      const opposite_type = opposite(type)

      const int_node_id = this._pin_to_int[type][pin_node_id]
      const opposite_int_node_id = this._pin_to_int[opposite_type][pin_node_id]

      let kind = type

      const process_plug = (int_node_id: string | undefined) => {
        if (int_node_id) {
          const { type, pinId, subPinId } = segmentPlugNodeId(int_node_id)

          const ext_node_id = getExtNodeId(type, pinId, subPinId)

          if (!node_id_set.has(ext_node_id)) {
            kind = type
            should_expose = true
          }
        }
      }

      process_plug(int_node_id)
      process_plug(opposite_int_node_id)

      if (should_expose) {
        const next_unit_id = next_id_map.unit[unit_id] ?? unit_id

        next_pin_id = next_pin_id ?? new_pin_id(type, pin_id)

        const { pinId, subPinId } =
          this._spec_get_pin_node_plug_spec(type, pin_node_id) ?? {}

        if (pinId && subPinId) {
          deepSet(next_plug_spec_map, [type, pinId, subPinId], {
            unitId: next_unit_id,
            pinId: pin_id,
            kind,
          })

          deepSet(next_pin_id_map, [next_unit_id, type, pin_id], {
            type,
            pinId,
            subPinId,
          })
        }

        expose_link_pin(unit_id, type, pin_id, next_pin_id)

        return next_pin_id
      }
    }

    for (const datum_node_id of datum_node_ids) {
      const { datumId } = segmentDatumNodeId(datum_node_id)

      datum_ids.push(datumId)
    }

    for (const unit_id of unit_ids) {
      const unit_spec_id = this._get_unit_spec_id(unit_id)

      const unit_ref_merge = this._ref_unit_to_merge[unit_id]

      let next_unit_id = unit_id

      if (graph_unit_spec?.units[unit_id]) {
        next_unit_id = newUnitId(
          specs,
          graph_unit_spec,
          unit_spec_id,
          next_unit_id_blacklist
        )
      }

      next_unit_id_blacklist.add(next_unit_id)

      next_id_map.unit[unit_id] = next_unit_id

      if (unit_ref_merge) {
        merge_node_ids.push(unit_ref_merge)

        node_id_set.add(unit_ref_merge)
      }
    }

    for (const pin_node_id of link_pin_node_ids) {
      const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

      const merge_node_id = this._pin_to_merge[pin_node_id]

      if (
        type === 'output' &&
        merge_node_id &&
        this._is_merge_ref(merge_node_id)
      ) {
        merge_node_ids.push(merge_node_id)
        node_id_set.add(merge_node_id)

        pull(link_pin_node_ids, pin_node_id)
      }
    }

    const merge_pin_count_per_type_map: Dict<IOOf<number>> = {}
    const merge_unit_inside_pin_count_map: Dict<IOOf<number>> = {}
    const merge_outside_pin_count: Dict<IOOf<number>> = {}
    const merge_inside_pin_count: Dict<IOOf<number>> = {}

    for (const merge_node_id of merge_node_ids) {
      const { mergeId } = segmentMergeNodeId(merge_node_id)

      const merge_pin_count_per_type = { input: 0, output: 0 }
      const merge_unit_inside_pin_count = { input: 0, output: 0 }
      const merge_unit_inside_pin: IOOf<{ unit_id: string; pin_id: string }[]> =
        { input: [], output: [] }
      const merge_collapse_unit_outside_pin: IOOf<
        { unit_id: string; pin_id: string }[]
      > = { input: [], output: [] }

      this._for_each_merge_pin(mergeId, (unit_id, type, pin_id) => {
        merge_pin_count_per_type[type]++

        if (node_id_set.has(unit_id) || unit_id === graph_unit_id) {
          merge_unit_inside_pin_count[type]++

          merge_unit_inside_pin[type].push({ unit_id, pin_id })
        } else {
          merge_collapse_unit_outside_pin[type].push({ unit_id, pin_id })
        }
      })

      deepSet(merge_inside_pin_count, [mergeId], merge_unit_inside_pin_count)

      const merge_outside_input_count =
        merge_pin_count_per_type.input - merge_unit_inside_pin_count.input
      const merge_outside_output_count =
        merge_pin_count_per_type.output - merge_unit_inside_pin_count.output

      merge_pin_count_per_type_map[mergeId] = merge_pin_count_per_type
      merge_unit_inside_pin_count_map[mergeId] = merge_unit_inside_pin_count

      deepSet(
        merge_outside_pin_count,
        [mergeId, 'input'],
        merge_outside_input_count
      )
      deepSet(
        merge_outside_pin_count,
        [mergeId, 'output'],
        merge_outside_output_count
      )
    }

    for (const exposed_pin_node_id of exposed_node_ids) {
      const { type, pinId, subPinId } = segmentPlugNodeId(exposed_pin_node_id)

      const sub_pin_spec = this._spec_get_sub_pin_spec(type, pinId, subPinId)

      exposed_pin_sets[type][pinId] = exposed_pin_sets[type][pinId] || new Set()

      const exposed_pin_set = exposed_pin_sets[type][pinId]

      if (exposed_pin_set.has(subPinId)) {
        continue
      }

      exposed_pin_set.add(subPinId)

      const ext_node_id = getExtNodeIdFromIntNodeId(exposed_pin_node_id)

      const internal_node_id = this._get_exposed_pin_internal_node_id(
        type,
        pinId,
        subPinId
      )

      if (internal_node_id) {
        const opposite_type = opposite(type)

        const add_merge = (other_type, merge_id?: string) => {
          const new_merge_id = merge_id

          deepSet(next_id_map, ['plug', type, pinId, subPinId], {
            mergeId: new_merge_id,
            type: other_type,
          })
        }

        if (this._is_merge_node_id(internal_node_id)) {
          const { mergeId } = segmentMergeNodeId(internal_node_id)

          if (node_id_set.has(internal_node_id)) {
            let other_type = type

            const merge_inside_pin_count =
              merge_unit_inside_pin_count_map[mergeId]['input'] +
              merge_unit_inside_pin_count_map[mergeId]['output']

            if (merge_inside_pin_count === 0 || merge_inside_pin_count > 1) {
              deepSet(next_merge_pin_id, [mergeId, type, 'pinId'], pinId)

              deepSet(next_plug_spec_map, [type, pinId, subPinId], {
                mergeId,
              })
            } else {
              deepSet(next_plug_spec_map, [type, pinId, subPinId], {})
            }

            if (merge_outside_pin_count[mergeId][other_type] > 0) {
              add_merge(other_type, mergeId)
            }
          } else {
            deepSet(next_plug_spec_map, [type, pinId, subPinId], {})

            add_merge(opposite_type, mergeId)
          }
        } else if (this._is_link_pin_node_id(internal_node_id)) {
          const {
            unitId,
            pinId: _pinId,
            type: kind,
          } = segmentLinkPinNodeId(internal_node_id)

          if (unit_ids.includes(unitId)) {
            const nextUnitId = next_id_map.unit[unitId] ?? unitId

            deepSet(next_plug_spec_map, [type, pinId, subPinId], {
              unitId: nextUnitId,
              pinId: _pinId,
              kind,
            })

            deepSet(next_pin_id_map, [unitId, type, _pinId, 'plug'], {
              type,
              pinId,
              subPinId,
            })

            if (!link_pin_node_ids.includes(internal_node_id)) {
              add_merge(type)
            }
          } else {
            if (node_id_set.has(internal_node_id)) {
              const {
                unitId,
                type: kind,
                pinId,
              } = segmentLinkPinNodeId(internal_node_id)

              if (unitId === graph_unit_id) {
                deepSet(next_plug_spec_map, [type, pinId, subPinId], {})
              } else {
                deepSet(next_plug_spec_map, [type, pinId, subPinId], {
                  unitId,
                  kind,
                  pinId,
                })
              }
            } else {
              deepSet(next_plug_spec_map, [type, pinId, subPinId], {})

              const merge_id = this._new_merge_id(next_merge_id_blacklist)

              next_merge_id_blacklist.add(merge_id)

              add_merge(opposite_type, merge_id)
            }
          }
        } else if (this._is_unit_node_id(internal_node_id)) {
          deepSet(next_plug_spec_map, [type, pinId, subPinId], {
            unitId: internal_node_id,
            pinId: SELF,
          })
        } else {
          if (
            !sub_pin_spec.unitId &&
            !sub_pin_spec.mergeId &&
            !node_id_set.has(ext_node_id)
          ) {
            deepSet(next_id_map, ['plug', type, pinId, subPinId], {
              template: true,
            })
          }

          deepSet(next_plug_spec_map, [type, pinId, subPinId], {})
        }
      }

      graph_spec_pin_id_set[type].add(pinId)

      plugs.push({ type, pinId, subPinId })
    }

    for (const merge_node_id of merge_node_ids) {
      const { mergeId } = segmentMergeNodeId(merge_node_id)

      delete next_spec.merges[mergeId]
    }

    for (const merge_node_id of merge_node_ids) {
      const { mergeId } = segmentMergeNodeId(merge_node_id)

      merge_ids.push(mergeId)

      const merge = this._get_merge(merge_node_id)

      const ref = this._is_merge_ref(merge_node_id)

      const merge_graph_pin: IOOf<string[]> = { input: [], output: [] }
      const merge_pin_count_per_type = { input: 0, output: 0 }
      const merge_collapse_unit_inside_pin_count = { input: 0, output: 0 }
      const merge_collapse_unit_inside_pin: IOOf<
        { unit_id: string; pin_id: string }[]
      > = { input: [], output: [] }
      const merge_collapse_unit_outside_pin: IOOf<
        { unit_id: string; pin_id: string }[]
      > = { input: [], output: [] }
      const merge_anchor_pin_id: IOOf<{ unit_id: string; pin_id: string }> = {
        input: undefined,
        output: undefined,
      }

      const merge_pin_ids: Dict<{ unit_id: string; pin_id: string }[]> = {
        input: [],
        output: [],
      }

      this._for_each_merge_pin(mergeId, (unit_id, type, pin_id) => {
        merge_pin_count_per_type[type]++

        merge_pin_ids[type].push({ unit_id, pin_id })

        if (node_id_set.has(unit_id) || unit_id === graph_unit_id) {
          merge_collapse_unit_inside_pin_count[type]++
          merge_collapse_unit_inside_pin[type].push({ unit_id, pin_id })
        } else {
          merge_collapse_unit_outside_pin[type].push({ unit_id, pin_id })
        }

        if (unit_id !== graph_unit_id) {
          //
        } else {
          merge_graph_pin[type].push(pin_id)
        }
      })

      merge_anchor_pin_id.input = merge_pin_ids['input'].sort((a, b) =>
        a.pin_id.localeCompare(b.pin_id)
      )[0]
      merge_anchor_pin_id.output = merge_pin_ids['output'].sort((a, b) =>
        a.pin_id.localeCompare(b.pin_id)
      )[0]

      merge_graph_pin.input = merge_graph_pin.input.sort()
      merge_graph_pin.output = merge_graph_pin.output.sort()

      const merge_outside_pin_count = {
        input:
          merge_pin_count_per_type.input -
          merge_collapse_unit_inside_pin_count.input,
        output:
          merge_pin_count_per_type.output -
          merge_collapse_unit_inside_pin_count.output,
      }

      io((type) => {
        if (merge_outside_pin_count[type] > 0) {
          const opposite_type = opposite(type)

          const type_ =
            merge_collapse_unit_inside_pin_count[opposite_type] === 0 &&
            merge_outside_pin_count[opposite_type] > 0
              ? opposite_type
              : type

          const opposite_type_ = opposite(type_)

          let start_merge_anchor =
            merge_anchor_pin_id[opposite_type_] || merge_anchor_pin_id[type_]

          let start_merge_anchor_pin_id = start_merge_anchor.pin_id

          if (start_merge_anchor_pin_id === SELF) {
            start_merge_anchor_pin_id = start_merge_anchor.unit_id
          }

          const next_pin_id =
            deepGetOrDefault(
              next_merge_pin_id,
              [mergeId, opposite_type_, 'pinId'],
              undefined
            ) ||
            merge_to_exposed_pin_id[opposite_type_][merge_node_id] ||
            merge_graph_pin[opposite_type_][0] ||
            newSpecPinId(
              graph_unit_spec,
              opposite_type_,
              start_merge_anchor_pin_id,
              graph_spec_pin_id_set[opposite_type_]
            )

          graph_spec_pin_id_set[opposite_type_].add(next_pin_id)

          merge_to_exposed_pin_id[opposite_type_][merge_node_id] = next_pin_id

          let next_merge_id = newMergeIdInSpec(
            next_spec,
            opposite_merge_id_blacklist
          )

          let next_merge_sub_pin_spec: GraphSubPinSpec = {}

          if (merge_collapse_unit_inside_pin_count[opposite_type_] === 0) {
            if (
              (merge_collapse_unit_inside_pin_count[type_] === 0 ||
                merge_collapse_unit_inside_pin_count[type_] > 1) &&
              merge_pin_count_per_type.input > 0 &&
              merge_pin_count_per_type.output > 0
            ) {
              const _next_merge_id = next_id_map.merge[mergeId] ?? mergeId

              next_merge_sub_pin_spec = {
                mergeId: _next_merge_id,
              }
            } else {
              next_merge_sub_pin_spec = {}
            }
          } else if (
            merge_collapse_unit_inside_pin_count[opposite_type_] +
              merge_collapse_unit_inside_pin_count[type_] >
              1 &&
            merge_pin_count_per_type[type] >= 1
          ) {
            const _next_merge_id = next_id_map.merge[mergeId] ?? mergeId

            next_merge_sub_pin_spec = {
              mergeId: _next_merge_id,
            }
          } else if (
            merge_collapse_unit_inside_pin_count[opposite_type_] === 1
          ) {
            const { unit_id, pin_id } =
              merge_collapse_unit_inside_pin[opposite_type_][0]

            if (unit_id !== graph_unit_id) {
              next_merge_sub_pin_spec = {
                unitId: unit_id,
                pinId: pin_id,
                kind: opposite_type_,
              }
            } else {
              next_merge_id = mergeId
            }
          } else {
            //
          }

          opposite_merge_id_blacklist.add(next_merge_id)

          next_merge_set.add(next_merge_id)

          const opposite_merge = {}

          forEachPinOnMerge(merge, (unitId, type_, pinId) => {
            if (type_ === type_) {
              deepSet(opposite_merge, [unitId, type_, pinId], true)
            }
          })

          deepSet(next_merge_pin_id, [mergeId, opposite_type_], {
            mergeId: next_merge_id,
            pinId: next_pin_id,
            subPinSpec: next_merge_sub_pin_spec,
            oppositeMerge: opposite_merge,
            ref,
          })
        }
      })

      if (
        merge_outside_pin_count.input === 0 &&
        merge_outside_pin_count.output === 0
      ) {
        this._for_each_merge_pin(mergeId, (unit_id, type, pin_id) => {
          if (unit_id === graph_unit_id) {
            graph_spec_pin_id_set[type].delete(pin_id)
          }
        })
      }

      const merge_collapse_unit_pin_total =
        merge_collapse_unit_inside_pin_count.input +
        merge_collapse_unit_inside_pin_count.output

      let next_merge_id = mergeId

      if (graph_unit_spec.merges[mergeId]) {
        next_merge_id = newMergeIdInSpec(
          graph_unit_spec,
          next_merge_id_blacklist
        )
      }

      next_merge_id_blacklist.add(next_merge_id)

      next_id_map.merge[mergeId] = next_merge_id
    }

    for (const unit_id of unit_ids) {
      const check_link_pin_plug = (
        pin_node_id: string,
        type: IO,
        pin_id: string
      ) => {
        if (!this._spec_is_link_pin_ignored(pin_node_id)) {
          const merge_node_id = this._pin_to_merge[pin_node_id]

          if (!merge_node_id) {
            let next_pin_id = null

            const opposite_type = opposite(type)

            const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)

            const ext_pin_node_id = this._pin_to_ext[type][anchor_node_id]
            const opposite_ext_pin_node_id =
              this._pin_to_ext[opposite_type][anchor_node_id]

            const is_self_output = type === 'output' && pin_id === SELF

            let should_expose =
              !isSelfPin(type, pin_id) ||
              ext_pin_node_id ||
              opposite_ext_pin_node_id

            if (selected_node_ids.includes(anchor_node_id)) {
              if (ext_pin_node_id) {
                const { type, pinId, subPinId } =
                  segmentPlugNodeId(ext_pin_node_id)

                next_pin_id = pinId
              } else if (opposite_ext_pin_node_id) {
                const { type, pinId, subPinId } = segmentPlugNodeId(
                  opposite_ext_pin_node_id
                )

                next_pin_id = pinId
              }
            }

            if (should_expose) {
              try_expose_link_pin(
                pin_node_id,
                unit_id,
                type,
                pin_id,
                next_pin_id
              )
            }
          }
        }
      }

      this._for_each_unit_pin(unit_id, check_link_pin_plug)

      const self_pin_node_id = getPinNodeId(unit_id, 'output', SELF)

      check_link_pin_plug(self_pin_node_id, 'output', SELF)
    }

    for (const unit_id of unit_ids) {
      const process_pin = (pin_node_id: string, type: IO, pin_id: string) => {
        if (!node_id_set.has(pin_node_id)) {
          const merge_node_id = this._pin_to_merge[pin_node_id]

          if (merge_node_id) {
            const merge_ref_unit_id = this._merge_to_ref_unit[merge_node_id]

            if (!node_id_set.has(merge_node_id) || pin_id === SELF) {
              let next_pin_id = deepGetOrDefault(
                merge_to_exposed_pin_id,
                [type, merge_node_id],
                null
              )

              next_pin_id = try_expose_link_pin(
                pin_node_id,
                unit_id,
                type,
                pin_id,
                next_pin_id
              )

              deepSet(
                merge_to_exposed_pin_id,
                [type, merge_node_id],
                next_pin_id
              )
            }
          }
        }
      }

      this._for_each_unit_pin(unit_id, process_pin)

      const ref_merge_node_id = this._ref_unit_to_merge[unit_id]

      if (ref_merge_node_id) {
        const ref_pin_node_id = getSelfPinNodeId(unit_id)

        const { mergeId: ref_merge_id } = segmentMergeNodeId(ref_merge_node_id)

        if (merge_outside_pin_count[ref_merge_id]['input'] > 0) {
          process_pin(ref_pin_node_id, 'output', SELF)
        }
      }
    }

    for (const unit_id of unit_ids) {
      const unit_spec_id = this._get_unit_spec_id(unit_id)

      const next_unit_id = next_id_map[unit_id] ?? unit_id

      if (this._is_unit_component(unit_id)) {
        const sub_component_parent_id =
          this._spec_get_sub_component_parent_id(unit_id)

        if (sub_component_parent_id) {
          if (node_id_set.has(sub_component_parent_id)) {
            const sub_component_parent_next_id =
              next_id_map.unit[sub_component_parent_id] ??
              sub_component_parent_id

            const parent_children = this._spec_get_sub_component_children(
              sub_component_parent_id
            )

            const i = parent_children.indexOf(unit_id)

            next_sub_component_parent_id_map[unit_id] = sub_component_parent_id
            next_sub_component_index_map[unit_id] = i
            next_sub_component_children_map[sub_component_parent_id] =
              next_sub_component_children_map[sub_component_parent_id] || []

            insert(
              next_sub_component_children_map[sub_component_parent_id],
              unit_id,
              i
            )

            if (sub_component_parent_next_id) {
              next_sub_component_parent_id_map[next_unit_id] =
                sub_component_parent_next_id
            }
          } else if (sub_component_parent_id === graph_unit_id) {
            if (this._is_unit_component(graph_unit_id)) {
              const { slots } = graph_unit_spec.component ?? { slots: [] }

              for (const slot of slots) {
                const [graph_sub_component_id, slot_name] = slot

                if (slot_name === 'default') {
                  next_sub_component_parent_id_map[unit_id] =
                    graph_sub_component_id

                  break
                }
              }
            }
          }
        }
      }
    }

    for (const pin_node_id of link_pin_node_ids) {
      const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

      if (unit_ids.includes(unitId)) {
        //
      } else {
        const opposite_type = oppositePinType(type)

        const opposite_pin_id = newSpecPinId(
          graph_unit_spec,
          opposite_type,
          pinId,
          graph_spec_pin_id_set[opposite_type]
        )

        graph_spec_pin_id_set[opposite_type].add(opposite_pin_id)

        opposite_pin_id_map[pin_node_id] = opposite_pin_id

        const ref_merge_node_id = this._ref_output_to_merge[pin_node_id]

        let opposite_merge_id

        if (ref_merge_node_id) {
          const { mergeId } = segmentMergeNodeId(ref_merge_node_id)

          opposite_merge_id = mergeId
        } else {
          if (unitId === graph_unit_id) {
            //
          } else {
            opposite_merge_id = this._new_merge_id(opposite_merge_id_blacklist)
          }
        }

        if (opposite_merge_id) {
          opposite_merge_id_blacklist.add(opposite_merge_id)

          opposite_merge_id_map[pin_node_id] = opposite_merge_id
        }
      }
    }

    for (const merge_id of merge_ids) {
      const merge = this._spec_get_merge(merge_id)

      for (const unit_id in merge) {
        const merge_unit = merge[unit_id]

        const { input = {}, output = {} } = merge_unit

        const move_pin_into_graph = (type: IO, pin_id: string) => {
          const pin_node_id = getPinNodeId(unit_id, type, pin_id)

          const opposite_type = oppositePinType(type)

          const opposite_pin_id = newSpecPinId(
            graph_unit_spec,
            opposite_type,
            pin_id,
            graph_spec_pin_id_set[opposite_type]
          )

          graph_spec_pin_id_set[opposite_type].add(opposite_pin_id)

          opposite_pin_id_map[pin_node_id] = opposite_pin_id

          let opposite_merge_id

          const ref_merge_node_id = this._ref_output_to_merge[pin_node_id]

          if (ref_merge_node_id) {
            const { mergeId } = segmentMergeNodeId(ref_merge_node_id)

            opposite_merge_id = mergeId
          } else {
            opposite_merge_id = this._new_merge_id(opposite_merge_id_blacklist)
          }

          opposite_merge_id_blacklist.add(opposite_merge_id)

          opposite_merge_id_map[pin_node_id] = opposite_merge_id
        }

        if (!node_id_set.has(unit_id)) {
          for (const input_id in input) {
            move_pin_into_graph('input', input_id)
          }
          for (const output_id in output) {
            move_pin_into_graph('output', output_id)
          }
        }
      }
    }

    for (const pin_node_id of link_pin_node_ids) {
      const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

      let mergeId: string | null
      let oppositePinId: string | null

      if (node_id_set.has(unitId)) {
        mergeId = null
        oppositePinId = null
      } else {
        mergeId = opposite_merge_id_map[pin_node_id]
        oppositePinId = opposite_pin_id_map[pin_node_id]
      }

      const pin_plug_node_id = this._pin_to_ext[type][pin_node_id]

      if (
        pin_plug_node_id &&
        node_id_set.has(pin_plug_node_id) &&
        !node_id_set.has(unitId)
      ) {
        //
      } else {
        deepSet(next_id_map, ['link', unitId, type, pinId], {
          mergeId,
          oppositePinId,
        })

        link_pins.push({ unitId, type, pinId })
      }
    }

    for (const unit_id of unit_ids) {
      const unit_merges = this._get_unit_merges(unit_id)

      for (const merge_id in unit_merges) {
        if (merge_ids.includes(merge_id)) {
          const merge = unit_merges[merge_id]

          const next_merge_id = next_id_map.merge[merge_id]

          forEachPinOnMerge(merge, (unitId, type, pinId) => {
            if (unit_ids.includes(unitId)) {
              if (
                merge_inside_pin_count[merge_id].input +
                  merge_inside_pin_count[merge_id].output !==
                1
              ) {
                deepSet(
                  next_unit_pin_merge_map,
                  [unitId, type, pinId],
                  next_merge_id
                )
              }
            } else if (unitId === graph_unit_id) {
              const pin_spec = this.__get_unit_pin_spec(
                unitId,
                type,
                pinId
              ) as GraphPinSpec

              for (const sub_pin_id in pin_spec.plug) {
                const sub_pin_spec = pin_spec.plug[sub_pin_id]

                const { unitId, pinId, mergeId } = sub_pin_spec

                if (unitId && pinId) {
                  deepSet(
                    next_unit_pin_merge_map,
                    [unitId, type, pinId],
                    next_merge_id
                  )
                } else if (mergeId) {
                  //
                }
              }
            } else {
              //
            }
          })
        }
      }
    }

    const nextSpecId = newSpecId()

    return {
      nodeIds: {
        unit: unit_ids,
        merge: merge_ids,
        link: link_pins,
        plug: plugs,
        data: datum_ids,
      },
      nextSpecId,
      nextIdMap: next_id_map,
      nextPinIdMap: next_pin_id_map,
      nextMergePinId: next_merge_pin_id,
      nextUnitPinMergeMap: next_unit_pin_merge_map,
      nextPlugSpec: next_plug_spec_map,
      nextSubComponentParentMap: next_sub_component_parent_id_map,
      nextSubComponentChildrenMap: next_sub_component_children_map,
      nextSubComponentIndexMap: next_sub_component_index_map,
      nextSubComponentParentSlot: {},
      nextSubComponentSlot: {},
    }
  }

  private _ensure_node_long_press_collapse = (node_id: string): void => {
    // console.log('Graph', '_ensure_node_long_press_collapse', node_id)

    if (!this._collapse_node_id.has(node_id)) {
      this._start_node_long_press_collapse(node_id)
    }
  }

  private _start_node_long_press_collapse = (node_id: string): void => {
    // console.log('Graph', '_start_node_long_press_collapse', node_id)

    if (this._collapse_node_id.has(node_id)) {
      return
    }

    this._collapse_node_id.add(node_id)

    this._collapse_remaining++

    this._set_node_layer(node_id, LAYER_COLLAPSE)
  }

  private _stop_node_long_press_collapse = (node_id: string): void => {
    // console.log('Graph', '_stop_node_long_press_collapse', node_id)

    if (!this._collapse_node_id.has(node_id)) {
      return
    }

    this._collapse_remaining--

    this._collapse_node_id.delete(node_id)
    this._collapse_end_set.add(node_id)
  }

  private _stop_collapse = () => {
    // console.log('Graph', '_stop_collapse')

    const { specs } = this.$props

    const graph_id = this._collapse_next_unit_id

    if (!this._collapse_unit_id && graph_id) {
      if (this._is_unit_component(graph_id)) {
        this._connect_sub_component(graph_id)
      }
    }

    if (this._is_unit_component(graph_id)) {
      this._set_sub_component_controlled(graph_id, false)
    }

    this._start_debugger()

    this._collapse_init_node_id_set = new Set()
    this._collapse_unit_spec = {}
    this._collapse_commit = false
    this._collapsing = false
    this._collapse_unit_id = null
    this._collapse_world_position = NULL_VECTOR
    this._collapse_datum_id = null
    this._collapse_datum_node_id = null
    this._collapse_sub_component_children = {}
    this._collapse_sub_component_parent_id = {}
    this._collapse_next_sub_component_index_map = {}
    this._collapse_remaining = 0
    this._collapse_node_id = new Set()
    this._collapse_end_set = new Set()

    this._collapse_unit_next_pin_map = {}
    this._collapse_merge_next_pin_map = {}
    this._collapse_next_plug_spec_map = { input: {}, output: {} }
    this._collapse_sub_component_next_children = {}
    this._collapse_next_id_map = {
      unit: {},
      merge: {},
      link: {},
      plug: {},
    }
    this._collapse_next_map = null
    this._collapse_next_unit_id = null

    for (const selected_node_id in this._selected_node_id) {
      this._stop_drag_node_static(selected_node_id)

      this._refresh_node_layer(selected_node_id)

      if (this._is_pin_node_id(selected_node_id)) {
        const datum_node_id = this._pin_to_datum[selected_node_id]

        if (datum_node_id) {
          this._refresh_datum_visible(datum_node_id)
        }
      }
    }

    this._simulation.alphaDecay(0.01)

    if (graph_id) {
      this._refresh_core_border_color(graph_id)
      this._refresh_node_fixed(graph_id)
      this._refresh_unit_layer(graph_id)
    }

    this._start_graph_simulation(LAYER_NONE)

    this.dispatchEvent('collapse_end', undefined, false)
  }

  private _client_to_graph = (
    clientX: number,
    clientY: number
  ): [number, number] => {
    return zoomInvert(
      this._zoom,
      clientX - this._translate_x,
      clientY - this._translate_y
    )
  }

  private _force_pointer_drop_node = (
    node_id: string,
    pointerId: number,
    clientX: number,
    clientY: number
  ): void => {
    this.__on_node_pointer_leave(node_id, pointerId)
    this.__on_node_pointer_up(node_id, pointerId)
    this.__on_pointer_up(pointerId, false)
    this._on_node_drag_end(node_id)
  }

  private _force_pointer_drag_node = (
    node_id: string,
    pointer_id: number,
    clientX: number,
    clientY: number
  ): void => {
    this.__on_node_pointer_enter(node_id, pointer_id)
    this.__on_node_pointer_down(node_id, pointer_id, clientX, clientY)
    this.__on_pointer_down(pointer_id, clientX, clientY)

    const [x, y] = this._client_to_graph(clientX, clientY)

    this.__on_node_drag_start(node_id, pointer_id, x, y)
  }

  private _long_press_collapse_node = (node_id: string): void => {
    // console.log('Graph', '_long_press_collapse_node', node_id)

    this._state_move_node_into_graph(
      this._collapse_next_unit_id,
      node_id,
      this._collapse_next_map
    )

    if (this._collapse_remaining === 0) {
      this._stop_collapse()
    }
  }

  private _node_type__template = <
    T extends {
      unit: any
      link: any
      merge: any
      plug: any
      datum: any
      err: any
    },
  >(
    node_id: string,
    callback_map: {
      unit: (unit_id: string) => T['unit']
      link: (pin_node_id: string) => T['link']
      merge: (merge_node_id: string) => T['merge']
      plug: (plug_node_id: string) => T['plug']
      datum: (datum_node_id: string) => T['datum']
      err: (err_node_id: string) => T['err']
    }
  ) => {
    const { unit, link, merge, plug, datum, err } = callback_map

    if (this._is_unit_node_id(node_id)) {
      return unit && unit(node_id)
    } else if (this._is_link_pin_node_id(node_id)) {
      return link && link(node_id)
    } else if (this._is_merge_node_id(node_id)) {
      return merge && merge(node_id)
    } else if (this._is_datum_node_id(node_id)) {
      return datum && datum(node_id)
    } else if (this._is_plug_node_id(node_id)) {
      return plug && plug(node_id)
    } else if (this._is_err_node_id(node_id)) {
      return err && err(node_id)
    }
  }

  private _state_move_node_into_graph = (
    graph_id: string,
    node_id: string,
    collapse_map: GraphMoveSubGraphData
  ): void => {
    // console.log('Graph', '_state_move_node_into_graph', graph_id, node_id)

    const {
      nextIdMap,
      nextPinIdMap,
      nextUnitPinMergeMap,
      nextMergePinId,
      nextPlugSpec,
    } = collapse_map

    if (this._is_int_node_id(node_id)) {
      if (!this._collapse_init_node_id_set.has(node_id)) {
        const ext_node_id = getExtNodeIdFromIntNodeId(node_id)

        this._state_move_node_into_graph(graph_id, ext_node_id, collapse_map)

        return
      }
    }

    this._node_type__template(node_id, {
      unit: (unit_id) => {
        const unit_spec = this._get_unit(unit_id)

        const next_unit_id = nextIdMap.unit?.[unit_id] ?? unit_id

        const next_unit_merges = nextUnitPinMergeMap[unit_id]

        this._state_move_unit_into_graph(
          graph_id,
          unit_id,
          unit_spec,
          next_unit_id,
          nextPinIdMap,
          nextUnitPinMergeMap
        )
      },
      link: (pin_node_id) => {
        const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

        const { mergeId, oppositePinId } = deepGetOrDefault(
          nextIdMap,
          ['link', unitId, type, pinId],
          { mergeId: null, oppositePinId: null }
        )

        const is_pin_ref = this._is_link_pin_ref(pin_node_id)

        const merge_node_id = this._pin_to_merge[pin_node_id]

        const pin_plug_node_id = this._pin_to_ext[type][pin_node_id]

        if (merge_node_id && is_pin_ref) {
          this._stop_node_long_press_collapse(pin_node_id)

          this._state_move_node_into_graph(
            graph_id,
            merge_node_id,
            collapse_map
          )

          return
        }

        if (pin_plug_node_id) {
          const plugSpec = segmentPlugNodeId(pin_plug_node_id)

          this._state_move_link_pin_into_graph(
            graph_id,
            unitId,
            type,
            pinId,
            mergeId,
            oppositePinId,
            plugSpec
          )
        } else {
          this._state_move_link_pin_into_graph(
            graph_id,
            unitId,
            type,
            pinId,
            mergeId,
            oppositePinId,
            null
          )
        }
      },
      merge: (pin_node_id) => {
        const { mergeId } = segmentMergeNodeId(pin_node_id)

        const next_merge_id = nextIdMap.merge?.[mergeId] ?? mergeId

        const next_merge_pin_id_map = nextMergePinId[mergeId] ?? {}

        const merge = this._spec_get_merge(mergeId)

        const next_merge: GraphMergeSpec = {}

        forEachPinOnMerge(merge, (unitId, type, pinId) => {
          if (unitId !== graph_id) {
            if (nextIdMap.unit?.[unitId]) {
              deepSet(next_merge, [unitId, type, pinId], true)
            }
          }
        })

        this._state_move_merge_into_graph(
          graph_id,
          mergeId,
          next_merge_id,
          next_merge,
          nextPinIdMap,
          next_merge_pin_id_map
        )
      },
      datum: (datum_node_id) => {
        this._move_datum_into_graph(graph_id, datum_node_id)
      },
      plug: (plug_node_id) => {
        this._state_move_plug_into_graph(graph_id, plug_node_id, collapse_map)
      },
      err: () => {
        //
      },
    })
  }

  private _move_datum_into_graph = (
    graph_id: string,
    datum_node_id: string
  ): void => {
    // console.log('Graph', '_move_datum_into_graph', graph_id, datum_node_id)

    for (const collapse_node_id in this._collapse_node_id) {
      if (!this._is_datum_node_id(collapse_node_id)) {
        return
      }
    }

    this._stop_node_long_press_collapse(datum_node_id)

    this._move_datum_into_subgraph(graph_id, datum_node_id)
  }

  private _move_datum_into_subgraph = (
    sub_graph_id: string,
    datum_node_id: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_move_datum_into_subgraph',
    //   sub_graph_id,
    //   datum_node_id
    // )

    const datum_pin_node_id = this._datum_to_pin[datum_node_id]

    if (datum_pin_node_id) {
      if (this._collapse_init_node_id_set.has(datum_pin_node_id)) {
        return
      }
    }

    const value = this._get_datum_value(datum_node_id)

    const pin_node_id = this._datum_to_pin[datum_node_id]

    if (pin_node_id) {
      const { unitId, type, pinId } = segmentLinkPinNodeId(pin_node_id)

      const init_pin_merge_id = findPinMergeId(
        this._collapse_init_spec,
        unitId,
        type,
        pinId
      )

      const init_pin_merge_node_id = getMergeNodeId(init_pin_merge_id)

      if (init_pin_merge_id) {
        if (this._collapse_init_node_id_set.has(init_pin_merge_node_id)) {
          this._sim_remove_datum(datum_node_id)
        } else {
          this._sim_remove_datum(datum_node_id)
        }
      } else {
        if (this._collapse_init_node_id_set.has(pin_node_id)) {
          this._sim_remove_datum(datum_node_id)
        } else {
          this._remove_datum(datum_node_id)
        }
      }
    } else {
      this._remove_datum(datum_node_id)
    }

    const graph = this._ensure_subgraph(sub_graph_id)

    const position = graph.jiggle_world_screen_center()

    graph.add_new_datum(value, position, true)
  }

  private _move_datum_into_array = (datum_node_id: string): void => {
    const { datumId } = segmentDatumNodeId(datum_node_id)

    const element_tree = this._datum_tree[datumId]
    const array_tree = this._datum_tree[this._collapse_datum_id]

    const { type: array_type } = array_tree

    if (array_type === TreeNodeType.ArrayLiteral) {
      const next_array_tree = _updateNodeAt(
        array_tree,
        [array_tree.children.length],
        element_tree
      )

      const datum = this._datum[this._collapse_datum_node_id] as Datum

      datum.setProp('data', next_array_tree)
      datum.dispatchEvent('datumchange', { data: next_array_tree })

      this._remove_datum(datum_node_id)

      this._stop_node_long_press_collapse(datum_node_id)
    } else {
      throw new Error('not an array')
    }
  }

  private _spec_component_remove_sub_component = (
    sub_component_id: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_spec_component_remove_sub_component',
    //   sub_component_id
    // )

    const sub_component_parent_id =
      this._spec_get_sub_component_parent_id(sub_component_id)

    if (sub_component_parent_id) {
      removeSubComponentChild(
        { subComponentId: sub_component_parent_id, childId: sub_component_id },
        this._spec.component
      )
    }

    removeRoot({ childId: sub_component_id }, this._spec.component)
    removeSubComponent({ unitId: sub_component_id }, this._spec.component)
  }

  private _state_move_unit_into_graph__remove = (
    graph_id: string,
    unit_id: string,
    next_unit_id: string
  ) => {
    this._sim_move_unit_into_graph_remove(graph_id, unit_id, next_unit_id)
    this._spec_move_unit_into_graph_remove(graph_id, unit_id, next_unit_id)
  }

  private _spec_move_unit_into_graph_remove = (
    graph_id: string,
    unit_id: string,
    next_unit_id: string
  ) => {
    this._spec_remove_unit(unit_id, false)
  }

  private _add_unit_between_pins(
    source_node_id: string,
    target_node_id: string
  ) {
    const { specs } = this.$props

    if (source_node_id === target_node_id) {
      return
    }

    const new_spec_id = this.$system.newSpecId()

    const {
      unitId: source_unit_id,
      type: source_pin_type,
      pinId: source_pin_id,
    } = segmentLinkPinNodeId(source_node_id)
    const {
      unitId: target_unit_id,
      type: target_pin_type,
      pinId: target_pin_id,
    } = segmentLinkPinNodeId(target_node_id)

    const new_spec = emptyGraphSpec({
      inputs: {
        a: {
          plug: {
            0: {},
          },
        },
      },
      outputs: {
        a: {
          plug: {
            0: {},
          },
        },
      },
    })

    this._add_empty_spec(new_spec_id, new_spec)

    const new_unit_id = this._new_unit_id(new_spec_id)

    const new_unit = { id: new_spec_id }

    const bundle = unitBundleSpec(new_unit, specs)

    const source_position = this._get_node_position(source_node_id)
    const target_position = this._get_node_position(target_node_id)

    const position = mediumPoint(source_position, target_position)

    const layout_position = this._screen_center()

    this._add_unit(
      new_unit_id,
      bundle,
      position,
      emptyIO({}, {}),
      layout_position,
      null
    )

    const new_unit_source_pin_id = getPinNodeId(new_unit_id, 'input', 'a')
    const new_unit_target_pin_id = getPinNodeId(new_unit_id, 'output', 'a')

    const new_source_merge_id = this._merge_pin_pin(
      new_unit_source_pin_id,
      source_node_id
    )
    const new_target_merge_id = this._merge_pin_pin(
      new_unit_target_pin_id,
      target_node_id
    )

    this._deselect_node(source_node_id)
    this._deselect_node(target_node_id)
    this._deselect_node(new_source_merge_id)
    this._deselect_node(new_target_merge_id)
  }

  private _state_set_unit_pin_data(pin_node_id: string, data: string) {
    this._spec_set_pin_data(pin_node_id, data)
    this._sim_set_pin_data_value(pin_node_id, data)
  }

  private _sim_move_unit_into_graph_remove(
    graph_id: string,
    unit_id: string,
    next_unit_id: string
  ) {
    // console.log(
    //   'Graph',
    //   '_sim_move_unit_into_graph_remove',
    //   graph_id,
    //   unit_id,
    //   next_unit_id
    // )

    if (this._is_unit_component(unit_id)) {
      // this._sim_remove_layout_core(unit_id)
      this._sim_remove_component(unit_id, false, false)
    }

    this._sim_remove_unit_body(unit_id)
  }

  private _state_move_unit_into_graph__inject(
    graph_id: string,
    unit_id: string,
    unit_spec: GraphUnitSpec,
    next_unit_id: string,
    next_pin_id_map: GraphMoveSubGraphData['nextPinIdMap'],
    next_unit_merges: Dict<IOOf<Dict<string>>>,
    next_pin_position: UnitPinPosition,
    unit: GraphUnitSpec,
    sub_component_spec: InjectSubComponentOpt | null,
    sub_component_slot: string | null,
    sub_component_parent_slot: string,
    unit_sub_componennt: Component | null,
    meta: GraphConnectUnitMeta
  ) {
    this._spec_move_unit_into_graph__inject(
      graph_id,
      unit_id,
      unit_spec,
      next_unit_id,
      next_pin_id_map,
      next_unit_merges,
      unit,
      sub_component_spec,
      sub_component_slot,
      sub_component_parent_slot
    )
    this._sim_move_unit_into_graph__inject(
      graph_id,
      unit_id,
      unit_spec,
      next_unit_id,
      next_pin_id_map,
      unit,
      sub_component_spec,
      sub_component_slot,
      sub_component_parent_slot,
      unit_sub_componennt,
      next_pin_position,
      meta
    )
  }

  private _sim_move_unit_into_graph__inject(
    graph_id: string,
    unit_id: string,
    graph_unit_spec: GraphUnitSpec,
    next_unit_id: string,
    next_pin_id_map: GraphMoveSubGraphData['nextPinIdMap'],
    unit: GraphUnitSpec,
    sub_component_spec: InjectSubComponentOpt | null,
    sub_component_slot: string | null,
    sub_component_parent_slot: string,
    sub_component: Component | null,
    pin_position: UnitPinPosition,
    meta: GraphConnectUnitMeta
  ) {
    // console.log(
    //   '_sim_move_unit_into_graph__inject',
    //   graph_id,
    //   unit_id,
    //   next_unit_id,
    //   next_pin_id_map,
    //   unit,
    //   sub_component_spec,
    //   sub_component
    // )

    const { getSpec } = this.$props

    const is_graph_component = this._is_unit_component(graph_id)

    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    const icon = deepGetOrDefault(graph_spec, ['metadata', 'icon'], 'question')

    this._set_core_icon(graph_id, icon)

    this._refresh_core_icon_hidden(graph_id)

    const { id: unit_spec_id } = unit

    const spec = this._collapse_unit_spec[unit_id] as GraphSpec

    const insert_pin = (type: IO, pin_id: string) => {
      const { pinId, subPinId, plug } = deepGetOrDefault(
        next_pin_id_map,
        [type, pin_id],
        {
          pinId: undefined,
          subPinId: undefined,
        }
      )

      if (pinId && subPinId) {
        const next_pin_id = pinId
        const next_sub_pin_id = subPinId
        const next_pin_node_id = getPinNodeId(graph_id, type, pinId)

        const position =
          pin_position?.[type]?.[pin_id] || this._jiggle_world_screen_center()

        if (!this._has_anchor_node(next_pin_node_id)) {
          this._sim_graph_unit_expose_pin_set(
            graph_id,
            type,
            next_pin_id,
            position
          )

          if (type === 'output' && pin_id === SELF) {
            this._sim_set_pin_data_value(next_pin_node_id, 'null')
          }

          this._set_node_layer(next_pin_node_id, LAYER_COLLAPSE)

          const constant = deepGetOrDefault(
            graph_unit_spec,
            [type, pin_id, 'constant'],
            false
          )

          if (constant) {
            this._sim_set_unit_pin_constant(next_pin_node_id, true)
          }

          if (meta.selected.links[type].has(next_pin_id)) {
            this._select_node(next_pin_node_id)
          }
        }
      }
    }

    forEachGraphSpecPin(spec, insert_pin)

    insert_pin('output', SELF)

    if (!is_graph_component) {
      this._refresh_core_circle(graph_id)
    }
  }

  private _spec_move_unit_into_graph__inject(
    graph_id: string,
    unit_id: string,
    graph_unit_spec: GraphUnitSpec,
    next_unit_id: string,
    next_pin_id_map: GraphMoveSubGraphData['nextPinIdMap'],
    next_unit_pin_merges: Dict<IOOf<Dict<string>>>,
    unit: GraphUnitSpec,
    sub_component: InjectSubComponentOpt | null,
    sub_component_slot: string | null,
    sub_component_parent_slot: string
  ) {
    // console.log(
    //   'Graph',
    //   '_spec_move_unit_into_graph__inject',
    //   graph_id,
    //   unit_id,
    //   next_unit_id,
    //   next_pin_id_map,
    //   unit,
    //   sub_component,
    //   sub_component_slot,
    //   sub_component_parent_slot
    // )

    const { getSpec, setSpec } = this.$props

    const graph_spec_id = this._get_unit_spec_id(graph_id)
    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    const updated_graph_spec = clone(graph_spec)

    addUnit({ unitId: next_unit_id, unit: clone(unit) }, updated_graph_spec)

    if (sub_component) {
      updated_graph_spec.component = updated_graph_spec.component ?? {}

      const { width, height } = sub_component

      setSubComponent(
        {
          unitId: next_unit_id,
          subComponent: { children: [], childSlot: {}, width, height },
        },
        updated_graph_spec.component ?? {}
      )
      appendRoot({ childId: next_unit_id }, updated_graph_spec.component)

      const { defaultWidth = MIN_WIDTH, defaultHeight = MIN_HEIGHT } =
        updated_graph_spec.component

      const _defaultWidth = Math.max(defaultWidth, width)
      const _defaultHeight = Math.max(defaultHeight, height)

      setSize(
        { defaultWidth: _defaultWidth, defaultHeight: _defaultHeight },
        updated_graph_spec.component
      )

      if (sub_component.parent_id) {
        if (this._spec_graph_unit_has_unit(graph_id, sub_component.parent_id)) {
          removeRoot({ childId: next_unit_id }, updated_graph_spec.component)

          const at = (
            this._collapse_init_spec.component.subComponents[
              sub_component.parent_id
            ] ?? { children: [] }
          ).children.indexOf(unit_id)

          insertSubComponentChild(
            { parentId: sub_component.parent_id, childId: next_unit_id, at },
            updated_graph_spec.component
          )
        }
      }

      for (const sub_component_child_id of sub_component.children ?? []) {
        if (this._spec_graph_unit_has_unit(graph_id, sub_component_child_id)) {
          removeRoot(
            { childId: sub_component_child_id },
            updated_graph_spec.component
          )

          appendSubComponentChild(
            { parentId: next_unit_id, childId: sub_component_child_id },
            updated_graph_spec.component
          )
        }
      }

      if (sub_component_slot) {
        updated_graph_spec.component.slots =
          updated_graph_spec.component.slots ?? []
        updated_graph_spec.component.slots.push([
          next_unit_id,
          sub_component_slot,
        ])
      }

      deepDelete(updated_graph_spec, ['metadata', 'complexity'])
    }

    if (!updated_graph_spec.metadata || !updated_graph_spec.metadata.icon) {
      deepSet(updated_graph_spec, ['metadata', 'icon'], 'question')
    }

    const { id: unit_spec_id } = unit

    const unit_spec = this._collapse_unit_spec[unit_id] as GraphSpec

    const insert_pin = (type, pin_id) => {
      const { pinId, subPinId, ref, plug } = deepGetOrDefault(
        next_pin_id_map,
        [type, pin_id],
        {
          pinId: undefined,
          subPinId: undefined,
        }
      )

      const constant = isUnitPinConstant(
        this._collapse_init_spec,
        unit_id,
        type,
        pin_id
      )

      if (constant) {
        if (pinId) {
          setUnitPinConstant(
            { unitId: next_unit_id, type, pinId: pin_id, constant: false },
            updated_graph_spec
          )

          removeUnitPinData(
            { unitId: next_unit_id, type, pinId: pin_id },
            updated_graph_spec
          )

          this._spec_set_unit_pin_constant(graph_id, type, pinId, true)
        }
      }

      if (pinId && subPinId) {
        const pin_spec = deepGetOrDefault(
          updated_graph_spec,
          [`${type}s`, pinId],
          undefined
        )

        if (pin_spec) {
          exposePin(
            {
              pinId,
              type,
              subPinId,
              subPinSpec: {
                unitId: next_unit_id,
                pinId: pin_id,
                kind: type,
              },
            },
            updated_graph_spec
          )
        } else {
          exposePinSet(
            {
              pinId,
              type,
              pinSpec: {
                plug: {
                  [subPinId]: {
                    unitId: next_unit_id,
                    pinId: pin_id,
                    kind: type,
                  },
                },
                ref,
              },
            },
            updated_graph_spec
          )
        }
      }

      if (plug) {
        const { type, pinId, subPinId, kind = type } = plug

        if (hasPlug(updated_graph_spec, type, pinId, subPinId)) {
          plugPin(
            {
              type,
              pinId,
              subPinId,
              subPinSpec: {
                unitId: next_unit_id,
                pinId: pin_id,
                kind,
              },
            },
            updated_graph_spec
          )
        }
      }
    }

    forEachGraphSpecPin(unit_spec, insert_pin)

    insert_pin('output', SELF)

    setSpec(graph_spec_id, updated_graph_spec)

    const next_unit_merge = next_unit_pin_merges[unit_id]

    forIOObjKV(
      next_unit_merge ?? emptyIO({}, {}),
      (type, pin_id, next_merge_id: string) => {
        if (!this._spec_graph_unit_has_merge(graph_id, next_merge_id)) {
          this._spec_graph_unit_add_merge(graph_id, next_merge_id, {})
        }

        this._spec_graph_unit_add_pin_to_merge(
          graph_id,
          next_merge_id,
          next_unit_id,
          type,
          pin_id
        )
      }
    )
  }

  private _state_move_unit_into_graph__reconnect = (
    graph_id: string,
    unit_id: string,
    opt: GraphUnitConnect,
    meta: GraphConnectUnitMeta
  ) => {
    this._spec_move_unit_into_graph__reconnect(graph_id, unit_id, opt)
    this._sim_move_unit_into_graph__reconnect(graph_id, unit_id, opt, meta)
  }

  private _move_unit_into_graph__reconnect__template(
    graph_id: string,
    unit_id: string,
    opt: GraphUnitConnect,
    source: {
      hasUnit: (unitId: string) => boolean
      hasMerge: (merge_id: string) => boolean
      hasMergePin: (
        merge_id: string,
        unit_id: string,
        type: IO,
        pin_id: string
      ) => boolean
      addPinToMerge: (
        unit_id: string,
        type: IO,
        pin_id: string,
        merge_id: string
      ) => void
      addMerge(merge_id: string, merge: GraphMergeSpec)
      getUnitPinPlug: (
        unit_id: string,
        type: IO,
        pin_id: string
      ) => GraphPlugOuterSpec
      plugPin: (
        type: IO,
        pin_id: string,
        sub_pin_id: string,
        sub_pin_spec: GraphSubPinSpec,
        position: Position
      ) => void
      removePin: (type: IO, pin_id: string, sub_pin_id: string) => void
    },
    target: {
      hasMerge: (merge_id: string) => boolean
      getMerge: (merge_id: string) => GraphMergeSpec
      hasMergePin: (
        merge_id: string,
        unit_id: string,
        type: IO,
        pin_id: string
      ) => boolean
      plugPin: (
        type: IO,
        pin_id: string,
        sub_pin_id: string,
        sub_pin_spec: GraphSubPinSpec
      ) => void
      addPinToMerge: (
        unit_id: string,
        type: IO,
        pin_id: string,
        merge_id: string
      ) => void
      addMerge(merge_id: string, merge: GraphMergeSpec)
    }
  ) {
    const { getSpec } = this.$props

    const { merges, plugs } = opt

    const {
      addPinToMerge,
      addMerge,
      hasMergePin,
      plugPin,
      hasUnit,
      hasMerge,
      getUnitPinPlug,
      removePin,
    } = source

    const { nextIdMap, nextPinIdMap, nextUnitPinMergeMap, nextPlugSpec } =
      this._collapse_next_map

    const nextUnitId = nextIdMap.unit[unit_id] ?? unit_id

    const unit = this._collapse_init_spec.units[unit_id]

    const spec = this._get_unit_spec(graph_id)

    const unit_spec = getSpec(unit.id) as GraphSpec

    forEachSpecPin(unit_spec, (type, pin_id) => {
      const mergeId = deepGetOrDefault(
        nextUnitPinMergeMap,
        [nextUnitId, type, pin_id],
        undefined
      )

      if (mergeId) {
        if (!target.hasMerge(mergeId)) {
          target.addMerge(mergeId, {})
        }

        const mergeSpec = target.getMerge(mergeId)

        if (getMergePinCount(mergeSpec) === 0) {
          forIOObjKV(nextPlugSpec, (type, pinId, plugs) => {
            for (const subPinId in plugs) {
              const plug_node_id = getExtNodeId(type, pinId, subPinId)

              if (!this._has_node(plug_node_id)) {
                const subPin = plugs[subPinId]

                if (subPin.mergeId === mergeId) {
                  target.plugPin(type, pinId, subPinId, { mergeId })
                }
              }
            }
          })
        }

        if (target.hasMergePin(mergeId, nextUnitId, type, pin_id)) {
          //
        } else {
          target.addPinToMerge(nextUnitId, type, pin_id, mergeId)
        }
      }
    })

    const next_unit_id = deepGetOrDefault(
      this._collapse_next_map.nextIdMap,
      ['unit', unit_id],
      unit_id
    )

    for (const merge_id in merges) {
      const merge = merges[merge_id]

      const merge_unit = merge[graph_id]

      const type = isEmptyObject(merge_unit.input ?? {}) ? 'output' : 'input'

      const opposite_type = opposite(type)

      const next_merge_id = merge_id

      const merge_ = {}

      forEachPinOnMerge(merge, (unit_id, type, pin_id) => {
        if (hasUnit(unit_id)) {
          deepSet(merge_, [unit_id, type, pin_id], true)
        }
      })

      if (hasMerge(next_merge_id)) {
        const merge_unit = merge[graph_id]

        forEachPinOnMerge(merge_, (unit_id, type, pin_id) => {
          addPinToMerge(unit_id, type, pin_id, next_merge_id)
        })
      } else {
        const merge_has_self = deepGetOrDefault(
          merge,
          [graph_id, 'output', SELF],
          false
        )

        if (!merge_has_self && getMergePinCount(merge_) > 1) {
          addMerge(next_merge_id, merge_)
        }
      }
    }

    forIOObjKV(
      plugs,
      (type, pin_id, { kind, pinId, subPinId, position, type: type_ }) => {
        position = position ?? this._jiggle_world_screen_center()

        const next_pin_id = deepGetOrDefault(
          this._collapse_next_map.nextPinIdMap,
          [unit_id, kind, pin_id, 'pinId'],
          pin_id
        )

        const ext_pin_id = getExtNodeId(type_, pinId, subPinId)

        if (this._collapse_init_node_id_set.has(ext_pin_id)) {
          if (this._has_node(ext_pin_id)) {
            //
          } else {
            target.plugPin(type_, pinId, subPinId, {
              unitId: next_unit_id,
              pinId: pin_id,
              kind,
            })
          }
        } else {
          plugPin(
            type_,
            pinId,
            subPinId,
            {
              unitId: graph_id,
              pinId: next_pin_id,
              kind,
            },
            position
          )
        }
      }
    )
  }

  private _spec_move_unit_into_graph__reconnect(
    graph_id: string,
    unit_id: string,
    opt: GraphUnitConnect
  ) {
    this._move_unit_into_graph__reconnect__template(
      graph_id,
      unit_id,
      opt,
      {
        addPinToMerge: (unit_id, type, pin_id, merge_id) => {
          this._spec_add_link_pin_to_merge(merge_id, unit_id, type, pin_id)
        },
        addMerge: (merge_id, merge) => {
          this._spec_add_merge(merge_id, merge)
        },
        plugPin: (type, pin_id, sub_pin_id, sub_pin_spec) => {
          this._spec_plug_sub_pin(type, pin_id, sub_pin_id, sub_pin_spec)
        },
        hasUnit: (unit_id) => {
          return this._spec_has_unit(unit_id)
        },
        hasMerge: (merge_id) => {
          return this.__spec_has_merge(merge_id)
        },
        getUnitPinPlug: (
          unit_id: string,
          type: IO,
          pin_id: string
        ): GraphPlugOuterSpec => {
          return this._spec_get_unit_pin_plug(unit_id, type, pin_id)
        },
        removePin: (type, pin_id, sub_pin_id) => {
          return this.__spec_remove_exposed_sub_pin(type, pin_id, sub_pin_id)
        },
        hasMergePin: (merge_id, unit_id, type, pin_id) => {
          return this._spec_has_merge_pin(merge_id, unit_id, type, pin_id)
        },
      },
      {
        plugPin: (type, pinId, subPinId, subPinSpec) => {
          this._on_graph_unit_plug_pin_moment({
            type,
            pinId,
            subPinId,
            subPinSpec,
            path: [graph_id],
          })
        },
        addPinToMerge: (
          unit_id: string,
          type: IO,
          pin_id: string,
          merge_id: string
        ): void => {
          return this._spec_graph_unit_add_pin_to_merge(
            graph_id,
            merge_id,
            unit_id,
            type,
            pin_id
          )
        },
        addMerge: (merge_id: string, merge: GraphMergeSpec) => {
          return this._spec_graph_unit_add_merge(graph_id, merge_id, merge)
        },
        hasMerge: (merge_id: string): boolean => {
          return this._spec_graph_unit_has_merge(graph_id, merge_id)
        },
        getMerge: (merge_id): GraphMergeSpec => {
          return this._spec_graph_get_merge_spec(graph_id, merge_id)
        },
        hasMergePin: (
          merge_id: string,
          unit_id: string,
          type: IO,
          pin_id: string
        ): boolean => {
          return this._spec_graph_unit_has_merge_pin(
            graph_id,
            merge_id,
            unit_id,
            type,
            pin_id
          )
        },
      }
    )
  }

  private _spec_get_unit_pin_plug = (
    unit_id: string,
    type: IO,
    pin_id: string
  ): GraphPlugOuterSpec | null => {
    const pin_node_id = getPinNodeId(unit_id, type, pin_id)

    return this._spec_get_pin_node_plug_spec(type, pin_node_id)
  }

  private _sim_move_unit_into_graph__reconnect(
    graph_id: string,
    unit_id: string,
    opt: GraphUnitConnect,
    meta: GraphConnectUnitMeta = {
      selected: { merges: [], links: emptyIO(new Set(), new Set()) },
    }
  ) {
    // console.log(
    //   'Graph',
    //   '_sim_move_unit_into_graph__reconnect',
    //   graph_id,
    //   opt,
    //   meta
    // )

    const { data } = opt

    this._move_unit_into_graph__reconnect__template(
      graph_id,
      unit_id,
      opt,
      {
        addPinToMerge: (unit_id, type, pin_id, merge_id) => {
          const merge_node_id = getMergeNodeId(merge_id)
          const pin_node_id = getPinNodeId(unit_id, type, pin_id)

          if (this._pin_to_merge[pin_node_id]) {
            //
          } else {
            this._sim_add_link_pin_to_merge(pin_node_id, merge_node_id)

            if (
              this._is_link_pin_ref(pin_node_id) &&
              this._is_merge_ref(merge_node_id)
            ) {
              if (!this._datum_to_pin[pin_node_id]) {
                this._on_graph_unit_ref_link_pin_data_moment({
                  unitId: unit_id,
                  type,
                  pinId: pin_id,
                  data: 'null',
                })
              }
            }
          }
        },
        hasUnit: (unit_id) => {
          return this._spec_has_unit(unit_id)
        },
        addMerge: (merge_id, merge) => {
          const merge_node_id = getMergeNodeId(merge_id)

          if (
            this._has_anchor_node(merge_node_id) ||
            this._is_merge_ref(merge_node_id)
          ) {
            const merge_graph = merge[graph_id]

            forIOObjKV(merge_graph, (type, pin_id) => {
              const pin_node_id = getPinNodeId(graph_id, type, pin_id)

              if (!this._pin_to_merge[pin_node_id]) {
                this._sim_add_link_pin_to_merge(pin_node_id, merge_node_id)
              }
            })
          } else {
            const fallback_position = this._init_merge_spec_position(merge)

            const position = deepGetOrDefault(
              meta,
              ['position', 'merges', merge_id],
              fallback_position
            )

            this._sim_add_merge(merge_id, merge, position)
            this._sim_collapse_merge(merge_id)
          }
        },
        plugPin: (type, pin_id, sub_pin_id, sub_pin_spec, position) => {
          const pin_node_id = getSubPinSpecNodeId(type, sub_pin_spec)

          if (sub_pin_spec.unitId && !this._has_anchor_node(pin_node_id)) {
            this._spec_graph_unit_expose_pin_set(
              sub_pin_spec.unitId,
              sub_pin_spec.kind ?? type,
              sub_pin_spec.pinId,
              {}
            )
            this._sim_graph_unit_expose_pin_set(
              sub_pin_spec.unitId,
              sub_pin_spec.kind ?? type,
              sub_pin_spec.pinId,
              position
            )
          }

          const anchor_node_id = getSubPinSpecNodeId_(type, sub_pin_spec)

          if (!this._pin_to_int[type][anchor_node_id]) {
            this._state_plug_exposed_pin(type, pin_id, sub_pin_id, sub_pin_spec)
          }
        },
        hasMerge: (merge_id) => {
          const merge_node_id = getMergeNodeId(merge_id)

          const anchor_node_id = this._get_merge_anchor_node_id(merge_node_id)

          return anchor_node_id && this._has_node(anchor_node_id)
        },
        hasMergePin: (merge_id, unit_id, type, pin_id) => {
          return this._spec_has_merge_pin(merge_id, unit_id, type, pin_id)
        },
        getUnitPinPlug: (
          unit_id: string,
          type: IO,
          pin_id: string
        ): GraphPlugOuterSpec => {
          return this._spec_get_unit_pin_plug(unit_id, type, pin_id)
        },
        removePin: (type, pin_id, sub_pin_id) => {
          return this.__sim_remove_exposed_sub_pin(type, pin_id, sub_pin_id)
        },
      },
      {
        plugPin: (type, pinId, subPinId, subPinSpec) => {
          this._on_graph_unit_plug_pin_moment({
            type,
            pinId,
            subPinId,
            subPinSpec,
            path: [graph_id],
          })
        },
        addPinToMerge: (
          unit_id: string,
          type: IO,
          pin_id: string,
          merge_id: string
        ): void => {
          this._on_graph_unit_add_pin_to_merge_moment({
            type,
            unitId: unit_id,
            pinId: pin_id,
            mergeId: merge_id,
            path: [graph_id],
          })
        },
        getMerge: (merge_id): GraphMergeSpec => {
          return this._get_graph_unit_merge(graph_id, merge_id)
        },
        addMerge: (merge_id: string, merge: GraphMergeSpec) => {
          this._on_graph_unit_add_merge_moment({
            mergeId: merge_id,
            mergeSpec: merge,
            path: [graph_id],
          })
        },
        hasMerge: (merge_id: string): boolean => {
          return this._has_graph_unit_merge(graph_id, merge_id)
        },
        hasMergePin: (
          merge_id: string,
          unit_id: string,
          type: IO,
          pin_id: string
        ): boolean => {
          return this._has_graph_unit_merge_pin(
            graph_id,
            merge_id,
            unit_id,
            type,
            pin_id
          )
        },
      }
    )

    forIO(data, (type, pin_data) => {
      forEachObjKV(pin_data, (pin_id, datum_tree) => {
        const pin_node_id = getPinNodeId(graph_id, type, pin_id)

        if (this._has_anchor_node(pin_node_id)) {
          const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)

          const merge_ref_unit_id = this._merge_to_ref_unit[anchor_node_id]

          if (this._is_unit_node_id(anchor_node_id)) {
            if (this._ref_unit_to_merge[anchor_node_id]) {
              return
            }
          }

          const position =
            this._predict_pin_datum_initial_position(anchor_node_id)

          this._graph_debug_set_pin_data_tree(pin_node_id, datum_tree)
        }
      })
    })
  }

  private _state_move_unit_into_graph = (
    graph_id: string,
    unit_id: string,
    unit_spec: GraphUnitSpec,
    next_unit_id: string,
    next_unit_pin_map: Dict<
      IOOf<
        Dict<{
          pinId: string
          subPinId: string
          ref?: boolean
          defaultIgnored?: boolean
        }>
      >
    >,
    next_unit_merges: Dict<IOOf<Dict<string>>>
  ): void => {
    // console.log(
    //   'Graph',
    //   '_state_move_unit_into_graph',
    //   graph_id,
    //   unit_id,
    //   next_unit_id,
    //   next_unit_pin_map
    // )

    // const this_interface = this._state_get_this_graph_interface()
    // const graph_interface = this._state_get_subgraph_graph_interface(graph_id)

    // const pin_specs = {
    //   input: this._collapse_init_spec.inputs ?? {},
    //   output: this._collapse_init_spec.outputs ?? {},
    // }

    // moveUnit(
    //   this_interface,
    //   graph_interface,
    //   graph_id,
    //   unit_id,
    //   this._collapse_next_map,
    //   {},
    //   new Set(),
    //   {},
    //   new Set(),
    //   pin_specs,
    //   false
    // )

    const unit = this._get_unit(unit_id)

    const prev_merges = clone(
      getUnitMergesSpec(this._collapse_init_spec, unit_id)
    )
    const curr_merges = clone(this._get_unit_merges(unit_id))
    const prev_plugs = getUnitExposedPins(this._collapse_init_spec, unit_id)

    const prev_inputs = this._get_unit_input_node_ids(unit_id)
    const prev_outputs = this._get_unit_output_node_ids(unit_id)
    const prev_data = this._get_unit_data(unit_id)

    const merges = {}
    const data = clone(prev_data)
    const plugs = clone(prev_plugs)

    const next_pin_map = next_unit_pin_map[unit_id] ?? {}

    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    const pin_id_blacklist: IOOf<Set<string>> = reduceObj(
      next_unit_pin_map,
      (acc, io_map) => {
        forIOObjKV(io_map, (type, _pinId, { pinId }) => {
          acc[type].add(pinId)
        })

        return acc
      },
      emptyIO(new Set(), new Set())
    )

    forEachObjKV(curr_merges, (merge_id) => {
      const merge_node_id = getMergeNodeId(merge_id)

      const ref = this._is_merge_ref(merge_node_id)

      const merge = prev_merges[merge_id]
      const prev_merge_unit = merge[unit_id]

      merges[merge_id] = clone(merge)

      delete merges[merge_id][unit_id]

      const next_merge_unit = {}

      const merge_is_collapsing_too = this._collapse_node_id.has(merge_node_id)

      let merge_should_be_ignored = merge_is_collapsing_too

      if (!merge_should_be_ignored) {
        forIOObjKV(prev_merge_unit, (type, pin_id: string) => {
          const is_self_pin = type === 'output' && pin_id === SELF

          if (next_pin_map[type]?.[pin_id] || is_self_pin) {
            const fallback_pin_id = newSpecPinId(
              graph_spec,
              type,
              pin_id,
              pin_id_blacklist[type]
            )
            const next_pin_id = deepGetOrDefault(
              next_pin_map,
              [type, pin_id, 'pinId'],
              fallback_pin_id
            )
            const next_sub_pin_id = deepGetOrDefault(
              next_pin_map,
              [type, pin_id, 'subPinId'],
              '0'
            )

            const default_ignored = this.__spec_is_link_pin_ignored(
              unit_id,
              type,
              pin_id
            )

            deepSet(next_merge_unit, [type, next_pin_id], true)
          }
        })
      }

      deepSet(
        merges,
        [merge_id, graph_id],
        deepMerge(
          deepGetOrDefault(curr_merges, [merge_id, graph_id], {}),
          next_merge_unit
        )
      )
    })

    forEachObjKV(prev_merges, (merge_id) => {
      const merge = merges[merge_id]

      const pin_count = getMergePinCount(merge)

      if (pin_count < 2) {
        delete merges[merge_id]
      }
    })

    forIO(prev_data, (type, pin_data) => {
      forEachObjKV(pin_data, (pin_id, datum_tree) => {
        delete data[type][pin_id]

        const next_pin_id = deepGetOrDefault(
          next_pin_map,
          [type, pin_id, 'pinId'],
          null
        )

        if (next_pin_id) {
          data[type][next_pin_id] = datum_tree
        }
      })
    })

    const connect_opt: GraphUnitConnect = {
      merges,
      plugs,
      data,
    }

    const connect_meta: GraphConnectUnitMeta = {
      position: {
        merges: mapObjKV(curr_merges, (merge_id) => {
          const merge_node_id = getMergeNodeId(merge_id)

          const anchor_node_id = this._get_pin_anchor_node_id(merge_node_id)

          return this._get_node_position(anchor_node_id)
        }),
        data: {},
      },
      selected: {
        links: {
          input: new Set(),
          output: new Set(),
        },
        merges: keys(prev_merges).filter((merge_id) =>
          this._collapse_node_id.has(getMergeNodeId(merge_id))
        ),
      },
    }

    this._for_each_unit_pin(unit_id, (pin_node_id, type, pin_id) => {
      if (this._is_link_pin_merged(pin_node_id)) {
        //
      } else {
        const next_graph_pin_id = deepGetOrDefault(
          next_pin_map,
          [type, pin_id, 'pinId'],
          newSpecPinId(graph_spec, type, pin_id, pin_id_blacklist[type])
        )

        pin_id_blacklist[type].add(next_graph_pin_id)
      }
    })

    const unit_pin_position = this._get_unit_pin_position(unit_id)

    let sub_component_spec: InjectSubComponentOpt | null = null
    let sub_component_slot: string | null = null
    let sub_component_parent_slot: string | null = 'default'
    let sub_component: Component | null = null

    if (this._is_unit_component(unit_id)) {
      const graph_component = this._get_sub_component(graph_id)

      sub_component = this._get_sub_component(unit_id)

      if (graph_component) {
        sub_component = graph_component.getSubComponent(next_unit_id)
      }

      const children =
        this._collapse_next_map.nextSubComponentChildrenMap[unit_id]
      const parent_id =
        this._collapse_next_map.nextSubComponentParentMap[unit_id]
      const index = this._collapse_next_map.nextSubComponentIndexMap[unit_id]

      const { width, height } = this._get_unit_component_graph_size(unit_id)

      const spec = this._get_sub_component_spec(unit_id)

      sub_component_spec = {
        children,
        spec,
        parent_id,
        index,
        width,
        height,
      }

      sub_component_slot =
        this._collapse_next_map.nextSubComponentSlot[unit_id] ?? null

      sub_component_parent_slot =
        this._collapse_next_map.nextSubComponentParentSlot[unit_id] ?? 'default'
    }

    this._state_move_unit_into_graph__remove(graph_id, unit_id, next_unit_id)
    this._state_move_unit_into_graph__inject(
      graph_id,
      unit_id,
      unit_spec,
      next_unit_id,
      next_pin_map,
      next_unit_merges,
      unit_pin_position,
      unit,
      sub_component_spec,
      sub_component_slot,
      sub_component_parent_slot,
      sub_component,
      connect_meta
    )
    this._state_move_unit_into_graph__reconnect(
      graph_id,
      unit_id,
      connect_opt,
      connect_meta
    )
  }

  private _state_move_plug_into_graph = (
    graph_id: string,
    exposed_pin_node_id: string,
    collapse_map: GraphMoveSubGraphData
  ): void => {
    // console.log(
    //   'Graph',
    //   '_state_move_plug_into_graph',
    //   graph_id,
    //   exposed_pin_node_id
    // )

    const { type, pinId, subPinId } = segmentPlugNodeId(exposed_pin_node_id)

    const pin_spec = this._get_pin_spec(type, pinId)

    const int_node_id = getIntNodeId(type, pinId, subPinId)
    const ext_node_id = getExtNodeId(type, pinId, subPinId)

    const int_position =
      this._has_node(int_node_id) && this._get_node_position(int_node_id)
    const ext_position =
      this._has_node(ext_node_id) && this._get_node_position(ext_node_id)

    const sub_pin_spec = this._spec[`${type}s`][pinId]['plug'][subPinId]

    const this_interface = this._state_make_this_graph_interface()
    const graph_interface = this._state_get_subgraph_graph_interface(graph_id)

    const {
      pinId: nextPinId,
      type: nextType,
      subPinId: nextSubPinId,
      subPinSpec: nextSubPinSpec,
    } = movePlug(
      this_interface,
      graph_interface,
      graph_id,
      type,
      pinId,
      pin_spec,
      subPinId,
      sub_pin_spec,
      collapse_map
    )

    if (nextPinId) {
      const next_pin_node_position = int_position || ext_position

      const next_pin_node_id = getPinNodeId(graph_id, nextType, nextPinId)

      if (this._has_node(next_pin_node_id)) {
        this._set_node_position(next_pin_node_id, next_pin_node_position)
      }
    }
  }

  private _spec_is_plug_ref = (type: IO, pinId: string): boolean => {
    return this._spec[`${type}s`][pinId]['ref'] ?? false
  }

  private _spec_graph_unit_get_unit = (
    graph_id: string,
    unit_id: string
  ): GraphUnitSpec => {
    const spec = this._get_unit_spec(graph_id) as GraphSpec

    const { units } = spec

    const unit = units[unit_id]

    return unit
  }

  private _spec_graph_unit_get_unit_bundle = (
    graph_id: string,
    unit_id: string
  ): UnitBundleSpec => {
    const { specs } = this.$props

    const unit = this._spec_graph_unit_get_unit(graph_id, unit_id)

    const bundle = unitBundleSpec(unit, specs)

    return bundle
  }

  private _spec_graph_unit_plug_specs = (
    graph_id: string
  ): IOOf<Dict<Dict<GraphSubPinSpec>>> => {
    const spec = this._get_unit_spec(graph_id) as GraphSpec

    return getPlugSpecs(spec)
  }

  private _spec_graph_unit_get_exposed_pin_specs = (
    graph_id: string
  ): IOOf<GraphPinsSpec> => {
    const spec = this._get_unit_spec(graph_id) as GraphSpec

    return getExposedPinSpecs(spec)
  }

  private _spec_graph_unit_get_pin_spec = (
    graph_id: string,
    type: IO,
    pin_id: string
  ) => {
    const spec = this._get_unit_spec(graph_id) as GraphSpec

    return getPinSpec(spec, type, pin_id)
  }

  private _spec_graph_get_pin_spec = (
    graph_id: string,
    type: IO,
    pin_id: string
  ): GraphPinSpec => {
    const spec = this._get_unit_spec(graph_id) as GraphSpec

    return getPinSpec(spec, type, pin_id)
  }

  private _spec_graph_get_merges_spec = (graph_id: string) => {
    const { getSpec } = this.$props

    const spec = this._get_unit_spec(graph_id) as GraphSpec

    return spec.merges ?? {}
  }

  private _spec_graph_get_merge_spec = (graph_id: string, merge_id: string) => {
    const { getSpec } = this.$props

    const spec = this._get_unit_spec(graph_id) as GraphSpec

    return spec.merges[merge_id]
  }

  private _spec_graph_get_unit_pin_data = (
    graph_id: string,
    unitId: string,
    type: IO,
    pinId: string
  ) => {
    //

    return {}
  }

  private _spec_graph_get_unit_spec = (graph_id: string, unit_id: string) => {
    const { getSpec } = this.$props

    const unit = this._spec_graph_unit_get_unit(graph_id, unit_id)

    const { id } = unit

    const spec = getSpec(id)

    const input_names = keys(spec.inputs ?? {})

    return input_names
  }

  private _spec_graph_get_unit_input_names = (
    graph_id: string,
    unit_id: string
  ) => {
    const { getSpec } = this.$props

    const unit = this._spec_graph_unit_get_unit(graph_id, unit_id)

    const { id } = unit

    const spec = getSpec(id)

    const input_names = keys(spec.inputs ?? {})

    return input_names
  }

  private _spec_graph_get_unit_output_names = (
    graph_id: string,
    unit_id: string
  ) => {
    const { getSpec } = this.$props

    const unit = this._spec_graph_unit_get_unit(graph_id, unit_id)

    const { id } = unit

    const spec = getSpec(id)

    const output_names = keys(spec.outputs ?? {})

    return output_names
  }

  private _spec_unit_has_pin_named = (
    graph_id: string,
    type: IO,
    name: string
  ) => {
    const spec = this._get_unit_spec(graph_id)

    const has_pin_named = hasPinNamed(spec, type, name)

    return has_pin_named
  }

  private _spec_has_pin_named = (type: IO, pin_id: string) => {
    const has_pin_named = hasPinNamed(this._spec, type, pin_id)

    return has_pin_named
  }

  private _spec_has_plug = (type: IO, pinId: string, subPinId: string) => {
    const has_pin_named = hasPlug(this._spec, type, pinId, subPinId)

    return has_pin_named
  }

  private _spec_graph_get_unit_pin_ignored = (
    graph_id: string,
    unit_id: string,
    type: IO,
    pin_id: string
  ) => {
    const { getSpec } = this.$props

    const unit = this._spec_graph_unit_get_unit(graph_id, unit_id)

    const { id } = unit

    const spec = getSpec(id)

    const ignored = deepGetOrDefault(
      unit,
      [type, pin_id, 'ignored'],
      deepGetOrDefault(spec, [`${type}s`, pin_id, 'defaultIgnored'], false)
    )

    return ignored
  }

  private _spec_graph_get_unit_interface = (
    graph_id: string,
    unit_id: string
  ): U => {
    const { getSpec } = this.$props

    const spec = clone(this._get_unit_spec(graph_id)) as GraphSpec

    const unit_data = this._get_unit_data(graph_id)

    return this._spec_graph_get_unit_interface_from_spec(
      spec,
      unit_id,
      unit_data
    )
  }

  private _spec_graph_get_unit_interface_from_spec = (
    spec: GraphSpec,
    unit_id: string,
    unit_data: IOOf<Dict<TreeNode>>
  ): U => {
    const { getSpec } = this.$props

    const unit = spec.units[unit_id]

    const { id } = unit

    const unit_spec = getSpec(id)

    const interface_: U = {
      setParent: function (parent: Unit<any, any>) {
        throw new MethodNotImplementedError()
      },
      setInputs: function (inputs: Pins<any>, opts: PinOpts): void {
        throw new MethodNotImplementedError()
      },
      setOutputIgnored: function (name: string, ignore?: boolean): boolean {
        throw new MethodNotImplementedError()
      },
      setPinRef: function (type: IO, name: string, ref: boolean): void {
        throw new MethodNotImplementedError()
      },
      setInputRef: function (name: string, ref: boolean): void {
        throw new MethodNotImplementedError()
      },
      setOutputRef: function (name: string, ref: boolean): void {
        throw new MethodNotImplementedError()
      },
      setInput: function (name: string, input: Pin<any>, opt: PinOpt): void {
        throw new MethodNotImplementedError()
      },
      isPinConstant: (type: IO, name: string): boolean => {
        return isUnitPinConstant(spec, unit_id, type, name)
      },
      isPinIgnored: (type: IO, name: string): boolean => {
        const ignored = deepGetOrDefault(
          unit,
          [type, name, 'ignored'],
          deepGetOrDefault(
            unit_spec,
            [`${type}s`, name, 'defaultIgnored'],
            false
          )
        )

        return ignored
      },
      isPinRef: (type: IO, pinId: string): boolean => {
        return isPinRef({ type, pinId }, spec)
      },
      addInput: function (name: string, input: Pin<any>, opt: PinOpt): void {
        throw new MethodNotImplementedError()
      },
      removeInput: function (name: string): void {
        throw new MethodNotImplementedError()
      },
      setOutputs: function (outputs: Pins<any>, opts: PinOpts) {
        throw new MethodNotImplementedError()
      },
      setOutput: function (name: string, output: Pin<any>, opt: PinOpt) {
        throw new MethodNotImplementedError()
      },
      addOutput: function (name: string, output: Pin<any>): void {
        throw new MethodNotImplementedError()
      },
      removeOutput: function (name: string): void {
        throw new MethodNotImplementedError()
      },
      removePin: function (type: IO, name: string) {
        throw new MethodNotImplementedError()
      },
      getPin: function (type: IO, pinId: string): Pin<any> {
        throw new MethodNotImplementedError()
      },
      getInputs: function (): Pins<any> {
        throw new MethodNotImplementedError()
      },
      getDataInputs: function (): Pins<Partial<any>> {
        throw new MethodNotImplementedError()
      },
      getRefInputs: function (): Pins<Partial<any>> {
        throw new MethodNotImplementedError()
      },
      getInput: function <K>(name: K): Pin<K> {
        throw new MethodNotImplementedError()
      },
      getOutputs: function (): Pins<any> {
        throw new MethodNotImplementedError()
      },
      getDataOutputs: function (): Pins<Partial<any>> {
        throw new MethodNotImplementedError()
      },
      peakAllOutput: function (): Dict<any> {
        throw new MethodNotImplementedError()
      },
      peakAll: function (): Dict<any> {
        throw new MethodNotImplementedError()
      },
      hasPinNamed: function (type: IO, name: string): boolean {
        return hasPinNamed(unit_spec, type, name)
      },
      getInputCount: function (): number {
        throw new MethodNotImplementedError()
      },
      getOutputCount: function (): number {
        throw new MethodNotImplementedError()
      },
      getInputNames: (): string[] => {
        const input_names = keys(unit_spec.inputs ?? {})

        return input_names
      },
      getOutputNames: (): string[] => {
        const output_names = keys(unit_spec.outputs ?? {})

        return output_names
      },
      setPinData: function (type: IO, pinId: string, data: any): void {
        throw new MethodNotImplementedError()
      },
      removePinData: function (type: IO, pinId: string): void {
        throw new MethodNotImplementedError()
      },
      setInputConstant: function (pinId: string, constant: boolean): void {
        throw new MethodNotImplementedError()
      },
      setOutputConstant: function (pinId: string, constant: boolean): void {
        throw new MethodNotImplementedError()
      },
      getCatchErr: function (): boolean {
        throw new MethodNotImplementedError()
      },
      getConfig: function (): Opt {
        throw new MethodNotImplementedError()
      },
      reset: function (): void {
        throw new MethodNotImplementedError()
      },
      pause: function (): void {
        throw new MethodNotImplementedError()
      },
      play: function (): void {
        throw new MethodNotImplementedError()
      },
      paused: function (): boolean {
        throw new MethodNotImplementedError()
      },
      snapshot: function (): Memory {
        throw new MethodNotImplementedError()
      },
      restore: function (state: Memory): void {
        throw new MethodNotImplementedError()
      },
      getSelfPin: function (): Pin<U<any, any>> {
        throw new MethodNotImplementedError()
      },
      err: function (err?: string | Error): string {
        throw new MethodNotImplementedError()
      },
      hasErr: function (): boolean {
        throw new MethodNotImplementedError()
      },
      getErr: function (): string {
        throw new MethodNotImplementedError()
      },
      takeErr: function (): string {
        throw new MethodNotImplementedError()
      },
      getPinsData: function (): { input: Dict<any>; output: Dict<any> } {
        throw new MethodNotImplementedError()
      },
      getInputData: function (): Dict<any> {
        throw new MethodNotImplementedError()
      },
      getRefInputData: function (): Dict<Unit<any, any>> {
        throw new MethodNotImplementedError()
      },
      getSpec: function (): Spec {
        throw new MethodNotImplementedError()
      },
      getPinData: function (type: IO, pinId: string) {
        return deepGetOrDefault(unit_data, [type, pinId, 'value'], undefined)
      },
      setPinConstant: function (
        type: IO,
        pinId: string,
        constant: boolean
      ): void {
        throw new MethodNotImplementedError()
      },
      getUnitBundleSpec: (): UnitBundleSpec => {
        const { specs } = this.$props

        const bundle = unitBundleSpec(unit, specs)

        return bundle
      },
      setPin: function <
        T extends IO,
        K extends T extends 'input'
          ? string | number | symbol
          : string | number | symbol,
      >(type: T, name: K, pin: Pin<any>, opt: PinOpt) {
        throw new MethodNotImplementedError()
      },
      setPinIgnored: function (type: IO, name: string, ignored: boolean): void {
        throw new MethodNotImplementedError()
      },
      setInputIgnored: function <K extends string | number | symbol>(
        name: K,
        ignore?: boolean
      ): boolean {
        throw new MethodNotImplementedError()
      },
      getRefOutputs: function (): Pins<Partial<any>> {
        throw new MethodNotImplementedError()
      },
      getOutput: function <K extends string | number | symbol>(
        name: K
      ): Pin<any> {
        throw new MethodNotImplementedError()
      },
      push: function <K extends string | number | symbol>(
        name: K,
        data: any
      ): void {
        throw new MethodNotImplementedError()
      },
      pushInput: function <K extends string | number | symbol>(
        name: K,
        data: any
      ): void {
        throw new MethodNotImplementedError()
      },
      pushAllInput: function (data: Partial<any>): void {
        throw new MethodNotImplementedError()
      },
      pushOutput: function <K extends string | number | symbol>(
        name: K,
        data: any
      ): void {
        throw new MethodNotImplementedError()
      },
      pushAllOutput: function (data: Partial<any>): void {
        throw new MethodNotImplementedError()
      },
      pushAll: function (data: Partial<any>): void {
        throw new MethodNotImplementedError()
      },
      takeInput: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      takeOutput: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      take: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      takeAll: function (): Dict<any> {
        throw new MethodNotImplementedError()
      },
      peakInput: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      peakOutput: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      peak: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      renamePin: function <
        T extends IO,
        K extends T extends 'input'
          ? string | number | symbol
          : string | number | symbol,
      >(type: T, name: K, newName: K): void {
        throw new MethodNotImplementedError()
      },
      renameInput: function <K extends string | number | symbol>(
        name: K,
        newName: K
      ): void {
        throw new MethodNotImplementedError()
      },
      renameOutput: function (name: string, newName: string): void {
        throw new MethodNotImplementedError()
      },
      hasRefPinNamed: function <
        T extends IO,
        K extends T extends 'input'
          ? string | number | symbol
          : string | number | symbol,
      >(type: T, name: K): boolean {
        throw new MethodNotImplementedError()
      },
      hasRefInputNamed: function <K extends string | number | symbol>(
        name: K
      ): boolean {
        throw new MethodNotImplementedError()
      },
      hasRefOutputNamed: function <K extends string | number | symbol>(
        name: K
      ): boolean {
        throw new MethodNotImplementedError()
      },
      hasInputNamed: function <K extends string | number | symbol>(
        name: K
      ): boolean {
        throw new MethodNotImplementedError()
      },
      hasOutputNamed: function <K extends string | number | symbol>(
        name: K
      ): boolean {
        throw new MethodNotImplementedError()
      },
    }

    return interface_
  }

  private _state_get_unit_interface = (unit_id: string): U => {
    const { getSpec } = this.$props

    const spec = clone(this._get_unit_spec(unit_id)) as GraphSpec

    const bundle = clone(this._get_unit_bundle(unit_id))

    const unit_data = this._get_unit_data(unit_id)

    const interface_: U = {
      setParent: function (parent: Unit<any, any>) {
        throw new MethodNotImplementedError()
      },
      setInputs: function (inputs: Pins<any>, opts: PinOpts): void {
        throw new MethodNotImplementedError()
      },
      setOutputIgnored: function (name: string, ignore?: boolean): boolean {
        throw new MethodNotImplementedError()
      },
      setPinRef: function (type: IO, name: string, ref: boolean): void {
        throw new MethodNotImplementedError()
      },
      setInputRef: function (name: string, ref: boolean): void {
        throw new MethodNotImplementedError()
      },
      setOutputRef: function (name: string, ref: boolean): void {
        throw new MethodNotImplementedError()
      },
      setInput: function (name: string, input: Pin<any>, opt: PinOpt): void {
        throw new MethodNotImplementedError()
      },
      isPinConstant: (type: IO, name: string): boolean => {
        return isUnitPinConstant(spec, unit_id, type, name)
      },
      isPinIgnored: (type: IO, name: string): boolean => {
        return isUnitPinConstant(spec, unit_id, type, name)
      },
      isPinRef: (type: IO, name: string): boolean => {
        return isPinRef({ type, pinId: name }, spec)
      },
      addInput: function (name: string, input: Pin<any>, opt: PinOpt): void {
        throw new MethodNotImplementedError()
      },
      removeInput: function (name: string): void {
        throw new MethodNotImplementedError()
      },
      setOutputs: function (outputs: Pins<any>, opts: PinOpts) {
        throw new MethodNotImplementedError()
      },
      setOutput: function (name: string, output: Pin<any>, opt: PinOpt) {
        throw new MethodNotImplementedError()
      },
      addOutput: function (name: string, output: Pin<any>): void {
        throw new MethodNotImplementedError()
      },
      removeOutput: function (name: string): void {
        throw new MethodNotImplementedError()
      },
      removePin: function (type: IO, name: string) {
        throw new MethodNotImplementedError()
      },
      getPin: function (type: IO, pinId: string): Pin<any> {
        throw new MethodNotImplementedError()
      },
      getInputs: function (): Pins<any> {
        throw new MethodNotImplementedError()
      },
      getDataInputs: function (): Pins<Partial<any>> {
        throw new MethodNotImplementedError()
      },
      getRefInputs: function (): Pins<Partial<any>> {
        throw new MethodNotImplementedError()
      },
      getInput: function <K extends keyof any>(name: K): Pin<K> {
        throw new MethodNotImplementedError()
      },
      getOutputs: function (): Pins<any> {
        throw new MethodNotImplementedError()
      },
      getDataOutputs: function (): Pins<Partial<any>> {
        throw new MethodNotImplementedError()
      },
      getRefOutputs: function (): Pins<Partial<any>> {
        throw new MethodNotImplementedError()
      },
      takeAll: function (): Dict<any> {
        throw new MethodNotImplementedError()
      },
      renameOutput: function (name: string, newName: string): void {
        throw new MethodNotImplementedError()
      },

      hasPinNamed: (type: IO, name: string): boolean => {
        return hasPinNamed(spec, type, name)
      },
      getInputCount: function (): number {
        throw new MethodNotImplementedError()
      },
      getOutputCount: function (): number {
        throw new MethodNotImplementedError()
      },
      getInputNames: (): string[] => {
        return keys(spec.inputs ?? {})
      },
      getOutputNames: (): string[] => {
        return keys(spec.outputs ?? {})
      },
      setPinData: function (type: IO, pinId: string, data: any): void {
        throw new MethodNotImplementedError()
      },
      removePinData: function (type: IO, pinId: string): void {
        throw new MethodNotImplementedError()
      },
      setInputConstant: function (pinId: string, constant: boolean): void {
        throw new MethodNotImplementedError()
      },
      setOutputConstant: function (pinId: string, constant: boolean): void {
        throw new MethodNotImplementedError()
      },
      getCatchErr: function (): boolean {
        throw new MethodNotImplementedError()
      },
      getConfig: function (): Opt {
        throw new MethodNotImplementedError()
      },
      reset: function (): void {
        throw new MethodNotImplementedError()
      },
      pause: function (): void {
        throw new MethodNotImplementedError()
      },
      play: function (): void {
        throw new MethodNotImplementedError()
      },
      paused: function (): boolean {
        throw new MethodNotImplementedError()
      },
      snapshot: function (): Memory {
        throw new MethodNotImplementedError()
      },
      restore: function (state: Memory): void {
        throw new MethodNotImplementedError()
      },
      getSelfPin: function (): Pin<U<any, any>> {
        throw new MethodNotImplementedError()
      },
      err: function (err?: string | Error): string {
        throw new MethodNotImplementedError()
      },
      hasErr: function (): boolean {
        throw new MethodNotImplementedError()
      },
      getErr: function (): string {
        throw new MethodNotImplementedError()
      },
      takeErr: function (): string {
        throw new MethodNotImplementedError()
      },
      getPinsData: function (): { input: Dict<any>; output: Dict<any> } {
        throw new MethodNotImplementedError()
      },
      getInputData: function (): Dict<any> {
        throw new MethodNotImplementedError()
      },
      getRefInputData: function (): Dict<Unit<any, any>> {
        throw new MethodNotImplementedError()
      },
      getSpec: function (): Spec {
        return spec
      },
      getPinData: function (type: IO, pinId: string) {
        return deepGetOrDefault(unit_data, [type, pinId, 'value'], undefined)
      },
      setPinConstant: function (
        type: IO,
        pinId: string,
        constant: boolean
      ): void {
        throw new MethodNotImplementedError()
      },
      getUnitBundleSpec: (): UnitBundleSpec => {
        return bundle
      },
      setPin: function <
        T extends IO,
        K extends T extends 'input'
          ? string | number | symbol
          : string | number | symbol,
      >(type: T, name: K, pin: Pin<any>, opt: PinOpt) {
        throw new MethodNotImplementedError()
      },
      setPinIgnored: function (type: IO, name: string, ignored: boolean): void {
        throw new MethodNotImplementedError()
      },
      setInputIgnored: function <K extends string | number | symbol>(
        name: K,
        ignore?: boolean
      ): boolean {
        throw new MethodNotImplementedError()
      },
      getOutput: function <K extends string | number | symbol>(
        name: K
      ): Pin<any> {
        throw new MethodNotImplementedError()
      },
      push: function <K extends string | number | symbol>(
        name: K,
        data: any
      ): void {
        throw new MethodNotImplementedError()
      },
      pushInput: function <K extends string | number | symbol>(
        name: K,
        data: any
      ): void {
        throw new MethodNotImplementedError()
      },
      pushAllInput: function (data: Partial<any>): void {
        throw new MethodNotImplementedError()
      },
      pushOutput: function <K extends string | number | symbol>(
        name: K,
        data: any
      ): void {
        throw new MethodNotImplementedError()
      },
      pushAllOutput: function (data: Partial<any>): void {
        throw new MethodNotImplementedError()
      },
      pushAll: function (data: Partial<any>): void {
        throw new MethodNotImplementedError()
      },
      takeInput: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      takeOutput: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      take: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      peakInput: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      peakOutput: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      peak: function <K extends string | number | symbol>(name: K) {
        throw new MethodNotImplementedError()
      },
      peakAllOutput: function (): Dict<any> {
        throw new MethodNotImplementedError()
      },
      peakAll: function (): Dict<any> {
        throw new MethodNotImplementedError()
      },
      renamePin: function <
        T extends IO,
        K extends T extends 'input'
          ? string | number | symbol
          : string | number | symbol,
      >(type: T, name: K, newName: K): void {
        throw new MethodNotImplementedError()
      },
      renameInput: function <K extends string | number | symbol>(
        name: K,
        newName: K
      ): void {
        throw new MethodNotImplementedError()
      },
      hasRefPinNamed: function <
        T extends IO,
        K extends T extends 'input'
          ? string | number | symbol
          : string | number | symbol,
      >(type: T, name: K): boolean {
        throw new MethodNotImplementedError()
      },
      hasRefInputNamed: function <K extends string | number | symbol>(
        name: K
      ): boolean {
        throw new MethodNotImplementedError()
      },
      hasRefOutputNamed: function <K extends string | number | symbol>(
        name: K
      ): boolean {
        throw new MethodNotImplementedError()
      },
      hasInputNamed: function <K extends string | number | symbol>(
        name: K
      ): boolean {
        throw new MethodNotImplementedError()
      },
      hasOutputNamed: function <K extends string | number | symbol>(
        name: K
      ): boolean {
        throw new MethodNotImplementedError()
      },
    }

    return interface_
  }

  private _spec_graph_unit_expose_pin_set = (
    graph_id: string,
    type: IO,
    pinId: string,
    pinSpec: GraphPinSpec
  ) => {
    return this._spec_graph_unit__template(exposePinSet, graph_id, {
      type,
      pinId,
      pinSpec,
    })
  }

  private _spec_graph_unit_plug_pin = (
    graph_id: string,
    type: IO,
    pinId: string,
    subPinId: string,
    subPinSpec: GraphSubPinSpec
  ) => {
    return this._spec_graph_unit__template(plugPin, graph_id, {
      type,
      pinId,
      subPinId,
      subPinSpec,
    })
  }

  private _spec_graph_unit_expose_pin = (
    graph_id: string,
    type: IO,
    pinId: string,
    subPinId: string,
    subPinSpec: GraphSubPinSpec
  ) => {
    return this._spec_graph_unit__template(exposePin, graph_id, {
      type,
      pinId,
      subPinId,
      subPinSpec,
    })
  }

  private _spec_graph_unit_cover_pin_set = (
    graph_id: string,
    type: IO,
    pinId: string
  ) => {
    return this._spec_graph_unit__template(coverPinSet, graph_id, {
      type,
      pinId,
    })
  }

  private _spec_graph_unit_cover_pin = (
    graph_id: string,
    type: IO,
    pinId: string,
    subPinId: string
  ) => {
    return this._spec_graph_unit__template(coverPin, graph_id, {
      type,
      pinId,
      subPinId,
    })
  }

  private _spec_graph_unit_set_unit_pin_constant = (
    graph_id: string,
    unitId: string,
    type: IO,
    pinId: string,
    constant: boolean
  ) => {
    return this._spec_graph_unit__template(setUnitPinConstant, graph_id, {
      unitId,
      type,
      pinId,
      constant,
    })
  }

  private _spec_graph_unit__template = <T>(
    transform: (data: T, graphSpec: GraphSpec) => void,
    graph_id: string,
    data: T
  ) => {
    const { specs, setSpec } = this.$props

    const graph_spec_id = this._get_unit_spec_id(graph_id)
    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    let next_graph_spec = clone(graph_spec)

    transform(data, next_graph_spec)

    setSpec(graph_spec_id, next_graph_spec)
  }

  private _spec_graph_unit_add_sub_pin = (
    graph_id: string,
    type: IO,
    pin_id: string,
    ref: boolean,
    sub_pin_id: string,
    sub_pin_spec: GraphSubPinSpec
  ): void => {
    // console.log(
    //   'Graph',
    //   '_spec_graph_unit_add_sub_pin',
    //   graph_id,
    //   type,
    //   pin_id,
    //   ref,
    //   sub_pin_id,
    //   sub_pin_spec
    // )

    const { setSpec } = this.$props

    const graph_spec_id = this._get_unit_spec_id(graph_id)
    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    let next_graph_spec = clone(graph_spec)

    const pins = graph_spec[`${type}s`] || {}

    const pin = pins[pin_id]

    if (!pin) {
      exposePinSet(
        { pinId: pin_id, type, pinSpec: { plug: {}, ref } },
        next_graph_spec
      )

      setSpec(graph_spec_id, next_graph_spec)
    }

    plugPin(
      { type, pinId: pin_id, subPinId: sub_pin_id, subPinSpec: sub_pin_spec },
      next_graph_spec
    )

    setSpec(graph_spec_id, next_graph_spec)
  }

  private _spec_graph_unit_remove_pin = (
    graphId: string,
    type: IO,
    pinId: string,
    mergeId: string | null
  ) => {
    // console.log('Graph', '_spec_graph_unit_remove_pin', graphId, type, mergeId)

    const { setSpec } = this.$props

    const graph_spec_id = this._get_unit_spec_id(graphId)
    const graph_spec = this._get_unit_spec(graphId) as GraphSpec

    const next_graph_spec = clone(graph_spec)

    const pin_plug = findUnitPinPlug(this._spec, graphId, type, pinId)

    if (pin_plug) {
      this._spec_unplug_sub_pin(type, pin_plug.pinId, pin_plug.subPinId)
    }

    coverPinSet({ pinId, type }, next_graph_spec)

    if (mergeId) {
      const pin_node_id = getPinNodeId(graphId, type, pinId)

      this._spec_remove_pin_or_merge(pin_node_id)
    }

    deepDelete(this._spec, ['units', graphId, type, pinId])

    setSpec(graph_spec_id, next_graph_spec)
  }

  private _spec_graph_unit_remove_pin_or_merge = (
    graph_id: string,
    mergeId: string,
    unitId: string,
    type: IO,
    pinId: string
  ) => {
    const { setSpec } = this.$props

    const graph_spec_id = this._get_unit_spec_id(graph_id)
    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    const next_graph_spec = clone(graph_spec)

    removePinFromMerge({ mergeId, unitId, type, pinId }, next_graph_spec)

    setSpec(graph_spec_id, next_graph_spec)
  }

  private _spec_graph_unit_get_sub_pin_spec = (
    graph_id: string,
    type: IO,
    pinId: string,
    subPinId: string
  ): GraphSubPinSpec => {
    const spec = this._get_unit_spec(graph_id) as GraphSpec

    return getSubPinSpec(spec, type, pinId, subPinId)
  }

  private _spec_graph_unit_add_merge = (
    graph_id: string,
    mergeId: string,
    merge: GraphMergeSpec
  ) => {
    // console.log('Graph', '_spec_graph_unit_add_merge', graph_id, mergeId, merge)

    const { setSpec } = this.$props

    const graph_spec_id = this._get_unit_spec_id(graph_id)
    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    let next_graph_spec = clone(graph_spec)

    addMerge({ mergeId, mergeSpec: merge }, next_graph_spec)

    setSpec(graph_spec_id, next_graph_spec)
  }

  private _spec_graph_unit_remove_merge = (
    graph_id: string,
    mergeId: string
  ) => {
    // console.log('Graph', '_spec_graph_unit_remove_merge', graph_id, mergeId, merge)

    const { setSpec } = this.$props

    const graph_spec_id = this._get_unit_spec_id(graph_id)
    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    let next_graph_spec = clone(graph_spec)

    removeMerge({ mergeId }, next_graph_spec)

    setSpec(graph_spec_id, next_graph_spec)
  }

  private _spec_graph_unit_remove_unit = (graph_id, unitId: string) => {
    const { setSpec } = this.$props

    const graph_spec_id = this._get_unit_spec_id(graph_id)
    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    let next_graph_spec = clone(graph_spec)

    removeUnit({ unitId }, next_graph_spec)

    setSpec(graph_spec_id, next_graph_spec)
  }

  private _spec_graph_unit_add_pin_to_merge = (
    graph_id: string,
    mergeId: string,
    unitId: string,
    type: IO,
    pinId: string
  ) => {
    // console.log(
    //   'Graph',
    //   '_spec_graph_unit_add_pin_to_merge',
    //   graph_id,
    //   mergeId,
    //   unitId,
    //   type,
    //   pin_id
    // )

    const { setSpec } = this.$props

    const graph_spec_id = this._get_unit_spec_id(graph_id)
    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    let next_graph_spec = clone(graph_spec)

    addPinToMerge({ mergeId, unitId, type, pinId }, next_graph_spec)

    setSpec(graph_spec_id, next_graph_spec)
  }

  private _spec_graph_unit_has_merge = (
    graph_unit_id: string,
    merge_id: string
  ): boolean => {
    const spec = this._get_unit_spec(graph_unit_id) as GraphSpec

    return hasMerge(spec, merge_id)
  }

  private _spec_graph_unit_has_merge_pin = (
    graph_unit_id: string,
    merge_id: string,
    unit_id: string,
    type: IO,
    pin_id: string
  ) => {
    const spec = this._get_unit_spec(graph_unit_id) as GraphSpec

    return hasMergePin(spec, merge_id, unit_id, type, pin_id)
  }

  private _spec_graph_unit_has_plug = (
    graph_unit_id: string,
    type: IO,
    pin_id: string,
    sub_pin_id: string
  ) => {
    const spec = this._get_unit_spec(graph_unit_id) as GraphSpec

    return hasPlug(spec, type, pin_id, sub_pin_id)
  }

  private _spec_graph_unit_get_pin_plug_count = (
    graph_unit_id: string,
    type: IO,
    pin_id: string
  ) => {
    const spec = this._get_unit_spec(graph_unit_id) as GraphSpec

    return getPlugCount(spec, type, pin_id)
  }

  private _spec_get_pin_plug_count = (type: IO, pin_id: string): number => {
    return getPlugCount(this._spec, type, pin_id)
  }

  private _spec_graph_unit_is_unit_pin_constant = (
    graph_unit_id: string,
    unit_id: string,
    type: IO,
    pin_id: string
  ): boolean => {
    const spec = this._get_unit_spec(graph_unit_id) as GraphSpec

    return isUnitPinConstant(spec, unit_id, type, pin_id)
  }

  private _spec_graph_unit_has_unit = (
    graph_unit_id: string,
    unit_id: string
  ): boolean => {
    const spec = this._get_unit_spec(graph_unit_id) as GraphSpec

    return hasUnit(spec, unit_id)
  }

  private _state_move_link_pin_into_graph = (
    graph_id: string,
    unit_id: string,
    type: IO,
    pin_id: string,
    merge_id: string | null,
    opposite_pin_id: string | null,
    plug_spec: GraphPlugOuterSpec | null
  ): void => {
    // console.log(
    //   'Graph',
    //   '_state_move_link_pin_into_graph',
    //   graph_id,
    //   unit_id,
    //   type,
    //   pin_id,
    //   merge_id,
    //   opposite_pin_id
    // )

    this._graph_spec_move_link_pin_into_graph__inject(
      graph_id,
      unit_id,
      type,
      pin_id,
      opposite_pin_id
    )

    this._spec_move_link_pin_into_graph(
      graph_id,
      unit_id,
      type,
      pin_id,
      opposite_pin_id,
      merge_id
    )

    this._sim_move_link_pin_into_graph(
      graph_id,
      unit_id,
      type,
      pin_id,
      opposite_pin_id,
      merge_id,
      plug_spec
    )

    this._graph_spec_move_link_pin_into_graph__remove(
      graph_id,
      unit_id,
      type,
      pin_id,
      opposite_pin_id
    )
  }

  private _sim_graph_add_link_pin = (
    graph_id: string,
    type: IO,
    pin_id: string,
    pin_spec: GraphPinSpec
  ) => {
    const graph = this._ensure_subgraph(graph_id)

    graph.add_exposed_pin_set(type, pin_id, pin_spec, undefined)
  }

  private _sim_move_link_pin_into_graph = (
    graph_id: string,
    unit_id: string,
    type: IO,
    pin_id: string,
    opposite_pin_id: string | null,
    merge_id: string | null,
    plug_spec: GraphPlugOuterSpec | null
  ): void => {
    // console.log(
    //   'Graph',
    //   '_sim_move_link_pin_into_graph',
    //   graph_id,
    //   unit_id,
    //   type,
    //   pin_id,
    //   opposite_pin_id,
    //   merge_id
    // )

    const pin_node_id = getPinNodeId(unit_id, type, pin_id)

    const ref = this._is_link_pin_ref(pin_node_id)

    if (graph_id === unit_id) {
      const int_node_id = this._pin_to_int[type][pin_node_id]

      this._sim_graph_unit_remove_pin(pin_node_id)
    } else {
      const datum_node_id = this._pin_to_datum[pin_node_id]

      if (datum_node_id) {
        if (this._collapse_node_id.has(datum_node_id)) {
          this._stop_node_long_press_collapse(datum_node_id)

          this._deselect_node(datum_node_id)
        }
      }

      const opposite_type = oppositePinType(type)

      const pin_node = this._node[pin_node_id]
      const graph_node = this._node[graph_id]

      const { x: pin_x, y: pin_y, r: pin_r } = pin_node
      const { x: graph_x, y: graph_y, r: graph_r } = graph_node

      const u = unitVector(graph_x, graph_y, pin_x, pin_y)
      const position = pointInNode(graph_node, u, PIN_RADIUS)
      const medium_point = mediumPoint(position, pin_node)

      if (opposite_pin_id && merge_id) {
        const merge_node_id = getMergeNodeId(merge_id)

        const merge_anchor_node_id =
          this._get_merge_anchor_node_id(merge_node_id)

        this._sim_graph_unit_expose_pin_set(
          graph_id,
          opposite_type,
          opposite_pin_id,
          position
        )

        if (this._has_node(merge_anchor_node_id)) {
          this._stop_node_long_press_collapse(merge_anchor_node_id)

          const opposite_pin_node_id = getPinNodeId(
            graph_id,
            opposite_type,
            opposite_pin_id
          )

          this._sim_add_link_pin_to_merge(opposite_pin_node_id, merge_node_id)
        } else {
          const merge = {
            [unit_id]: {
              [type]: {
                [pin_id]: true,
              },
            },
            [graph_id]: {
              [opposite_type]: {
                [opposite_pin_id]: true,
              },
            },
          }

          this._stop_node_long_press_collapse(pin_node_id)

          this._sim_add_merge(merge_id, merge, medium_point)
          this._sim_collapse_merge(merge_id)

          const datum_tree = this._pin_datum_tree[pin_node_id]

          if (datum_tree) {
            const new_datum_id = this._new_datum_id()

            const value = datum_tree.value
            const position = this._has_node(datum_node_id)
              ? this._get_node_position(datum_node_id)
              : this._predict_pin_datum_initial_position(pin_node_id)

            const tree = getTree(value)

            this._sim_add_pin_datum_tree(
              graph_id,
              opposite_type,
              opposite_pin_id,
              new_datum_id,
              tree,
              position,
              false
            )
          }
        }
      } else {
        this._stop_node_long_press_collapse(pin_node_id)
      }
    }
  }

  private _spec_move_link_pin_into_graph = (
    graph_id: string,
    unit_id: string,
    type: IO,
    pin_id: string,
    opposite_pin_id: string | null,
    merge_id: string | null
  ): void => {
    // console.log(
    //   'Graph',
    //   '_spec_move_link_pin_into_graph',
    //   graph_id,
    //   unit_id,
    //   type,
    //   pin_id,
    //   opposite_pin_id,
    //   merge_id
    // )

    if (graph_id === unit_id) {
      //
    } else {
      if (merge_id && opposite_pin_id) {
        if (this.__spec_has_merge(merge_id)) {
          this._spec_add_link_pin_to_merge(merge_id, unit_id, type, pin_id)
        } else {
          const opposite_type = oppositePinType(type)

          const merge: GraphMergeSpec = {
            [unit_id]: {
              [type]: {
                [pin_id]: true,
              },
            },
            [graph_id]: {
              [opposite_type]: {
                [opposite_pin_id]: true,
              },
            },
          }

          this._spec_add_merge(merge_id, merge)
        }
      }
    }
  }

  private _graph_spec_move_link_pin_into_graph__inject = (
    graph_id: string,
    unit_id: string,
    type: IO,
    pin_id: string,
    opposite_pin_id: string | null
  ): void => {
    // console.log(
    //   'Graph',
    //   '_graph_spec_move_link_pin_into_graph__inject',
    //   graph_id,
    //   unit_id,
    //   type,
    //   pin_id,
    //   opposite_pin_id
    // )

    const { setSpec } = this.$props

    const pin_node_id = getPinNodeId(unit_id, type, pin_id)

    const ref = this._is_link_pin_ref(pin_node_id)

    const graph_spec_id = this._get_unit_spec_id(graph_id)
    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    if (graph_id === unit_id) {
      //
    } else {
      if (opposite_pin_id) {
        const updated_graph_spec = clone(graph_spec)

        const opposite_type = oppositePinType(type)

        exposePinSet(
          {
            pinId: opposite_pin_id,
            type: opposite_type,
            pinSpec: { plug: { '0': {} }, ref },
          },
          updated_graph_spec
        )

        setSpec(graph_spec_id, updated_graph_spec)
      }
    }
  }

  private _graph_spec_move_link_pin_into_graph__remove = (
    graph_id: string,
    unit_id: string,
    type: IO,
    pinId: string,
    opposite_pin_id: string | null
  ): void => {
    // console.log(
    //   'Graph',
    //   '_graph_spec_move_link_pin_into_graph__remove',
    //   graph_id,
    //   unit_id,
    //   type,
    //   pin_id,
    //   opposite_pin_id
    // )

    const { setSpec } = this.$props

    const pin_node_id = getPinNodeId(unit_id, type, pinId)

    const graph_spec_id = this._get_unit_spec_id(graph_id)
    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    if (graph_id === unit_id) {
      const updated_graph_spec = clone(graph_spec)

      coverPinSet(
        {
          pinId,
          type,
        },
        updated_graph_spec
      )

      deepDelete(this._spec, ['units', graph_id, type, pinId])

      setSpec(graph_spec_id, updated_graph_spec)
    } else {
      //
    }
  }

  private _move_merge_into_graph = (
    graph_id: string,
    merge_id: string,
    next_merge_id: string,
    next_merge: GraphMergesSpec
  ): void => {
    // console.log('Graph', '_move_merge_into_graph', graph_id, merge_id)

    this._state_move_merge_into_sub_graph(
      graph_id,
      merge_id,
      next_merge_id,
      next_merge
    )
    this._state_move_merge_into_graph(
      graph_id,
      merge_id,
      next_merge_id,
      {},
      {},
      {}
    )
    // this._pod_move_merge_into_graph(graph_id, merge_id, next_merge_id)
  }

  private _state_move_merge_into_sub_graph = (
    graph_id: string,
    merge_id: string,
    next_merge_id: string,
    next_merge: GraphMergeSpec
  ) => {
    // console.log('Graph', '_state_move_merge_into_sub_graph', graph_id, merge_id)

    const { setSpec } = this.$props

    const graph_spec_id = this._get_unit_spec_id(graph_id)
    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    if (next_merge) {
      const next_spec = clone(graph_spec)

      addMerge({ mergeId: next_merge_id, mergeSpec: next_merge }, next_spec)

      setSpec(graph_spec_id, next_spec)
    }
  }

  private _state_move_merge_into_graph = (
    graph_id: string,
    merge_id: string,
    next_merge_id: string,
    next_merge: GraphMergesSpec,
    next_unit_pin_id_map: GraphMoveSubGraphData['nextPinIdMap'],
    next_pin_id_map
  ): void => {
    // console.log(
    //   'Graph',
    //   '_state_move_merge_into_graph',
    //   graph_id,
    //   merge_id,
    //   next_merge_id,
    //   next_unit_pin_id_map,
    //   next_pin_id_map
    // )

    const merge_spec = this._collapse_init_spec.merges[merge_id]

    const pin_specs = {
      input: this._collapse_init_spec.inputs ?? {},
      output: this._collapse_init_spec.outputs ?? {},
    }

    const ignored_unit_set = new Set(this._collapse_next_map.nodeIds.unit)

    const merge_node_id = getMergeNodeId(merge_id)

    const merge_is_ref = this._is_merge_ref(merge_node_id)
    const merge_datum_node_id = this._get_merge_datum_node_id(merge_node_id)

    const data =
      merge_datum_node_id && this._get_datum_value(merge_datum_node_id)

    moveMerge(
      this._state_make_this_graph_interface(),
      this._state_get_subgraph_graph_interface(graph_id),
      graph_id,
      merge_id,
      merge_spec,
      merge_is_ref,
      data,
      this._collapse_next_map,
      {},
      ignored_unit_set,
      pin_specs,
      false
    )
  }

  private _set_long_press_pointer = (
    pointerId: number,
    x: number,
    y: number
  ): void => {
    this._long_press_screen_position = { x, y }
    this._long_press_pointer.add(pointerId)
    this._long_press_count++
  }

  private _on_long_press = (event: UnitPointerEvent): void => {
    // console.log('Graph', '_on_long_press')

    const { pointerId, clientX, clientY, screenX, screenY } = event

    if (this._cancel_long_press) {
      this._cancel_long_press = false
      return
    }

    if (this._multiselect_area_ing) {
      this._on_multiselect_area_end()
    }

    this._set_long_press_pointer(pointerId, clientX, clientY)

    if (this._is_background_pointer(pointerId)) {
      this._on_background_long_press(event)
    }
  }

  private _long_click_cancel_pointer_id = new Set<number>()

  private _on_long_click_cancel = (event): void => {
    // console.log('Graph', '_on_long_click_cancel')

    const { pointerId } = event

    const hovered_pointer_id = this._pointer_id_hover_node_id[pointerId]

    if (hovered_pointer_id) {
      this._long_click_cancel_pointer_id.add(pointerId)
    } else {
      //
    }
  }

  private _cancel_drag_and_drop = () => {
    // console.log('Graph', '_cancel_drag_and_drop')

    if (this._drag_and_drop_cancel) {
      this._drag_and_drop_cancel()
      this._drag_and_drop_cancel = undefined
    }

    this._drag_and_drop = false
    this._drag_and_drop_bundle = null
  }

  private _on_click_hold = (event: UnitPointerEvent): void => {
    // console.log('Graph', '_on_click_hold')

    const { pointerId, screenX, screenY } = event

    if (this._swap_next_click_hold_long_press) {
      this._on_long_press(event)
      return
    }

    if (this._cancel_click_hold) {
      this._cancel_click_hold = false
      return
    }

    if (this._is_background_pointer(pointerId)) {
      this._on_background_click_hold(screenX, screenY, event)
    } else {
      //
    }
  }

  private _stop_gesture = () => {
    // console.log('Graph', '_stop_gesture')

    this._capturing_gesture = false

    this._unlisten_gesture()
    this._unlisten_gesture = undefined
  }

  private _animating_unit_explosion: Dict<Promise<any>> = {}

  private _on_graph_background_multiselect_long_press = (
    event: UnitPointerEvent
  ) => {
    // console.log('Editor', '_on_graph_background_multiselect_long_press')

    const { clientX, clientY, pointerId } = event

    if (this._pointer_down_count === 1 || this._capturing_gesture) {
      const selected_node_ids = keys(this._selected_node_id)

      if (this._capturing_gesture) {
        this._stop_gesture()
      }

      const valid_selected_node_ids = selected_node_ids.filter((node_id) => {
        if (this._animating_unit_explosion[node_id]) {
          return false
        }

        return true
      })

      this._start_long_press_collapse(
        pointerId,
        null,
        valid_selected_node_ids,
        {
          x: clientX,
          y: clientY,
        }
      )
    } else {
      //
    }
  }

  private _on_layout_background_long_press = (event: UnitPointerEvent) => {
    // console.log('Graph', '_on_layout_background_long_press')

    if (this._mode === 'multiselect') {
      const parent_id = this._get_current_layout_layer_id()
      const slot_name = 'default'
      const next_parent_id = this._spec_get_sub_component_parent_id(parent_id)
      const next_slot_name = 'default'

      const children = this._spec_get_sub_component_children(parent_id)

      const selected_children = children.filter(this._is_node_selected)

      if (parent_id) {
        if (selected_children) {
          this._remove_sub_component_children(
            parent_id,
            slot_name,
            next_parent_id,
            next_slot_name,
            selected_children
          )

          this._refresh_layout_node_target_position(parent_id)
          this._move_all_current_layout_node_target_position()
        }
      }
    }
  }

  private _on_graph_background_long_press = (event: UnitPointerEvent) => {
    const { specs } = this.$props

    const { pointerId, clientX, clientY, screenX, screenY } = event

    if (this._mode === 'multiselect') {
      this._on_graph_background_multiselect_long_press(event)
    } else if (this._mode === 'info') {
      //
    } else if (
      this._mode === 'add' ||
      this._mode === 'change' ||
      this._mode === 'remove' ||
      this._mode === 'data'
    ) {
      if (!this._capturing_gesture && this._search_hidden) {
        // const all_selected_node_ids = this._get_all_selected_node_ids()
        // const all_node_ids = keys(this._node)
        // if (all_selected_node_ids.length > 0) {
        //   this._start_long_press_collapse(
        //     pointerId,
        //     null,
        //     all_selected_node_ids,
        //     { x: clientX, y: clientY }
        //   )
        // } else {
        //   // const screen_center = this._screen_center()
        //   this._start_long_press_collapse(
        //     pointerId,
        //     null,
        //     all_node_ids,
        //     // screen_center,
        //     { x: clientX, y: clientY }
        //   )
        // }
      }
    }
  }

  private _on_background_long_press = (event: UnitPointerEvent): void => {
    // console.log('Graph', '_on_background_long_press')

    const { pointerId, screenX, screenY } = event

    this._long_press_background_pointer.add(pointerId)
    this._long_press_background_count++

    this._animate_pulse(screenX, screenY, 'in')

    if (this._tree_layout) {
      this._on_layout_background_long_press(event)
    } else {
      this._on_graph_background_long_press(event)
    }
  }

  private _animate_pulse = (
    screenX: number,
    screenY: number,
    direction: 'in' | 'out'
  ): void => {
    // console.log('Graph', '_animate_pulse', screenX, screenY, direction)

    const { showLongPress } = this.$system

    const { $theme } = this.$context

    const color = this._get_color()

    const stroke = getThemeModeColor($theme, this._mode, color)

    showLongPress(screenX, screenY, { stroke, direction })
  }

  private _unlisten_gesture: Unlisten

  private _start_gesture = (event: UnitPointerEvent): void => {
    // console.log('Graph', '_start_gesture')

    if (!this._capturing_gesture) {
      const { captureGesture } = this.$system

      const { $theme } = this.$context

      this._capturing_gesture = true

      const color = this._get_color()
      const strokeStyle = getThemeModeColor($theme, this._mode, color)
      const lineWidth = 4

      const unlisten = captureGesture(
        event,
        { strokeStyle, lineWidth },
        this._on_capture_gesture_end
      )

      this._unlisten_gesture = unlisten
    }
  }

  private _on_backspace_keydown = () => {
    // console.log('Graph', '_on_backspace_keydown')

    if (!this._edit_datum_id && !this._edit_node_name_id) {
      const all_selected_node_ids = keys(this._selected_node_id)

      this._remove_nodes(all_selected_node_ids)
    }
  }

  private _clear_debugger = (): void => {
    this._debug_buffer = []
    this._debug_cursor = -1
  }

  private _remove_selected_nodes = (): void => {
    if (this._selected_node_count > 0) {
      const selected_node_list = _keys({ obj: this._selected_node_id }).keys
      this._remove_nodes(selected_node_list)
    }
  }

  private _on_alt_keyup() {
    // console.log('Graph', '_on_alt_keyup')

    if (this._unlisten_gesture && !this._capturing_gesture) {
      this._stop_gesture()
    }
  }

  private _on_alt_keydown() {
    //
  }

  private _on_backtick_keyup() {
    const { animate } = this._config()

    this._enter_all_fullwindow(animate)
  }

  private _on_ctrl_semicolon_keydown = () => {
    // console.log('Graph', '_on_ctrl_semicolon_keydown')

    if (this._focused) {
      if (this._search_hidden) {
        if (this._mode === 'none' || this._mode === 'add') {
          //
        } else if (this._mode === 'change') {
          if (this._selected_node_count === 0) {
            //
          } else if (this._selected_node_count === 1) {
            const selected_node_id = getObjSingleKey(this._selected_node_id)

            if (this._is_unit_node_id(selected_node_id)) {
              this._on_unit_blue_click(selected_node_id)

              return
            } else {
              //
            }
          } else {
            //
          }
        }

        this._show_search()
      } else {
        this._hide_search()
      }
    }
  }

  private _last_save_file_handle: FileSystemFileHandle
  private _last_save_filename: string

  public getUnitBundle = (): UnitBundleSpec => {
    const bundle = this.getBundle()

    const unit_bundle = {
      unit: {
        id: this._spec.id,
      },
      specs: { ...bundle.specs, [this._spec.id]: this._spec },
    }

    return unit_bundle
  }

  private _set_spec_node_positions = (
    spec: GraphSpec,
    editor: Editor_,
    node_positions: Dict<Position>
  ) => {
    for (const node_id in node_positions) {
      const node_position = node_positions[node_id]

      const round_node_position = roundPoint(node_position)

      if (isUnitNodeId(node_id)) {
        deepSet(
          spec,
          ['units', node_id, 'metadata', 'position'],
          round_node_position
        )
      } else if (isLinkPinNodeId(node_id)) {
        const { unitId, type, pinId } = segmentLinkPinNodeId(node_id)

        deepSet(
          spec,
          ['units', unitId, type, pinId, 'metadata', 'position'],
          round_node_position
        )
      } else if (isMergeNodeId(node_id)) {
        const { mergeId } = segmentMergeNodeId(node_id)

        deepSet(
          spec,
          ['metadata', 'position', 'merge', mergeId],
          round_node_position
        )
      } else if (isExternalNodeId(node_id)) {
        const { type, pinId, subPinId } = segmentPlugNodeId(node_id)

        deepSet(
          spec,
          [`${type}s`, pinId, 'metadata', 'position', subPinId, 'ext'],
          round_node_position
        )
      } else if (isInternalNodeId(node_id)) {
        const { type, pinId, subPinId } = segmentPlugNodeId(node_id)

        deepSet(
          spec,
          [
            `${type}s`,
            pinId,
            'plug',
            subPinId,
            'metadata',
            'position',
            subPinId,
            'int',
          ],
          round_node_position
        )
      } else if (isDatumNodeId(node_id)) {
        const { datumId } = segmentDatumNodeId(node_id)

        const unit_pin = editor.getDatumPin(datumId)

        if (unit_pin) {
          const { unitId, type, pinId } = unit_pin

          if (isUnitPinConstant(spec, unitId, type, pinId)) {
            deepSet(
              spec,
              ['units', unitId, type, pinId, 'metadata', 'data', 'position'],
              round_node_position
            )
          }
        } else {
          deepSet(spec, ['metadata', 'position', 'data'], round_node_position)
        }
      }
    }
  }

  public getBundle(): BundleSpec {
    const { specs } = this.$props

    const spec = this._get_full_user_spec()

    const bundle = bundleSpec(spec, specs)

    this._set_spec_node_positions_rec(this, bundle.spec, specs)

    return bundle
  }

  private _set_spec_node_positions_rec = (
    editor: Editor_,
    spec: GraphSpec,
    specs: Specs
  ) => {
    const processSubGraph = (editor: Editor_, spec: GraphSpec) => {
      if (!isSystemSpec(spec)) {
        let node_positions = editor.get_node_relative_positions()

        this._set_spec_node_positions(spec, editor, node_positions)

        for (const unitId in spec.units) {
          const subgraph = editor._subgraph_cache[unitId]

          const unit = spec.units[unitId]

          if (!unit.id) {
            delete spec.units[unitId]

            continue
          }

          if (subgraph) {
            const unit_spec = editor._get_unit_spec(unitId) as GraphSpec

            processSubGraph(subgraph, unit_spec)
          }
        }
      }
    }

    processSubGraph(editor, spec)
  }

  public set_spec_node_positions_rec = (
    editor: Editor_,
    spec: GraphSpec,
    specs: Specs
  ) => {
    this._set_spec_node_positions_rec(editor, spec, specs)
  }

  public save = async (force_dialog: boolean = false) => {
    const { specs } = this.$props

    const {
      api: {
        file: {
          isSaveFilePickerSupported,
          showSaveFilePicker,
          downloadText: downloadData,
        },
      },
    } = this.$system

    const { name } = this._spec

    const bundle = this.getBundle()

    if (isSaveFilePickerSupported()) {
      const options = {
        suggestedName:
          this._last_save_filename ??
          this._last_open_filename ??
          `${name}.unit`,
        startIn: 'desktop',
        excludeAcceptAllOption: false,
        id: 'unit',
        types: [
          {
            description: 'unit',
            accept: {
              'application/unit': ['.unit'],
            },
          },
        ],
      }

      let handle: FileSystemFileHandle

      try {
        handle = await showSaveFilePicker(options)
      } catch (err) {
        // console.log('err', err)

        return
      }

      this._last_save_file_handle = handle
      this._last_save_filename = handle.name

      const name_ = handle.name.slice(0, -5)

      deepSet(bundle, ['spec', 'name'], name_)

      if (bundle.spec.render) {
        const { width, height } = this.get_max_component_graph_size_size()

        deepSet(bundle, ['spec', 'component', 'defaultWidth'], width)
        deepSet(bundle, ['spec', 'component', 'defaultHeight'], height)
      }

      await this._save_silently(bundle)
    } else {
      downloadData({
        name: `${name}.unit`,
        text: JSON.stringify(bundle, null, 2),
        mimetype: 'text/json',
        charset: 'utf-8',
      })
    }
  }

  private _save_silently = async (bundle: BundleSpec) => {
    const {
      api: {
        window: { CompressionStream },
      },
    } = this.$system

    if (this._last_save_file_handle) {
      const writableStream = await this._last_save_file_handle.createWritable()

      await saveToUnitFile(this.$system, this._last_save_file_handle, bundle)
    } else {
      throw new Error('cannot save silently without previous file handler')
    }
  }

  private _on_ctrl_s_keydown = () => {
    // console.log('Graph', '_on_ctrl_s_keydown')

    this.save()
  }

  private _on_ctrl_shift_s_keydown = () => {
    // console.log('Graph', '_on_ctrl_shift_s_keydown')

    this.save(true)
  }

  private _on_ctrl_o_keydown = () => {
    // console.log('Graph', '_on_ctrl_o_keydown')

    this._open_file()
  }

  private _on_ctrl_r_keydown = () => {
    // console.log('Graph', '_on_ctrl_r_keydown')

    this._reload()
  }

  private _reload = () => {
    if (this._selected_node_count) {
      const unit_ids = keys(this._selected_node_id).filter(
        this._is_unit_node_id
      )

      for (const unitId of unit_ids) {
        const $unit = this._pod.$refUnit({ unitId, _: ['U'], detached: true })

        $unit.$reset({})
      }
    } else {
      this._pod.$reset({})
    }
  }

  private _decant_node_ids = (
    node_ids: string[]
  ): {
    unit_ids: string[]
    merge_node_ids: string[]
    link_pin_node_ids: string[]
    exposed_node_ids: string[]
    datum_node_ids: string[]
    err_node_ids: string[]
  } => {
    const unit_ids: string[] = []
    const merge_node_ids: string[] = []
    const link_pin_node_ids: string[] = []
    const exposed_node_ids: string[] = []
    const datum_node_ids: string[] = []
    const err_node_ids: string[] = []

    for (const node_id of node_ids) {
      this._node_type__template(node_id, {
        unit: () => unit_ids.push(node_id),
        merge: () => merge_node_ids.push(node_id),
        link: () => link_pin_node_ids.push(node_id),
        plug: () => exposed_node_ids.push(node_id),
        datum: () => datum_node_ids.push(node_id),
        err: () => err_node_ids.push(node_id),
      })
    }

    return {
      unit_ids,
      merge_node_ids,
      link_pin_node_ids,
      exposed_node_ids,
      datum_node_ids,
      err_node_ids,
    }
  }

  public _sub_graph_selection = (
    node_ids: string[],
    deep: boolean
  ): BundleSpec => {
    const { specs, newSpec, newSpecId } = this.$props

    const { classes } = this.$system

    const id = newSpecId()

    const graph: GraphSpec = emptySpec({ id })

    const units: GraphUnitsSpec = {}
    const merges: GraphMergesSpec = {}
    const inputs: GraphPinsSpec = {}
    const outputs: GraphPinsSpec = {}
    const component: GraphComponentSpec = {}
    const data: GraphDataSpec = {}

    const pins = {
      input: inputs,
      output: outputs,
    }

    const {
      unit_ids,
      merge_node_ids,
      link_pin_node_ids,
      exposed_node_ids,
      datum_node_ids,
    } = this._decant_node_ids(node_ids)

    const _ref_unit_merge_count: Dict<number> = {}

    for (const unit_id of unit_ids) {
      const unit = clone(this._get_unit(unit_id))

      delete unit.memory

      units[unit_id] = unit

      const unit_merges = this._get_unit_merges(unit_id)

      for (const unit_merge_id in unit_merges) {
        const unit_merge_node_id = getMergeNodeId(unit_merge_id)

        if (this._merge_ref[unit_merge_node_id]) {
          _ref_unit_merge_count[unit_merge_node_id] =
            _ref_unit_merge_count[unit_merge_node_id] ?? 0
          _ref_unit_merge_count[unit_merge_node_id] += 1

          if (_ref_unit_merge_count[unit_merge_node_id] === 2) {
            merge_node_ids.push(unit_merge_node_id)
          }
        }
      }

      if (this._is_unit_component(unit_id)) {
        component.children = component.children || []
        component.subComponents = component.subComponents || {}
        component.children.push(unit_id)
        // TODO
        // should copy hierarchy too
        component.subComponents[unit_id] = {}
      }
    }

    for (const merge_node_id of merge_node_ids) {
      const { mergeId } = segmentMergeNodeId(merge_node_id)

      const merge = this._spec_get_merge(mergeId)

      let merge_pin_count = 0

      const partial_merge: GraphMergeSpec = {}

      for (const unit_id in merge) {
        if (units[unit_id]) {
          const merge_unit = merge[unit_id]
          const {
            input: merge_unit_input = {},
            output: merge_unit_output = {},
          } = merge_unit
          const merge_unit_pin_count =
            keyCount(merge_unit_input) + keyCount(merge_unit_output)
          merge_pin_count += merge_unit_pin_count
          partial_merge[unit_id] = merge_unit
        }
      }

      if (merge_pin_count > 1) {
        merges[mergeId] = partial_merge
      }
    }

    for (const datum_node_id of datum_node_ids) {
      const datum_pin_node_id = this._datum_to_pin[datum_node_id]
      const datum_plug_node_id = this._datum_to_plug[datum_node_id]

      if (
        (datum_pin_node_id && node_ids.includes(datum_pin_node_id)) ||
        (datum_plug_node_id && node_ids.includes(datum_plug_node_id))
      ) {
        //
      } else {
        const { datumId } = segmentDatumNodeId(datum_node_id)

        const tree = this._datum_tree[datumId]

        const { value } = tree

        data[datumId] = { value }
      }
    }

    const exposed_pin_set: IOOf<Set<string>> = {
      input: new Set(),
      output: new Set(),
    }

    for (const exposed_node_id of exposed_node_ids) {
      const { pinId, type, subPinId } = segmentPlugNodeId(exposed_node_id)

      const sub_pin_spec = clone(
        this._get_exposed_sub_pin_spec(type, pinId, subPinId)
      )

      const { unitId, pinId: _pinId, mergeId } = sub_pin_spec

      if (unitId && pinId) {
        if (!units[unitId]) {
          delete sub_pin_spec.unitId
          delete sub_pin_spec.pinId
        }
      } else if (mergeId) {
        if (!merges[mergeId]) {
          delete sub_pin_spec.mergeId
        }
      }

      exposed_pin_set[type].add(pinId)

      if (type === 'input') {
        deepSet(inputs, [pinId, 'plug', subPinId], sub_pin_spec)
      } else {
        deepSet(outputs, [pinId, 'plug', subPinId], sub_pin_spec)
      }
    }

    io((type) => {
      const pin_set = exposed_pin_set[type]

      for (const pin_id of pin_set) {
        const ref = this._is_pin_ref(type, pin_id)
        const defaultIgnored = this._is_pin_default_ignored(type, pin_id)

        deepSet(pins, [type, pin_id, 'ref'], ref)
        deepSet(pins, [type, pin_id, 'defaultIgnored'], defaultIgnored)
      }
    })

    if (!isEmptyObject(units)) {
      graph.units = units
    }

    if (!isEmptyObject(component)) {
      graph.component = component
    }

    if (!isEmptyObject(merges)) {
      graph.merges = merges
    }

    if (!isEmptyObject(inputs)) {
      graph.inputs = inputs
    }

    if (!isEmptyObject(outputs)) {
      graph.outputs = outputs
    }

    if (!isEmptyObject(data)) {
      graph.data = data
    }

    const bundle = bundleSpec(graph, specs)

    for (const datumId in data) {
      const { value } = data[datumId]

      let dataRef

      try {
        dataRef = evaluateDataValue(value, specs, classes)
      } catch {
        continue
      }

      for (const path of dataRef.ref) {
        let unit_bundle = deepGet(dataRef.data, path) as UnitBundleSpec

        unit_bundle = unitBundleSpec(
          unit_bundle.unit,
          weakMerge(unit_bundle.specs, specs)
        )

        for (const specId in unit_bundle.specs) {
          bundle.specs[specId] = unit_bundle.specs[specId]
        }
      }
    }

    return bundle
  }

  public _copy_nodes = async (
    node_ids: string[],
    deep: boolean,
    callback: Callback<BundleSpec>
  ) => {
    // console.log('Graph', '_copy_nodes', node_ids, deep)

    const {
      api: {
        clipboard: { writeText },
      },
    } = this.$system

    const { specs, newSpec, newSpecId } = this.$props

    const id = newSpecId()

    const bundle = this._sub_graph_selection(node_ids, deep)

    try {
      const json = JSON.stringify(bundle)

      await writeText(json)
    } catch (err) {
      this._show_err(err)
    }
  }

  public _show_err = (err: string): void => {
    // TODO
    // console.error(err)
  }

  public cut_nodes = (node_ids: string[]) => {
    this._copy_nodes(node_ids, false, () => {
      // TODO
    })

    this._remove_nodes(node_ids)
  }

  public cut_single_node = (node_id: string): void => {
    const node_ids = [node_id]

    this.cut_nodes(node_ids)
  }

  public cut_selected_nodes = () => {
    // console.log('Graph', 'cut_selected_nodes')
    const node_ids = keys(this._selected_node_id)
    this.cut_nodes(node_ids)
  }

  public copy_single_node = (node_id: string, deep: boolean): void => {
    const node_ids = [node_id]

    this._copy_nodes(node_ids, deep, () => {
      // TODO
    })
  }

  public copy_selected_nodes = (deep: boolean) => {
    const selected_node_id_clone = clone(this._selected_node_id)

    for (const node_id in this._selected_node_id) {
      if (this._is_unit_node_id(node_id)) {
        const unit_ref_merge_node_id = this._ref_unit_to_merge[node_id]

        if (unit_ref_merge_node_id) {
          // node_ids.push(unit_ref_merge_node_id)
          selected_node_id_clone[unit_ref_merge_node_id] = true
        }
      } else if (this._is_datum_node_id(node_id)) {
        const pin_node_id = this._datum_to_pin[node_id]

        if (pin_node_id && this._selected_node_id[pin_node_id]) {
          delete selected_node_id_clone[node_id]
        }
      }
    }

    const node_ids = keys(selected_node_id_clone)

    this._copy_nodes(node_ids, deep, () => {
      // TODO
    })
  }

  private _validate_graph_spec = (data: any): boolean => {
    return validateGraphSpec(data)
  }

  private _validate_bundle_spec = (data: any): boolean => {
    return validateBundleSpec(data)
  }

  private _validate_text_bundle_spec = (data: any): boolean => {
    if (typeof data !== 'object' || data === null) {
      return false
    }

    if (!data.spec) {
      return false
    }

    return this._validate_bundle_spec(data)
  }

  private _paste_clipboard = async (position: Position) => {
    const {
      api: {
        clipboard: { readText, read },
      },
    } = this.$system

    let text: string

    try {
      const items: ClipboardItems = await read()

      for (const item of items) {
        if (item.types.includes('image/png')) {
          const blob = await item.getType('image/png')

          this._drop_file(blob, position)
        } else if (item.types.includes('text/plain')) {
          const text = await item.getType('text/plain')

          this._drop_file(text, position)

          return
        }
      }
    } catch (err) {
      //
    }

    try {
      text = await readText()
    } catch (err) {
      return
    }

    this._drop_text(text, position)
  }

  private _drop_text = (text: string, position: Position): void => {
    let try_json = (text: string) => {
      let json: BundleSpec | undefined = undefined

      try {
        json = JSON.parse(text) as BundleSpec
      } catch {
        //
      }

      if (json) {
        const valid = this._validate_text_bundle_spec(json)

        if (valid) {
          this.paste_bundle(json, position, true, true, false)
        } else {
          const datum_id = this.add_new_datum(stringify(json), position, true)

          move_datum(datum_id)
        }
      }

      return json
    }

    const move_datum = (datum_id: string) => {
      const datum_node_id = getDatumNodeId(datum_id)

      if (this._selected_node_count === 1) {
        const single_selected_node_id = getObjSingleKey(this._selected_node_id)

        if (this._is_pin_node_id(single_selected_node_id)) {
          if (
            this._is_datum_pin_type_match(
              datum_node_id,
              single_selected_node_id
            )
          ) {
            if (this._is_pin_node_id(single_selected_node_id)) {
              this._move_datum_to_pin(datum_node_id, single_selected_node_id)
            } else {
              //
            }
          }
        }
      }
    }

    if (try_json(text)) {
      //
    } else {
      if (text) {
        let tree: TreeNode

        try {
          tree = getTree__cached(text)
        } catch (err) {
          //
        }

        ;[tree] = _filterEmptyNodes(tree, getTree__cached)

        if (try_json(tree.value)) {
          //
        } else {
          let bundle

          if (tree.type === TreeNodeType.ObjectLiteral) {
            const data = _evaluate(
              tree,
              this.$props.specs,
              this.$system.classes
            )

            if (data) {
              if (validateBundleSpec(data)) {
                bundle = data
              }
            }
          }

          if (bundle) {
            this.paste_bundle(bundle, position, true, true, false)
          } else {
            let datum_id = this._new_datum_id()

            if (tree) {
              const tree = this._escape_external_text_if_needed(text)

              this.__sim_add_datum_node(datum_id, tree, position, true)
            } else {
              datum_id = this._paste_escaped_plain_text(text, position)

              move_datum(datum_id)
            }

            if (datum_id) {
              move_datum(datum_id)
            }
          }
        }
      }
    }
  }

  private _paste_escaped_plain_text = (
    text: string,
    position: Position
  ): string => {
    const text_to_paste = `"${escape(text)}"`

    return this._paste_plain_text(text_to_paste, position)
  }

  private _paste_plain_text = (text: string, position: Position): string => {
    const datum_id = this._new_datum_id()

    this.add_datum(datum_id, text, position, true)

    return datum_id
  }

  public paste_bundle = (
    bundle: BundleSpec,
    position: Position,
    mount: boolean,
    emit: boolean,
    deep: boolean
  ) => {
    // console.log('Graph', 'paste_bundle', bundle, {
    //   position,
    //   mount,
    //   emit,
    //   deep,
    // })

    const { specs, injectSpecs } = this.$props

    const { spec } = bundle

    const all_bundle_specs = { ...bundle.specs, [spec.id]: spec }

    const map_spec_id = injectSpecs(bundle.specs ?? {})

    const all_specs = weakMerge(specs, all_bundle_specs)

    const { map_unit_id, map_merge_id, map_plug_id, map_datum_id } =
      buildGraphRemap(
        spec,
        (id) => getSpec(all_specs, id),
        (spec_id, blacklist) => {
          return newUnitId(all_specs, this._spec, spec_id, blacklist)
        },
        this._new_merge_id,
        this._new_sub_pin_id,
        this._new_datum_id
      )

    const remapped_graph = remapGraph(
      spec,
      map_unit_id,
      map_merge_id,
      map_plug_id,
      map_datum_id
    )

    const { actions } = this._paste_spec(
      remapped_graph,
      position,
      mount,
      emit,
      deep,
      map_unit_id
    )

    return { map_unit_id, map_merge_id, map_plug_id, map_datum_id, actions }
  }

  public _state_paste_spec = (
    graph: GraphSpec,
    position: Position,
    map_unit_id: Dict<string>,
    map_merge_id: Dict<string>,
    map_plug_id: IOOf<Dict<Dict<string>>>,
    map_datum_id: Dict<string>,
    restart_simulation: boolean = true,
    register: boolean = true
  ): void => {
    // console.log('Graph', '_paste_spec', graph)

    const _graph = remapGraph(
      graph,
      map_unit_id,
      map_merge_id,
      map_plug_id,
      map_datum_id
    )

    return this.__state_paste_spec(
      _graph,
      position,
      restart_simulation,
      true,
      register
    )
  }

  public _paste_spec = (
    graph: GraphSpec,
    position: Position,
    mount: boolean,
    emit: boolean,
    deep: boolean,
    map_unit_id: Dict<string>
  ): { actions: Action[] } => {
    // console.log('Graph', '_paste_spec', graph)

    const actions = this._make_paste_spec_bulk_action(graph, deep, map_unit_id)

    this._dispatch_action(makeBulkEditAction(actions))

    this.__state_paste_spec(graph, position, undefined, undefined, mount)
    emit && this.__pod_paste_spec(clone(graph), actions)

    return { actions }
  }

  private _recenter_graph_position = (graph: GraphSpec) => {
    const { classes } = this.$system
    const { specs } = this.$props

    const {
      units = {},
      merges = {},
      inputs = {},
      outputs = {},
      component = {},
      data = {},
      metadata,
    } = graph

    const positions: Position[] = []

    for (const unit_id in units) {
      const unit = units[unit_id]

      const unit_position = deepGetOrDefault(
        graph,
        ['units', unit_id, 'metadata', 'position'],
        undefined
      )

      if (unit_position) {
        positions.push(unit_position)
      }

      const { input = {}, output = {} } = unit

      const processPins = (pins) => {
        for (const pinId in pins) {
          const pin = pins[pinId]

          const pin_position = pin.metadata?.position

          if (pin_position) {
            positions.push(unit_position)
          }
        }
      }

      processPins(input)
      processPins(output)
    }

    for (const merge_id in merges) {
      const merge_position = deepGetOrDefault(
        graph,
        ['metadata', 'position', 'merge', merge_id],
        undefined
      )

      if (merge_position) {
        positions.push(merge_position)
      }
    }

    const type_pins = { input: inputs, output: outputs }

    io((type) => {
      const pins = type_pins[type]

      for (const pin_id in pins) {
        const pin = pins[pin_id]

        const { plug = {} } = pin

        for (const subPinId in plug) {
          const subPin = plug[subPinId]

          const sub_pin_position = deepGetOrDefault(
            pin,
            ['metadata', 'position', subPinId],
            undefined
          ) as GraphPinSpec['metadata']['position'][any]

          if (sub_pin_position) {
            if (sub_pin_position.ext) {
              positions.push(sub_pin_position.ext)
            }
            if (sub_pin_position.int) {
              positions.push(sub_pin_position.int)
            }
          }
        }
      }
    })

    const center = positions.length ? centerOfMass(positions) : NULL_VECTOR

    for (const unit_id in units) {
      const unit = units[unit_id]

      const unit_position = deepGetOrDefault(
        graph,
        ['units', unit_id, 'metadata', 'position'],
        NULL_VECTOR
      )

      const next_unit_position = subtractVector(unit_position, center)

      deepSet(
        graph,
        ['units', unit_id, 'metadata', 'position'],
        next_unit_position
      )

      const { input = {}, output = {} } = unit

      const processPins = (pins) => {
        for (const pinId in pins) {
          const pin = pins[pinId]

          const pin_position = pin.metadata?.position

          if (pin_position) {
            const next_pin_position = subtractVector(pin_position, center)

            deepSet(pin, ['metadata', 'position'], next_pin_position)
          }
        }
      }

      processPins(input)
      processPins(output)
    }

    for (const merge_id in merges) {
      const merge_position = deepGetOrDefault(
        graph,
        ['metadata', 'position', 'merge', merge_id],
        undefined
      )

      if (merge_position) {
        const next_merge_position = subtractVector(merge_position, center)

        deepSet(
          graph,
          ['metadata', 'position', 'merge', merge_id],
          next_merge_position
        )
      }
    }

    io((type) => {
      const pins = type_pins[type]

      for (const pin_id in pins) {
        const pin = pins[pin_id]

        const { plug = {} } = pin

        for (const subPinId in plug) {
          const subPin = plug[subPinId]

          const sub_pin_position = deepGetOrDefault(
            pin,
            ['metadata', 'position', subPinId],
            undefined
          ) as GraphPinSpec['metadata']['position'][any]

          if (sub_pin_position) {
            if (sub_pin_position.ext) {
              const new_ext_position = subtractVector(
                sub_pin_position.ext,
                center
              )

              deepSet(
                pin,
                ['metadata', 'position', subPinId, 'ext'],
                new_ext_position
              )
            }
            if (sub_pin_position.int) {
              const new_int_position = subtractVector(
                sub_pin_position.int,
                center
              )

              deepSet(
                pin,
                ['metadata', 'position', subPinId, 'int'],
                new_int_position
              )
            }
          }
        }
      }
    })
  }

  public __state_paste_spec = (
    graph: GraphSpec,
    position: Position,
    restart_simulation: boolean = true,
    register: boolean = true,
    mount: boolean
  ): void => {
    // console.log('Graph', '__state_paste_spec', graph)

    this._simulation_prevent_restart = true

    this._recenter_graph_position(graph)

    const { classes } = this.$system
    const { specs } = this.$props

    const {
      units = {},
      merges = {},
      inputs = {},
      outputs = {},
      component = {},
      data = {},
      metadata,
    } = graph

    const start_node_count = this._node_count

    for (const unit_id in units) {
      const unit = units[unit_id]

      const unit_position = deepGetOrDefault(
        graph,
        ['units', unit_id, 'metadata', 'position'],
        NULL_VECTOR
      )

      const p = addVector(position, unit_position)

      this._spec_add_unit(unit_id, unit, register)
      this._sim_add_unit_core(unit_id, unit, p)
    }

    for (const merge_id in merges) {
      const merge = clone(merges[merge_id])

      const merge_pin_count = getMergePinCount(merge)

      const merge_position =
        merge_pin_count > 0
          ? this._init_merge_spec_position(merge)
          : this._jiggle_world_screen_center()

      if (merge_pin_count === 0 || merge_pin_count > 1) {
        this._state_add_merge(merge_id, merge, merge_position)
      }
    }

    for (const unit_id in units) {
      const unit = units[unit_id]

      const {
        input,
        output,
        memory = { input: {}, output: {}, memory: {} },
      } = unit

      const unit_position = this._get_node_position(unit_id)

      const unit_pin_position = this._get_spec_init_unit_pin_position(
        graph,
        unit_id,
        position
      )

      this._sim_add_unit_pins(unit_id, unit, unit_pin_position, position)

      const register_memory_pin = (
        type: IO,
        pin_id: string,
        pin_memory_spec
      ) => {
        const { _register } = pin_memory_spec

        if (_register) {
          const tree = getTree__cached(_register)

          const pin_node_id = getPinNodeId(unit_id, type, pin_id)

          const datum_node_id = this._pin_to_datum[pin_node_id]

          if (datum_node_id) {
            const { datumId } = segmentDatumNodeId(datum_node_id)

            this._set_datum(datumId, tree)
          } else {
            const datum_id = this._new_datum_id()

            this._sim_add_pin_datum(unit_id, type, pin_id, datum_id, _register)
          }
        }
      }

      forEachObjKV(memory.input, register_memory_pin.bind(this, 'input'))
      forEachObjKV(memory.output, register_memory_pin.bind(this, 'output'))
    }

    for (const merge_id in merges) {
      this._sim_collapse_merge(merge_id)
    }

    const type_pins = { input: inputs, output: outputs }

    io((type) => {
      const pins = type_pins[type]

      for (const pin_id in pins) {
        const pin = pins[pin_id]

        const { plug = {} } = pin

        if (this._spec_has_pin_named(type, pin_id)) {
          const data = this._unit_datum[type][pin_id]

          for (const sub_pin_id in plug) {
            const sub_pin_spec = plug[sub_pin_id]

            const pin_node_id = this._get_exposed_pin_spec_internal_node_id(
              type,
              sub_pin_spec
            )

            const plug_position = {
              int: position,
              ext: position,
            }

            this._state_add_exposed_pin(
              type,
              pin_id,
              sub_pin_id,
              sub_pin_spec,
              plug_position
            )

            if (data) {
              this._sim_add_plug_datum(type, pin_id, sub_pin_id, data)

              const ext_node_id = getExtNodeId(type, pin_id, sub_pin_id)

              this._refresh_node_color(ext_node_id)
            }
          }
        } else {
          const plug_positions = mapObjKV(plug, (subPinId: string) => ({
            int: addVector(
              position,
              pin.metadata?.position?.[subPinId]?.int ?? NULL_VECTOR
            ),
            ext: addVector(
              position,
              pin.metadata?.position?.[subPinId]?.ext ?? NULL_VECTOR
            ),
          }))

          this._state_add_exposed_pin_set(type, pin_id, pin, plug_positions)
        }
      }
    })

    const { subComponents = {} } = component

    const fallback_parent_id: string | null =
      this._get_sub_component_target_parent_id()

    const parent_map = {}

    for (const unit_id in subComponents) {
      const sub_component = subComponents[unit_id]

      const { children = [] } = sub_component

      for (const child_id of children) {
        parent_map[child_id] = unit_id
      }
    }

    for (const unit_id in subComponents) {
      const parent_id = parent_map[unit_id] || fallback_parent_id

      const sub_component_spec = subComponents[unit_id]

      const copy_sub_component_spec = {
        width: sub_component_spec.width,
        height: sub_component_spec.height,
      }

      let at: number

      if (parent_id) {
        const children = getSubComponentChildren(graph, parent_id)

        at = children.indexOf(unit_id)

        this._spec_insert_component(parent_id, unit_id, at)
      } else {
        const children = getSubComponentChildren(graph, parent_id)

        at = this._spec.component?.children?.length ?? 0

        this._spec_insert_component(parent_id, unit_id, at)
      }
    }

    for (const unit_id in subComponents) {
      const parent_id = parent_map[unit_id] || fallback_parent_id

      const layout_position = NULL_VECTOR

      this._sim_add_core_component(unit_id, parent_id, layout_position)

      mount && this._sim_add_sub_component(unit_id, {}, undefined, false)
    }

    const sub_component_ids = keys(subComponents)

    const ordered_sub_component_ids =
      this._order_sub_component_ids(sub_component_ids)

    if (mount) {
      for (const unit_id of ordered_sub_component_ids) {
        this._sim_add_sub_component_to_parent(unit_id, undefined)
      }
    }

    for (const datum_id in data) {
      const datum = data[datum_id]

      let { value } = datum

      if (!value) {
        continue
      }

      value = stringifyDataValue(value, specs, classes)

      this._sim_add_datum_node(datum_id, value, position)

      const datum_node_id = getDatumNodeId(datum_id)
    }

    const final_node_count = this._node_count

    const delta_node_count = final_node_count - start_node_count

    const node_count_changed = delta_node_count !== 0

    if (restart_simulation) {
      this._simulation_prevent_restart = false

      if (node_count_changed) {
        this._start_graph_simulation(LAYER_NONE)
      }
    }
  }

  private _make_paste_spec_bulk_action = (
    graph: GraphSpec,
    deep: boolean,
    map_unit_id: Dict<string>
  ): Action[] => {
    // console.log(
    //   'Graph',
    //   '_make_paste_spec_bulk_action',
    //   graph,
    //   deep,
    //   map_unit_id
    // )

    const { specs, getSpec } = this.$props

    const {
      units = {},
      merges = {},
      inputs = {},
      outputs = {},
      component = {
        subComponents: {},
        children: [],
      },
      data = {},
    } = graph

    const bulk_actions = []

    const reverse_map_unit_id = revertObj(map_unit_id)

    for (const unit_id in units) {
      const unit = units[unit_id]

      const spec = getSpec(unit.id)

      const is_unit_component = isComponentSpec(spec)

      const bundle = clone(unitBundleSpec(unit, specs))

      if (deep) {
        const source_unit_id = reverse_map_unit_id[unit_id]

        bulk_actions.push(makeCloneUnitAction(source_unit_id, unit_id))
      } else {
        bulk_actions.push(makeAddUnitAction(unit_id, bundle))
      }
    }

    for (const sub_component_id in component.subComponents) {
      const unit = units[sub_component_id]

      const sub_component_spec = component.subComponents[sub_component_id]

      const { children = [] } = sub_component_spec

      bulk_actions.push(
        makeMoveSubComponentRootAction(sub_component_id, {}, children, {}, {})
      )
    }

    for (const merge_id in merges) {
      const merge = merges[merge_id]

      bulk_actions.push(makeAddMergeAction(merge_id, clone(merge)))
    }

    const type_pins = { input: inputs, output: outputs }

    io((type) => {
      const pins = type_pins[type]

      for (const pin_id in pins) {
        const pin = clone(pins[pin_id])

        const { plug = {} } = pin

        const new_sub_pin_id_blacklist = new Set<string>()

        if (this._has_exposed_pin_named(type, pin_id)) {
          for (const sub_pin_id in plug) {
            const sub_pin = plug[sub_pin_id]

            let next_sub_pin_id: string

            if (this._spec_has_plug(type, pin_id, sub_pin_id)) {
              next_sub_pin_id = this._new_sub_pin_id(
                type,
                pin_id,
                new_sub_pin_id_blacklist
              )

              new_sub_pin_id_blacklist.add(next_sub_pin_id)
            } else {
              next_sub_pin_id = sub_pin_id
            }

            bulk_actions.push(
              makeExposePinAction(type, pin_id, next_sub_pin_id, sub_pin)
            )
          }
        } else {
          bulk_actions.push(
            makeExposePinSetAction(type, pin_id, pin, undefined)
          )
        }
      }
    })

    return bulk_actions
  }

  public __pod_paste_spec = (graph: GraphSpec, actions: Action[]): void => {
    // console.log('Graph', '_paste_spec', graph)

    const { specs, fork, bubble } = this.$props

    const {
      units = {},
      merges = {},
      inputs = {},
      outputs = {},
      component = {},
      data = {},
    } = graph

    const { subComponents = {} } = component

    this._pod.$bulkEdit({
      actions,
      fork,
      bubble,
    })

    for (const unit_id in subComponents) {
      this._connect_sub_component(unit_id)
    }

    this._download_pod_data()
  }

  private _on_ctrl_a_keydown = (key: string): void => {
    this._toggle_select_all_visible()
  }

  private _on_ctrl_c_keydown = (): void => {
    this.copy_selected_nodes(false)
  }

  private _on_ctrl_shift_c_keydown = (): void => {
    // console.log('Graph', '_on_ctrl_shift_c_keydown')
  }

  private _on_ctrl_x_keydown = (): void => {
    this.cut_selected_nodes()
  }

  private _on_ctrl_v_keydown = (): void => {
    const position = this._jiggle_world_screen_center()

    this._paste_clipboard(position)
  }

  private _on_ctrl_l_keydown = (key: string): void => {
    // console.log('Graph', '_on_ctrl_l_keydown')

    if (this._search) {
      if (this._search_hidden) {
        this._search.toggleShape()
      }
    }
  }

  private _add_unit_merges = (
    unit_id: string,
    merges: GraphMergesSpec,
    emit: boolean = true
  ) => {
    for (const merge_id in merges) {
      const merge = merges[merge_id]

      if (this._spec_has_merge(merge_id)) {
        const merge_node_id = getMergeNodeId(merge_id)

        const merge_unit = merge[unit_id]

        forIOObjKV(merge_unit, (type: IO, pin_id: string) => {
          const pin_node_id = getPinNodeId(unit_id, type, pin_id)

          this._merge_link_pin_merge_pin(pin_node_id, merge_node_id, emit)
        })
      } else {
        const merge_position = this._init_merge_spec_position(merge)

        this._add_merge(merge_id, merge, merge_position, emit)

        this._sim_collapse_merge(merge_id)
      }
    }
  }

  private _add_unit_plugs = (
    unitId: string,
    plugs: GraphUnitPlugs,
    emit: boolean = true
  ) => {
    forIOObjKV(plugs, (type, _pinId, { pinId, subPinId, position }) => {
      const pin_node_id = getPinNodeId(unitId, type, _pinId)

      const merge_node_id = this._pin_to_merge[pin_node_id]

      position =
        position ?? this.__predict_plug_initial_position(type, pinId, subPinId)

      if (merge_node_id) {
        const { mergeId } = segmentMergeNodeId(merge_node_id)

        this._plug_exposed_pin(type, pinId, subPinId, { mergeId })
      } else {
        this._plug_exposed_pin(type, pinId, subPinId, {
          unitId,
          pinId: _pinId,
          kind: type,
        })
      }
    })
  }

  private _on_ctrl_m_keydown = (key: string): void => {
    this._toggle_minimap()
  }

  private _force_finish_last_action: Unlisten

  private _animate_core_resize_unlisten: Dict<Unlisten> = {}

  private _undo = (): void => {
    if (this._action_buffer_cursor > -1) {
      const last_action = this._action_buffer[this._action_buffer_cursor]

      this._action_buffer_cursor--

      const opposite_action = reverseAction(last_action)

      if (this._force_finish_last_action) {
        this._force_finish_last_action()

        this._force_finish_last_action = undefined
      }

      this._execute_action(opposite_action, true)
    }
  }

  private _execute_action = (action: Action, emit: boolean): void => {
    // console.log('Editor', '_execute_action', action)

    const { fork, bubble, getSpec, injectSpecs } = this.$props

    const { type, data } = clone(action)

    switch (type) {
      case ADD_UNIT:
        {
          this._add_unit(
            data.unitId,
            data.bundle,
            data.position,
            data.pinPosition,
            data.layoutPosition,
            data.parentId,
            emit
          )

          if (this._is_unit_component(data.unitId)) {
            if (this._in_component_control) {
              this._sim_add_sub_component(data.unitId)

              this._connect_sub_component(data.unitId)

              if (this._tree_layout) {
                this._refresh_all_layout_node_target_position()
                this._move_all_current_layout_node_target_position()
                this._layout_scroll_search_unit_into_view()
                this._refresh_search_list_height_offset()
              }
            }
          }

          this._add_unit_merges(data.unitId, data.merges ?? {}, emit)
          this._add_unit_plugs(data.unitId, data.plugs ?? {}, emit)
        }
        break
      case REMOVE_UNIT:
        {
          this._remove_unit(data.unitId, emit)
        }
        break
      case ADD_MERGE:
        {
          this._add_merge(data.mergeId, data.mergeSpec, data.position, emit)
          this._sim_collapse_merge(data.mergeId)
        }
        break
      case REMOVE_MERGE:
        {
          const merge_node_id = getMergeNodeId(data.mergeId)

          this._remove_merge(merge_node_id, emit)
        }
        break
      case ADD_PIN_TO_MERGE:
        {
          const merge_node_id = getMergeNodeId(data.mergeId)
          const pin_node_id = getPinNodeId(data.unitId, data.type, data.pinId)

          this._merge_link_pin_merge_pin(pin_node_id, merge_node_id, emit)
        }
        break
      case REMOVE_PIN_FROM_MERGE:
        {
          const merge_node_id = getMergeNodeId(data.mergeId)
          const pin_node_id = getPinNodeId(data.unitId, data.type, data.pinId)

          this._remove_pin_from_merge(merge_node_id, pin_node_id, emit)
        }
        break
      case EXPOSE_PIN_SET: {
        this._expose_pin_set(
          data.type,
          data.pinId,
          data.pinSpec,
          data.data && stringify(data.data), // AD HOC
          data.position,
          emit
        )

        break
      }
      case MOVE_SUB_COMPONENT_ROOT:
        {
          if (data.parentId) {
            this._move_sub_component_root(
              data.parentId,
              data.children,
              // data.slotMap,
              'default',
              emit,
              false
            )
          } else {
            for (const child_id of data.children) {
              this._measure_sub_component_base(child_id)
            }

            this._remove_sub_component_children(
              data.prevParentIdMap,
              'default',
              null,
              'default',
              data.children
            )
          }

          emit &&
            this._pod.$moveSubComponentRoot({
              parentId: data.parentId,
              children: data.children,
              slotMap: data.slotMap ?? {},
              fork,
              bubble,
            })

          this._refresh_layout_node_target_position(null)

          this._animate_all_current_layout_layer_node()
        }
        break
      case SET_UNIT_PIN_CONSTANT:
        {
          const pin_node_id = getPinNodeId(data.unitId, data.type, data.pinId)

          this._set_link_pin_constant(pin_node_id, data.constant, emit)
        }
        break
      case SET_PIN_SET_FUNCTIONAL:
        {
          const pin_node_id = getPinNodeId(data.unitId, data.type, data.pinId)

          this._set_exposed_pin_functional(pin_node_id, data.constant, emit)
        }
        break
      case REORDER_SUB_COMPONENT:
        {
          this._stop_parent_sub_component_children_animation(data.parentId)

          this._reorder_sub_component(data.childId, data.to, emit)
        }
        break
      case COVER_PIN_SET:
        {
          this._state_cover_pin_set(data.type, data.pinId)
        }
        break
      case PLUG_PIN:
        {
          this._state_plug_exposed_pin(
            data.type,
            data.pinId,
            data.subPinId,
            data.subPinSpec
          )
          emit &&
            this._pod_plug_exposed_pin(
              data.type,
              data.pinId,
              data.subPinId,
              data.subPinSpec
            )
        }
        break
      case EXPOSE_UNIT_PIN_SET:
        {
          this._state_expose_unit_pin_set(
            data.unitId,
            data.type,
            data.pinId,
            data.pinSpec,
            data.position
          )
          emit &&
            this._pod_expose_unit_pin_set(
              data.unitId,
              data.type,
              data.pinId,
              data.pinSpec
            )
        }
        break
      case COVER_UNIT_PIN_SET:
        {
          this._state_cover_unit_pin_set(
            data.unitId,
            data.type,
            data.pinId,
            data.pinSpec,
            data.position
          )
          emit &&
            this._pod_cover_unit_pin_set(
              data.unitId,
              data.type,
              data.pinId,
              data.pinSpec
            )
        }
        break
      case UNPLUG_PIN:
        {
          this._state_unplug_exposed_pin(data.type, data.pinId, data.subPinId)
          emit &&
            this._pod_unplug_exposed_pin(data.type, data.pinId, data.subPinId)
        }
        break
      case SET_UNIT_PIN_IGNORED:
        {
          const pin_node_id = getPinNodeId(data.unitId, data.type, data.pinId)

          this._state_set_link_pin_ignored(pin_node_id, data.ignored)
          emit && this._pod_set_link_pin_ignored(pin_node_id, data.ignored)
        }

        break
      case MOVE_SUBGRAPH_INTO:
        {
          const _data = clone(data) as GraphMoveSubGraphIntoData

          this._set_node_fixed(_data.graphId, true)

          this._start_move_subgraph_into(_data.graphId, data)

          this._force_finish_last_action = () => {
            for (const node_id of [...this._collapse_node_id]) {
              this._long_press_collapse_node(node_id)
            }

            if (this._abort_sub_component_leave_base_animation[_data.graphId]) {
              const abort =
                this._abort_sub_component_leave_base_animation[_data.graphId]

              abort()

              delete this._abort_sub_component_leave_base_animation[
                _data.graphId
              ]
            }

            this._force_finish_last_action = undefined
          }
        }
        break
      case SET_UNIT_PIN_DATA:
        {
          const pin_node_id = getPinNodeId(data.unitId, data.type, data.pinId)

          if (data.data === undefined) {
            const datum_node_id = this._pin_to_datum[pin_node_id]

            if (datum_node_id) {
              this._remove_datum(datum_node_id)
            }
          } else {
            const oldValue = this._get_pin_datum_value(pin_node_id)

            this._state_set_unit_pin_data(pin_node_id, data.data)

            emit &&
              this._pod_set_pin_data(pin_node_id, data.data, oldValue, true)
          }
        }

        break
      case MOVE_SUBGRAPH_OUT_OF:
        {
          const _data = data as GraphMoveSubGraphOutOfData

          this._state_move_subgraph_out_of(data.graphId, _data)
        }

        break
      case SET_SUB_COMPONENT_SIZE:
        {
          this._state_layout_resize_sub_component(
            data.unitId,
            data.width,
            data.height
          )

          emit &&
            this._pod_set_sub_component_size(
              data.unitId,
              data.width,
              data.height
            )
        }

        break
      case SET_COMPONENT_SIZE:
        break
      case BULK_EDIT:
        {
          emit && this._pod.$bulkEdit(clone(data))

          for (const action of data.actions) {
            this._execute_action(action, false)
          }
        }
        break
      case SET_UNIT_SIZE:
        {
          const unit_id = data.unitId
          const width = data.width
          const height = data.height

          const node = this._node[unit_id]

          const target_trait = { width, height }

          this._animate_core_resize_unlisten[unit_id] = this._animate_core_size(
            unit_id,
            {
              width: node.width,
              height: node.height,
            },
            () => {
              return target_trait
            },
            ({ width, height }) => {
              this._resize_core_width(unit_id, width)
              this._resize_node_width(unit_id, width)

              this._resize_core_height(unit_id, height)
              this._resize_node_height(unit_id, height)
            },
            () => {
              this._state_set_unit_size(data.unitId, data.width, data.height)
            }
          )

          this._start_graph_simulation(LAYER_NORMAL)

          emit && this._pod_set_unit_size(data.unitId, data.width, data.height)
        }
        break
      case ADD_DATUM:
        {
          this._add_datum(
            data.id,
            data.value,
            this._jiggle_world_screen_center()
          )
        }
        break
      case REMOVE_DATUM:
        {
          const datum_node_id = getDatumNodeId(data.id)

          this._remove_datum(datum_node_id)
        }
        break
      case ADD_DATUM_LINK:
        {
          const datum_node_id = getDatumNodeId(data.id)

          const pin_node_id = this._spec_to_node_id(data.pinSpec)

          this._move_datum_to_pin(datum_node_id, pin_node_id)
        }
        break
      case REMOVE_DATUM_LINK:
        {
          const datum_node_id = getDatumNodeId(data.id)

          const pin_node_id = this._datum_to_pin[datum_node_id]

          if (pin_node_id) {
            this._remove_pin_datum_link(datum_node_id)
          }
        }
        break
      case REMOVE_UNIT_PIN_DATA:
        break
      case TAKE_UNIT_ERR:
        break
      default:
        throw new CodePathNotImplementedError()
    }
  }

  private _stop_parent_sub_component_children_animation = (
    parent_id: string
  ) => {
    if (!this._layout_parent_children_animation_frame[parent_id]) {
      this._cancel_layout_parent_children_animation(parent_id, 'default')

      const children = this._spec_get_sub_component_children(parent_id)

      const callback = this._layout_transfer_parent_callback[parent_id]

      this._end_layout_sub_component_transfer_children_animation(
        parent_id,
        'default',
        children
      )

      if (callback) {
        callback()
      }
    }
  }

  private _redo = (): void => {
    if (this._action_buffer_cursor < this._action_buffer.length - 1) {
      this._action_buffer_cursor++

      const action = this._action_buffer[this._action_buffer_cursor]

      if (this._force_finish_last_action) {
        this._force_finish_last_action()

        this._force_finish_last_action = undefined
      }

      this._execute_action(action, true)
    }
  }

  private _on_ctrl_z_keydown = (): void => {
    this._undo()
  }

  private _on_ctrl_shift_z_keydown = (): void => {
    this._redo()
  }

  private _order_node_by_x = (): [string, SimNode][] => {
    return this.__order_node_by_x_template(this._node)
  }

  private _order_node_by_y = (): [string, SimNode][] => {
    return this.__order_node_by_y_template(this._node)
  }

  private __order_node_by_x_template = (
    nodes: Dict<SimNode>
  ): [string, SimNode][] => {
    return this.__order_node_by_a__template('x', nodes)
  }

  private __order_node_by_y_template = (
    nodes: Dict<SimNode>
  ): [string, SimNode][] => {
    return this.__order_node_by_a__template('y', nodes)
  }

  private __order_node_by_a__template = (
    name: string,
    nodes: Dict<SimNode>
  ): [string, SimNode][] => {
    return Object.entries(nodes).sort(([_, a], [__, b]) => a[name] - b[name])
  }

  private __order_subgraph_by_a__template = (
    name: 'x' | 'y',
    filter: (node_id: string) => boolean
  ): string[] => {
    const subgraph_list = keys(this._subgraph_to_node)

    return subgraph_list.sort((a, b) => {
      const a_rect = this._get_subgraph_bounding_rect(a, filter)
      const b_rect = this._get_subgraph_bounding_rect(b, filter)

      return a_rect[name] - b_rect[name]
    })
  }

  private _get_subgraph_bounding_line = (
    subgraph_id: string,
    filter: (node_id: string) => boolean = () => true
  ): Line => {
    const node_ids = this._subgraph_to_node[subgraph_id]

    const nodes_obj: Dict<Rect> = [...node_ids].reduce((acc, node_id) => {
      if (filter(node_id)) {
        return {
          ...acc,
          [node_id]: this._node[node_id],
        }
      } else {
        return acc
      }
    }, {})

    const line = this.get_nodes_bounding_line(nodes_obj)

    return line
  }

  private _get_subgraph_bounding_rect = (
    subgraph_id: string,
    filter: (node_id: string) => boolean = () => true
  ): Rect => {
    const nodes = this._subgraph_to_node[subgraph_id]

    const nodes_obj: Dict<Rect> = [...nodes].reduce((acc, node_id) => {
      if (filter(node_id)) {
        return {
          ...acc,
          [node_id]: this._node[node_id],
        }
      } else {
        return acc
      }
    }, {})

    const rect = this.get_nodes_bounding_rect(nodes_obj)

    return rect
  }

  private _order_unit_by_x = (): [string, SimNode][] => {
    return this.__order_node_by_x_template(this._unit_node)
  }

  private _order_unit_by_y = (): [string, SimNode][] => {
    return this.__order_node_by_y_template(this._unit_node)
  }

  private _on_arrow_keydown = (key: string, event: IOKeyboardEvent) => {
    // console.log('Graph', '_on_arrow_keydown', key)

    if (this._is_shift_pressed()) {
      this._on_shift_arrow_keydown(key, event)
    } else {
      this._on_normal_arrow_keydown(key, event)
    }
  }

  private _on_normal_arrow_keydown = (key: string, event: IOKeyboardEvent) => {
    // console.log('Graph', '_on_normal_arrow_keydown', key)

    if (this._node_count === 0) {
      return
    }

    if (event.repeat) {
      return
    }

    let current_index = -1

    let nodes_ordered_by_axis

    const get_next_x_index = (): number => {
      const nodes_ordered_by_x = this.__order_node_by_x_template(
        this._unit_node
      ).map(([id]) => id)

      nodes_ordered_by_axis = nodes_ordered_by_x

      return get_next_a_index__template(nodes_ordered_by_x)
    }

    const get_next_y_index = (): number => {
      const nodes_ordered_by_y = this.__order_node_by_y_template(
        this._unit_node
      ).map(([id]) => id)

      nodes_ordered_by_axis = nodes_ordered_by_y

      return get_next_a_index__template(nodes_ordered_by_y)
    }

    const get_next_a_index__template = (
      nodes_ordered_by_a: string[]
    ): number => {
      const selected_index = nodes_ordered_by_a.findIndex((node_id) =>
        this._is_node_selected(node_id)
      )

      if (selected_index === -1) {
        if (offset === 1) {
          return 0
        } else {
          return nodes_ordered_by_a.length - 1
        }
      }

      return selected_index + offset
    }

    let offset = 0

    switch (key) {
      case 'ArrowLeft':
        offset = -1
        current_index = get_next_x_index()
        break
      case 'ArrowRight':
        offset = 1
        current_index = get_next_x_index()
        break
      case 'ArrowUp':
        offset = -1
        current_index = get_next_y_index()
        break
      case 'ArrowDown':
        offset = 1
        current_index = get_next_y_index()
        break
    }

    const next_index = current_index

    this._deselect_all()

    if (next_index !== undefined && next_index >= 0) {
      const next_selected_node = nodes_ordered_by_axis[next_index]

      if (next_selected_node) {
        this.select_node(next_selected_node)

        if (isKeyPressed(this.$system, 'Space')) {
          this._on_space_keydown()
        }
      }
    }
  }

  private _on_shift_arrow_keydown = (key: string, event: IOKeyboardEvent) => {
    // console.log('Graph', '_on_shift_arrow_keydown', key, shortcut)

    if (this._node_count === 0) {
      return
    }

    let offset = 0
    let ordered_subgraphs = []

    const filter = (node_id: string) => {
      return (
        this._is_node_visible(node_id) &&
        this._node_layer[node_id] === LAYER_NORMAL
      )
    }

    switch (key) {
      case 'ArrowLeft':
        offset = -1
        ordered_subgraphs = this.__order_subgraph_by_a__template('x', filter)
        break
      case 'ArrowRight':
        offset = 1
        ordered_subgraphs = this.__order_subgraph_by_a__template('x', filter)
        break
      case 'ArrowUp':
        offset = -1
        ordered_subgraphs = this.__order_subgraph_by_a__template('y', filter)
        break
      case 'ArrowDown':
        offset = 1
        ordered_subgraphs = this.__order_subgraph_by_a__template('y', filter)
        break
    }

    if (offset === 0) {
      return
    }

    const nearest_node_id = this._find_nearest_unit_id_to_center()

    const closest_subraph_id = this._node_to_subgraph[nearest_node_id]

    const current_index = ordered_subgraphs.indexOf(closest_subraph_id)

    const next_index =
      (current_index + offset + ordered_subgraphs.length) %
      ordered_subgraphs.length

    const next_subgraph_id = ordered_subgraphs[next_index]

    const nodes = this._get_subgraph_nodes(next_subgraph_id)

    const nodes_ = filterObj(nodes, (node, node_id) => {
      return filter(node_id)
    })

    this._center_on_nodes(nodes_)
  }

  private _get_subgraph_nodes = (subgraph_id: string): Dict<GraphSimNode> => {
    const node_ids = this._subgraph_to_node[subgraph_id]

    const nodes: Dict<GraphSimNode> = [...node_ids].reduce((acc, node_id) => {
      return {
        ...acc,
        [node_id]: this._node[node_id],
      }
    }, {})

    return nodes
  }

  private _on_space_keydown = (): void => {
    if (this._selected_node_count > 0) {
      this._center_graph_on_selected()
    } else {
      this._center_graph()
    }
  }

  private _on_slash_keydown = (): void => {
    if (this._control) {
      this._control.show_tooltips()
    }
  }

  private _on_slash_keyup = (): void => {
    if (this._control) {
      this._control.hide_tooltips()
    }
  }

  private _hide_search = () => {
    // console.log('Graph', '_hide_search')

    if (this._search) {
      this._search.blur()
    }
  }

  private _show_search = () => {
    // console.log('Graph', '_show_search')

    if (this._search) {
      this._search_to_be_focused = true

      this._search.focus({ preventScroll: true })
    }
  }

  private _on_backslash_keydown = (): void => {
    if (this._search) {
      this._search.start_microphone()
    }
  }

  private _on_backslash_keyup = (): void => {
    if (this._search) {
      this._search.stop_microphone()
    }
  }

  private _get_sub_component_slot_name = (sub_component_id: string): string => {
    const parent_id = this._spec_get_sub_component_parent_id(sub_component_id)

    if (parent_id) {
      const parent_component_spec = this._get_sub_component_spec(parent_id)

      const { childSlot = {} } = parent_component_spec

      return childSlot[sub_component_id] || 'default'
    } else {
      return 'default'
    }
  }

  private _insert_sub_component_child = (
    parent_id: string,
    sub_component_id: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_insert_sub_component_child',
    //   parent_id,
    //   sub_component_id
    // )

    if (!this._is_fullwindow) {
      const slot = this._get_sub_component_slot_name(sub_component_id)
      const i = this._spec_get_sub_component_parent_root_index(sub_component_id)

      this.__insert_sub_component_child(parent_id, sub_component_id, slot, i)
    }
  }
  private __insert_sub_component_child = (
    parent_id: string,
    sub_component_id: string,
    slot: string,
    i: number
  ): void => {
    const parent_component = this._get_sub_component(parent_id)
    const sub_component = this._get_sub_component(sub_component_id)

    if (!this._is_fullwindow) {
      parent_component.insertParentRootAt(sub_component, i, slot)
    }
  }

  private _mem_insert_sub_component_child = (
    parent_id: string,
    child_id: string,
    slot_name: string,
    i?: number
  ): void => {
    // console.log(
    //   'Graph',
    //   '_mem_insert_sub_component_child',
    //   parent_id,
    //   child_id
    // )

    if (i === undefined) {
      return this._mem_push_sub_component_child(parent_id, child_id, slot_name)
    }

    const parent_component = this._get_sub_component(parent_id)
    const sub_component = this._get_sub_component(child_id)

    if (this._is_fullwindow) {
      // TODO
    } else {
      if (parent_component.$parentRoot.length > i) {
        parent_component.insertParentRoot(sub_component, i, slot_name)
      } else {
        parent_component.pushParentRoot(sub_component, slot_name)
      }
    }
  }

  private _dom_insert_sub_component_child = (
    parent_id: string,
    sub_component_id: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_dom_insert_sub_component_child',
    //   parent_id,
    //   sub_component_id
    // )

    const parent_component = this._get_sub_component(parent_id)
    const sub_component = this._get_sub_component(sub_component_id)

    if (!this._is_fullwindow) {
      const slot = this._get_sub_component_slot_name(sub_component_id)
      const i = this._spec_get_sub_component_parent_root_index(sub_component_id)

      if (parent_component.$mountParentRoot.length > i) {
        parent_component.domInsertParentRootAt(sub_component, i, slot)
      } else {
        parent_component.domAppendParentRoot(sub_component, slot, i)
      }
    }
  }

  private _post_insert_sub_component_child = (
    parent_id: string,
    sub_component_id: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '_insert_sub_component_child',
    //   parent_id,
    //   sub_component_id
    // )

    const parent_component = this._get_sub_component(parent_id)
    const sub_component = this._get_sub_component(sub_component_id)

    if (!this._is_fullwindow) {
      const slot = this._get_sub_component_slot_name(sub_component_id)
      const i = this._spec_get_sub_component_parent_root_index(sub_component_id)

      if (parent_component.$mountParentRoot.length > i) {
        parent_component.postInsertParentRootAt(sub_component, i, slot)
      } else {
        parent_component.postAppendParentRoot(sub_component, slot, i)
      }
    }
  }

  private _on_escape_keydown = () => {
    // console.log('Graph', '_on_escape_keydown')

    if (this._edit_datum_node_id) {
      const datum = this._datum[this._edit_datum_node_id]

      datum.blur()
    } else {
      if (this._selected_node_count > 0) {
        this._deselect_all()
      } else {
        this.dispatchEvent('escape', {}, false)
      }
    }
  }

  private _on_enter_keydown = () => {
    // console.log('Graph', '_on_enter_keydown')
  }

  private _map_zoom_translate = (offsetX: number, offsetY: number) => {
    // console.log('Graph', '_map_zoom_translate', offsetX, offsetY)

    const { $width, $height } = this.$context

    const { _min_x, _min_y, _width, _height } = this._minimap

    const ratio = _width / _height
    const map_ratio = MINIMAP_WIDTH / MINIMAP_HEIGHT
    const r = ratio / map_ratio

    let aspectX = offsetX
    let aspectY = offsetY

    if (r > 1) {
      aspectY += (offsetY - MINIMAP_HEIGHT / 2) * (r - 1)
    } else {
      aspectX += (offsetX - MINIMAP_WIDTH / 2) * (1 / r - 1)
    }

    let x = _min_x + (aspectX * _width) / MINIMAP_WIDTH
    let y = _min_y + (aspectY * _height) / MINIMAP_HEIGHT
    const { x: zx, y: zy, z: zz } = this._zoom

    this._translate_x = (zx - x) * zz + $width / 2
    this._translate_y = (zy - y) * zz + $height / 2

    const zoom = translate(this._zoom, this._translate_x, this._translate_y)

    this.set_zoom(zoom)

    this._translate_pressed_node()

    this._translate_search_node()
  }

  private _on_minimap_wheel = ({
    deltaY,
    ctrlKey,
    clientX,
    clientY,
    offsetX,
    offsetY,
  }: IOWheelEvent): void => {
    if (!ctrlKey) {
      if (this._unit_count > 0) {
        this._zoom_in(deltaY, this._zoom.x, this._zoom.y)
        this._map_zoom_translate(offsetX, offsetY)
      }
    }
  }

  private _on_minimap_pointer_down = (event: UnitPointerEvent): void => {
    // console.log('Graph', '_on_minimap_pointer_down', clientX, clientY)
    const { pointerId } = event

    const { clientX, clientY } = event

    if (
      this._unit_count > 0 &&
      !this._is_minimap_drag_and_drop_mode(this._mode)
    ) {
      this._minimap.setPointerCapture(pointerId)

      this._minimap_pointer_down = true

      if (this._tree_layout) {
        const { $width, $height } = this.$context

        this._minimap_screen.setProp('x', -$width / 2)
        this._minimap_screen.setProp('y', clientY - 4.5 - $height / 2)
        this._minimap_screen.setProp('width', $width)
        this._minimap_screen.setProp('height', $height)
      } else {
        this._map_zoom_translate(clientX, clientY)
      }
    }
  }

  private _on_minimap_pointer_enter = () => {
    // console.log('Graph', '_on_minimap_pointer_enter')
    //
  }

  private _on_minimap_pointer_leave = () => {
    // console.log('Graph', '_on_minimap_pointer_leave')
    //
  }

  private _on_minimap_drag_start = () => {
    // console.log('Graph', '_on_minimap_drag_start')
    //
  }

  private _on_minimap_pointer_move = (event: UnitPointerEvent): void => {
    // console.log('Graph', '_on_minimap_pointer_move', clientX, clientY)
    if (this._minimap_pointer_down) {
      const { clientX, clientY } = event

      if (this._tree_layout) {
        const { $width, $height } = this.$context

        this._minimap_screen.setProp('x', -$width / 2)
        this._minimap_screen.setProp('y', clientY - 4.5 - $height / 2)
        this._minimap_screen.setProp('width', $width)
        this._minimap_screen.setProp('height', $height)
      } else {
        this._map_zoom_translate(clientX, clientY)
        this._start_graph_simulation(LAYER_NONE)
      }
    }
  }

  private _on_minimap_pointer_up = (event: UnitPointerEvent): void => {
    // console.log('Graph', '_on_minimap_pointer_up')
    const { pointerId } = event

    this._minimap_pointer_down = false

    if (this._minimap.hasPointerCapture(pointerId)) {
      this._minimap.releasePointerCapture(pointerId)
    }

    if (this._search_unit_id) {
      const search_unit_node = this._node[this._search_unit_id]

      search_unit_node.fx = undefined
      search_unit_node.fy = undefined

      this._for_each_unit_pin(this._search_unit_id, (pin_node_id) => {
        const search_unit_pin_node = this._node[pin_node_id]

        search_unit_pin_node.fx = undefined
        search_unit_pin_node.fy = undefined
      })
    }
  }

  private _zoom_in = (deltaY: number, clientX: number, clientY: number) => {
    // console.log('Graph', '_zoom_in', deltaY)
    const {
      api: {
        window: { setTimeout, clearTimeout },
      },
    } = this.$system

    const { $height, $width } = this.$context

    const {
      zoom: { minZoom, maxZoom },
    } = this._config()

    const wheel = deltaY < 0 ? 1 : -1

    const z = Math.exp(wheel * ZOOM_INTENSITY)

    const _z = this._zoom.z * z

    const x = clientX
    const y = clientY

    if (_z > minZoom && _z < maxZoom) {
      const zoom: Zoom = {
        z: _z,
        x: this._zoom.x - (x / _z - x / this._zoom.z),
        y: this._zoom.y - (y / _z - y / this._zoom.z),
      }

      this.set_zoom(zoom)

      this._maybe_refresh_simulation_by_drag()
    }
  }

  private _sim_relative_layer_m = (
    la: number,
    lb: number,
    r: number[][] = NODE_MASS_RELATIVE
  ) => {
    if (la * lb >= 0) {
      const la_abs = Math.abs(la)
      const lb_abs = Math.abs(lb)

      const rab = r[la_abs][lb_abs]

      return rab
    }
    return 0
  }

  private _sim_relative_m = (
    a: string,
    b: string,
    r: number[][] = NODE_MASS_RELATIVE
  ) => {
    const la = this._node_layer[a]
    const lb = this._node_layer[b]

    const la_sign = Math.sign(la)
    const lb_sign = Math.sign(lb)

    if (la_sign * lb_sign >= 0) {
      const la_abs = Math.abs(la)
      const lb_abs = Math.abs(lb)
      const rab = r[la_abs][lb_abs]
      return rab
    }

    return 0
  }

  private _zoom_target_node_id: string

  private _zoom_target_abort_animation: Unlisten

  private _zoom_target_is_animating = (): boolean => {
    return !!this._zoom_target_abort_animation
  }

  private _set_zoom_target = (node_id: string) => {
    this._zoom_target_node_id = node_id

    if (this._zoom_target_is_animating()) {
      //
    } else {
      this._start_zoom_target_animation()
    }
  }

  private _remove_zoom_target = () => {
    this._zoom_target_node_id = null
  }

  private _start_zoom_target_animation = () => {
    const n0 = this._zoom

    const n1 = () => {
      const { $width, $height } = this.$context

      const node = this.get_node(this._zoom_target_node_id)

      const { x, y } = node

      const zoom = zoomTransformCenteredAt(x, y, this._zoom.z, $width, $height)

      return {
        x: zoom.x - this._search_dock_offset_x / this._zoom.z / 2,
        y: zoom.y + this._search_dock_offset_y / this._zoom.z / 2,
        z: zoom.z,
      }
    }

    this._zoom_target_abort_animation = this._animate_simulate(
      n0,
      n1,
      [
        ['x', ANIMATION_DELTA_THRESHOLD / 10],
        ['y', ANIMATION_DELTA_THRESHOLD / 10],
      ],
      ({ x, y }) => {
        if (this._pointer_down_count === 0) {
          this._set_zoom({ x, y, z: this._zoom.z })
        }
      },
      () => {
        return false
      }
    )
  }

  private _stop_zoom_target_animation = () => {
    if (this._zoom_target_abort_animation) {
      this._zoom_target_abort_animation()
      this._zoom_target_abort_animation = undefined
    }
  }

  private _sim_max_d = (a: string, b: string): number => {
    const al = this._node_layer[a]
    const bl = this._node_layer[b]

    const a_sg = this._node_to_subgraph[a]
    const b_sg = this._node_to_subgraph[b]

    return this.__sim_max_l(al, bl, a_sg, b_sg)
  }

  private __sim_max_l = (
    al: number,
    bl: number,
    a_sg: string,
    b_sg: string
  ): number => {
    const same_subgraph = a_sg === b_sg

    const al_abs = Math.abs(al)
    const bl_abs = Math.abs(bl)

    if (same_subgraph) {
      const r = SUBGRAPH_RELATIVE_MAX_L[al_abs][bl_abs]

      return SUBGRAPH_MAX_D * r
    } else {
      const r = NOT_SUBGRAPH_RELATIVE_MAX_D[al_abs][bl_abs]
      return NOT_SUBGRAPH_MAX_D * r
    }
  }

  private _force_custom_layer_none = (alpha: number) => {
    this._force_link_y(alpha, this._pin_link)
    this._force_link_y(alpha, this._none_link)
  }

  private _force_center = (alpha: number, nodes: Dict<SimNode>) => {
    for (const a_id in nodes) {
      if (this._collapse_node_id.has(a_id)) {
        continue
      }

      const plug_node_id =
        deepGet(this._pin_to_int, ['input', a_id]) ||
        deepGet(this._pin_to_int, ['output', a_id])

      if (plug_node_id) {
        const a = nodes[a_id]

        const { $width, $height } = this.$context

        const { x: cx, y: cy } = this._world_screen_center()

        const z = this._zoom.z

        const RE = Math.min($width, $height) / 24 / z

        const dx = a.x - cx
        const dy = a.y - cy

        const r = Math.sqrt(dx * dx + dy * dy)

        const k = (0.1 * z * ((RE - r) * alpha)) / r

        a.ax += dx * k
        a.ay += dy * k
      }
    }
  }

  private _force_custom_layer_normal = (alpha: number) => {
    if (this._static) {
      for (const a_id in this._static_position) {
        if (this._static_count[a_id] === 0) {
          const a = this._node[a_id]
          const ax = a._x
          const ay = a._y
          const { x: cx, y: cy } = this._static_position[a_id]
          const dx = ax - cx
          const dy = ay - cy
          const r = Math.sqrt(dx * dx + dy * dy)
          if (r > 0) {
            const s = 0.1
            const k = s * alpha
            a.ax -= dx * k
            a.ay -= dy * k
          }
        }
      }
    }

    this._force_center(alpha, this._empty_merge_node)
  }

  private _force_link_y = (alpha: number, links: GraphSimLinks): void => {
    for (const link_id in links) {
      const link = links[link_id]

      const { source_id: a_id, target_id: b_id } = link

      const a = this._node[a_id]
      const b = this._node[b_id]

      const { _y: sy, layer: a_layer } = a
      const { _y: ty, layer: b_layer } = b

      const mab: number = this._sim_relative_layer_m(
        a_layer,
        b_layer,
        LINK_MASS_RELATIVE
      )
      const mba: number = this._sim_relative_layer_m(
        b_layer,
        a_layer,
        LINK_MASS_RELATIVE
      )

      const my = (sy + ty) / 2

      const ky = clamp((a.height + b.height) / UNIT_MIN_RADIUS / 12, 1, 24)

      const k = alpha / 3 / ky

      b.ay += (my - ty) * k * mab
      a.ay += (my - sy) * k * mba
    }
  }

  private _force_custom_layer_collapse = (alpha: number) => {
    if (this._collapsing) {
      const { x: cx, y: cy } = this._get_node_position(
        this._collapse_next_unit_id
      )

      for (const a_id of this._collapse_node_id) {
        const a = this._node[a_id]

        const { _x, _y } = a

        const dx = _x - cx
        const dy = _y - cy

        const s = 0.1
        const k = s * alpha

        a.ax -= dx * k
        a.ay -= dy * k
      }
    }
  }

  private _force_custom_layer_search = (alpha: number) => {
    const search_node_id =
      this._search_unit_id || this._search_unit_datum_node_id

    if (search_node_id) {
      let center: Position

      if (this._mode === 'change') {
        if (this._search_unit_id) {
          center = this._search_start_unit_position
        } else {
          center = this._search_unit_datum_start_position
        }
      } else {
        center = this._world_screen_center()
      }

      const { x: cx, y: cy } = center

      const a = this._node[search_node_id]

      const { _x, _y } = a

      const dx = _x - cx - this._search_dock_offset_x / this._zoom.z / 2
      const dy = _y - cy + this._search_dock_offset_y / this._zoom.z / 2

      const r = Math.sqrt(dx * dx + dy * dy)

      if (r > 0.1) {
        const k = alpha / 6

        a.ax -= dx * k
        a.ay -= dy * k
      }
    }

    this._force_link_y(alpha, this._search_link)
  }

  private _force_custom_layer_ignored = (alpha: number): void => {
    this._force_link_y(alpha, this._ignored_link)
  }

  private _get_closest_compatible = (
    node_id: string
  ): { node_id: string; l: number } => {
    const node = this._node[node_id]

    return this.__get_closest_compatible((other_node) => {
      const { l } = surfaceDistance(node, other_node)

      return l
    })
  }

  private __get_closest_compatible = (
    distance: (compatible_node: Thing) => number
  ): { node_id: string; l: number } => {
    let closest_comp_node_id = null
    let closest_l = Number.MAX_SAFE_INTEGER

    for (const compatible_node_id in this._compatible_node_id) {
      const comp_node = this._node[compatible_node_id]

      const l = distance(comp_node)

      if (l < NEAR) {
        if (l < closest_l) {
          closest_l = l
          closest_comp_node_id = compatible_node_id
        }
      }
    }

    return {
      node_id: closest_comp_node_id,
      l: closest_l,
    }
  }

  private _force_custom_layer_exposed = (alpha: number): void => {
    const { $width, $height } = this.$context

    const { x: cx, y: cy } = this._world_screen_center()

    const z = this._zoom.z

    const RE = Math.min($width, $height) / 24 / z

    for (const a_id in this._exposed_int_unplugged) {
      if (this._collapse_node_id.has(a_id)) {
        continue
      }

      const a = this._node[a_id]

      const { _x: a_x, _y: a_y } = a

      const { pinId, type, subPinId } = segmentPlugNodeId(a_id)

      const b_id = getExtNodeId(type, pinId, subPinId)

      const b = this._node[b_id]

      const { _x: b_x, _y: b_y } = b

      if (this._int_node_locked[a_id]) {
        const c_id = this._int_node_locked[a_id]

        const c = this._node[c_id]

        const a_u = unitVector(a_x, a_y, c.x, c.y)

        const k = 9 * alpha

        a.ax += a_u.x * k
        a.ay += a_u.y * k
      } else {
        let closest_comp_node_id = null
        let closest_l = Number.MAX_SAFE_INTEGER

        if (this._compatible_node_count > 0) {
          ;({ l: closest_l, node_id: closest_comp_node_id } =
            this.__get_closest_compatible((compatible_node) => {
              const { l: l_a } = surfaceDistance(a, compatible_node)
              const { l: l_b } = surfaceDistance(b, compatible_node)

              const comp_closest_l = Math.min(l_a, l_b)

              return comp_closest_l
            }))
        }

        if (this._drag_node_id[a_id]) {
          const u = unitVector(a_x, a_y, b_x, b_y)

          let a_u: Point

          if (closest_comp_node_id) {
            const comp_node = this._node[closest_comp_node_id]

            const { _x: comp_x, _y: comp_y } = comp_node

            a_u = unitVector(comp_x, comp_y, a_x, a_y)
          } else {
            a_u = unitVector(cx, cy, a_x, a_y)
          }

          const angle = radBetween(u.x, u.y, a_u.x, a_u.y)

          if (angle < 2 * Math.PI - 0.01) {
            const p = normalize({ x: a_u.x - u.x, y: a_u.y - u.y })

            const k = 1 * alpha

            b.ax += p.x * k
            b.ay += p.y * k
          }
        } else if (this._drag_node_id[b_id]) {
          const u = unitVector(b_x, b_y, a_x, a_y)

          if (closest_comp_node_id) {
            const comp_node = this._node[closest_comp_node_id]

            const { _x: c_x, _y: c_y, r: c_r } = comp_node

            const a_u = unitVector(a_x, a_y, c_x, c_y)

            const angle = radBetween(u.x, u.y, a_u.x, a_u.y)

            if (angle > 0.05) {
              const p = normalize({ x: a_u.x - u.x, y: a_u.y - u.y })

              const k = 1 * alpha

              a.ax += p.x * k
              a.ay += p.y * k
            }
          } else {
            const b_u = unitVector(b_x, b_y, cx, cy)

            const angle = radBetween(u.x, u.y, b_u.x, b_u.y)

            if (angle > 0.01) {
              const p = normalize({ x: b_u.x - u.x, y: b_u.y - u.y })

              const k = 1 * alpha

              a.ax += p.x * k
              a.ay += p.y * k
            }
          }
        } else {
          const dx = a_x - cx
          const dy = a_y - cy

          const r = Math.sqrt(dx * dx + dy * dy)

          const k = (0.1 * z * ((RE - r) * alpha)) / r

          a.ax += dx * k
          a.ay += dy * k
        }
      }
    }
  }

  private _force_custom_layer_data_linked = (alpha: number): void => {
    for (const link_id in this._visible_data_link) {
      const link = this._visible_data_link[link_id]

      const { source_id: a_id, target_id: b_id } = link

      const a = this._node[a_id]
      const b = this._node[b_id]

      const v = unitVector(b.x, b.y, a.x, a.y)

      const u = this._node_line_vector(b_id)

      const p = perpendicular(u)

      const k = 9 * alpha

      a.ax += k * Math.abs(p.x) * (u.x - v.x)
      a.ay += k * Math.abs(p.y) * (u.y - v.y)
    }
  }

  private _force_custom_layer_data = (alpha: number): void => {
    // const RD = Math.min($width, $height) / 3 / this._zoom.k
    // for (const datum_node_id in this._datum) {
    //   if (!this._datum_to_pin[datum_node_id]) {
    //     const a = this._nodes[datum_node_id]
    //     const dx = a._x - cx
    //     const dy = a._y - cy
    //     const r = Math.sqrt(dx * dx + dy * dy)
    //     let k = ((RD - r) * alpha) / r
    //     a.ax += dx * k
    //     a.ay += dy * k
    //   }
    // }
  }

  private _force_custom_layer_err = (alpha: number): void => {
    for (const err_node_id in this._err_node) {
      const { unitId } = segmentErrNodeId(err_node_id)

      if (this._err[unitId]) {
        const a = this._node[err_node_id]

        a.ay -= 3 * alpha
      }
    }
  }

  private _force_custom_layer_type = (alpha: number): void => {
    for (const link_id in this._type_link) {
      const link = this._type_link[link_id]
      const { source_id, target_id } = link
      // PERF
      if (this._is_pin_node_id(target_id) || this._is_unit_node_id(target_id)) {
        const a = this._node[source_id]
        a.ay -= 9 * alpha
      }
    }
  }

  private _force_custom: ((alpha: number) => void)[] = [
    this._force_custom_layer_none, // 0
    this._force_custom_layer_normal, // 1
    this._force_custom_layer_collapse, // 2
    this._force_custom_layer_search, // 3
    this._force_custom_layer_ignored, // 4
    this._force_custom_layer_exposed, // 5
    this._force_custom_layer_data_linked, // 6
    this._force_custom_layer_data, // 7
    this._force_custom_layer_err, // 8
    this._force_custom_layer_type, // 9
  ]

  private _force = (alpha: number): void => {
    // console.log(this._link)

    for (let i = this._simulation_layer; i < this._layer_node.length; i++) {
      const layer_node = this._layer_node[i]

      const layer_node_entry = Object.entries(layer_node)

      const layer_node_entry_n = layer_node_entry.length

      for (let ii = 0; ii < layer_node_entry_n; ii++) {
        const [a_id, a] = layer_node_entry[ii]

        const { layer: a_layer } = a

        const a_sg = this._node_to_subgraph[a_id]
        const a_max_link_heap = this._node_max_link_length_heap[a_id]

        const a_shrink = clamp(
          a_max_link_heap?.value.l / a_max_link_heap?.value.t ?? 1,
          1,
          Infinity
        )

        for (let jj = ii + 1; jj < layer_node_entry_n; jj++) {
          const [b_id, b] = layer_node_entry[jj]

          const { layer: b_layer } = b

          const b_sg = this._node_to_subgraph[b_id]

          const surface_d = _surfaceDistance(
            a.shape,
            a._x,
            a._y,
            a.r,
            a.width,
            a.height,
            b.shape,
            b._x,
            b._y,
            b.r,
            b.width,
            b.height
          )

          const { u } = surface_d

          let { l, d } = surface_d

          l = Math.max(l, 1)
          d = Math.max(d, 1)

          const L = this.__sim_max_l(a_layer, b_layer, a_sg, b_sg)

          if (l < L) {
            const mab: number = this._sim_relative_layer_m(
              a_layer,
              b_layer,
              NODE_MASS_RELATIVE
            )
            const mba: number = this._sim_relative_layer_m(
              b_layer,
              a_layer,
              NODE_MASS_RELATIVE
            )

            const k = (-90 * alpha) / l

            let kb = mab * k
            let ka = mba * k

            const charge_ab = this._node_charge[a_id]?.[b_id] ?? 1
            const charge_ba = this._node_charge[b_id]?.[a_id] ?? 1

            const z_ab = (b.ax -= u.x * kb * charge_ab)

            b.ay -= u.y * kb * charge_ab
            a.ax += u.x * ka * charge_ba
            a.ay += u.y * ka * charge_ba
          }
        }

        for (let l = i - 1; l >= 0; l--) {
          const prev_layer_node = this._layer_node[l]
          const prev_layer_node_entry = Object.entries(prev_layer_node)
          const prev_layer_node_entry_n = prev_layer_node_entry.length

          for (let j = 0; j < prev_layer_node_entry_n; j++) {
            const [b_id, b] = prev_layer_node_entry[j]

            const { layer: b_layer } = b

            const b_sg = this._node_to_subgraph[b_id]

            let { l, u, d } = _surfaceDistance(
              a.shape,
              a._x,
              a._y,
              a.r,
              a.width,
              a.height,
              b.shape,
              b._x,
              b._y,
              b.r,
              b.width,
              b.height
            )

            l = Math.max(l, 1)

            const L = this.__sim_max_l(a_layer, b_layer, a_sg, b_sg)

            if (l < L) {
              const m: number = this._sim_relative_layer_m(
                b_layer,
                a_layer,
                NODE_MASS_RELATIVE
              )

              let k = (-90 * alpha * m) / l

              const charge_ba = this._node_charge[b_id]?.[a_id] ?? 1

              if (a.fx === undefined) {
                a.ax += u.x * k * charge_ba
              }

              if (a.fy === undefined) {
                a.ay += u.y * k * charge_ba
              }
            }
          }
        }
      }

      const layer_link = this._layer_link[i]

      for (const link_id in layer_link) {
        const link = layer_link[link_id]

        const { s, source_id: a_id, target_id: b_id } = link

        const a = this._node[a_id]
        const b = this._node[b_id]

        const { layer: a_layer } = a
        const { layer: b_layer } = b

        const mab: number = this._sim_relative_layer_m(
          a_layer,
          b_layer,
          LINK_MASS_RELATIVE
        )
        const mba: number = this._sim_relative_layer_m(
          b_layer,
          a_layer,
          LINK_MASS_RELATIVE
        )

        let { l, d } = _surfaceDistance(
          a.shape,
          a._x,
          a._y,
          a.r,
          a.width,
          a.height,
          b.shape,
          b._x,
          b._y,
          b.r,
          b.width,
          b.height
        )

        l = Math.max(l, 1)
        d = Math.max(d, 1)

        const tl = link.l

        const z = tl / l

        deepSet(this._node_z, [a_id, link_id], z)
        deepSet(this._node_z, [b_id, link_id], z)

        const ax = a._x
        const bx = b._x
        const ay = a._y
        const by = b._y

        const k = (s * ((l - tl) * alpha)) / d

        const dvx = (bx - ax) * k
        const dvy = (by - ay) * k

        b.ax -= dvx * mab
        b.ay -= dvy * mab
        a.ax += dvx * mba
        a.ay += dvy * mba
      }

      this._force_custom[i](alpha)
    }
  }

  private _on_simulation_tick = (): void => {
    this._tick()
  }

  private _tick = (): void => {
    // console.log('Graph', '_tick')

    for (const node_id in this._node) {
      this._tick_node(node_id)
    }

    for (const link_id in this._link) {
      this._tick_link(link_id)
    }

    if (this._minimap) {
      this._tick_minimap()
    }
  }

  private _on_simulation_end = (): void => {
    // console.log('Graph', '_on_simulation_end')

    this._simulation_end = true
  }

  private _get_layout_node_anchor_id = (node_id: string): string => {
    let anchor_id = node_id
    let parent_id = this._layout_sub_component_parent[anchor_id]
    while (parent_id && !this._layout_path.includes(parent_id)) {
      anchor_id = parent_id
      parent_id = this._layout_sub_component_parent[anchor_id]
    }
    return anchor_id
  }

  private _set_layout_core_position = (
    sub_component_id: string,
    x: number,
    y: number
  ): void => {
    // console.log('Graph', '_set_layout_core_position', sub_component_id, x, y)

    const layout_core = this._layout_core[sub_component_id]

    layout_core.$element.style.left = `calc(50% + ${x}px)`
    layout_core.$element.style.top = `calc(50% + ${y}px)`

    const layout_node = this._layout_node[sub_component_id]

    layout_node.x = x
    layout_node.y = y

    if (this._control_lock) {
      if (this._minimap) {
        this._tick_minimap()
      }
    }

    if (!this._search_hidden) {
      if (this._search_unit_id === sub_component_id) {
        if (sub_component_id === this._search_unit_id) {
          const parent_layout_layer =
            this._ensure_parent_layout_layer(sub_component_id)
          const { scrollHeight } = parent_layout_layer.layer.$element
          this._refresh_layout_component_scroll(
            sub_component_id,
            scrollHeight,
            'up',
            1,
            NOOP
          )
        }
      }
    }
  }

  private _set_layout_core_position_x = (
    sub_component_id: string,
    x: number
  ): void => {
    // console.log('Graph', '_set_layout_core_position_x', sub_component_id, x)

    const layout_core = this._layout_core[sub_component_id]

    layout_core.$element.style.left = `calc(50% + ${x}px)`

    const layout_node = this._layout_node[sub_component_id]

    layout_node.x = x
  }

  private _set_layout_core_position_y = (
    sub_component_id: string,
    y: number
  ): void => {
    // console.log('Graph', '_set_layout_core_position_y', sub_component_id, y)

    const layout_core = this._layout_core[sub_component_id]

    layout_core.$element.style.top = `calc(50% + ${y}px)`

    const layout_node = this._layout_node[sub_component_id]

    layout_node.y = y
  }

  private _get_datum_spec = (datum_node_id: string): DatumSpec => {
    const value = this._get_datum_value(datum_node_id)

    const position = this._get_node_position(datum_node_id)

    const datum_spec: DatumSpec = { value, metadata: { position } }

    return datum_spec
  }

  private _set_spec_data = (spec: GraphSpec): void => {
    for (const datum_node_id in this._visible_unlinked_data_node) {
      const { datumId } = segmentDatumNodeId(datum_node_id)

      const datum_spec: DatumSpec = this._get_datum_spec(datum_node_id)

      deepSet_(spec, ['data', datumId], datum_spec)
    }
  }

  private _get_full_user_spec = (): GraphSpec => {
    const spec = clone(this._spec)

    delete spec.system

    spec.units = spec.units ?? {}

    this._set_spec_data(spec)

    if (this._is_component()) {
      this._spec.type = '`U`&`G`&`C`'
    } else {
      this._spec.type = '`U`&`G`'
    }

    return spec
  }

  private _is_component = () => {
    return isComponentSpec(this._spec)
  }

  private _set_spec_nodes_position = (spec: GraphSpec): void => {
    const position_map = this.get_nodes_center_relative_positions(this._node)

    this._set_spec_node_positions(spec, this, position_map)
  }

  private _pod_unlisten: Unlisten

  private _set_units_position = (units: GraphUnitsSpec): void => {
    const position_map = this._nodes_cm_position_map(units)

    for (const unit_id in units) {
      const unit = units[unit_id]

      const position = position_map[unit_id]

      unit.metadata = unit.metadata || {}
      unit.metadata.position = position
    }
  }

  private _pod_started = false

  private _setup_pod = (pod: $Graph) => {
    if (this._pod_started) {
      return
    }

    // console.trace('Graph', '_setup_pod')

    this._listen_pod(pod)
    this._start_debugger()
  }

  private _download_pod_data = () => {
    this.__download_pod_data(this._pod)
  }

  private __download_pod_data = (pod: $Graph) => {
    pod.$getAllPinData({}, (pinData) => {
      this._process_unit_io_all_data(pinData)
    })

    pod.$getGraphPinData({}, (state) => {
      this._process_graph_all_pin_data(state)
    })

    pod.$getGraphMergeInputData({}, (state: Dict<any>) => {
      this._process_graph_all_merge_data(state)
    })

    pod.$getGraphErr({}, (unit_err: Dict<string>) => {
      this._process_graph_all_err(unit_err)
    })
  }

  private _listen_pod = (pod: $Graph) => {
    // console.log('Graph', '_listen_pod', this._id)

    this._pod_started = true

    this.__download_pod_data(pod)

    this._pod_unlisten = callAll([
      pod.$watch(
        {
          events: [
            'pause',
            'fork',
            'set_name',
            'input',
            'output',
            'ref_input',
            'ref_output',
            'add_unit',
            'clone_unit',
            'remove_unit',
            'move_unit',
            'expose_pin_set',
            'cover_pin_set',
            'expose_pin',
            'cover_pin',
            'plug_pin',
            'unplug_pin',
            'add_pin_to_merge',
            'remove_pin_from_merge',
            'add_merge',
            'remove_merge',
            'move_subgraph_into',
            'move_subgraph_out_of',
            'reorder_sub_component',
            'move_sub_component_root',
            'set_unit_id',
            'set_pin_set_id',
            'set_unit_pin_constant',
            'set_unit_pin_ignored',
            'set_unit_pin_data',
            'set_unit_pin_set_id',
            'remove_unit_pin_data',
            'set_pin_set_functional',
            'set_pin_set_default_ignored',
            'bulk_edit',
            'set_metadata',
            'destroy',
          ],
        },
        this._on_moment
      ),
      pod.$watchGraph(
        {
          events: [
            'fork',
            'append_child',
            'remove_child',
            'insert_child',
            'input',
            'output',
            'ref_input',
            'ref_output',
            'err',
            'take_err',
            'catch_err',
          ],
        },
        this._on_graph_moment
      ),
    ])
  }

  private _process_io_active_data = (io_data: IOOf<Dict<any>>) => {
    const { input, output } = io_data

    this._unit_debug_reset_pins_data('input', keys(input), input)
    this._unit_debug_reset_pins_data('output', keys(input), output)
  }

  private _process_unit_io_all_data = (io_data: IOOf<Dict<any>>) => {
    const { input, output } = io_data

    const { inputs = {}, outputs = {} } = this._spec

    this._unit_debug_reset_pins_data('input', keys(inputs), input)
    this._unit_debug_reset_pins_data('output', keys(outputs), output)
  }

  private _unit_debug_reset_pins_data = (
    type: IO,
    pin_ids: string[],
    pins_data: Dict<any>
  ) => {
    for (const pin_id of pin_ids) {
      const data = pins_data[pin_id]

      this._unit_debug_reset_pin_data(type, pin_id, data)
    }
  }

  private _unit_debug_reset_pin_data = (
    type: IO,
    pin_id: string,
    data: any
  ) => {
    if (data === undefined) {
      if (this._unit_datum[type][pin_id] !== undefined) {
        this._sim_remove_pin_data(type, pin_id)
      }
    } else {
      this._sim_set_pin_set_data(type, pin_id, data)
    }
  }

  private _process_graph_active_pin_data = (
    state: Dict<IOOf<Dict<any>>>
  ): void => {
    // console.log('Graph', '_process_graph_active_pin_data', state)

    this._process_graph_io_data(keys(state), state)
  }

  private _process_graph_all_pin_data = (state: Dict<IOOf<Dict<any>>>) => {
    // console.log('Graph', '_process_graph_all_pin_data', state)

    const unit_ids = this._get_unit_ids()

    this._process_graph_io_data(unit_ids, state)
  }

  private _process_graph_io_data = (
    unit_ids: string[],
    state: Dict<IOOf<Dict<any>>>
  ): void => {
    // console.log('Graph', '_process_graph_io_data', unit_ids, state)

    for (const unit_id of unit_ids) {
      const unit_io_data = state[unit_id] || { input: {}, output: {} }

      this._process_graph_unit_io_data(unit_id, unit_io_data)
    }
  }

  private _process_graph_unit_io_data = (
    unit_id: string,
    io_data: IOOf<Dict<any>>
  ) => {
    const { input, output } = io_data

    this._process_graph_unit_pin_data(unit_id, 'input', keys(input), input)
    this._process_graph_unit_pin_data(unit_id, 'output', keys(output), output)
  }

  private _process_graph_unit_pin_data = (
    unit_id: string,
    type: IO,
    pin_ids: string[],
    pin_data: Dict<any>
  ) => {
    for (const pin_id of pin_ids) {
      const data = pin_data[pin_id]
      const pin_node_id = getPinNodeId(unit_id, type, pin_id)

      const current_data = this._get_pin_datum_value(pin_node_id)

      if (data !== current_data) {
        this._graph_debug_refresh_pin_data(pin_node_id, data)
      }
    }
  }

  private _for_each_spec_merge = (
    callback: (
      merge_node_id: string,
      merge_id: string,
      merge: GraphMergeSpec
    ) => void
  ) => {
    const merges = this._spec_get_merges()

    for (const merge_id in merges) {
      const merge_node_id = getMergeNodeId(merge_id)

      const merge = merges[merge_id]

      callback(merge_node_id, merge_id, merge)
    }
  }

  private _process_graph_active_merge_data = (state: Dict<any>): void => {
    this.__process_graph_merge_data(keys(state), state)
  }

  private __process_graph_merge_data = (
    merge_ids: string[],
    state: Dict<any>
  ): void => {
    for (const merge_id of merge_ids) {
      const merge_node_id = getMergeNodeId(merge_id)
      const data = state[merge_id]
      this._graph_debug_refresh_pin_data(merge_node_id, data)
    }
  }

  private _process_graph_all_merge_data = (state: Dict<any>): void => {
    const merges = this._spec_get_merges()
    this.__process_graph_merge_data(keys(merges), state)
  }

  private _process_graph_active_err = (unit_err: Dict<string>): void => {
    this._process_graph_err(keys(unit_err), unit_err)
  }

  private _process_graph_all_err = (unit_err: Dict<string>): void => {
    const units = this.get_units()

    this._process_graph_err(keys(units), unit_err)
  }

  private _process_graph_err = (
    unit_ids: string[],
    unit_err: Dict<string>
  ): void => {
    for (const unit_id of unit_ids) {
      const err = unit_err[unit_id]
      if (err) {
        this._graph_debug_set_unit_err(unit_id, err)
      } else {
        if (this._err[unit_id]) {
          this._graph_debug_take_err(unit_id)
        }
      }
    }
  }

  private _process_graph_active_children = (children: Dict<any>): void => {
    this._process_graph_children(keys(children), children)
  }

  private _process_graph_all_children = (children: Dict<any>): void => {
    const unit_ids = this._get_unit_ids()

    this._process_graph_children(unit_ids, children)
  }

  private _process_graph_children = (
    sub_component_ids: string[],
    children: Dict<any>
  ): void => {
    for (const sub_component_id of sub_component_ids) {
      const unit_children = children[sub_component_id]

      this._graph_children[sub_component_id] = unit_children
    }
  }

  private _start_move_subgraph_into(
    graphId: string,
    data: GraphMoveSubGraphData
  ) {
    const position = this._jiggle_world_screen_center()

    let there_is_selected_sub_component = false

    for (const unitId of data.nodeIds.unit ?? []) {
      if (this._is_unit_component(unitId)) {
        there_is_selected_sub_component = true
      }

      this._start_node_long_press_collapse(unitId)
    }

    for (const linkPin of data.nodeIds.link ?? []) {
      const { unitId, type, pinId } = linkPin

      const pin_node_id = getPinNodeId(unitId, type, pinId)

      this._start_node_long_press_collapse(pin_node_id)
    }

    for (const mergeId of data.nodeIds.merge ?? []) {
      const merge_node_id = getMergeNodeId(mergeId)

      const anchor_node_id = this._get_merge_anchor_node_id(merge_node_id)

      this._start_node_long_press_collapse(anchor_node_id)
    }

    for (const plugSpec of data.nodeIds.plug ?? []) {
      const { type, pinId, subPinId } = plugSpec

      const plug_node_id = getExtNodeId(type, pinId, subPinId)

      this._start_node_long_press_collapse(plug_node_id)
    }

    this._collapse_init_node_id_set = new Set(this._collapse_node_id)

    const should_predict_size =
      this._get_unit_spec_render(graphId) === undefined &&
      there_is_selected_sub_component
    const do_not_animate_graph_size =
      this._get_unit_spec_render(graphId) !== undefined

    this._state_move_subgraph_into(
      graphId,
      data,
      should_predict_size,
      do_not_animate_graph_size,
      position,
      true
    )
  }

  private async _open_file() {
    const {
      api: {
        file: {
          isOpenFilePickerSupported,
          showOpenFilePicker,
          fallbackShowOpenFilePicker,
        },
      },
    } = this.$system

    const opt = {
      startIn: 'desktop',
      id: 'unit',
      types: [
        {
          description: 'unit',
          accept: {
            'data/*': ['.unit'],
          },
        },
      ],
      excludeAcceptAllOption: false,
      multiple: false,
      accept: '.unit',
    }

    if (isOpenFilePickerSupported() && false) {
      try {
        const [fileHandle] = await showOpenFilePicker(opt)

        const file = await fileHandle.getFile()

        this._drop_file(file)
      } catch (err) {
        return
      }
    } else {
      try {
        const [file] = await fallbackShowOpenFilePicker(opt)

        this._drop_file(file)
      } catch (err) {
        return
      }
    }
  }

  private _on_background_click_hold(
    screenX: number,
    screenY: number,
    event: UnitPointerEvent
  ) {
    let should_start_gesture = false
    let should_animate_long_press = false

    if (this._tree_layout) {
      //
    } else {
      if (this._mode === 'multiselect') {
        this._on_background_long_press(event)
      } else if (this._mode === 'info') {
        should_start_gesture = true
      } else {
        should_start_gesture = true
        should_animate_long_press = true
      }
    }

    if (should_start_gesture) {
      this._animate_pulse(screenX, screenY, 'in')

      if (!this._capturing_gesture) {
        this._start_gesture(event)
      }
    }
  }

  public moment(
    path: string[],
    data: { type: 'unit' | 'graph'; moment: Moment }
  ): void {
    if (path.length > 0) {
      const [first, ..._path] = path
      if (first === this._subgraph_unit_id) {
        const subgraph = this._subgraph_cache[first]
        subgraph.moment(_path, data)
      } else {
        // swallow (async) debug moment if subgraph not visible
        return
      }
    } else {
      const { type, moment } = data
      if (type === 'unit') {
        this._on_moment(moment)
      } else {
        this._on_graph_moment(moment)
      }
    }
  }

  private _graph_children: Dict<any> = {}

  private _graph_debug_refresh_pin_data = (
    pin_node_id: string,
    data: string | undefined
  ): void => {
    // console.log('Graph', '_graph_debug_refresh_pin_data', pin_node_id, data)

    if (data === undefined) {
      this._graph_debug_drop_pin_data(pin_node_id)
    } else {
      this._graph_debug_set_pin_value(pin_node_id, data)
    }
  }

  private _plunk_pod = (): void => {
    if (!this._pod_started) {
      return
    }

    this._unlisten_pod()
    this._pause_debugger()
    this._clear_debugger()
  }

  private _unlisten_pod = (): void => {
    if (!this._pod_started) {
      return
    }

    // console.log('Graph', '_unlisten_pod')

    this._pod_started = false

    this._pod_unlisten()
    this._pod_unlisten = undefined
  }

  private _start_debugger = (): void => {
    // console.log('Graph', '_start_debugger', this._id)

    const {
      api: {
        window: { setInterval },
      },
    } = this.$system

    if (this._debug_interval !== null) {
      return
    }

    this._debug_interval = setInterval(() => {
      if (this._debug_cursor < this._debug_buffer.length - 1) {
        this._step_debugger()
      } else {
        this._pause_debugger()
      }
    }, 0)
  }

  private _step_debugger = (direction: 1 | -1 = 1): void => {
    // console.log('Graph', '_step_debugger')

    if (direction === 1 && this._debug_cursor < this._debug_buffer.length - 1) {
      this._debug_cursor++
      const moment = this._debug_buffer[this._debug_cursor]
      this._debug_moment(moment)
    } else if (direction === -1 && this._debug_cursor >= 0) {
      const moment = this._debug_buffer[this._debug_cursor]
      this._debug_moment(getOppositeMoment(moment))
      this._debug_cursor--
    } else {
      throw new ShouldNeverHappenError()
    }
  }

  private _debug_stop: boolean = false

  private _stop_debugger = (): void => {
    // console.log('Graph', '_stop_debugger', this._id)

    this._debug_stop = true

    this._pause_debugger()
  }

  private _pause_debugger = (): void => {
    // console.log('Graph', '_pause_debugger', this._id)

    if (this._debug_interval !== null) {
      clearInterval(this._debug_interval)

      this._debug_interval = null
    }
  }

  private _get_unit_pin_random_position = (unit_id: string): Position => {
    const unit_node = this._node[unit_id]
    const { x, y, shape, r } = unit_node
    if (shape === 'circle') {
    } else {
    }
    const position = randomInRadius(x, y, r + LINK_DISTANCE + PIN_RADIUS)
    return position
  }

  private _on_graph_unit_expose_pin = (data: GraphExposePinEventData): void => {
    // console.log('Graph', '_on_graph_unit_expose_pin', data)

    const { setSpec, specs, parent } = this.$props

    const { path } = data

    const graphUnitId = path[0]

    if (this._is_spec_updater(path)) {
      const { type, pinId, subPinId, subPinSpec, path } = data

      const spec = clone(findSpecAtPath(specs, this._spec, path))

      exposePin({ pinId, type, subPinId, subPinSpec }, spec)

      setSpec(spec.id, spec)
    }
  }

  private _on_graph_unit_cover_pin = (data: GraphExposePinEventData): void => {
    // console.log('Graph', '_on_graph_unit_cover_pin', data)

    const { type, pinId, subPinId, subPinSpec, path } = data

    const { setSpec, specs } = this.$props

    const { parent } = this.$props

    if (this._is_spec_updater(path)) {
      const { type, pinId, subPinId, path } = data

      const spec = clone(findSpecAtPath(specs, this._spec, path))

      coverPin({ pinId, type, subPinId }, spec)

      setSpec(spec.id, spec)
    }
  }

  private _on_graph_unit_expose_pin_set = (
    data: GraphExposedPinSetMomentData
  ): void => {
    // console.log('Graph', '_on_graph_unit_expose_pin_set', data)

    const { setSpec, specs, parent } = this.$props

    const { type, pinId, pinSpec, path } = data

    if (this._is_spec_updater(path)) {
      const spec = findSpecAtPath(specs, this._spec, path)

      const next_spec = clone(spec)

      const ref = isPinSpecRef(specs, next_spec, type, pinSpec)

      exposePinSet({ type, pinId, pinSpec: clone(pinSpec) }, next_spec)

      setPinSetRef({ type, pinId, ref }, next_spec)

      setSpec(next_spec.id, next_spec)

      if (path.length === 1) {
        const unitId = path[0]

        const pin_node_id = getPinNodeId(unitId, type, pinId)

        if (!this._pin_node[pin_node_id]) {
          const unit_spec_id = this._get_unit_spec_id(unitId)

          const unit_spec = this._get_unit_spec(unitId) as GraphSpec

          const position = this._get_unit_pin_random_position(unitId)

          this._sim_add_link_pin_node(unitId, type, pinId, position)
          this._sim_add_link_pin_link(unitId, type, pinId)
        } else {
          //
        }

        if (data.data !== undefined) {
          const value = stringify(data.data)

          this._graph_debug_set_pin_value(pin_node_id, value)
        }
      }
    }
  }

  private _on_graph_unit_set_unit_id = (data: GraphSetUnitIdMomentData) => {
    // console.log('Graph', '_on_graph_unit_set_unit_id', data)

    const { setSpec, specs, parent } = this.$props

    const { unitId, newUnitId, name, path } = data

    if (this._is_spec_updater(path)) {
      const spec = clone(findSpecAtPath(specs, this._spec, path))

      setUnitId({ unitId, newUnitId, name }, spec)

      setSpec(spec.id, spec)

      if (path.length === 0) {
        this._spec = spec
      }
    }
  }

  private _spec_remove_unit_pin = (unitId: string, type: IO, pinId: string) => {
    // console.log('Graph', '_spec_remove_unit_pin', unitId, type, pinId)

    deepDelete(this._spec, ['units', unitId, type, pinId])
  }

  private _on_graph_unit_cover_pin_set = (
    data: GraphExposedPinSetMomentData
  ): void => {
    // console.log('Graph', '_on_graph_unit_cover_pin_set', data)

    const { setSpec, forkSpec, specs, parent } = this.$props

    const { type, pinId, path } = data

    const unitId = path[0]

    if (path.length === 1) {
      this._sim_graph_remove_unit_pin(unitId, type, pinId)

      this._spec_remove_unit_pin(unitId, type, pinId)
    }

    if (this._is_spec_updater(path)) {
      const spec = clone(findSpecAtPath(specs, this._spec, path))

      coverPinSet({ type, pinId }, spec)

      setSpec(spec.id, spec)

      if (path.length >= 1) {
        const unit_id = last(path)
        const parent_path = butLast(path)

        let [parent_spec_id, parent_spec] = forkSpec(
          findSpecAtPath(specs, this._spec, parent_path)
        )

        parent_spec = clone(parent_spec)

        const pin_plug = findUnitPinPlug(parent_spec, unit_id, type, pinId)

        deepDelete(parent_spec, ['units', unit_id, type, pinId])

        if (pin_plug) {
          const plug_count = getPlugCount(parent_spec, type, pinId)

          unplugPin(pin_plug, parent_spec)
        }

        setSpec(parent_spec.id, parent_spec)
      }
    }
  }

  private _graph_component_children: Dict<{ id: string; state: Dict<any> }[]> =
    {}

  private _on_set_pin_set_functional = (
    data: GraphSetPinSetFunctionalMomentData
  ): void => {
    // console.log('Grapb', '_on_set_pin_set_functional', data)
  }

  private _on_set_pin_set_default_ignored = (
    data: GraphSetPinSetDefaultIgnoredMomentData
  ): void => {
    // console.log('Graph', '_on_set_pin_set_default_ignored', data)
  }

  private _componentify_core = (
    unit_id: string,
    sub_component_map: Dict<Component>,
    should_add_component: boolean = true
  ): void => {
    // console.log('Graph', '_componentify_core', unit_id)

    this._set_core_shape(unit_id, 'rect')
    this._spec_append_component(null, unit_id)
    this._sim_add_core_component(unit_id, null, { x: 0, y: 0 })

    this._mem_add_unit_component(unit_id, sub_component_map)
    this._mem_add_unit_component_parent(unit_id)

    if (this._subgraph_unit_id === unit_id) {
      //
    } else {
      should_add_component && this._place_sub_component(unit_id)
    }

    const ref_merge_node_id = this._ref_unit_to_merge[unit_id]

    if (ref_merge_node_id) {
      const { mergeId } = segmentMergeNodeId(ref_merge_node_id)

      this._for_each_merge_pin(mergeId, (unitId, type, pinId) => {
        if (type === 'input') {
          const pin_node_id = getPinNodeId(unitId, type, pinId)

          this._refresh_link_pin_marker(pin_node_id, unit_id)
        }
      })
    }

    this._connect_sub_component(unit_id)

    this._hide_core_icon(unit_id)
  }

  private _decomponentify_core = (
    unit_id: string,
    displace: boolean = true
  ): void => {
    // console.log('Graph', '_decomponentify_core', unit_id, displace)

    if (this._subgraph_unit_id === unit_id) {
      //
    } else {
      displace && this._displace_sub_component(unit_id)
    }

    this._sim_remove_component(unit_id, false, false)
    this._mem_remove_component(unit_id)
    this._spec_remove_component(unit_id)

    this._set_core_shape(unit_id, 'circle')

    this._show_core_icon(unit_id)
  }

  private _on_fork_moment = (data: GraphForkMomentData) => {
    // console.log('Graph', '_on_fork_moment', data)

    const { spec, path } = data

    if (path.length === 0) {
      this._spec.id = spec.id
    }
  }

  private _on_add_unit_moment = (data: GraphAddUnitMomentData): void => {
    // console.log('Graph', '_on_add_unit_moment', data)

    const { unitId, bundle, path } = data

    if (path.length === 0) {
      const position = this._jiggle_world_screen_center()

      const { unit } = bundle

      this._spec_add_unit(unitId, unit)

      if (this._is_unit_component(unitId)) {
        this._spec_append_component(null, unitId)
      }

      this._sim_add_unit(
        unitId,
        unit,
        position,
        {},
        { input: {}, output: {} },
        null
      )

      if (this._is_unit_component(unitId)) {
        this._sim_add_sub_component(unitId)

        this._connect_sub_component(unitId)
      }
    } else {
      this._on_graph_unit_add_unit_moment(data)
    }
  }

  private _on_clone_unit_moment = (unitId: string, newUnitId: string): void => {
    // console.log('Graph', '_on_clone_unit_moment', unitId, newUnitId)
  }

  private _on_unit_pause_moment = () => {
    this._flush_debugger()
  }

  private _on_graph_unit_fork_moment = (
    data: GraphForkMomentData & { unitId: string }
  ) => {
    // console.log('Graph', '_on_graph_unit_fork_moment', data)

    const {
      fork,
      specs,
      getSpec,
      setSpec,
      forkSpec,
      registerUnit,
      unregisterUnit,
    } = this.$props

    let { specId, spec: forked_unit_spec, path, unitId, bubble = true } = data

    if (!unitId) {
      return
    }

    if (path.length === 0) {
      this._spec_fork_unit(unitId, forked_unit_spec.id)
      this._sim_fork_unit(unitId, forked_unit_spec.id)
    } else {
      const spec = this._get_unit_spec(unitId) as GraphSpec

      const parent_path = path.slice(0, -1)

      const next_parent_spec = clone(
        findSpecAtPath(specs, spec, parent_path) as GraphSpec
      )

      const forked_unit_id = last(path)

      deepSet(
        next_parent_spec,
        ['units', forked_unit_id, 'id'],
        forked_unit_spec.id
      )

      setSpec(forked_unit_spec.id, forked_unit_spec)
      setSpec(next_parent_spec.id, next_parent_spec)

      this._register_spec(forked_unit_spec.id, false)
    }
  }

  private _on_graph_unit_set_name_moment = (
    data: GraphSetNameMomentData & { unitId: string }
  ) => {
    const { setSpec, specs } = this.$props

    const { name, path } = data

    if (this._is_spec_updater(path)) {
      const next_spec = clone(findSpecAtPath(specs, this._spec, path))

      setName({ name }, next_spec)

      setSpec(next_spec.id, next_spec)
    }
  }

  private _sim_fork_unit = (unit_id: string, next_spec_id: string): void => {
    //
  }

  private _spec_fork_unit = (
    unit_id: string,
    next_spec_id: string,
    unit_spec?: GraphSpec
  ): void => {
    // console.log('_spec_fork_unit', unit_id, next_spec_id)

    const { specs, setSpec, registerUnit, unregisterUnit } = this.$props

    const unit_spec_id = this._get_unit_spec_id(unit_id)

    unit_spec = clone(unit_spec ?? (this._get_unit_spec(unit_id) as GraphSpec))

    this._spec.units[unit_id].id = next_spec_id

    delete unit_spec.system

    unit_spec.id = next_spec_id

    setSpec(next_spec_id, unit_spec)

    this.__register_spec(this._system, next_spec_id, false)
    this._unregister_spec(unit_spec_id, false)
  }

  private _is_spec_updater = (path: string[]): boolean => {
    const { parent } = this.$props

    const graphUnitId: string = path[0]

    return !!(
      !this._subgraph_cache[graphUnitId] ||
      (path.length === 1 && last(path) === graphUnitId)
    )
  }

  private _spec_graph_unit_add_unit = (
    graph_id: string,
    unitId: string,
    unit: GraphUnitSpec
  ) => {
    // console.log('Graph', graph_id, unitId, unit)

    const { setSpec } = this.$props

    const graph_spec_id = this._get_unit_spec_id(graph_id)
    const graph_spec = this._get_unit_spec(graph_id) as GraphSpec

    const next_graph_spec = clone(graph_spec)

    addUnit({ unitId, unit }, next_graph_spec)

    setSpec(graph_spec_id, next_graph_spec)
  }

  private _on_graph_unit_clone_unit_moment = (
    data: GraphCloneUnitMomentData
  ) => {
    // console.log('Graph', '_on_graph_unit_clone_unit_moment', data)

    const { specs } = this.$props

    const { unitId, newUnitId, path } = data

    const unit_spec = findSpecAtPath(specs, this._spec, path)

    const graph_unit_spec = unit_spec.units[unitId]

    const bundle = unitBundleSpec(graph_unit_spec, specs)

    const _data: GraphAddUnitMomentData = {
      unitId: newUnitId,
      bundle,
      path,
    }

    this._on_graph_unit_add_unit_moment(_data)
  }

  private _on_graph_unit_add_unit_moment = (
    data: GraphAddUnitMomentData
  ): void => {
    // console.log('Graph', '_on_graph_unit_add_unit_moment', data, this._id)

    const { setSpec, getSpec, specs, parent } = this.$props

    const { unitId, bundle, path, parentId } = data

    const added_unit_spec_id = bundle.unit.id

    const added_unit_spec = getSpec(added_unit_spec_id) as GraphSpec
    const added_unit_spec_render = added_unit_spec.render
    const added_unit_is_component = isComponentId(
      weakMerge(bundle.specs ?? {}, specs),
      added_unit_spec_id
    )

    const graph_unit_id = path[0]
    const graph_unit_is_component = this._is_unit_component(graph_unit_id)
    const graph_unit_spec_render = this._get_unit_spec_render(graph_unit_id)

    const pod = this._pod.$refUnit({
      unitId: graph_unit_id,
      _: UCGEE,
    }) as $Graph

    const spec = findSpecAtPath(
      weakMerge(bundle.specs ?? {}, specs),
      this._spec,
      path
    )

    const parent_spec_id = spec.id
    const parent_spec_render = spec.render

    let next_spec = clone(spec)

    if (this._is_spec_updater(path)) {
      addUnit({ unitId, unit: bundle.unit }, next_spec)

      next_spec.metadata = next_spec.metadata || {}

      delete next_spec.metadata.complexity

      next_spec.component = next_spec.component ?? {}

      if (added_unit_is_component) {
        setSubComponent({ unitId, subComponent: {} }, next_spec.component)

        if (parentId) {
          appendSubComponentChild(
            { parentId, childId: unitId },
            next_spec.component
          )
        } else {
          appendRoot({ childId: unitId }, next_spec.component)
        }

        const { component: added_component_spec } = added_unit_spec

        const { defaultWidth = 120, defaultHeight = 120 } = added_component_spec

        next_spec.component.defaultWidth =
          next_spec.component.defaultWidth || defaultWidth
        next_spec.component.defaultHeight =
          next_spec.component.defaultHeight || defaultHeight

        next_spec.type = `\`U\`&\`G\`&\`C\``
      }

      setSpec(next_spec.id, next_spec)

      this._register_unit(bundle.unit.id)
    }

    const graph_unit_spec = this._get_unit_spec(graph_unit_id) as GraphSpec

    const next_graph_unit_spec =
      path.length === 1 ? next_spec : clone(graph_unit_spec)

    let all_added_unit_ancestors_are_component = true

    for (let i = path.length - 1; i >= 0; i--) {
      const sub_path = path.slice(0, i + 1)

      const ancestor_spec = findSpecAtPath(specs, this._spec, sub_path)

      all_added_unit_ancestors_are_component =
        all_added_unit_ancestors_are_component &&
        (isComponentSpec(ancestor_spec) ||
          getSpecRender(ancestor_spec) === undefined)
    }

    if (added_unit_is_component && all_added_unit_ancestors_are_component) {
      const just_turned_component_unit_id = path[1] ?? unitId

      next_graph_unit_spec.component = next_graph_unit_spec.component ?? {}

      if (
        !hasSubComponent(next_graph_unit_spec, just_turned_component_unit_id)
      ) {
        setSubComponent(
          { unitId: just_turned_component_unit_id, subComponent: {} },
          next_graph_unit_spec.component
        )
        appendRoot(
          { childId: just_turned_component_unit_id },
          next_graph_unit_spec.component
        )

        const { component: added_component_spec } = added_unit_spec

        const { defaultWidth = 120, defaultHeight = 120 } = added_component_spec

        next_graph_unit_spec.component.defaultWidth =
          next_graph_unit_spec.component.defaultWidth || defaultWidth
        next_graph_unit_spec.component.defaultHeight =
          next_graph_unit_spec.component.defaultHeight || defaultHeight

        setSpec(next_graph_unit_spec.id, next_graph_unit_spec)
      }
    }

    if (graph_unit_is_component) {
      if (added_unit_is_component && !all_added_unit_ancestors_are_component) {
        if (!this._subgraph_graph) {
          const sub_component = this._get_sub_component(graph_unit_id)

          let added_sub_component = sub_component.getSubComponent(unitId)

          if (!added_sub_component) {
            added_sub_component = null

            const sub_pod = pod.$refUnit({
              unitId,
              _: ['U', 'C', 'G', 'EE', 'V'],
            }) as $Graph

            const sub_sub_component = componentFromSpecId(
              this.$system,
              this.$system.specs,
              parent_spec_id,
              {}
            )
            sub_sub_component.connect(sub_pod)

            sub_component.setSubComponent(unitId, sub_sub_component)
            sub_component.pushRoot(sub_sub_component)

            added_sub_component = sub_sub_component
          }

          sub_component.appendRoot(added_sub_component)
        }
      }
    }

    if (graph_unit_spec_render === undefined) {
      if (added_unit_is_component && all_added_unit_ancestors_are_component) {
        if (graph_unit_is_component) {
          //
        } else {
          let sub_component_map = {}

          if (this._subgraph_unit_id === graph_unit_id) {
            sub_component_map = this._subgraph_graph._component.$subComponent
          }

          this._componentify_core(graph_unit_id, sub_component_map)
          this._refresh_core_rect(graph_unit_id)
        }
      } else {
        //
      }
    } else {
      //
    }

    this._refresh_core_icon_hidden(graph_unit_id)
    this._refresh_core_icon_size(graph_unit_id)

    this._start_graph_simulation(LAYER_NONE)
  }

  private _refresh_core_icon_hidden = (unit_id: string) => {
    const spec = this._get_unit_spec(unit_id) as GraphSpec

    const unit_count = keyCount(spec.units || {})

    const is_unit_component = this._is_unit_component(unit_id)

    if (is_unit_component) {
      this._hide_core_icon(unit_id)
    } else {
      if (unit_count > 0) {
        const icon = this._spec_get_unit_icon(unit_id) ?? 'question'

        this._set_core_icon(unit_id, icon)
        this._show_core_icon(unit_id)
      } else {
        this._hide_core_icon(unit_id)
      }
    }
  }

  private _get_core_icon_size = (unit_id: string): Size => {
    const { r } = this.get_node(unit_id)

    const width = r
    const height = width

    return {
      width,
      height,
    }
  }

  private _set_core_icon_size = (unit_id: string, size: Size): void => {
    const { width, height } = size

    const icon = this._core_icon[unit_id]

    icon.$element.style.width = `${width}px`
    icon.$element.style.height = `${height}px`
  }

  private _refresh_core_icon_size = (unit_id: string): void => {
    const icon_size = this._get_core_icon_size(unit_id)

    this._set_core_icon_size(unit_id, icon_size)
  }

  private _on_graph_unit_add_merge_moment = (
    data: GraphMergeMomentData
  ): void => {
    // console.log('Graph', '_on_graph_unit_add_merge_moment', data)

    const { parent, specs, setSpec } = this.$props

    const { mergeId, mergeSpec, path } = data

    if (this._is_spec_updater(path)) {
      const next_spec = clone(findSpecAtPath(specs, this._spec, path))

      addMerge({ mergeSpec: clone(mergeSpec), mergeId }, next_spec)

      setSpec(next_spec.id, next_spec)
    }
  }

  private _on_graph_unit_remove_merge_moment = (
    data: GraphMergeMomentData
  ): void => {
    // console.log('Graph', '_on_graph_unit_remove_merge_moment', data)

    const { parent, specs, setSpec } = this.$props

    const { mergeId, mergeSpec, path } = data

    if (this._is_spec_updater(path)) {
      const next_spec = clone(findSpecAtPath(specs, this._spec, path))

      removeMerge({ mergeId }, next_spec)

      setSpec(next_spec.id, next_spec)
    }
  }

  private _on_graph_unit_remove_unit_pin_data_moment = (
    data: GraphRemoveUnitPinDataMomentData
  ) => {
    // console.log('Graph', '_on_graph_unit_remove_unit_pin_data_moment', data)

    const { specs, setSpec } = this.$props

    const { unitId, type, pinId, path } = data

    if (this._is_spec_updater(path)) {
      const spec = clone(findSpecAtPath(specs, this._spec, path))

      removeUnitPinData({ unitId, type, pinId }, spec)

      setSpec(spec.id, spec)
    }
  }

  private _on_graph_unit_remove_pin_from_merge_moment = (
    data: GraphMergePinMomentData
  ) => {
    // console.log('Graph', '_on_graph_unit_remove_pin_from_merge_moment', data)

    const { parent, specs, setSpec } = this.$props

    const { path } = data

    if (this._is_spec_updater(path)) {
      const { mergeId } = data

      const spec = findSpecAtPath(specs, this._spec, path)

      removePinFromMerge(data, spec)

      setSpec(spec.id, spec)
    }
  }

  private _on_graph_unit_add_pin_to_merge_moment = (
    data: GraphMergePinMomentData
  ) => {
    // console.log('Graph', '_on_graph_unit_add_pin_to_merge_moment', data)
    const { parent, specs, setSpec } = this.$props

    const { path } = data

    if (this._is_spec_updater(path)) {
      const { mergeId } = data

      const spec = findSpecAtPath(specs, this._spec, path)

      addPinToMerge(data, spec)

      setSpec(spec.id, spec)
    }
  }

  private _on_graph_unit_plug_pin_moment = (
    data: GraphPlugMomentData
  ): void => {
    // console.log('Graph', '_on_graph_unit_plug_pin_moment', data)

    const { type, pinId, subPinId, subPinSpec, path } = data

    const unitId = path[0]

    const { specs, setSpec, getSpec } = this.$props

    if (this._is_spec_updater(path)) {
      const spec = findSpecAtPath(specs, this._spec, path)

      const next_unit_spec = clone(spec)

      delete next_unit_spec[`${type}s`][pinId].type

      plugPin(
        {
          pinId,
          type,
          subPinId,
          subPinSpec,
        },
        next_unit_spec
      )

      const prev_pin_spec = getPinSpec(spec, type, pinId)

      const was_ref = isPinSpecRef(specs, spec, type, prev_pin_spec)
      const ref = isSubPinSpecRef(specs, spec, type, subPinSpec)

      const setPinRef = () => {
        setPinSetRef({ type, pinId, ref }, next_unit_spec)
        setSpec(spec.id, next_unit_spec)
      }

      if (path.length === 1) {
        const pin_node_id = getPinNodeId(unitId, type, pinId)

        if (was_ref !== ref) {
          this._sim_set_unit_pin_ref(
            pin_node_id,
            ref,
            setPinRef,
            (mergeId: string, mergeSpec: GraphMergeSpec) => {
              this._spec_add_merge(mergeId, mergeSpec)
            },
            (unitId: string, type: IO, pinId: string, mergeId: string) => {
              this._spec_add_link_pin_to_merge(mergeId, unitId, type, pinId)
            },
            (unitId: string, type: IO, pinId, mergeId: string) => {
              this.__spec_remove_pin_from_merge(mergeId, unitId, type, pinId)
            }
          )
        } else {
          setSpec(spec.id, next_unit_spec)
        }

        const { kind = type } = subPinSpec

        if (was_ref && ref && kind === 'output') {
          this._sim_refresh_unit_ref_output_icon(unitId, type, pinId)
        }

        this._clear_graph_pin_type(unitId, type, pinId)
      } else {
        setPinRef()
      }
    }
  }

  private _on_graph_unit_unplug_pin_moment = (
    data: GraphPlugMomentData
  ): void => {
    // console.log('Graph', '_on_graph_unit_unplug_pin_moment', data)

    const { type, pinId, subPinId, subPinSpec, path } = data

    const unitId = path[0]

    const { specs, setSpec } = this.$props

    if (this._is_spec_updater(path)) {
      const spec = findSpecAtPath(specs, this._spec, path)

      const next_unit_spec = clone(spec)

      delete next_unit_spec[`${type}s`][pinId].type

      unplugPin(
        {
          pinId,
          type,
          subPinId,
        },
        next_unit_spec
      )

      const sub_pin_spec = getSubPinSpec(spec, type, pinId, subPinId)
      const pinSpec = getPinSpec(next_unit_spec, type, pinId)

      const was_ref = isSubPinSpecRef(specs, spec, type, sub_pin_spec)
      const ref = isPinSpecRef(specs, spec, type, pinSpec)

      const commit = () => {
        setPinSetRef({ type, pinId, ref }, next_unit_spec)
        setSpec(spec.id, next_unit_spec)
      }

      if (path.length === 1) {
        const pin_node_id = getPinNodeId(unitId, type, pinId)

        if (was_ref !== ref) {
          this._sim_set_unit_pin_ref(
            pin_node_id,
            ref,
            commit,
            (mergeId: string, mergeSpec: GraphMergeSpec) => {
              this._spec_add_merge(mergeId, mergeSpec)
            },
            (unitId: string, type: IO, pinId: string, mergeId: string) => {
              this._spec_add_link_pin_to_merge(mergeId, unitId, type, pinId)
            },
            (unitId: string, type: IO, pinId, mergeId: string) => {
              this.__spec_remove_pin_from_merge(mergeId, unitId, type, pinId)
            }
          )
        } else {
          commit()
        }

        this._clear_graph_pin_type(unitId, type, pinId)
      } else {
        commit()
      }
    }
  }

  private _set_core_shape = (unit_id: string, shape: Shape): void => {
    // console.log('Graph', '_set_core_shape', unit_id, shape)

    const node = this._node[unit_id]
    const core = this._core[unit_id]
    const core_selection = this._node_selection[unit_id]
    const core_area = this._core_area[unit_id]

    if (shape === 'circle') {
      node.shape = 'circle'
      core.$element.style.borderRadius = '50%'
      core_area.$element.style.borderRadius = '50%'
      core_selection.setProp('shape', 'circle')
    } else {
      node.shape = 'rect'
      core.$element.style.borderRadius = '0'
      core_area.$element.style.borderRadius = '0'
      core_selection.setProp('shape', 'rect')
    }
  }

  private _refresh_core_size = (unit_id: string): void => {
    // console.log('Graph', '_refresh_core_size', unit_id)

    if (this._is_unit_component(unit_id)) {
      this._refresh_core_rect(unit_id)
    } else {
      this._refresh_core_circle(unit_id)
    }
  }

  private _refresh_core_shape = (unit_id: string): void => {
    // console.log('Graph', '_refresh_core_shape', unit_id)

    if (this._is_unit_component(unit_id)) {
      this._set_core_shape(unit_id, 'rect')
    } else {
      this._set_core_shape(unit_id, 'circle')
    }
  }

  private _refresh_core_rect = (unit_id: string): void => {
    const { width, height } = this._get_unit_component_graph_size(unit_id)
    const { x, y } = this._get_node_position(unit_id)

    this._resize_node(unit_id, width + 2, height + 2)
    this._resize_core(unit_id, width + 2, height + 2)

    this._set_node_position(unit_id, { x, y })
  }

  private _refresh_core_circle = (unit_id: string): void => {
    // console.log('Graph', '_refresh_core_circle', unit_id)

    const _r = this._get_unit_radius(unit_id, true)
    const r = this._get_unit_radius(unit_id, false)
    const { x, y } = this._get_node_position(unit_id)

    const dr = r - _r
    const width = 2 * r
    const height = width

    this._resize_node(unit_id, width, height)
    this._resize_core(unit_id, width, height)
    this._set_node_position(unit_id, { x: x - dr, y: y - dr })
  }

  private _on_remove_unit_moment = (data: GraphAddUnitMomentData): void => {
    // console.log('Graph', '_on_remove_unit_moment')

    const { unitId } = data

    this._flush_debugger()

    this._state_remove_unit(unitId)
  }

  private _on_move_unit_moment = (data: GraphSpecUnitMoveMomentData): void => {
    // console.log('Graph', '_on_move_unit_moment', data)

    const { id } = data

    this._flush_debugger()

    this._state_remove_unit(id)
  }

  private _ensure_fork_spec(init_spec_id: string): {
    spec_id: string
    spec: GraphSpec
    forked: boolean
  } {
    // console.log('Graph', '_ensure_fork_spec')

    const { specs } = this.$props

    const init_spec = getGraphSpec(specs, init_spec_id)

    const forked_spec_id = newSpecId(specs)
    const forked_spec = clone(init_spec)

    forked_spec.id = forked_spec_id

    return {
      spec_id: forked_spec_id,
      spec: forked_spec,
      forked: true,
    }
  }

  private _on_graph_unit_remove_unit_moment = (
    data: GraphAddUnitMomentData
  ): void => {
    // console.log('Graph', '_on_graph_unit_remove_unit_moment', data)

    const { setSpec, specs, parent, unregisterUnit } = this.$props

    const { bundle, path, unitId, destroy = true } = data

    const _specs = weakMerge(bundle.specs ?? {}, specs)

    const graph_unit_id = path[0]

    const { unit } = bundle

    const removed_unit_spec_id = unit.id

    const graph_unit_was_component = this._is_unit_component(graph_unit_id)

    const spec = findSpecAtPath(specs, this._spec, path)

    let next_spec = spec

    const is_removed_unit_component = isComponentId(
      weakMerge(specs, bundle.specs ?? {}),
      removed_unit_spec_id
    )

    const spec_sub_component_count = keyCount(
      spec.component?.subComponents ?? {}
    )

    if (this._is_spec_updater(path)) {
      next_spec = clone(spec)

      removeUnit({ unitId }, next_spec)

      next_spec.metadata = next_spec.metadata || {}

      delete next_spec.metadata.complexity

      if (is_removed_unit_component) {
        const parent_id = getSubComponentParentId(spec, unitId)

        removeSubComponent({ unitId }, next_spec.component)

        if (parent_id) {
          removeSubComponentChild(
            {
              subComponentId: parent_id,
              childId: unitId,
            },
            next_spec.component
          )
        } else {
          removeRoot({ childId: unitId }, next_spec.component)
        }
      }

      setSpec(spec.id, next_spec)

      const subgraph = this.getSubgraphAtPath(path)

      ;(async () => {
        if (subgraph) {
          if (subgraph._animating_unit_explosion[unitId]) {
            await subgraph._animating_unit_explosion[unitId]
          }

          this._unregister_unit(bundle.unit.id)
        }
      })()
    }

    let all_ancestors_are_component = true

    for (let i = path.length - 1; i >= 0; i--) {
      const sub_path = path.slice(0, i + 1)

      const ancestor_spec = findSpecAtPath(specs, this._spec, sub_path)

      all_ancestors_are_component =
        all_ancestors_are_component &&
        (isComponentSpec(ancestor_spec) ||
          getSpecRender(ancestor_spec) === undefined)
    }

    const graph_spec = this._get_unit_spec(graph_unit_id) as GraphSpec

    const next_graph_spec = path.length === 1 ? next_spec : clone(graph_spec)

    const possibly_turned_circle_unit_id = path[1] ?? unitId

    let parent_path_to_update = path
    let unit_id_to_update = unitId

    const subgraph_path = this.getSubgraphPath()

    while (parent_path_to_update.length >= 0) {
      const parent_spec = findSpecAtPath(
        specs,
        this._spec,
        parent_path_to_update
      ) as GraphSpec

      const next_parent_spec = clone(parent_spec)

      if (is_removed_unit_component && all_ancestors_are_component) {
        if ((parent_spec.component?.children?.length ?? 0) === 0) {
          const parent_sub_component_count = keyCount(
            deepGetOrDefault(parent_spec, ['component', 'subComponents'], {})
          )

          const parent_component = this._component.pathGetSubComponent(
            parent_path_to_update
          )

          const removed_component =
            parent_component &&
            parent_component.getSubComponent(unit_id_to_update)

          const parent_id = getSubComponentParentId(
            next_parent_spec,
            unit_id_to_update
          )

          if (parent_id) {
            removeSubComponentChild(
              {
                subComponentId: parent_id,
                childId: unit_id_to_update,
              },
              next_parent_spec.component
            )

            if (parent_component) {
              const sub_component_parent_root =
                parent_component.getSubComponent(parent_id)

              if (
                sub_component_parent_root.$parentRoot.includes(
                  removed_component
                )
              ) {
                sub_component_parent_root.pullParentRoot(removed_component)
              }
            }
          } else {
            removeRoot(
              { childId: possibly_turned_circle_unit_id },
              next_parent_spec.component
            )

            if (parent_component) {
              if (parent_component.$root.includes(removed_component)) {
                parent_component.pullRoot(removed_component)
              }
            }
          }

          removeSubComponent(
            { unitId: possibly_turned_circle_unit_id },
            next_parent_spec.component
          )

          if (parent_component) {
            if (parent_component.$subComponent[unit_id_to_update]) {
              parent_component.removeSubComponent(unit_id_to_update)
            }
          }

          setSpec(next_parent_spec.id, next_parent_spec)
        }

        if (!parent_path_to_update.length) {
          break
        }

        unit_id_to_update = last(parent_path_to_update)
        parent_path_to_update = parent_path_to_update.slice(0, -1)
      } else {
        break
      }
    }

    const graph_unit_is_component = this._is_unit_component(graph_unit_id)

    if (graph_unit_was_component && !graph_unit_is_component) {
      if (this._get_node_shape(graph_unit_id) === 'rect') {
        this._decomponentify_core(graph_unit_id, false)
      }
    } else if (!graph_unit_was_component && graph_unit_is_component) {
      if (this._get_node_shape(graph_unit_id) === 'circle') {
        this._componentify_core(graph_unit_id, {}, true)
      }
    }

    this._refresh_core_icon_hidden(graph_unit_id)
    this._refresh_core_size(graph_unit_id)
    this._refresh_core_icon_size(graph_unit_id)

    this._start_graph_simulation(LAYER_NONE)
  }

  private _spec_set_unit_spec_id = (unit_id: string, spec_id: string): void => {
    // console.log('Graph', '_spec_set_unit_spec_id', unit_id, spec_id)

    const old_spec_id = this._get_unit_spec_id(unit_id)

    if (spec_id === old_spec_id) {
      return
    }

    this._spec.units[unit_id].id = spec_id

    this._unregister_unit(old_spec_id)
    this._register_unit(spec_id)
  }

  private _is_node_visible = (node_id: string): boolean => {
    if (this._is_unit_node_id(node_id)) {
      return true
    } else if (this._is_link_pin_node_id(node_id)) {
      return this._is_link_pin_visible(node_id)
    } else if (this._is_merge_node_id(node_id)) {
      return true
    } else if (this._is_datum_node_id(node_id)) {
      return !!this._visible_data_node[node_id]
    } else if (this._is_int_node_id(node_id)) {
      return !this._int_to_node[node_id]
    } else if (this._is_ext_node_id(node_id)) {
      return true
    } else {
      return false
    }
  }

  // center of mass
  private _nodes_cm = (node_ids: Dict<any>): Position => {
    let sum_x: number = 0
    let sum_y: number = 0
    let count = 0
    for (const node_id in node_ids) {
      if (this._is_node_visible(node_id)) {
        const { x, y } = this._get_node_position(node_id)
        sum_x += x
        sum_y += y
        count++
      }
    }
    const x = sum_x / count
    const y = sum_y / count
    return { x, y }
  }

  private _nodes_cm_position_map = (node_ids: Dict<any>): Dict<Position> => {
    const position: Dict<Position> = {}

    if (!isEmptyObject(node_ids)) {
      const cm = this._nodes_cm(node_ids)

      const { x: cx, y: cy } = cm

      for (const node_id in node_ids) {
        const p = this._get_node_position(node_id)

        const { x, y } = p

        const rp = { x: Math.floor(x - cx), y: Math.floor(y - cy) }

        position[node_id] = rp
      }
    }

    return position
  }

  private _init_merge_spec_position = (
    merge_spec: GraphMergeSpec
  ): Position => {
    const center_of_mass = this._nodes_cm(merge_spec)

    return center_of_mass
  }

  private _sim_collapse_merge = (merge_id: string): void => {
    // console.log('Graph', '_sim_collapse_merge', merge_id)

    const merge_node_id = getMergeNodeId(merge_id)

    const merge_spec = this._spec_get_merge(merge_id)

    return this.__sim_collapse_merge(merge_id, merge_spec)
  }

  private __sim_collapse_merge = (
    merge_id: string,
    merge_spec: GraphMergeSpec
  ): void => {
    // console.log('Graph', '__sim_collapse_merge', merge_id)

    const merge_node_id = getMergeNodeId(merge_id)

    const merge_ref_unit_id = this._merge_to_ref_unit[merge_node_id]
    const merge_ref_output_id = this._merge_to_ref_output[merge_node_id]

    forEachPinOnMerge(merge_spec, (unitId, type, pinId) => {
      const pin_node_id = getPinNodeId(unitId, type, pinId)

      this._sim_add_link_pin_to_merge(pin_node_id, merge_node_id)
    })
  }

  private _on_add_merge_moment = (moment: GraphMergeMomentData): void => {
    // console.log('Graph', '_on_add_merge_moment', moment)

    const { mergeId, mergeSpec } = moment

    const position = this._init_merge_spec_position(mergeSpec)

    this._spec_add_merge(mergeId, mergeSpec)

    this._sim_add_merge(mergeId, mergeSpec, position)
    this._sim_collapse_merge(mergeId)
  }

  private _on_remove_merge_moment = (data: GraphMergeMomentData): void => {
    // console.log('Graph', '_on_remove_merge_moment', moment)

    const { mergeId } = data

    this.__state_remove_merge(mergeId)
  }

  private _on_add_pin_to_merge_moment = (
    data: GraphMergePinMomentData
  ): void => {
    // console.log('Graph', '_on_add_pin_to_merge_moment', data)
    const { mergeId, unitId, type, pinId } = data
    const merge_node_id = getMergeNodeId(mergeId)
    const pin_node_id = getPinNodeId(unitId, type, pinId)
    this._spec_add_link_pin_to_merge(mergeId, unitId, type, pinId)
    this._sim_add_link_pin_to_merge(pin_node_id, merge_node_id)
  }

  private _on_remove_pin_from_merge_moment = (
    data: GraphMergePinMomentData
  ): void => {
    // console.log('Graph', '_on_remove_pin_from_merge_moment', data)

    const { mergeId, unitId, type, pinId } = data

    const merge_node_id = getMergeNodeId(mergeId)
    const pin_node_id = getPinNodeId(unitId, type, pinId)

    this._sim_remove_pin_from_merge(merge_node_id, pin_node_id)
    this.__spec_remove_pin_from_merge(mergeId, unitId, type, pinId)
  }

  private _on_remove_unit_pin_data_moment = () => {
    //
  }

  private _on_expose_pin_set = (data: GraphExposedPinSetMomentData): void => {
    // console.log('Graph', '_on_expose_pin_set', data)

    const { type, pinId, pinSpec } = data

    this._spec_add_exposed_pin_set(type, pinId, pinSpec)
    this._sim_add_exposed_pin_set(type, pinId, pinSpec)
  }

  private _on_cover_pin_set = (data: GraphExposedPinSetMomentData): void => {
    // console.log('Graph', '_on_cover_pin_set', data)

    const { type, pinId, path } = data

    if (path.length === 0) {
      this._state_cover_pin_set(type, pinId)
    } else {
      this._on_graph_unit_cover_pin_set(data)
    }
  }

  private _on_expose_pin = (data: GraphExposePinEventData): void => {
    // console.log('Graph', '_on_expose_pin', data)

    const { type, pinId, subPinId, subPinSpec } = data

    this._state_add_exposed_pin(type, pinId, subPinId, subPinSpec, {})
  }

  private _on_cover_pin = (data: GraphExposePinEventData): void => {
    // console.log('Graph', '_on_cover_pin', data)

    const { type, pinId, subPinId } = data

    this.__sim_remove_exposed_sub_pin(type, pinId, subPinId)
    this.__spec_remove_exposed_sub_pin(type, pinId, subPinId)
  }

  private _on_plug_pin = (data: GraphPlugMomentData): void => {
    // console.log('Graph', '_on_plug_pin', data)

    const { type, pinId, subPinId, subPinSpec } = data
    this._sim_plug_exposed_pin(type, pinId, subPinId, subPinSpec)
    this._spec_plug_sub_pin(type, pinId, subPinId, subPinSpec)
  }

  private _on_unplug_pin = (data: GraphPlugMomentData): void => {
    // console.log('Graph', '_on_unplug_pin', data)

    const { type, pinId, subPinId } = data
    this._sim_unplug_exposed_pin(type, pinId, subPinId)
    this._spec_unplug_sub_pin(type, pinId, subPinId)
  }

  private _on_move_subgraph_into = (data: GraphMoveSubgraphIntoMomentData) => {
    // console.log('Graph', '_on_move_subgraph_into', data)

    const {
      graphId,
      nodeIds,
      nextIdMap,
      nextPinIdMap,
      nextMergePinId,
      nextPlugSpec,
      nextSubComponentParentMap,
      nextSubComponentChildrenMap,
      path,
    } = data

    if (path.length === 0) {
      const spec = emptySpec({})

      const position = this._jiggle_world_screen_center()

      this._paste_spec(spec, position, true, true, false, {})
    }
  }

  private _on_reorder_sub_component = (
    data: GraphReorderSubComponentMomentData
  ) => {
    // console.log('Graph', '_on_reorder_sub_component', data)

    const { path } = data

    if (path.length === 0) {
      this._state_reorder_sub_component(data.childId, data.to)
    }
  }

  private _on_move_sub_component_root = (
    data: GraphMoveSubComponentRootData
  ) => {
    // console.log('Graph', '_on_move_sub_component_root', data)
  }

  private _on_move_subgraph_out_of = (
    data: GraphMoveSubgraphIntoMomentData
  ) => {
    const {
      graphId,
      nodeIds,
      nextIdMap,
      nextPinIdMap,
      nextMergePinId,
      nextPlugSpec,
      nextSubComponentParentMap,
      nextSubComponentChildrenMap,
      path,
    } = data

    if (path.length === 0) {
      //
    }
  }

  private _on_set_unit_pin_constant = (
    data: GraphSetUnitPinConstantMomentData
  ) => {
    // console.log('Graph', '_on_set_unit_pin_constant', data)

    const { unitId, type, pinId, constant } = data

    const pin_node_id = getPinNodeId(unitId, type, pinId)

    this._state_set_unit_pin_constant(pin_node_id, constant)
  }

  private _on_set_unit_pin_ignored = (
    data: GraphSetUnitPinIgnoredMomentData
  ) => {
    // console.log('Graph', '_on_set_unit_pin_ignored', data)

    const { unitId, type, pinId, ignored } = data

    const pin_node_id = getPinNodeId(unitId, type, pinId)

    this._state_set_link_pin_ignored(pin_node_id, ignored)
  }

  private _on_set_unit_pin_data = (_data: GraphSetUnitPinDataMomentData) => {
    // console.log('Graph', '_on_set_unit_pin_data', _data)

    const { classes } = this.$system

    const { specs } = this.$props

    const { unitId, type, pinId, data, path } = _data

    if (path.length === 0) {
      setUnitPinData({ unitId, type, pinId, data }, this._spec, specs, classes)
    }
  }

  private _on_bulk_edit = (data: GraphBulkEditData) => {
    // console.log('Graph', '_on_bulk_edit', data)

    const { actions } = data

    for (const action of actions) {
      this._execute_action(action, false)
    }
  }

  private _on_set_unit_id = (data: GraphSetUnitIdMomentData) => {
    // console.log('_on_set_unit_id', data, this._id)

    this._on_graph_unit_set_unit_id(data)
  }

  private _on_set_metadata = (data: GraphSetMetadataData) => {
    // console.log('Graph', '_on_set_metadata', data)
  }

  private _on_graph_unit_set_pin_set_functional = (
    data: GraphSetPinSetFunctionalMomentData & { unitId: string }
  ) => {
    // console.log('Graph', '_on_graph_unit_set_pin_set_functional', data)

    const { setSpec, specs } = this.$props

    const { type, pinId, functional, path } = data

    const graph_unit_id = path[0]

    if (this._is_spec_updater(path)) {
      const next_spec = clone(findSpecAtPath(specs, this._spec, path))

      setPinSetFunctional({ type, pinId, functional }, next_spec)

      setSpec(next_spec.id, next_spec)
    }
  }

  private _on_graph_unit_set_pin_set_default_ignored = (
    data: GraphSetPinSetDefaultIgnoredMomentData
  ) => {
    // console.log('Graph', '_on_graph_unit_set_pin_set_default_ignored', data)

    const { setSpec, specs } = this.$props

    const { type, pinId, defaultIgnored, path } = data

    if (this._is_spec_updater(path)) {
      const next_spec = clone(findSpecAtPath(specs, this._spec, path))

      setPinSetDefaultIgnored({ type, pinId, defaultIgnored }, next_spec)

      setSpec(next_spec.id, next_spec)

      if (path.length === 1) {
        const graph_unit_id = path[0]

        const ignored = this._get_graph_unit_pin_spec_ignored(
          graph_unit_id,
          type,
          pinId
        )

        if (ignored === undefined) {
          const should_be_ignored = this.__spec_is_link_pin_ignored(
            graph_unit_id,
            type,
            pinId
          )

          const pin_node_id = getPinNodeId(graph_unit_id, type, pinId)

          const merge_node_id = this._get_pin_merge_node_id(pin_node_id)
          const plug_node_id = this._spec_get_unit_pin_plug(
            graph_unit_id,
            type,
            pinId
          )

          const link_id = getPinLinkIdFromPinNodeId(pin_node_id)

          const current_ignored = this._link_layer[link_id] === LAYER_IGNORED

          if (should_be_ignored) {
            if (merge_node_id || plug_node_id) {
              if (current_ignored) {
                this._state_set_link_pin_ignored(pin_node_id, false)
              }
            } else {
              if (!current_ignored) {
                this._sim_set_unit_pin_ignored(pin_node_id, true)
              }
            }
          } else {
            if (current_ignored) {
              this._sim_set_unit_pin_ignored(pin_node_id, false)
            }
          }
        }
      }
    }
  }

  private _on_graph_unit_move_subgraph_into = (
    data: GraphMoveSubgraphIntoMomentData
  ) => {
    // console.log('Graph', '_on_graph_unit_move_subgraph_into', data)

    const { specs, setSpec } = this.$props

    const { graphId, nodeIds, path, graphBundle } = data

    const { unit } = graphBundle

    const { id } = unit

    const spec = getSpec(weakMerge(specs, graphBundle.specs), id)

    const graph_unit_id = path[0]

    const { plug } = nodeIds

    const unit_spec = findSpecAtPath(specs, this._spec, path)

    if (this._is_spec_updater(path)) {
      const parent_spec = findSpecAtPath(specs, this._spec, path)

      const spec = findSpecAtPath(specs, this._spec, [...path, graphId])

      const next_parent_spec = clone(parent_spec)
      const next_spec = clone(spec)

      const graph_unit_spec = this._get_unit_spec(graph_unit_id) as GraphSpec

      const merges = clone(
        this._get_graph_unit_unit_merges(graph_unit_id, data.graphId)
      )
      const plugs = clone(
        this._get_graph_unit_unit_plugs(graph_unit_id, data.graphId)
      )

      const connectOpt = {
        merges,
        plugs,
      }

      const spec_interface = weakMerge(
        this._make_graph_spec_interface(next_spec),
        {
          coverPinSet: (type, pinId, path_) => {
            deepDelete(next_parent_spec, ['units', graphId, type, pinId])

            coverPinSet({ type, pinId }, next_spec)
          },
        }
      )

      const subgraph_path = this.getSubgraphPath()

      const subgraph_interface =
        this._make_graph_spec_interface(next_parent_spec)

      const commit = () => {
        moveSubgraph(
          subgraph_interface,
          spec_interface,
          data.graphId,
          data,
          connectOpt,
          false
        )

        setSpec(next_spec.id, next_spec)
        setSpec(next_parent_spec.id, next_parent_spec)
      }

      if (isEqual(subgraph_path, path)) {
        const subgraph = this.getSubgraphAtPath(subgraph_path)

        if (subgraph._collapsing) {
          const unlisten = subgraph.addEventListener(
            makeCustomListener('collapse_end', () => {
              commit()

              unlisten()
            })
          )
        } else {
          commit()
        }
      } else {
        commit()
      }
    }
  }

  private _on_graph_unit_move_subgraph_out_of = (
    data: GraphMoveSubgraphIntoMomentData
  ) => {
    // console.log('Graph', '_on_graph_unit_move_subgraph_out_of', data)

    const { specs, setSpec, getSpec } = this.$props

    const { graphId, nodeIds, path, nextSpecId } = data

    const graph_unit_id = path[0]

    const { plug } = nodeIds

    if (this._is_spec_updater(path)) {
      const parent_spec = findSpecAtPath(specs, this._spec, path)

      const spec = findSpecAtPath(specs, this._spec, [...path, graphId])

      const next_spec = clone(spec)

      const graph_unit_spec = this._get_unit_spec(graph_unit_id) as GraphSpec

      const merges = clone(
        this._get_graph_unit_unit_merges(graph_unit_id, data.graphId)
      )
      const plugs = clone(
        this._get_graph_unit_unit_plugs(graph_unit_id, data.graphId)
      )

      const connectOpt = {
        merges,
        plugs,
      }

      const spec_interface = this._make_graph_spec_interface(spec)

      const subgraph_path = this.getSubgraphPath()

      const subgraph_interface =
        this._state_get_subgraph_graph_interface(graph_unit_id)

      const commit = () => {
        moveSubgraph(
          spec_interface,
          subgraph_interface,
          data.graphId,
          data,
          connectOpt,
          true
        )
      }

      if (isEqual(subgraph_path, path)) {
        const subgraph = this.getSubgraphAtPath(subgraph_path)

        if (subgraph._collapsing) {
          const unlisten = subgraph.addEventListener(
            makeCustomListener('collapse_end', () => {
              commit()

              unlisten()
            })
          )
        } else if (subgraph._animating_unit_explosion[data.graphId]) {
          ;(async () => {
            await subgraph._animating_unit_explosion[data.graphId]

            commit()
          })()
        } else {
          commit()
        }
      } else {
        commit()
      }
    }
  }

  private _on_graph_unit_move_sub_component_root = (
    data: GraphMoveSubComponentRootMomentData
  ) => {
    // console.log('Graph', '_on_graph_unit_move_sub_component_root', data)

    const { specs, setSpec } = this.$props

    const { path } = data

    const graph_unit_id = path[0]

    if (this._is_spec_updater(path)) {
      const { parentId, children, slotMap } = data

      const unit_spec = clone(findSpecAtPath(specs, this._spec, path))

      moveSubComponentRoot(data, unit_spec.component)

      setSpec(unit_spec.id, unit_spec)
    }
  }

  private _on_graph_unit_reorder_sub_component = (
    data: GraphReorderSubComponentMomentData
  ) => {
    // console.log('Graph', '_on_graph_unit_reorder_sub_component', data)

    const { specs, setSpec } = this.$props

    const { path } = data

    const graph_unit_id = path[0]

    if (this._is_spec_updater(path)) {
      const unit_spec = clone(findSpecAtPath(specs, this._spec, path))

      reorderSubComponent(data, unit_spec.component)

      setSpec(unit_spec.id, unit_spec)
    }
  }

  private _on_graph_unit_set_unit_size = (
    data: GraphSetUnitSizeData & { path: string[] }
  ) => {
    // console.log('Graph', '_on_graph_unit_set_unit_size', data)

    const { specs, setSpec } = this.$props

    const { unitId, width, height, path } = data

    if (this._is_spec_updater(path)) {
      const unit_spec = clone(findSpecAtPath(specs, this._spec, path))

      setUnitSize({ unitId, width, height }, unit_spec)

      setSpec(unit_spec.id, unit_spec)
    }

    if (path.length === 0) {
      this._start_graph_simulation(LAYER_NORMAL)
    }
  }

  private _on_graph_unit_set_component_size = (
    data: GraphSetComponentSizeData & { path: string[] }
  ) => {
    const { specs } = this.$props

    const { width, height, path } = data

    if (this._is_spec_updater(path)) {
      const spec = findSpecAtPath(specs, this._spec, path)

      setComponentSize({ width, height }, spec)
    }
  }

  private _on_graph_unit_set_sub_component_size = (
    data: GraphSetSubComponentSizeData & { path: string[] }
  ) => {
    // console.log('Graph', '_on_graph_unit_set_sub_component_size', data)

    const { specs } = this.$props

    const { unitId, width, height, path } = data

    if (this._is_spec_updater(path)) {
      const spec = findSpecAtPath(specs, this._spec, path)

      setSubComponentSize({ unitId, width, height }, spec)
    }
  }

  private _state_graph_remove_unit_pin = (
    unitId: string,
    type: IO,
    pinId: string
  ) => {
    const pin_node_id = getPinNodeId(unitId, type, pinId)

    const mergeId = this._get_pin_merge_id(pin_node_id)

    this._sim_graph_remove_unit_pin(unitId, type, pinId)
    this._spec_graph_unit_remove_pin(unitId, type, pinId, mergeId)
  }

  private _sim_graph_remove_unit_pin = (
    unitId: string,
    type: IO,
    pinId: string
  ) => {
    // console.log('Graph', '_sim_graph_remove_unit_pin', unitId, type, pinId)

    const { specs } = this.$props

    const pin_node_id = getPinNodeId(unitId, type, pinId)

    const merge_node_id = this._pin_to_merge[pin_node_id]

    if (merge_node_id) {
      this._state_remove_pin_or_merge(pin_node_id)
    }

    const plug_node_id = this._pin_to_int[type][pin_node_id]

    if (plug_node_id) {
      const { type, pinId, subPinId } = segmentPlugNodeId(plug_node_id)

      this._state_unplug_exposed_pin(type, pinId, subPinId)
    }

    if (this._pin_node[pin_node_id]) {
      this._sim_graph_unit_remove_pin(pin_node_id)
    }
  }

  private _on_graph_unit_pin_data_moment = (
    _data: GraphUnitPinDataMomentData
  ) => {
    const { unitId, type, pinId } = _data

    const pin_node_id = getPinNodeId(unitId, type, pinId)

    if (this._is_link_pin_ref(pin_node_id)) {
      this._on_graph_unit_ref_link_pin_data_moment(_data)
    } else {
      this._on_graph_unit_link_pin_data_moment(_data)
    }
  }

  private _on_graph_unit_link_pin_data_moment = (
    _data: GraphUnitPinDataMomentData
  ): void => {
    // console.log('Graph', '_on_graph_unit_link_pin_data_moment', _data)

    const { unitId, pinId, type, data } = _data

    const pin_node_id = getPinNodeId(unitId, type, pinId)

    if (data) {
      this._graph_debug_set_pin_value(pin_node_id, data)
    }
  }

  private _should_watch_ref_pin = (
    pin_node_id: string,
    unitId: string,
    type: IO,
    pinId: string
  ): boolean => {
    return (
      this._is_input_pin_node_id(pin_node_id) &&
      this._is_link_pin_ref(pin_node_id) &&
      this._spec_is_link_pin_constant(unitId, type, pinId)
    )
  }

  private _on_graph_unit_ref_link_pin_data_moment = (
    _data: GraphUnitPinDataMomentData
  ) => {
    // console.log('Graph', '_on_graph_unit_ref_link_pin_data_moment', _data)

    const { unitId, type, pinId } = _data

    this._set_graph_unit_ref_link_pin_data(unitId, type, pinId, _data.data)
  }

  private _set_graph_unit_ref_link_pin_data = (
    unitId: string,
    type: IO,
    pinId: string,
    data: any
  ) => {
    // console.log(
    //   'Graph',
    //   '_set_graph_unit_ref_link_pin_data_moment',
    //   unitId,
    //   type,
    //   pinId,
    //   data
    // )

    const pin_node_id = getPinNodeId(unitId, type, pinId)

    this._graph_debug_set_pin_value(pin_node_id, data)
  }

  private _on_graph_unit_ref_link_pin_drop_moment = (
    _data: GraphUnitPinDropMomentData
  ) => {
    // console.log('_on_graph_unit_ref_link_pin_drop_moment', _data)

    this._on_graph_unit_link_pin_drop_moment(_data)
  }

  private _on_graph_unit_destroy = (data: { path: string[] }) => {
    // console.log('_on_graph_unit_destroy', data)

    const { specs, setSpec } = this.$props

    let { path } = data

    const unitId = last(path)

    path = path.slice(0, -1)

    if (this._is_spec_updater(path)) {
      const unit_spec = clone(findSpecAtPath(specs, this._spec, path))

      removeUnit({ unitId }, unit_spec)

      setSpec(unit_spec.id, unit_spec)
    }

    if (path.length === 0) {
      this._state_remove_unit_merges(unitId)
      this._state_remove_unit_plugs(unitId)

      this._ascend_node(unitId)

      this._animate_unit_opacity(unitId, 1, 0, () => {
        this._descend_node(unitId)

        this._state_remove_unit(unitId)
      })

      this._start_graph_simulation(LAYER_NORMAL)
    }
  }

  private _on_graph_unit_err_moment = (data: GraphUnitErrMomentData) => {
    // console.log('Graph', '_on_graph_unit_err_moment', data)

    const { unitId, err } = data

    this._graph_debug_set_unit_err(unitId, err)
  }

  private _graph_debug_set_unit_err(unit_id: string, err: string) {
    this._set_core_border_color(unit_id, COLOR_OPAQUE_RED)

    if (!this._err[unit_id]) {
      this._err[unit_id] = err

      this._sim_add_unit_err(unit_id, err)
    } else {
      this._sim_set_unit_err(unit_id, err)
    }
  }

  private _on_graph_unit_take_err_moment = (data: GraphUnitErrMomentData) => {
    // console.log('Graph', '_on_graph_unit_take_err_moment', data)

    const { unitId } = data

    this._graph_debug_take_err(unitId)
  }

  private _graph_debug_take_err = (unitId: string): void => {
    // console.log('Graph', '_graph_debug_take_err', unitId)

    const errNodeId = getErrNodeId(unitId)

    if (this._has_node(unitId) && this._has_node(errNodeId)) {
      this._reset_core_border_color(unitId)
      this._sim_remove_unit_err(unitId)
    }
  }

  private _on_graph_unit_append_child_moment = (moment: GraphMoment): void => {
    // console.log('Graph', '_on_graph_unit_append_child_moment', moment)
  }

  private _on_graph_unit_remove_child_at_moment = (
    moment: GraphMoment
  ): void => {
    // console.log('Graph', '_on_graph_unit_remove_child_at_moment', moment)
  }

  private _on_graph_unit_insert_child_at_moment = (
    moment: GraphMoment
  ): void => {
    // console.log('Graph', '_on_graph_unit_insert_child_at_moment', moment)
  }

  private _for_each_plug = (
    type: IO,
    pin_id: string,
    run: (sub_pin_id: string) => void
  ): void => {
    const pin = this._get_pin(type, pin_id)

    const { plug } = pin

    for (const sub_pin_id in plug) {
      run(sub_pin_id)
    }
  }

  private _ignore_sub_pin_data_update: {
    input: Dict<Dict<string>>
    output: Dict<Dict<string>>
  } = { input: {}, output: {} }

  private _sim_set_pin_set_data = (
    type: IO,
    pinId: string,
    data: string,
    tree?: TreeNode,
    data_position: Dict<Position> = {}
  ): void => {
    // console.log('Graph', '_unit_debug_set_pin_data', type, pinId, data)

    this._unit_datum[type][pinId] = data

    if (!this._is_pin_ref(type, pinId)) {
      this._for_each_plug(type, pinId, (subPinId) => {
        if (
          !this._ignore_sub_pin_data_update[type][pinId] ||
          !this._ignore_sub_pin_data_update[type][pinId][subPinId]
        ) {
          const position = data_position[subPinId]

          this._sim_set_plug_datum(type, pinId, subPinId, data, position)
        }
      })
    }

    this._set_exposed_pin_set_color(type, pinId, this._theme.data)
  }

  private _sim_remove_plug_or_pin = (
    type: IO,
    pinId: string,
    subPinId: string
  ) => {
    const plug_count = this._spec_get_pin_plug_count(type, pinId)

    if (plug_count === 1) {
      this._sim_cover_pin_set(type, pinId)
    } else {
      this.__sim_remove_exposed_sub_pin(type, pinId, subPinId)
    }
  }

  private _sim_remove_pin_data = (type: IO, pinId: string) => {
    // console.log('Graph', '_sim_remove_pin_data', type, pinId)

    this._for_each_plug(type, pinId, (subPinId) => {
      const ext_node_id = getExtNodeId(type, pinId, subPinId)

      const datum_node_id = this._plug_to_datum[ext_node_id]

      if (datum_node_id) {
        this._sim_remove_plug_datum(type, pinId, subPinId)
      }
    })

    delete this._unit_datum[type][pinId]

    this._reset_exposed_pin_set_color(type, pinId)
  }

  private _invalid_datum_node_id: Dict<boolean> = {}
  private _invalid_datum_data: Dict<string> = {}

  private _sim_set_datum_value = (
    datum_id: string,
    datum_node_id: string,
    anchor_node_id: string,
    data: string,
    next_tree?: TreeNode
  ) => {
    const { classes } = this.$system
    const { specs, injectSpecs } = this.$props

    const tree = this._datum_tree[datum_id]
    const datum = this._datum[datum_node_id]

    const position = this._get_node_position(datum_node_id)

    const class_literal = tree.type === TreeNodeType.Unit

    next_tree = next_tree ?? _getValueTree__cached(data)

    const next_class_literal = next_tree.type === TreeNodeType.Unit

    if (
      (next_class_literal && !class_literal) ||
      (!next_class_literal && class_literal)
    ) {
      this._sim_remove_datum(datum_node_id)
      this._sim_add_datum_node(datum_id, data, position)
      this._sim_add_pin_datum_link(datum_node_id, anchor_node_id, false)

      this._refresh_datum_size(datum_node_id, next_tree)
    } else if (next_class_literal) {
      const { value } = next_tree

      const bundle = evaluateBundleStr(value, specs, classes)

      injectSpecs(bundle.specs ?? {})

      const { id } = bundle.unit

      const _datum = datum as ClassDatum

      _datum.setProp('id', id)
      _datum.dispatchEvent('datumchange', { data: getTree(id) })

      this._datum_tree[datum_id] = next_tree

      this._refresh_class_literal_datum_node_selection(datum_node_id)
    } else {
      const _datum = datum as Datum

      if (datum_id !== this._edit_datum_id) {
        _datum.setProp('data', next_tree)
        _datum.dispatchEvent('datumchange', { data: next_tree })

        this._datum_tree[datum_id] = next_tree

        this._refresh_datum_size(datum_node_id, next_tree)
      } else {
        this._refresh_datum_size(datum_node_id, tree)
      }
    }

    this._refresh_datum_visible(datum_node_id)
  }

  private _dispatch_data_removed = (datum_id: string) => {
    this._graph.dispatchEvent(
      'data_removed',
      {
        specId: this._spec.id,
        datumId: datum_id,
      },
      true
    )
  }

  private _dispatch_data_added = (datum_id: string, value: string) => {
    this._graph.dispatchEvent(
      'data_added',
      {
        specId: this._spec.id,
        datumId: datum_id,
        value,
      },
      true
    )
  }

  private _refresh_datum_size = (datum_node_id: string, tree?: TreeNode) => {
    tree = tree ?? this._get_datum_tree(datum_node_id)

    const { width, height } = this._get_datum_tree_size(tree)

    this._resize_datum(datum_node_id, width, height)
    this._resize_selection(datum_node_id, width, height)
  }

  private __graph_debug_set_pin_data = (
    pin_node_id: string,
    pin_datum_node_id: string,
    data: string
  ): void => {
    // console.log(
    //   'Graph',
    //   '__graph_debug_set_pin_data',
    //   pin_node_id,
    //   pin_datum_node_id,
    //   data
    // )

    const { datumId } = segmentDatumNodeId(pin_datum_node_id)

    this._sim_set_datum_value(datumId, pin_datum_node_id, pin_node_id, data)
    this._mem_set_pin_datum(pin_node_id, datumId)
    this._refresh_pin_color(pin_node_id)
  }

  private _graph_debug_set_pin_value = (
    pin_node_id: string,
    value: string
  ): void => {
    // console.log('Graph', '_graph_debug_set_pin_data', pin_node_id, value)

    const tree = _getValueTree__cached(value)

    this._graph_debug_set_pin_data_tree(pin_node_id, tree)
  }

  private _graph_debug_set_pin_data_tree = (
    pin_node_id: string,
    tree: TreeNode
  ): void => {
    // console.log('Graph', '_graph_debug_set_pin_data', pin_node_id, tree)

    const { parent } = this.$props

    const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)

    if (!this._has_node(anchor_node_id)) {
      // console.warn('debug moment with no node', anchor_node_id)
      return
    }

    const pin_datum_node_id = this._pin_to_datum[pin_node_id]

    let datum_id: string

    const { type } = segmentLinkPinNodeId(pin_node_id)

    if (pin_datum_node_id) {
      const { datumId: _datum_id } = segmentDatumNodeId(pin_datum_node_id)

      datum_id = _datum_id

      if (this._visible_data_node[pin_datum_node_id]) {
        this.__graph_debug_set_pin_data(
          pin_node_id,
          pin_datum_node_id,
          tree.value
        )
      } else {
        this._invalid_datum_node_id[pin_datum_node_id] = true
        this._invalid_datum_data[pin_datum_node_id] = tree.value
      }
    } else {
      datum_id = this._new_datum_id()

      const datum_node_id = getDatumNodeId(datum_id)

      const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)

      const is_class_literal = tree.type === TreeNodeType.Unit

      this._datum_tree[datum_id] = tree

      if (
        this._is_pin_node_id(anchor_node_id) &&
        (!this._is_pin_node_ref(anchor_node_id) || is_class_literal)
      ) {
        const position =
          this._predict_pin_datum_initial_position(anchor_node_id)

        this._sim_add_datum_node(datum_id, tree.value, position)
        this._sim_add_pin_datum_link(datum_node_id, pin_node_id, false)

        if (this._is_merge_node_id(anchor_node_id)) {
          const { mergeId } = segmentMergeNodeId(anchor_node_id)

          this._for_each_merge_pin(mergeId, (unit_id, type, pin_id) => {
            const pin_node_id = getPinNodeId(unit_id, type, pin_id)

            this._refresh_pin_datum_visible(pin_node_id)
          })

          if (this._has_node(anchor_node_id)) {
            this._refresh_merge_pin_color(anchor_node_id)
          }
        }
      }

      this._mem_set_pin_datum(pin_node_id, datum_id)
    }

    this._spec_set_pin_data(pin_node_id, tree.value)
  }

  private _on_graph_unit_link_pin_drop_moment = (
    data: GraphUnitPinDropMomentData
  ): void => {
    // console.log('Graph', '_graph_debug_link_pin_drop_moment', data)

    const { unitId, type, pinId } = data

    const pin_node_id = getPinNodeId(unitId, type, pinId)

    this._graph_debug_drop_pin_data(pin_node_id)
  }

  private _graph_debug_drop_pin_data = (pin_node_id: string): void => {
    // console.log('Graph', '_graph_debug_drop_pin_data', pin_node_id)

    const anchor_node_id = this._get_pin_anchor_node_id(pin_node_id)

    if (!this._has_node(anchor_node_id)) {
      return
    }

    const datum_node_id = this._pin_to_datum[pin_node_id]

    if (datum_node_id) {
      if (this._edit_datum_node_id === datum_node_id) {
        this._edit_datum_committed = false
      } else {
        this._sim_remove_datum(datum_node_id)
      }
    }

    this._mem_remove_pin_datum_tree_if(pin_node_id)
    this._spec_remove_pin_data(pin_node_id)
  }

  private _mem_remove_pin_datum_tree_if = (pin_node_id: string): void => {
    const pin_datum_tree = this._pin_datum_tree[pin_node_id]

    if (pin_datum_tree) {
      this._mem_remove_pin_datum_tree(pin_node_id)
    }
  }

  private _on_graph_unit_merge_data_moment = (
    data: GraphMergePinDataMomentData
  ): void => {
    // console.log('Graph', '_on_graph_unit_merge_data_moment', data)

    const { mergeId, data: _data } = data

    const merge_node_id = getMergeNodeId(mergeId)

    this._graph_debug_set_pin_value(merge_node_id, _data)
  }

  private _on_graph_unit_merge_drop_moment = (
    data: GraphMergePinDataMomentData
  ): void => {
    // console.log('Graph', '_on_graph_unit_merge_drop_moment', data)

    const { mergeId } = data

    const merge_node_id = getMergeNodeId(mergeId)

    this._graph_debug_drop_pin_data(merge_node_id)
  }

  private _on_graph_moment = (moment: Moment<any>): void => {
    // console.log('Graph', '_on_graph_moment', moment)

    this._debug_buffer.push(moment)

    if (this._debug_interval) {
      if (this._debug_buffer.length > MAX_DEBUG_BUFFER_SIZE) {
        this._flush_debugger()
      }
    }

    if (this._debug_interval === null) {
      this._start_debugger()
    }
  }

  private _on_graph_unit_link_pin_invalid_moment = () => {
    //
  }

  private _on_graph_unit_merge_invalid_moment = () => {
    //
  }

  private _on_graph_unit_set_pin_set_id = (
    data: GraphSetPinSetIdMomentData
  ) => {
    // console.log('Editor', '_on_graph_unit_set_pin_set_id', data)

    const { parent, specs, setSpec } = this.$props

    const { type, pinId, nextPinId, path } = data

    const opposite_type = opposite(type)

    const graphUnitId = path[0]

    const spec = this._get_unit_spec(graphUnitId) as GraphSpec

    const pin_node_id = getPinNodeId(graphUnitId, type, pinId)

    let mergeId
    let merge

    if (this._is_spec_updater(path)) {
      const spec = clone(findSpecAtPath(specs, this._spec, path))

      const pin_spec = this.__get_unit_pin_spec(
        graphUnitId,
        type,
        pinId
      ) as GraphPinSpec

      let pin_position: Position
      let merge_node_id: string
      let merge_position: Position
      let plug: GraphPlugSpec
      let datum_value: string

      if (path.length === 1) {
        pin_position = this._get_anchor_node_position(pin_node_id)

        merge_node_id = this._pin_to_merge[pin_node_id]

        merge = merge_node_id ? this._get_merge(merge_node_id) : {}

        merge_position = merge_node_id
          ? this._get_anchor_node_position(merge_node_id)
          : NULL_VECTOR

        if (merge_node_id) {
          plug = this._spec_get_pin_node_plug_spec(type, merge_node_id)
        } else {
          plug =
            this._spec_get_pin_node_plug_spec(type, pin_node_id) ||
            this._spec_get_pin_node_plug_spec(opposite_type, pin_node_id)
        }

        datum_value = this._get_pin_datum_value(pin_node_id)

        this._state_graph_unit_remove_pin(pin_node_id, graphUnitId, type, pinId)

        const unit_pin_spec = deepGetOrDefault(
          this._spec,
          ['units', graphUnitId, type, pinId],
          undefined
        )

        deepDelete(this._spec, ['units', graphUnitId, type, pinId])

        deepSet(
          this._spec,
          ['units', graphUnitId, type, nextPinId],
          unit_pin_spec
        )
      }

      setPinSetId({ type, pinId, nextPinId }, spec)

      if (path.length === 1) {
        const next_pin_node_id = getPinNodeId(graphUnitId, type, nextPinId)

        this._state_graph_unit_expose_pin_set(
          graphUnitId,
          type,
          nextPinId,
          pin_spec,
          pin_position
        )

        if (datum_value) {
          this._state_set_unit_pin_data(next_pin_node_id, datum_value)
        }

        if (merge_node_id) {
          ;({ mergeId } = segmentMergeNodeId(merge_node_id))

          if (this.__spec_has_merge(mergeId)) {
            this._state_merge_link_pin_merge_pin(
              next_pin_node_id,
              merge_node_id
            )
          } else {
            deepDelete(merge, [graphUnitId, type, pinId])
            deepSet(merge, [graphUnitId, type, nextPinId], true)

            this._state_add_merge(mergeId, merge, merge_position)
            this._sim_collapse_merge(mergeId)
          }
        }

        if (plug) {
          let { type: _type, pinId, subPinId, subPinSpec } = plug

          if (subPinSpec.unitId && subPinSpec.pinId) {
            subPinSpec = {
              kind: subPinSpec.kind ?? _type,
              unitId: subPinSpec.unitId,
              pinId: nextPinId,
            }
          }

          unplugPin({ type: _type, pinId, subPinId }, this._spec)

          this._state_plug_exposed_pin(_type, pinId, subPinId, subPinSpec)

          setSpec(this._spec.id, this._spec)
        }
      }

      setSpec(spec.id, spec)
    }

    if (path.length === 2) {
      // grandparent

      const next_spec = clone(spec)

      const unitId = path[1]

      const mergeId = findPinMergeId(spec, unitId, type, pinId)

      const unit_pin_spec = deepGetOrDefault(
        spec,
        ['units', unitId, type, pinId],
        {}
      )

      deepDelete(next_spec, ['units', unitId, type, pinId])
      deepSet(next_spec, ['units', unitId, type, nextPinId], unit_pin_spec)

      if (mergeId) {
        const merge = next_spec.merges[mergeId]

        deepDelete(merge, [unitId, type, pinId])
        deepSet(merge, [unitId, type, nextPinId], true)

        removeMerge({ mergeId }, next_spec)
        addMerge({ mergeId, mergeSpec: merge }, next_spec)
      }

      setSpec(spec.id, next_spec)
    }
  }

  private _on_graph_unit_set_unit_pin_constant = (
    data: GraphSetUnitPinConstantMomentData
  ) => {
    // console.log('Editor', '_on_graph_unit_set_unit_pin_constant', data)

    const { classes } = this.$system
    const { setSpec, specs } = this.$props

    const { unitId, type, pinId, constant, data: pinData, path } = data

    if (this._is_spec_updater(path)) {
      const spec = clone(findSpecAtPath(specs, this._spec, path))

      setUnitPinConstant({ unitId, type, pinId, constant }, spec)

      if (data) {
        if (constant) {
          setUnitPinData(
            { unitId, type, pinId, data: pinData },
            spec,
            specs,
            classes
          )
        }
      }

      if (type === 'input') {
        if (!constant) {
          removeUnitPinData({ unitId, type, pinId }, spec)
        }
      }

      setSpec(spec.id, spec)
    }
  }

  private _on_graph_unit_set_unit_pin_ignored = (
    data: GraphSetUnitPinIgnoredMomentData
  ) => {
    // console.log('Editor', '_on_graph_unit_set_unit_pin_ignored', data)

    const { setSpec, specs } = this.$props

    const { unitId, type, pinId, ignored, path } = data

    if (this._is_spec_updater(path)) {
      const spec = findSpecAtPath(specs, this._spec, path)

      setUnitPinIgnored({ unitId, type, pinId, ignored }, spec)

      setSpec(spec.id, spec)
    }
  }

  private _should_fork_path = (path: string[], id: string) => {
    const {
      setSpec,
      forkSpec,
      shouldFork,
      registerUnit,
      unregisterUnit,
      specs,
    } = this.$props

    const should = shouldFork(id)

    const editor = this.getSubgraphAtPath(path)

    if (editor) {
      const fork = !!editor.getProp('fork')

      return should && fork
    }

    return should
  }

  private _on_graph_unit_set_unit_pin_data = (
    _data: GraphSetUnitPinDataMomentData
  ) => {
    // console.log('Editor', '_on_graph_unit_set_unit_pin_data', _data)

    const {
      setSpec,
      forkSpec,
      shouldFork,
      registerUnit,
      unregisterUnit,
      specs,
    } = this.$props

    const { classes } = this.$system

    const { unitId, type, pinId, data, path } = _data

    if (this._is_spec_updater(path)) {
      const spec = findSpecAtPath(specs, this._spec, path)

      const constant = deepGetOrDefault(
        spec,
        ['units', unitId, type, pinId, 'constant'],
        false
      )

      if (constant) {
        for (let i = path.length; i > 0; i--) {
          const graphId = path[i - 1]

          const path_ = path.slice(0, i)
          const parent_path_ = path.slice(0, i - 1)

          let spec_ = clone(findSpecAtPath(specs, this._spec, path_))
          let parent_spec_ = clone(
            findSpecAtPath(specs, this._spec, parent_path_)
          )

          let next_spec_ = clone(spec_)
          let next_parent_spec_ = clone(parent_spec_)

          if (i === path.length) {
            setUnitPinData(
              { unitId, type, pinId, data },
              next_spec_,
              specs,
              classes
            )

            setSpec(next_spec_.id, next_spec_)

            if (next_spec_.id === spec_.id) {
              //
            } else {
              registerUnit(next_spec_.id)
              unregisterUnit(spec_.id)
            }
          }

          next_parent_spec_.units[graphId].id = next_spec_.id

          if (i === 1) {
            this._spec = next_parent_spec_
          } else {
            setSpec(next_parent_spec_.id, next_parent_spec_)
          }

          if (next_parent_spec_.id === parent_spec_.id) {
            //
          } else {
            registerUnit(next_parent_spec_.id)
            unregisterUnit(parent_spec_.id)
          }
        }
      }
    }
  }

  private _on_graph_unit_metadata = (data: GraphMetadataMomentData) => {
    // console.log('Graph', '_on_graph_unit_metadata', data)

    const { specs, setSpec } = this.$props

    const {
      path,
      data: { path: path_, data: data_ },
    } = data

    if (this._is_spec_updater(path)) {
      const spec = clone(findSpecAtPath(specs, this._spec, path))

      if (path_[0] === 'icon') {
        const icon = data_

        setMetadata({ path: ['metadata', ...path_], value: data_ }, spec)

        if (path.length === 1) {
          const unitId = path[0]

          this._set_core_icon(unitId, icon)
        }
      } else if (path_[0] === 'description') {
        const description = data_

        setMetadata({ path: ['metadata', ...path_], value: data_ }, spec)

        if (path.length === 1) {
          const unitId = path[0]

          this._set_unit_temp_description(unitId, description)
        }
      }

      setSpec(spec.id, spec)
    }
  }

  private _on_graph_unit_bulk_edit = (data: GraphBulkEditMomentData) => {
    // console.log('Graph', '_on_graph_unit_bulk_edit', data, this._id)

    const { parent } = this.$props

    const { actions, path, transaction } = data

    if (transaction) {
      return
    }

    processActions(
      actions,
      mapObjKV(
        {
          coverPinSet: (data) => {
            this._on_graph_unit_cover_pin_set({ ...data, path })
          },
          exposePinSet: (data) => {
            this._on_graph_unit_expose_pin_set(data)
          },
          addUnitSpec: (data) => {
            this._on_graph_unit_add_unit_moment(data)
          },
          removeUnit: (data) => {
            this._on_graph_unit_remove_unit_moment(data)
          },
          addMerge: (data) => {
            this._on_graph_unit_add_merge_moment(data)
          },
          removeMerge: (data) => {
            this._on_graph_unit_remove_merge_moment(data)
          },
          removeUnitPinData: (data) => {
            this._on_graph_unit_remove_unit_pin_data_moment({ ...data, path })
          },
          addPinToMerge: (data) => {
            this._on_graph_unit_add_pin_to_merge_moment({ ...data, path })
          },
          removePinData: (data) => {
            //
          },
          takeInput: (data) => {
            //
          },
          moveSubgraphInto: (data) => {
            this._on_graph_unit_move_subgraph_into(data)
          },
          moveSubgraphOutOf: (data) => {
            this._on_graph_unit_move_subgraph_out_of(data)
          },
          coverPin: (data) => {
            this._on_graph_unit_cover_pin(data)
          },
          exposePin: (data) => {
            this._on_graph_unit_expose_pin(data)
          },
          plugPin: (data) => {
            this._on_graph_unit_plug_pin_moment({ ...data, path })
          },
          setSubComponentSize: (data) => {
            this._on_graph_unit_set_sub_component_size({ ...data, path })
          },
          setUnitSize: (data) => {
            this._on_graph_unit_set_unit_size({ ...data, path })
          },
          setComponentSize: (data) => {
            this._on_graph_unit_set_component_size(data)
          },
          moveSubComponentRoot: (data) => {
            this._on_graph_unit_move_sub_component_root({ ...data, path })
          },
          removePinFromMerge: (data) => {
            this._on_graph_unit_remove_pin_from_merge_moment({ ...data, path })
          },
          cloneUnit: (data) => {
            this._on_graph_unit_clone_unit_moment({ ...data, path })
          },
        },
        (_, callback) => {
          return (data) => {
            data.path = path

            callback(data)
          }
        }
      ),
      () => {
        throw new CodePathNotImplementedError()
      }
    )
    // }
  }

  private _graph_moment_handler: Dict<Dict<Function>> = {
    input: {
      data: this._on_graph_unit_link_pin_data_moment,
      drop: this._on_graph_unit_link_pin_drop_moment,
      invalid: this._on_graph_unit_link_pin_invalid_moment,
    },
    output: {
      data: this._on_graph_unit_link_pin_data_moment,
      drop: this._on_graph_unit_link_pin_drop_moment,
      invalid: this._on_graph_unit_link_pin_invalid_moment,
    },
    ref_input: {
      data: this._on_graph_unit_ref_link_pin_data_moment,
      drop: this._on_graph_unit_ref_link_pin_drop_moment,
      invalid: this._on_graph_unit_link_pin_invalid_moment,
    },
    ref_output: {
      data: this._on_graph_unit_ref_link_pin_data_moment,
      drop: this._on_graph_unit_ref_link_pin_drop_moment,
      invalid: this._on_graph_unit_link_pin_invalid_moment,
    },
    merge: {
      data: this._on_graph_unit_merge_data_moment,
      drop: this._on_graph_unit_merge_drop_moment,
      invalid: this._on_graph_unit_merge_invalid_moment,
    },
    unit: {
      destroy: this._on_graph_unit_destroy,
      err: this._on_graph_unit_err_moment,
      take_err: this._on_graph_unit_take_err_moment,
      catch_err: this._on_graph_unit_take_err_moment,
      append_child: this._on_graph_unit_append_child_moment,
      remove_child: this._on_graph_unit_remove_child_at_moment,
      insert_child: this._on_graph_unit_insert_child_at_moment,
    },
    graph: {
      fork: this._on_graph_unit_fork_moment,
      set_name: this._on_graph_unit_set_name_moment,
      add_merge: this._on_graph_unit_add_merge_moment,
      remove_merge: this._on_graph_unit_remove_merge_moment,
      plug_pin: this._on_graph_unit_plug_pin_moment,
      unplug_pin: this._on_graph_unit_unplug_pin_moment,
      add_unit: this._on_graph_unit_add_unit_moment,
      clone_unit: this._on_graph_unit_clone_unit_moment,
      remove_unit: this._on_graph_unit_remove_unit_moment,
      expose_pin: this._on_graph_unit_expose_pin,
      cover_pin: this._on_graph_unit_cover_pin,
      expose_pin_set: this._on_graph_unit_expose_pin_set,
      cover_pin_set: this._on_graph_unit_cover_pin_set,
      add_pin_to_merge: this._on_graph_unit_add_pin_to_merge_moment,
      remove_pin_from_merge: this._on_graph_unit_remove_pin_from_merge_moment,
      set_pin_set_functional: this._on_graph_unit_set_pin_set_functional,
      set_pin_set_default_ignored:
        this._on_graph_unit_set_pin_set_default_ignored,
      move_subgraph_into: this._on_graph_unit_move_subgraph_into,
      move_subgraph_out_of: this._on_graph_unit_move_subgraph_out_of,
      move_sub_component_root: this._on_graph_unit_move_sub_component_root,
      reorder_sub_component: this._on_graph_unit_reorder_sub_component,
      set_unit_id: this._on_graph_unit_set_unit_id,
      set_pin_set_id: this._on_graph_unit_set_pin_set_id,
      set_unit_pin_constant: this._on_graph_unit_set_unit_pin_constant,
      set_unit_pin_ignored: this._on_graph_unit_set_unit_pin_ignored,
      set_unit_pin_data: this._on_graph_unit_set_unit_pin_data,
      remove_unit_pin_data: this._on_graph_unit_remove_unit_pin_data_moment,
      set_metadata: this._on_graph_unit_metadata,
      bulk_edit: this._on_graph_unit_bulk_edit,
    },
  }

  private _debug_moment = (moment: Moment<any>): void => {
    // console.log('Graph', '_debug_moment', moment)

    const { event, type, data } = moment

    this._graph_moment_handler[type][event](data)
  }

  private _on_data_moment = (moment: PinDataMomentData): void => {
    // console.log('Graph', '_on_data_moment', moment)

    let { type, pinId, data } = moment

    const ref = this._is_pin_ref(type as IO, pinId)

    if (data === undefined) {
      return
    }

    if (ref) {
      data = 'null'
    }

    this._sim_set_pin_set_data(type as IO, pinId, data)
  }

  private _on_drop_moment = (moment: PinDropMomentData): void => {
    // console.log('Graph', '_on_drop_moment', moment)

    const { type, pinId } = moment

    this._sim_remove_pin_data(type, pinId)
  }

  private _set_link_pin_invalid = (pin_node_id: string) => {
    const {} = segmentPinLinkId(pin_node_id)

    this._pin_invalid_set.add(pin_node_id)
  }

  private _on_invalid_moment = (moment: PinDataMomentData) => {
    // console.log('Graph', '_on_data_moment', moment)

    const { type, pinId, data } = moment

    //
  }

  private _on_unit_destroy_moment = () => {
    //
  }

  private _unit_moment_handler: Dict<Dict<Function>> = {
    input: {
      data: this._on_data_moment,
      drop: this._on_drop_moment,
      invalid: this._on_invalid_moment,
    },
    output: {
      data: this._on_data_moment,
      drop: this._on_drop_moment,
      invalid: this._on_invalid_moment,
    },
    ref_input: {
      data: this._on_data_moment,
      drop: this._on_drop_moment,
      invalid: this._on_invalid_moment,
    },
    ref_output: {
      data: this._on_data_moment,
      drop: this._on_drop_moment,
      invalid: this._on_invalid_moment,
    },
    merge: {
      data: NOOP,
      drop: NOOP,
      invalid: NOOP,
    },
    unit: {
      set_input: NOOP,
      set_output: NOOP,
      remove_input: NOOP,
      remove_output: NOOP,
      err: NOOP,
      take_err: NOOP,
      catch_err: NOOP,
      pause: this._on_unit_pause_moment,
      destroy: this._on_unit_destroy_moment,
    },
    graph: {
      fork: this._on_fork_moment,
      add_unit: this._on_add_unit_moment,
      clone_unit: this._on_clone_unit_moment,
      remove_unit: this._on_remove_unit_moment,
      move_unit: this._on_move_unit_moment,
      add_merge: this._on_add_merge_moment,
      remove_merge: this._on_remove_merge_moment,
      add_pin_to_merge: this._on_add_pin_to_merge_moment,
      remove_pin_from_merge: this._on_remove_pin_from_merge_moment,
      remove_unit_pin_data: this._on_remove_unit_pin_data_moment,
      expose_pin_set: this._on_expose_pin_set,
      cover_pin_set: this._on_cover_pin_set,
      expose_pin: this._on_expose_pin,
      cover_pin: this._on_cover_pin,
      plug_pin: this._on_plug_pin,
      unplug_pin: this._on_unplug_pin,
      set_unit_id: this._on_set_unit_id,
      set_pin_set_functional: this._on_set_pin_set_functional,
      set_pin_set_default_ignored: this._on_set_pin_set_default_ignored,
      move_subgraph_into: this._on_move_subgraph_into,
      move_subgraph_out_of: this._on_move_subgraph_out_of,
      reorder_sub_component: this._on_reorder_sub_component,
      move_sub_component_root: this._on_move_sub_component_root,
      set_unit_pin_constant: this._on_set_unit_pin_constant,
      set_unit_pin_ignored: this._on_set_unit_pin_ignored,
      set_unit_pin_data: this._on_set_unit_pin_data,
      set_metadata: this._on_set_metadata,
      bulk_edit: this._on_bulk_edit,
    },
  }

  private _on_moment = (moment: Moment): void => {
    // console.log('_on_moment', moment, this._id)

    moment = clone(moment)

    const { event, type, data } = moment

    if (moment.data?.path && moment.data?.path.length > 0) {
      this._on_graph_moment(moment)
    } else {
      this._unit_moment_handler[type][event](data)
    }
  }

  private _get_color = (): string => {
    const { $color } = this.$context
    const { style = {} } = this.$props

    const { color = $color } = style

    return color
  }

  private _refresh_minimap_color = () => {
    if (this._minimap) {
      const color = this._get_color()

      this._minimap.$element.style.color = color

      if (this._minimap_screen) {
        this._minimap_screen.$element.style.stroke = this._theme.link
      }
    }
  }

  private _background_color = (): string => {
    const { $theme } = this.$context

    const backgroundColor = setAlpha(themeBackgroundColor($theme), 0.75)

    return backgroundColor
  }

  private _refresh_color = (): void => {
    // console.log('Graph', '_refresh_color')

    const { parent } = this.$props

    const color = this._get_color()

    this._refresh_theme()

    for (const unit_id in this._subgraph_cache) {
      const graph = this._subgraph_cache[unit_id]

      mergePropStyle(graph, { color })
    }

    if (this._enabled()) {
      this._refresh_minimap_color()
    }

    if (!parent) {
      if (this._transcend) {
        const backgroundColor = this._background_color()

        mergePropStyle(this._transcend, {
          backgroundColor,
        })
      }
    }
  }

  private _enabled = (): boolean => {
    const { disabled } = this.$props

    if (disabled === undefined) {
      const { $disabled } = this.$context

      return !$disabled
    } else {
      return !disabled
    }
  }

  private _refresh_enabled = (): void => {
    const { animate } = this._config()

    if (this._enabled()) {
      if (this._disabled) {
        this._enable()

        this._show_transcend(animate)
      }
    } else {
      if (!this._disabled) {
        this._disable(false)

        this._hide_transcend(animate)
      }
    }
  }

  private _state_graph_unit_remove_pin(
    pin_node_id: string,
    graph_id: string,
    type: IO,
    pinId: string
  ) {
    const mergeId = this._get_pin_merge_id(pin_node_id)

    this._sim_graph_unit_remove_pin(pin_node_id)
    this._spec_graph_unit_remove_pin(graph_id, type, pinId, mergeId)
  }

  private _state_graph_unit_expose_pin_set(
    graphUnitId: string,
    type: IO,
    nextPinId: string,
    pin_spec: GraphPinSpec,
    pin_position: Point
  ) {
    this._spec_graph_unit_expose_pin_set(graphUnitId, type, nextPinId, pin_spec)
    this._sim_graph_unit_expose_pin_set(
      graphUnitId,
      type,
      nextPinId,
      pin_position
    )
  }

  private _unlisten_frame: Unlisten

  onPropChanged(prop: string, current: any) {
    // console.log('Graph', 'onPropChanged', prop, current)

    if (prop === 'style') {
      const { style = {} } = this.$props
      this._graph.setProp('style', {
        ..._DEFAULT_STYLE,
        ...style,
      })

      this._refresh_color()
    } else if (prop === 'disabled') {
      if (this._focused) {
        this._refresh_enabled()
      }
    } else if (prop === 'zoom') {
      this._set_zoom(current)
    } else if (prop === 'graph') {
      const { graph, component } = this.$props

      const { animate } = this._config()

      if (this._is_fullwindow) {
        this._leave_all_fullwindow_sub_component(false)
      }

      for (const subComponentId in this._component.$subComponent) {
        const subComponent = this._component.getSubComponent(subComponentId)
        const subComponentParent =
          this._component.getSubComponentParent(subComponentId)

        if (subComponentParent) {
          subComponentParent.memRemoveParentRoot(subComponent)
        } else {
          this._component.memRemoveRoot(subComponent)
        }

        this._component.removeSubComponent(subComponentId)

        subComponent.destroy()
      }

      this._plunk_pod()

      this._pod = graph

      this._reset_spec()

      if (this._focused) {
        this._refresh_enabled()
      }
    } else if (prop === 'fullwindow') {
      if (this._subgraph_graph) {
        this._subgraph_graph.setProp('fullwindow', current)
      } else {
        const { animate } = this._config()

        if (current === true && !this._is_fullwindow) {
          this._enter_all_fullwindow(animate)
        } else if (current === false && this._is_fullwindow) {
          this._leave_all_fullwindow(animate)
        }
      }
    } else if (prop === 'frame') {
      const { frame } = this.$props

      const { animate } = this._config()

      if (this._in_component_control) {
        if (this._is_fullwindow) {
          this._leave_component_frame()
        }
      }

      this._frame = frame

      if (this._unlisten_frame) {
        this._unlisten_frame()
      }

      this._unlisten_frame = listenMovement(this._frame, () => {
        if (this._is_fullwindow) {
          this._fullwindow_focusing = true

          if (!this._frame_out) {
            this._show_transcend(animate)
          }

          setTimeout(() => {
            this._fullwindow_focusing = false
          }, 0)
        }
      })

      if (this._in_component_control) {
        if (this._is_fullwindow) {
          this._enter_component_frame()
        }
      }

      for (const unit_id in this._subgraph_cache) {
        const graph = this._subgraph_cache[unit_id]

        graph.setProp('frame', this._frame)
      }
    } else if (prop === 'component') {
      if (this._is_fullwindow) {
        this._leave_component_frame()
      }

      this._component = current

      if (this._is_fullwindow) {
        this._enter_component_frame()
      }
    } else if (prop === 'frameOut') {
      const frame_out = current

      if (this._in_component_control) {
        if (this._is_fullwindow) {
          if (!this._frame_out && frame_out) {
            this._set_fullwindow_frame_off(false)
          } else if (this._frame_out && !frame_out) {
            const { animate } = this._config()

            this._set_fullwindow_frame_on(false)
            this._disable_input()
            this._hide_control(animate)
          }
        }
      }

      this._frame_out = frame_out

      for (const unit_id in this._subgraph_cache) {
        const graph = this._subgraph_cache[unit_id]

        graph.setProp('frameOut', this._frame_out)
      }
    } else if (prop === 'registry') {
      this._system = current
    } else if (prop === 'config') {
      this._refresh_config()
    }
  }
}
